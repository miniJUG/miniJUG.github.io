<!doctype html>
<html>
  <head>
    <title>API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 2">
    <meta property="og:description" content="Продолжаем рассказ про API, которые появились в новых версиях Java&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2020-02-09">
    <meta property="article:author" content="Zheka Kozlov">
    <meta property="article:author_url" content="https://twitter.com/ZhekaKozlov">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@ZhekaKozlov">
    <meta name="twitter:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 2">
    <meta name="twitter:description" content="Продолжаем рассказ про API, которые появились в новых версиях Java&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.ru/api_to_upgrade_from_java_8_part_2.png">
    <meta property="og:image:width" content="1033">
    <meta property="og:image:height" content="533">
    <meta name="twitter:image" content="https://minijug.ru/api_to_upgrade_from_java_8_part_2.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
  </head>
  <body class="bg-light">
    <div class="container">
      <div class="row">
        <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</h3>
<p class="text-secondary"><time datetime="2020-02-09">9 февраля, 2020</time></p>
<article>
<p><a href="api_to_upgrade_from_java_8.html">Продолжаем</a> рассказ про API, которые появились в новых версиях Java.</p>

<h4>1. <code class="text-nowrap">Files.mismatch()</code></h4>
<h5>Появился в: Java 12</h5>
<p>На практике довольно часто возникает необходимость проверить, являются ли два файла в точности одинаковыми или нет. С помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html#mismatch(java.nio.file.Path,java.nio.file.Path)">Files.mismatch()</a></code>, появившегося в Java 12, это наконец-то можно сделать. Этот метод возвращает позицию первого несовпадающего байта в двух файлах или <code class="text-nowrap">-1</code>, если файлы идентичны.</p>
<p>Это может быть полезно, например, когда синхронизируешь содержимое двух директорий. Чтобы не перезаписывать файл при копировании тем же самым содержимым и лишний раз не нагружать диск, можно сначала проверить, идентичны файлы или нет:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static void</span> syncDirs(Path srcDir, Path dstDir)
        <span style="color: blue">throws</span> IOException {
    <span style="color: green">// Для простоты демонстрации считаем, что поддиректорий нет</span>
    <span style="color: blue">try</span> (Stream&lt;Path&gt; stream = Files.list(srcDir)) {
        <span style="color: blue">for</span> (Path src : stream.collect(toList())) {
            Path dst = dstDir.resolve(src.getFileName());
            <span style="color: blue">if</span> (!Files.exists(dst)) {
                System.out.println(<span style="color: darkred">"Copying file "</span> + dst);
                Files.copy(src, dst);
            } <span style="color: blue">else if</span> (Files.mismatch(src, dst) >= 0) {
                System.out.println(<span style="color: darkred">"Overwriting file "</span> + dst);
                Files.copy(src, dst, StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }
}</pre>
<!-- cut -->
<p>(Кстати, когда уже наконец <code class="text-nowrap">Stream</code> отнаследуют от <code class="text-nowrap">Iterable</code>? Хочется просто писать <code class="text-nowrap">for (Path file : stream)</code>, а не возиться с промежуточными списками.)</p>

<h4>2. Новые методы в <code class="text-nowrap">java.time</code></h4>
<h5>Появились в: Java 9</h5>
<p>В Java почти 20 лет не было нормального API для работы с датами и временем. Эту проблему решили лишь в Java 8, когда ввели новый пакет <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/package-summary.html">java.time</a></code> под руководством небезызвестного <a href="https://blog.joda.org/">Стивена Колборна</a>, создателя библиотеки <a href="https://www.joda.org/joda-time/">Joda Time</a>. А в девятой версии <code class="text-nowrap">java.time</code> добавили множество интересных методов.</p>
<p>В Java 8 <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html">Duration</a></code> нельзя просто разбить на составляющие (например, прошло 2 дня, 7 часов, 15 минут, 12 секунд). В Java 9 для этого появились методы <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#toDaysPart()">toDaysPart()</a></code>, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#toHoursPart()">toHoursPart()</a></code>, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#toMinutesPart()">toMinutesPart()</a></code>, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#toSecondsPart()">toSecondsPart()</a></code> и т.д. Пример:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static</span> String modifiedAgo(Path path) <span style="color: blue">throws</span> IOException {
    FileTime time = Files.getLastModifiedTime(path);
    Instant to = Instant.now();
    Instant from = time.toInstant();
    Duration d = Duration.between(from, to);
    <span style="color: blue">return</span> String.format(
        <span style="color: darkred">"Файл был изменён %d дней, %d часов, %d минут, %d секунд назад"</span>,
        d.toDaysPart(), d.toHoursPart(),
        d.toMinutesPart(), d.toSecondsPart());
}</pre>
<p>А что если нам надо узнать, сколько <i>месяцев</i> назад был изменён файл? Элегантного способа на Java 8, насколько мне известно, нет. А в Java 9 для этого можно использовать новый метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#dividedBy(java.time.Duration)">Duration.dividedBy()</a></code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static long</span> modifiedAgo(Path path, ChronoUnit unit)
        <span style="color: blue">throws</span> IOException {
    FileTime time = Files.getLastModifiedTime(path);
    Instant to = Instant.now();
    Instant from = time.toInstant();
    Duration d = Duration.between(from, to);
    <span style="color: blue">return</span> d.dividedBy(unit.getDuration());
}

<span style="color: blue">public static void</span> main(String[] args) <span style="color: blue">throws</span> Exception {
    Path path = ...
    System.out.printf(<span style="color: darkred">"Файл был изменён %d месяцев назад%n"</span>,
        modifiedAgo(path, ChronoUnit.MONTHS));
}
</pre>
<p>Нововведения коснулись также класса <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalDate.html">LocalDate</a></code>. С помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalDate.html#ofInstant(java.time.Instant,java.time.ZoneId)">LocalDate.ofInstant()</a></code> можно сконвертировать <code class="text-nowrap">Instant</code> в <code class="text-nowrap">LocalDate</code>:</p>
<pre class="border p-lg-2 p-1">LocalDate date = LocalDate.ofInstant(
    Instant.now(), ZoneId.systemDefault());
System.out.println(date);</pre>
<p>А используя новый метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalDate.html#datesUntil(java.time.LocalDate)">LocalDate.datesUntil()</a></code>, наконец-то можно легко получить <code class="text-nowrap">Stream</code> всех дат в интервале между двумя датами:</p>
<pre class="border p-lg-2 p-1">LocalDate from = LocalDate.of(2020, 1, 1);
LocalDate to = LocalDate.of(2020, 1, 9);
from.datesUntil(to)
    .forEach(System.out::println);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">2020-01-01
2020-01-02
2020-01-03
2020-01-04
2020-01-05
2020-01-06
2020-01-07
2020-01-08</pre>
<p>Также есть <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalDate.html#datesUntil(java.time.LocalDate,java.time.Period)">перегрузка</a>, где можно указать период:</p>
<pre class="border p-lg-2 p-1">LocalDate from = LocalDate.of(2020, 1, 1);
LocalDate to = LocalDate.of(2020, 1, 31);
from.datesUntil(to, Period.ofWeeks(1))
    .forEach(System.out::println);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">2020-01-01
2020-01-08
2020-01-15
2020-01-22
2020-01-29</pre>
<p>Остальные методы:</p>
<ul>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Clock.html#tickMillis(java.time.ZoneId)">Clock.tickMillis()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/Duration.html#truncatedTo(java.time.temporal.TemporalUnit)">Duration.truncatedTo()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalDate.html#toEpochSecond(java.time.LocalTime,java.time.ZoneOffset)">LocalDate.toEpochSecond()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalTime.html#ofInstant(java.time.Instant,java.time.ZoneId)">LocalTime.ofInstant()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/LocalTime.html#toEpochSecond(java.time.LocalDate,java.time.ZoneOffset)">LocalTime.toEpochSecond()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/OffsetTime.html#toEpochSecond(java.time.LocalDate)">OffsetTime.toEpochSecond()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/chrono/Chronology.html#epochSecond(int,int,int,int,int,int,java.time.ZoneOffset)">Chronology.epochSecond()</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/format/DateTimeFormatterBuilder.html#appendGenericZoneText(java.time.format.TextStyle)">DateTimeFormatterBuilder.appendGenericZoneText()</a></code></li>
</ul>

<h4>3. <code class="text-nowrap">Collection.toArray()</code> с функцией-генератором</h4>
<h5>Появился в: Java 11</h5>
<p>С конвертацией коллекций в массивы у Java была непростая история. С момента появления <code class="text-nowrap">Collection</code> в Java 1.2 было два способа создания массива на основе коллекции:</p>
<ul>
  <li>Использовать метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Collection.html#toArray()">Collection.toArray()</a></code>, который возвращает <code class="text-nowrap">Object[]</code>.</li>
  <li>Использовать метод <code class="text-nowrap">Collection.toArray(Object[])</code>, который принимает уже созданный массив и заполняет его. Если переданный массив недостаточной длины, то создаётся новый массив нужной длины того же типа и возвращается. С появлением дженериков в Java 1.5 метод логичным образом поменял свою сигнатуру на <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Collection.html#toArray(T%5B%5D)">Collection.toArray(T[])</a></code>.</li>
</ul>
<p>Загвоздка в том, что если нужен массив конкретного типа (допустим <code class="text-nowrap">String[]</code>), второй метод можно использовать двумя способами:</p>
<ul>
  <li>Использовать конструкцию <code class="text-nowrap">collection.toArray(new String[0])</code>. Тем самым, мы сознательно почти всегда отбрасываем массив, а передаём его туда, чтобы метод узнал тип массива.</li>
  <li>Использовать конструкцию <code class="text-nowrap">collection.toArray(new String[collection.size()])</code>. В этом случае массив передаётся нужной длины, а значит ничего зря не отбрасывается, и код по идее работает быстрее. К тому же здесь не нужен рефлективный вызов.</li>
</ul>
<p>Таким образом, второй вариант долгое время считался основным, и в IntelliJ IDEA даже была инспекция, которая подсвечивала первый вариант и предлагала конвертировать его во второй, более эффективный.</p>
<p>Однако в 2016 году вышла <a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">статья Алексея Шипилёва</a>, где он решил досконально разобраться в этом вопросе и пришёл к выводу, что не-а: первый вариант всё-таки быстрее (по крайней мере в версиях JDK 6+). Эта статья получила большой <a href="https://twitter.com/shipilev/status/689211445142228992">резонанс</a>, и в IDEA решили изменить инспекцию, сделав у неё три опции: предпочитать пустой массив (default), предпочитать преаллоцированный массив или предпочитать то или иное в зависимости от версии Java.</p>
<p>Но история на этом не закончилась, потому что некоторые программисты принципиально не желали использовать эти хаки с пустыми массивами и хотели писать код "элегантно". Поэтому они вспомнили про <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html#toArray(java.util.function.IntFunction)">Stream.toArray(IntFunction[])</a></code> и стали писать <code class="text-nowrap">collection.stream().toArray(String[]::new)</code>. Медленно? Ну и что, зато красиво.</p>
<p>Программисты из Oracle посмотрели на всё это безобразие и подумали: а давайте уже сделаем один нормальный способ, который и будет рекомендованным? И в Java 11 добавили долгожданный метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Collection.html#toArray(java.util.function.IntFunction)">Collection.toArray(IntFunction[])</a></code>, <del>тем самым запутав людей ещё сильнее</del>.</p>
<p>Но на самом деле никакой путаницы нет. Да, теперь есть 4 варианта, но если вы не выжимаете такты из своего процессора, то вам следует просто использовать новый метод:</p>
<pre class="border p-lg-2 p-1">List&lt;Integer&gt; list = ...;
Integer[] array = list.toArray(Integer[]::<span style="color: blue">new</span>);</pre>

<h4>4. Методы <code class="text-nowrap">InputStream</code>: <code class="text-nowrap">readNBytes()</code>, <code class="text-nowrap">readAllBytes()</code>, <code class="text-nowrap">transferTo()</code></h4>
<h5>Появились в: Java 9 / Java 11</h5>
<p>Ещё одно неудобство, которое существовало в Java долгие годы &ndash; отсутствие стандартного короткого способа считать все данные из <code class="text-nowrap">InputStream</code>. Если не прибегать к библиотекам, то в Java 8 решить такую задачу довольно нетривиально: нужно завести список буферов, заполнять их, пока данные не кончатся, потом слить в один большой массив, учесть, что последний буфер заполнен лишь частично и т.д. Короче, нюансов хватает.</p>
<p>В Java 9 добавили метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/InputStream.html#readAllBytes()">InputStream.readAllBytes()</a></code>, который берёт всю эту работу на себя и возвращает заполненный массив байтов точной длины. Например, прочитать <code class="text-nowrap">stdout</code>/<code class="text-nowrap">stderr</code> процесса теперь очень легко:</p>
<pre class="border p-lg-2 p-1">Process proc = Runtime.getRuntime().exec(<span style="color: darkred">"java -version"</span>);
<span style="color: blue">try</span> (InputStream inputStream = proc.getErrorStream()) {
    <span style="color: blue">byte</span>[] bytes = inputStream.readAllBytes();
    System.out.print(<span style="color: blue">new</span> String(bytes));
}</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">openjdk version "14-ea" 2020-03-17
OpenJDK Runtime Environment (build 14-ea+33-1439)
OpenJDK 64-Bit Server VM (build 14-ea+33-1439, mixed mode, sharing)</pre>
<p>Также если надо прочитать только <code class="text-nowrap">N</code> байтов, то можно использовать метод из Java 11 <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/InputStream.html#readNBytes(int)">InputStream.readNBytes()</a></code>.</p>
<p>Если же надо легко и эффективно (без промежуточного массива) перенаправить <code class="text-nowrap">InputStream</code> в <code class="text-nowrap">OutputStream</code>, то можно использовать <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/InputStream.html#transferTo(java.io.OutputStream)">InputStream.transferTo()</a></code>. Например, для вывода версии Java в файл код будет выглядеть примерно так:</p>
<pre class="border p-lg-2 p-1">Process proc = Runtime.getRuntime().exec(<span style="color: darkred">"java -version"</span>);
Path path = Path.of(<span style="color: darkred">"out.txt"</span>);
<span style="color: blue">try</span> (InputStream inputStream = proc.getErrorStream();
     OutputStream outputStream = Files.newOutputStream(path)) {
    inputStream.transferTo(outputStream);
}</pre>
<p>Кстати, перенаправить <code class="text-nowrap">Reader</code> во <code class="text-nowrap">Writer</code> теперь тоже можно: с помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/Reader.html#transferTo(java.io.Writer)">Reader.transferTo()</a></code>, появившегося в Java 10.</p>

<h4>5. <code class="text-nowrap">Collectors.teeing()</code></h4>
<h5>Появился в: Java 12</h5>
<p>При использовании <code class="text-nowrap">Stream</code> часто возникает необходимость собрать элементы в два коллектора. Допустим, у нас есть <code class="text-nowrap">Stream</code> из <code class="text-nowrap">Employee</code>, и нужно узнать:</p>
<ul>
  <li>Сколько всего сотрудников в Stream.</li>
  <li>Сколько сотрудников, у которых есть телефонный номер.</li>
</ul>
<p>Как это сделать в Java 8? Первое, что приходит в голову: сначала позвать <code class="text-nowrap">Stream.count()</code>, а потом <code class="text-nowrap">Stream.filter()</code> и <code class="text-nowrap">Stream.count()</code>. Однако это не сработает, потому что <code class="text-nowrap">Stream</code> является одноразовым и второй вызов выбросит исключение.</p>
<p>Второй вариант &ndash; завести два счётчика и увеличивать их внутри <code class="text-nowrap">Stream.forEach()</code>:</p>
<pre class="border p-lg-2 p-1">Stream&lt;Employee&gt; employees = ...
<span style="color: blue">int</span>[] countWithPhoneAndTotal = {0, 0};
employees
    .forEach(emp -> {
        if (emp.getPhoneNumber() != <span style="color: blue">null</span>) {
            countWithPhoneAndTotal[0]++;
        }
        countWithPhoneAndTotal[1]++;
    });
System.out.println(<span style="color: darkred">"Employees with phone number: "</span>
    + countWithPhoneAndTotal[0]);
System.out.println(<span style="color: darkred">"Total employees: "</span>
    + countWithPhoneAndTotal[1]);
</pre>
<p>В принципе, это работает, но это императивный подход, который плохо переносится на другие виды коллекторов. <code class="text-nowrap">Stream.peek()</code> плох по той же причине.</p>
<p>Ещё есть идея использовать <code class="text-nowrap">Stream.reduce()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> CountWithPhoneAndTotal {
    <span style="color: blue">final int</span> withPhone;
    <span style="color: blue">final int</span> total;

    CountWithPhoneAndTotal(<span style="color: blue">int</span> withPhone, <span style="color: blue">int</span> total) {
        <span style="color: blue">this</span>.withPhone = withPhone;
        <span style="color: blue">this</span>.total = total;
    }
}

CountWithPhoneAndTotal countWithPhoneAndTotal = employees
    .reduce(
        <span style="color: blue">new</span> CountWithPhoneAndTotal(0, 0),
        (count, employee) -> <span style="color: blue">new</span> CountWithPhoneAndTotal(
            employee.getPhoneNumber() != <span style="color: blue">null</span>
                ? count.withPhone + 1
                : count.withPhone,
            count.total + 1),
        (count1, count2) -> <span style="color: blue">new</span> CountWithPhoneAndTotal(
            count1.withPhone + count2.withPhone,
            count1.total + count2.total));
System.out.println(<span style="color: darkred">"Employees with phone number: "</span>
    + countWithPhoneAndTotal.withPhone);
System.out.println(<span style="color: darkred">"Total employees: "</span>
    + countWithPhoneAndTotal.total);</pre>
<p>Этот вариант, конечно же, кошмар. Во-первых, он слишком огромный, во-вторых, неэффективный, так как на каждом шагу создаётся новый экземпляр <code class="text-nowrap">CountWithPhoneAndTotal</code>. Если когда-нибудь доделают <a href="http://cr.openjdk.java.net/~briangoetz/valhalla/sov/02-object-model.html">Валгаллу</a>, то можно будет пометить класс <code class="text-nowrap">CountWithPhoneAndTotal</code> как <code class="text-nowrap">inline</code>, но первая проблема всё равно останется.</p>
<p>На этом мои идеи закончились. Если вдруг кто-то придумает, как сделать такой подсчёт в Java 8 коротким и эффективным, то напишите в комментариях. А я расскажу, как это можно сделать в Java 12 с помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction)">Collectors.teeing()</a></code>:</p>
<pre class="border p-lg-2 p-1">Entry&lt;Long, Long&gt; countWithPhoneAndTotal = employees
    .collect(teeing(
        filtering(employee -> employee.getPhoneNumber() != <span style="color: blue">null</span>, counting()),
        counting(),
        Map::entry
    ));</pre>
<p>И всё.</p>
<p>С методом <code class="text-nowrap">Collectors.teeing()</code> была очень интересная история: когда ему придумывали имя, то долго не могли <a href="https://mail.openjdk.java.net/pipermail/core-libs-dev/2018-June/053718.html">прийти к консенсусу</a> из-за огромного количество предложенных вариантов. Чего там только не было: <code class="text-nowrap">toBoth</code>, <code class="text-nowrap">collectingToBoth</code>, <code class="text-nowrap">collectingToBothAndThen</code>, <code class="text-nowrap">pairing</code>, <code class="text-nowrap">bifurcate</code>, <code class="text-nowrap">distributing</code>, <code class="text-nowrap">unzipping</code>, <code class="text-nowrap">forking</code>, ... В итоге его назвали <code class="text-nowrap">teeing</code> от английского слова tee, которое само произошло от буквы <b>T</b>, напоминающую по форме раздваиватель. В этом и есть суть имени метода: он <i>раздваивает</i> поток на две части.</p>

<h4>6. <code class="text-nowrap">Runtime.version()</code></h4>
<h5>Появился в: Java 9</h5>
<p>Иногда нужно узнать версию Java во время выполнения. Помните ли вы, как это сделать? Скорее всего, вы полезете искать название нужного свойства в интернете. Возможно некоторые вспомнят, что оно называется <code class="text-nowrap">java.version</code>. А ещё вроде бы есть <code class="text-nowrap">java.specification.version</code>... На самом деле, таких свойств как минимум пять:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">for</span> (String key : Arrays.asList(
        <span style="color: darkred">"java.version"</span>,
        <span style="color: darkred">"java.runtime.version"</span>,
        <span style="color: darkred">"java.specification.version"</span>,
        <span style="color: darkred">"java.vm.version"</span>,
        <span style="color: darkred">"java.vm.specification.version"</span>)) {
    System.out.println(key + <span style="color: darkred">" = "</span> + System.getProperty(key));
}</pre>
<p>Если запустить код на Java 8, то он выведет примерно следующее:</p>
<pre class="border p-lg-2 p-1">java.version = 1.8.0_192
java.runtime.version = 1.8.0_192-b12
java.specification.version = 1.8
java.vm.version = 25.192-b12
java.vm.specification.version = 1.8</pre>
<p>Как отсюда вытащить цифру 8? Наверное, надо взять <code class="text-nowrap">java.specification.version</code>, отбросить <code class="text-nowrap">1.</code>, потом сконвертировать строку в число... Но не торопитесь, потому что на Java 9 это всё сломается:</p>
<pre class="border p-lg-2 p-1">java.version = 9.0.1
java.runtime.version = 9.0.1+11
java.specification.version = 9
java.vm.version = 9.0.1+11
java.vm.specification.version = 9</pre>
<p>Однако не печальтесь, потому что в Java 9 <a href="https://openjdk.java.net/jeps/223">появилось</a> нормальное API для получения версий и было <a href="https://openjdk.java.net/jeps/322">немного допилено</a> в Java 10. С этим API больше не нужно ничего &laquo;вытаскивать&raquo; и парсить, а можно просто позвать метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Runtime.html#version()">Runtime.version()</a></code>. Этот метод возвращает объект типа <code class="text-nowrap">Runtime.Version</code>, у которого можно запросить все нужные части версии:</p>
<pre class="border p-lg-2 p-1">Runtime.Version version = Runtime.version();
System.out.println(<span style="color: darkred">"Feature = "</span> + version.feature());
System.out.println(<span style="color: darkred">"Interim = "</span> + version.interim());
System.out.println(<span style="color: darkred">"Update = "</span> + version.update());
System.out.println(<span style="color: darkred">"Patch = "</span> + version.patch());</pre>
<p>Например, вот что он вернёт, если его позвать на JDK 11.0.5:</p>
<pre class="border p-lg-2 p-1">Feature = 11
Interim = 0
Update = 5
Patch = 0</pre>

<h4>7. <code class="text-nowrap">Optional.isEmpty()</code></h4>
<h5>Появился в: Java 11</h5>
<p>Я не стану утверждать, что этот метод изменит вашу жизнь радикальным образом, но всё же в некоторых случаях он сможет избавить вас от ненужных отрицаний:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (!stream.findAny().isPresent()) {
    System.out.println(<span style="color: darkred">"Stream is empty"</span>);
}</pre>
<p>Используя метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html#isEmpty()">Optional.isEmpty()</a></code>, код можно немножко упростить:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (stream.findAny().isEmpty()) {
    System.out.println(<span style="color: darkred">"Stream is empty"</span>);
}</pre>
<p>Также этот метод позволяет заменить лямбды на ссылки на методы в некоторых случаях:</p>
<pre class="border p-lg-2 p-1">Stream&lt;Optional&lt;Integer&gt;&gt; stream = Stream.of(
    Optional.of(1),
    Optional.empty(),
    Optional.of(2));

<span style="color: blue">long</span> emptyCount = stream
    .filter(Optional::isEmpty) <span style="color: green">// Было opt -> !opt.isPresent()</span>
    .count();</pre>

<h4>8. HTTP-клиент</h4>
<h5>Появился в: Java 11</h5>
<p>Долгое время единственным API для клиентского HTTP был класс <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/net/HttpURLConnection.html">HttpURLConnection</a></code>, который существовал в Java практически с момента её появления. Спустя два десятилетия стало очевидно, что он больше не отвечает современным требованиям: он неудобен в использовании, не поддерживает HTTP/2 и веб-сокеты, работает только в блокирующем режиме, а ещё его очень трудно поддерживать. Поэтому было принятое решение создать новый HTTP Client, который <a href="http://openjdk.java.net/jeps/110">попал в Java 9</a> в качестве <a href="http://openjdk.java.net/jeps/11">инкубационного</a> модуля, а позже был <a href="http://openjdk.java.net/jeps/321">стандартизован в Java 11</a>.</p>
<p>Новый клиент находится в модуле <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.net.http/java/net/http/package-summary.html">java.net.http</a></code>, и его использование осуществляется через главный класс <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.net.http/java/net/http/HttpClient.html">HttpClient</a></code>. Приведём пример, как можно сделать простой HTTP-запрос с сайта и получить содержимое страницы с кодом ответа:</p>
<pre class="border p-lg-2 p-1">HttpClient client = HttpClient.newHttpClient();

HttpRequest request = HttpRequest
    .newBuilder(new URI(<span style="color: darkred">"https://minijug.ru"</span>))
    .build();

HttpResponse&lt;Stream&lt;String&gt;&gt; response = client.send(request,
    HttpResponse.BodyHandlers.ofLines());

System.out.println(<span style="color: darkred">"Status code = "</span> + response.statusCode());
System.out.println(<span style="color: darkred">"Body = "</span>);
<span style="color: green">// Первые 4 строки</span>
response.body().limit(4).forEach(System.out::println);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">Status code = 200
Body =
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title>miniJUG&lt;/title&gt;</pre>
<p>В модуле <code class="text-nowrap">java.net.http</code> большое количество возможностей, и на их описание уйдёт много времени, поэтому сегодня мы ограничимся только примером выше.</p>

<h4>9. <code class="text-nowrap">Lookup.defineClass()</code></h4>
<h5>Появился в: Java 9</h5>
<p>Приходилось ли вам загружать классы во время выполнения? Если да, вы наверняка знаете, что в Java 8 без нового загрузчика класса это сделать нельзя. Ну или ещё можно использовать <code class="text-nowrap">Unsafe.defineClass()</code> или <code class="text-nowrap">Unsafe.defineAnonymousClass()</code>, но это нестандартное API, которое крайне не рекомендуется использовать.</p>
<p>Однако есть хорошая новость: если вам нужно загрузить класс в том же пакете, не создавая новый загрузчик класса, то для этого можно использовать стандартный метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineClass(byte%5B%5D)">MethodHandles.Lookup.defineClass()</a></code>, который появился в Java 9. Этому методу достаточно передать массив байтов класса:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Main.java</span>
<span style="color: blue">import</span> java.lang.invoke.MethodHandles;
<span style="color: blue">import</span> java.nio.file.Files;
<span style="color: blue">import</span> java.nio.file.Path;

<span style="color: blue">public class</span> Main {
    <span style="color: blue">public static void</span> main(String[] args) throws Exception {
        <span style="color: blue">byte</span>[] bytes = Files.readAllBytes(Path.of(<span style="color: darkred">"Temp.class"</span>));
        Class&lt;?&gt; clazz = MethodHandles.lookup().defineClass(bytes);
        Object obj = clazz.getDeclaredConstructor().newInstance();
        System.out.println(obj);
    }
}</pre>
<pre class="border p-lg-2 p-1"><span style="color: green">// Temp.java</span>
<span style="color: blue">class</span> Temp {
    @Override
    <span style="color: blue">public</span> String toString() {
        <span style="color: blue">return</span> <span style="color: darkred">"Hello from Temp!"</span>;
    }
}</pre>
<p>Теперь скомпилируем класс <code class="text-nowrap">Temp</code>, а затем скомпилируем и запустим класс <code class="text-nowrap">Main</code></p>
<pre class="border p-lg-2 p-1">&gt; javac Temp.java

&gt; javac Main.java

&gt; java Main
Hello from Temp!</pre>

<p>Повторюсь, чтобы это сработало, класс <code class="text-nowrap">Temp</code> и класс <code class="text-nowrap">Main</code> должны находиться в одном пакете (в данном случае они оба находятся в дефолтном пакете, поэтому всё хорошо). Если класс <code class="text-nowrap">Temp</code> будет находиться в другом пакете, то понадобится завести специальный класс-делегат в том же пакете, что и <code class="text-nowrap">Temp</code>, и осуществлять загрузку через него.</p>
<p>Да, пример выше совсем простой, но это сделано исключительно для краткости и простоты демонстрации. Так как <code class="text-nowrap">defineClass()</code> принимает массив байтов, то загружать класс можно откуда угодно, а не только с файловой системы. Можно даже загрузить класс, скомпилированный в память во время исполнения. Для этого можно использовать <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.compiler/javax/tools/ToolProvider.html#getSystemJavaCompiler()">ToolProvider.getSystemJavaCompiler()</a></code>, который находится в модуле <code class="text-nowrap">java.compiler</code> (конкретную реализацию я оставлю в качестве упражнения для читателя).</p>

<h4>10. <code class="text-nowrap">ByteArrayOutputStream.writeBytes()</code></h4>
<h5>Появился в: Java 11</h5>
<p>Метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/ByteArrayOutputStream.html#writeBytes(byte%5B%5D)">ByteArrayOutputStream.writeBytes()</a></code> &ndash; это дублёр метода <code class="text-nowrap">ByteArrayOutputStream.write()</code> с одним важным отличием: в сигнатуре <code class="text-nowrap">write()</code> есть <code class="text-nowrap">throws IOException</code>, а в сигнатуре <code class="text-nowrap">writeBytes()</code> &ndash; нету (<code class="text-nowrap">IOException</code> есть во <code class="text-nowrap">write()</code>, потому что этот метод наследуется от <code class="text-nowrap">OutputStream</code>). Это значит, что <a href="https://bugs.openjdk.java.net/browse/JDK-8199713">начиная</a> с Java 11, использование <code class="text-nowrap">ByteArrayOutputStream</code> становится немножко проще:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static byte</span>[] concat(Stream&lt;<span style="color: blue">byte</span>[]&gt; stream) {
    ByteArrayOutputStream out = <span style="color: blue">new</span> ByteArrayOutputStream();
    <span style="color: green">// stream.forEach(out::write); (Не скомпилируется)</span>
    stream.forEach(out::writeBytes);
    <span style="color: blue">return</span> out.toByteArray();
}</pre>

<h4>Бонус: конструктор <code class="text-nowrap">IndexOutOfBoundsException(int)</code></h4>
<h5>Появился в: Java 9</h5>
<p>Сегодняшний рассказ хочу завершить мелким улучшением в Java 9: если вам надо выбросить <code class="text-nowrap">IndexOutOfBoundsException</code> с указанием неправильного индекса, то теперь можно просто передать этот индекс в <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/IndexOutOfBoundsException.html#%3Cinit%3E(int)">конструктор</a>, и он сам сгенерирует сообщение:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static void</span> doAtIndex(<span style="color: blue">int</span> index) {
    <span style="color: blue">if</span> (index < 0) {
        <span style="color: blue">throw new</span> IndexOutOfBoundsException(index);
    }
    <span style="color: green">// ...</span>
}

<span style="color: blue">public static void</span> main(String[] args) {
    <span style="color: green">// java.lang.IndexOutOfBoundsException: Index out of range: -1</span>
    doAtIndex(-1);
}</pre>

<h4>Заключение</h4>
<p>Итак, мы рассмотрели ещё 10 (+1) новых API, которые появились в новых версиях Java. Всё ещё не хотите обновляться? Если нет, то тогда ждите следующую часть.</p>
</article>
  <p class="pt-4 font-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2020" role="button" aria-expanded="true" aria-controls="year2020">2020</a>
  <ul class="collapse show" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li>API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
</div>
      </div>
    </div>
    <div class="container d-md-flex flex-row">
      <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
      <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/ZhekaKozlov">Евгений Козлов</a>, 2017-2021</div>
      <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.ru/feed.xml">Feed</a></div>
    </div>
    <script src="jquery-3.3.1.slim.min.js"></script>
    <script src="popper.min.js"></script>
    <script src="bootstrap.min.js"></script>
  </body>
</html>
