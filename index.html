<!doctype html>
<html lang="ru">
  <head>
    <title>miniJUG</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="miniJUG">
    <meta property="og:description" content="Новости Java">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2025-09-16">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="miniJUG">
    <meta name="twitter:description" content="Новости Java">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.org/minijug.png">
    <meta property="og:image:width" content="1269">
    <meta property="og:image:height" content="664">
    <meta name="twitter:image" content="https://minijug.org/minijug.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Вышла Java 25</h3>
<p class="text-secondary"><time datetime="2025-09-16">16 сентября, 2025</time></p>
<article>
<p>Вышла общедоступная версия <a href="https://openjdk.org/projects/jdk/25/">Java 25</a>. В этот релиз попало около <a href="https://builds.shipilev.net/backports-monitor/release-notes-25.html">2600 закрытых задач и 18 JEP'ов</a>. Release Notes можно посмотреть <a href="http://jdk.java.net/25/release-notes">здесь</a>. Полный список изменений API &ndash; <a href="https://javaalmanac.io/jdk/25/apidiff/24/">здесь</a>.</p>

<p>Java 25 является LTS-релизом, а значит у него будут выходить обновления <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">как минимум 5 лет</a> с момента выхода (до сентября 2030 года).</p>

<p>Скачать JDK 25 можно по этим ссылкам:</p>
<ul>
  <li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a> (лицензия <a href="https://www.oracle.com/downloads/licenses/no-fee-license.html">NFTC</a>)</li>
  <li><a href="http://jdk.java.net/25/">OpenJDK</a> (лицензия <a href="https://openjdk.org/legal/gplv2+ce.html">GPLv2 with Classpath Exception</a>)</li>
</ul>

<p class="mt-2">Рассмотрим все JEP'ы, которые попали в Java 25.</p>

<h4>Язык</h4>

<h5><a href="https://openjdk.org/jeps/511">Module Import Declarations (JEP 511)</a></h5>
<p>Module Import Declarations, которые были в режиме preview в <a href="https://openjdk.org/jeps/476">Java 23</a> и <a href="https://openjdk.org/jeps/494">Java 24</a>, стали постоянной языковой конструкцией. По сравнению с Java 24 фича осталась без изменений.</p>

<p class="mt-2">Декларация <code class="text-nowrap">import module M</code> эквивалентна импорту всех экспортированных пакетов из модуля <code class="text-nowrap">M</code> и его транзитивных зависимостей в текущий модуль.</p>
<p>Например, импорт модуля <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/module-summary.html"><code class="text-nowrap">java.base</code></a> имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">import</span> java.io.*;
<span style="color: blue">import</span> java.lang.*;
<span style="color: blue">import</span> java.lang.annotation.*;
<span style="color: green">// ... 49 packages ...</span>
<span style="color: blue">import</span> javax.security.auth.x500.*;
<span style="color: blue">import</span> javax.security.cert.*;</pre>

<p>Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как <code class="text-nowrap">List</code>, <code class="text-nowrap">Map</code>, <code class="text-nowrap">Stream</code>, <code class="text-nowrap">Path</code>, <code class="text-nowrap">Function</code> и др. без необходимости отдельного импорта их с указанием соответствующих пакетов.</p>

<p>Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую <a href="https://openjdk.org/jeps/458">без предварительной компиляции</a>.</p>

<p>При использовании <i>компактных исходных файлов</i> модуль <code class="text-nowrap">java.base</code> импортируется автоматически. Об этом следующий JEP 512.</p>

<h5><a href="https://openjdk.org/jeps/512">Compact Source Files and Instance Main Methods (JEP 512)</a></h5>
<p>Компактные исходные файлы и instance-методы <code class="text-nowrap">main()</code> стали постоянными. Среди рассматриваемых сегодня эта языковая фича была в preview дольше всех, появившись ещё аж в прошлом LTS-релизе: <a href="https://openjdk.org/jeps/445">Java 21</a>, <a href="https://openjdk.org/jeps/463">Java 22</a>, <a href="https://openjdk.org/jeps/477">Java 23</a> и <a href="https://openjdk.org/jeps/495">Java 24</a>.</p>

<p>В этом релизе есть несколько изменений:</p>
<ul>
  <li>Название "простые исходные файлы" поменялось на "компактные исходные файлы".</li>
  <li>Класс <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/IO.html"><code class="text-nowrap">java.io.IO</code></a> теперь стал <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/IO.html"><code class="text-nowrap">java.lang.IO</code></a>. Значит, он теперь импортируется неявно в любой исходный файл (необязательно компактный).</li>
  <li>Статические методы класса <code class="text-nowrap">IO</code> больше не импортируются неявно в компактных исходных файлах. Теперь придётся указывать класс (например, <code class="text-nowrap">IO.println("Hello, world!")</code>), либо вручную статически импортировать методы.</li>
  <li>Реализация класса <code class="text-nowrap">IO</code> теперь базируется на <code class="text-nowrap">System.out</code> и <code class="text-nowrap">System.in</code>, а не на <code class="text-nowrap">java.io.Console</code>.</li>
</ul>

<p>Какие возможности даёт JEP 512?</p>

<p>Теперь можно запускать классы, у которых метод <code class="text-nowrap">main()</code> не является <code class="text-nowrap">public static</code> (т.е. является instance-методом) и у которого нет параметра <code class="text-nowrap">String[] args</code>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> HelloWorld {
    <span style="color: blue">void</span> main() {
        System.out.println(<span style="color: darkred">"Hello, World!"</span>);
    }
}</pre>
<p>В таком случае во время запуска JVM сама создаст экземпляр класса <code class="text-nowrap">HelloWorld</code> и вызовет у него метод <code class="text-nowrap">main()</code>:</p>
<pre class="border p-lg-2 p-1">$ java HelloWorld.java
Hello, World!</pre>

<p class="mt-2">Кроме того, можно запускать файлы и без объявленного класса вовсе. Такие файлы называются <i>компактными исходными файлами</i>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// HelloWorld.java</span>

String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}</pre>
<pre class="border p-lg-2 p-1">$ java HelloWorld.java
Hello, World!</pre>

<p>В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод <code class="text-nowrap">main()</code> и другие верхнеуровневые объявления в файле:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// class &lt;some name> { ← неявно</span>
String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}
<span style="color: green">// }</span></pre>

<p>Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:</p>
<ul>
  <li>Неявный класс может находиться только в безымянном пакете.</li>
  <li>Код в неявном классе не может ссылаться на него по имени.</li>
  <li>Неявный класс всегда имеет один дефолтный конструктор без аргументов.</li>
  <li>Неявный класс всегда является final и наследуется от <code class="text-nowrap">java.lang.Object</code>.</li>
</ul>
<p>При этом неявный класс не является безымянным: у него есть <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Class.html#getName()">имя</a>, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).</p>

<p>Наконец, с помощью класса <code class="text-nowrap">java.lang.IO</code> можно в примере выше заменить магический <code class="text-nowrap">System.out.println()</code> на более короткий и понятный <code class="text-nowrap">IO.println()</code>:</p>
<!--java--><pre class="border p-lg-2 p-1">String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    IO.println(greeting);
}</pre>

<p>Ещё одной особенностью компактных исходных файлов является то, что каждый такой файл неявно импортирует модуль <code class="text-nowrap">java.base</code> (фича из предыдущего JEP 511). Это значит, что ко всем базовым классам Java можно обращаться без необходимости импортов:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">void</span> main() {
    IO.println(List.of(<span style="color: darkred">"James"</span>, <span style="color: darkred">"Bill"</span>, <span style="color: darkred">"Guy"</span>));
}</pre>

<p class="mt-2">Компактные исходные файлы и instance-методы <code class="text-nowrap">main()</code> вводятся в Java с двумя целями:</p>
<ol>
  <li>Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).</li>
  <li>Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.</li>
</ol>

<h5><a href="https://openjdk.org/jeps/513">Flexible Constructor Bodies (JEP 513)</a></h5>
<p>Flexible Constructor Bodies, которые были в preview три релиза (<a href="https://openjdk.org/jeps/447">Java 22</a>, <a href="https://openjdk.org/jeps/482">Java 23</a>, <a href="https://openjdk.org/jeps/492">Java 24</a>), стали постоянной фичей языка. По сравнению с Java 24 изменений нет.</p>

<p>Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (<code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>):</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">super</span>(value);
    }
}</pre>

<p>Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">super</span>(verifyPositive(value));
    }

    <span style="color: blue">private static long</span> verifyPositive(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">return</span> value;
    }
}</pre>

<p>Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Super {
    <span style="color: blue">public</span> Super(C x, C y) { ... }
}

<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">private</span> Sub(C x) { <span style="color: green">// Auxiliary constructor</span>
        <span style="color: blue">super</span>(x, x); <span style="color: green">// x is shared here</span>
    }

    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>(<span style="color: blue">new</span> C(i));
    }
}</pre>

<p>В Java 25 то же самое можно реализовать гораздо короче:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">var</span> x = <span style="color: blue">new</span> C(i);
        <span style="color: blue">super</span>(x, x);
    }
}</pre>

<p>Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать instance-методы). Рассмотрим несколько примеров некорректного кода:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A() {
        System.out.print(<span style="color: blue">this</span>); <span style="color: red">// Error</span>
        var x = i;              <span style="color: red">// Error</span>
        hashCode();             <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> B {
    <span style="color: blue">int</span> i;
    <span style="color: blue">void</span> m() {}
}

<span style="color: blue">class</span> C <span style="color: blue">extends</span> B {
    C() {
        <span style="color: blue">var</span> x = i; <span style="color: red">// Error</span>
        m();       <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Outer {
    <span style="color: blue">class</span> Inner {
    }

    Outer() {
        <span style="color: blue">new</span> Inner(); <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Однако если читать поля конструируемого класса до вызова <code class="text-nowrap">super()</code> нельзя, то инициализировать их можно:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>.i = i; <span style="color: green">// OK</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: red">// new Sub(42) will print 0</span>
    }
}</pre>

<p>Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова <code class="text-nowrap">super()</code>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
        <span style="color: blue">super</span>();
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: green">// new Sub(42) will print 42</span>
    }
}</pre>

<p>Также инициализация полей до <code class="text-nowrap">super()</code> можно пригодиться в проекте Valhalla для <a href="https://youtu.be/IF9l8fYfSnI?t=2006">definite assignment полей</a> null-restricted value-классов.</p>

<p>Интересно, что новая возможность затрагивает исключительно компилятор Java &ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом <code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).</p>

<h5><a href="https://openjdk.org/jeps/507">Primitive Types in Patterns, instanceof, and switch (Third Preview) (JEP 507)</a></h5>
<p>Примитивные типы в паттернах, <code class="text-nowrap">instanceof</code> и <code class="text-nowrap">switch</code>, которые были в режиме preview в <a href="https://openjdk.org/jeps/455">Java 23</a> и <a href="https://openjdk.org/jeps/488">Java 24</a>, остаются на третье preview без изменений:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>

Object obj = 42;
<span style="color: blue">if</span> (obj <span style="color: blue">instanceof int</span> i) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"int: "</span> + i);
}

<span style="color: blue">switch</span> (obj) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case double</span> d -> System.out.println(<span style="color: darkred">"double: "</span> + d);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>Проверять можно также и то, попадают ли значения в диапазон типа:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">int</span> i = 42;
<span style="color: blue">if</span> (i <span style="color: blue">instanceof byte</span> b) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"byte: "</span> + b);
}

<span style="color: blue">double</span> d = 3.0;
<span style="color: blue">switch</span> (d) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> f -> System.out.println(<span style="color: darkred">"float: "</span> + f);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>В примерах выше <code class="text-nowrap">42</code> попадает в диапазон byte (<code class="text-nowrap">[-128; 127]</code>), а <code class="text-nowrap">3.0</code> без потери точности приводится к <code class="text-nowrap">int</code>. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.</p>

<p>Подобные проверки могут быть полезны и в паттернах записей:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">record</span> JsonNumber(<span style="color: blue">double</span> d) {}

<span style="color: blue">var</span> json = <span style="color: blue">new</span> JsonNumber(3.0);
<span style="color: blue">if</span> (json <span style="color: blue">instanceof</span> JsonNumber(<span style="color: blue">int</span> i)) { <span style="color: green">// matches</span>
    <span style="color: green">// ...</span>
}</pre>

<p>Если до Java 23-25 типы выражений-селекторов в <code class="text-nowrap">switch</code> могли быть только <code class="text-nowrap">int</code>, <code class="text-nowrap">short</code>, <code class="text-nowrap">byte</code> и <code class="text-nowrap">char</code> и для них поддерживались только константные ветки (<code class="text-nowrap">case 3</code> и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">float</span> f = 1.0f;
<span style="color: blue">switch</span> (f) {
    <span style="color: blue">case</span> 0f -> System.out.println(<span style="color: darkred">"0"</span>);
    <span style="color: blue">case float</span> x <span style="color: blue">when</span> x == 1f -> System.out.println(<span style="color: darkred">"1"</span>); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> x -> System.out.println(<span style="color: darkred">"other"</span>);
}

<span style="color: blue">boolean</span> b = <span style="color: darkred">"hello"</span>.isEmpty();
<span style="color: blue">switch</span> (b) {
    <span style="color: blue">case true</span> -> System.out.println(<span style="color: darkred">"empty"</span>);
    <span style="color: blue">case false</span> -> System.out.println(<span style="color: darkred">"non-empty"</span>); <span style="color: green">// matches</span>
}</pre>

<h4>API</h4>
<h5><a href="https://openjdk.org/jeps/502">Stable Values (Preview) (JEP 502)</a></h5>
<p>В Java в режиме preview появилось новое API для <i>стабильных значений</i>. С помощью них можно создавать иммутабельные данные с отложенной инициализацией, то есть в момент первого обращения. При этом они имеют такую же производительность, как и final поля.</p>

<p>Вспомним, как в Java можно реализовать отложенную инициализацию классическими средствами:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">class</span> OrderController {
    <span style="color: blue">private</span> Logger logger = <span style="color: blue">null</span>;

    Logger getLogger() {
        <span style="color: blue">if</span> (logger == <span style="color: blue">null</span>) {
            logger = Logger.create(OrderController.<span style="color: blue">class</span>);
        }
        <span style="color: blue">return</span> logger;
    }

    <span style="color: blue">void</span> submitOrder(User user, List&lt;Product> products) {
        getLogger().info(<span style="color: darkred">"order started"</span>);
        ...
        getLogger().info(<span style="color: darkred">"order submitted"</span>);
    }
}</pre>
<p>В примере выше объект <code class="text-nowrap">logger</code> инициализируется в момент первого обращения. У такого подхода есть несколько проблем:</p>
<ul>
  <li>Любой доступ к полю <code class="text-nowrap">logger</code> должен происходить через метод <code class="text-nowrap">getLogger()</code>. Это можно забыть сделать.</li>
  <li>Код не является потокобезопасным: объект <code class="text-nowrap">logger</code> может инициализироваться несколько раз.</li>
  <li>Компилятор не может применить оптимизацию constant folding, так как поле <code class="text-nowrap">logger</code> не является final.</li>
</ul>

<p>Частично проблем выше можно избежать, прибегнув к другим более сложным идиомам, например, double-checked locking или class holder. Однако с double-checked locking код становится невероятно громоздким и хрупким (например, можно забыть вставить ключевое слово <code class="text-nowrap">volatile</code>), а так же отсутствует constant folding. С class holder код становится более-менее простым и надёжным (и есть constant folding), но у этой идиомы есть серьёзные ограничения: она применима только к статическим полям и для каждого поля приходится объявлять свой собственный класс. Также можно использовать <code class="text-nowrap">ConcurrentHashMap</code>, однако и у неё есть недостатки: отсутствует constant folding и есть проблемы, если функция возвращает <code class="text-nowrap">null</code>.</p>

<p>Теперь посмотрим, как код будет выглядеть с новым интерфейсом <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html"><code class="text-nowrap">StableValue</code></a>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
<span style="color: blue">class</span> OrderController {
    <span style="color: blue">private final</span> StableValue&lt;Logger> logger = StableValue.of();

    Logger getLogger() {
        <span style="color: blue">return</span> logger.orElseSet(() -> Logger.create(OrderController.<span style="color: blue">class</span>));
    }

    <span style="color: blue">void</span> submitOrder(User user, List&lt;Product> products) {
        getLogger().info(<span style="color: darkred">"order started"</span>);
        ...
        getLogger().info(<span style="color: darkred">"order submitted"</span>);
    }
}</pre>

<p>Метод <code class="text-nowrap">orElseSet()</code> вызывается, чтобы получить содержимое объекта <code class="text-nowrap">logger</code>. Если содержимое уже получено, то оно просто возвращается. Если нет, то содержимое вычисляется путём вызова переданного <code class="text-nowrap">Supplier</code>'а. <code class="text-nowrap">StableValue</code> гарантирует, что <code class="text-nowrap">Supplier</code> вызовется не более одного раза, тем самым обеспечивая потокобезопасность.</p>

<p>Под капотом <code class="text-nowrap">StableValue</code> реализован таким образом, что использует внутреннюю для JDK аннотацию <code class="text-nowrap">@Stable</code> для хранения содержимого в поле, не являющееся final. Эта аннотация даёт сигнал виртуальной машине, что поле не будет меняться более одного раза, а значит виртуальная машина после установки может считать его константным значением, что открывает возможность для constant folding. Таким образом, <code class="text-nowrap">StableValue</code> позволяет добиваться одновременно гибкости инициализации и хорошей производительности.</p>

<p>Часто удобно создать стабильное значение и сразу же в месте объявления передать <code class="text-nowrap">Supplier</code> для инициализации. Для этого есть метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html#supplier(java.util.function.Supplier)"><code class="text-nowrap">StableValue.supplier()</code></a>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
<span style="color: blue">class</span> OrderController {
    <span style="color: blue">private final</span> Supplier&lt;Logger> logger
        = StableValue.supplier(() -> Logger.create(OrderController.<span style="color: blue">class</span>));

    <span style="color: blue">void</span> submitOrder(User user, List&lt;Product> products) {
        logger.get().info(<span style="color: darkred">"order started"</span>);
        ...
        logger.get().info(<span style="color: darkred">"order submitted"</span>);
    }
}</pre>
<p>В примере выше объект <code class="text-nowrap">StableValue&lt;Logger></code> заменился на <code class="text-nowrap">Supplier&lt;Logger></code>, а код стал короче, потому что исчез метод <code class="text-nowrap">getLogger()</code>.</p>

<p>API также позволяет создавать не только значения с единичным содержимым, но и различные стабильные коллекции и стабильные функции. Приведём пример стабильного списка:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
<span style="color: blue">class</span> Application {
    <span style="color: blue">private static final</span> List&lt;OrderController> ORDERS
        = StableValue.list(POOL_SIZE, _ -> <span style="color: blue">new</span> OrderController());

    <span style="color: blue">public static</span> OrderController orders() {
        <span style="color: blue">long</span> index = Thread.currentThread().threadId() % POOL_SIZE;
        <span style="color: blue">return</span> ORDERS.get((<span style="color: blue">int</span>)index);
    }
}</pre>
<p>В примере выше список <code class="text-nowrap">ORDERS</code> &ndash; это список, который для каждого индекса вычисляет значение в момент обращения и не более одного раза. Таким образом, <code class="text-nowrap">StableValue</code> &ndash; это ещё и хороший вариант для написания кэшей.</p>

<h5><a href="https://openjdk.org/jeps/503">Remove the 32-bit x86 Port (JEP 503)</a></h5>
<p>32-битный x86 порт OpenJDK был окончательно удалён. Это означает, что из кодовой базы удалены части кода, отвечающие за 32 бит x86. Собрать JDK под эту платформу больше нельзя.</p>

<p>Ранее 32-битный x86 порт был помечен как <a href="https://openjdk.org/jeps/501">deprecated for removal</a> в Java 24. Причинами удаления порта являются сложность поддержки, отсутствие на ней эффективной реализации виртуальных потоков, окончание поддержки <a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro">Windows 10 в октябре 2025</a> (последняя версия Windows, поддерживающая 32 бит), скорое <a href="https://lists.debian.org/debian-devel-announce/2023/12/msg00003.html">прекращение поддержки 32 бит x86 в Debian</a> и др. Удаление 32 бит x86 поможет упростить и ускорить разработку OpenJDK, в частности таких API как Loom, Foreign Function & Memory API, Vector API и т.д.</p>

<h5><a href="https://openjdk.org/jeps/505">Structured Concurrency (Fifth Preview) (JEP 505)</a></h5>
<p>Structured Concurrency, которое было в режиме preview в <a href="https://openjdk.org/jeps/453">Java 21</a>, <a href="https://openjdk.org/jeps/462">Java 22</a>, <a href="https://openjdk.org/jeps/480">Java 23</a> и <a href="https://openjdk.org/jeps/499">Java 24</a>, остаётся в режиме preview в пятый раз.</p>

<p>По сравнению с Java 24 есть важное изменение в API: <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a> теперь создаётся не через публичные конструкторы, а через различные перегрузки статического метода <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open()"><code class="text-nowrap">open()</code></a>.</p>

<p>Structured Concurrency &ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.</p>

<p>В центре нового API класс <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a>, у которого есть два главных метода:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"><code class="text-nowrap">fork()</code></a> &ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,</li>
  <li><a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"><code class="text-nowrap">join()</code></a> &ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()">закрыт</a>.</li>
</ul>
<p>Пример использования <code class="text-nowrap">StructuredTaskScope</code>, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
<span style="color: blue">try</span> (<span style="color: blue">var</span> scope = StructuredTaskScope.open()) {
    Subtask&lt;String> user = scope.fork(() -> findUser());
    Subtask&lt;Integer> order = scope.fork(() -> fetchOrder());

    scope.join(); <span style="color: green">// Join subtasks, propagating exceptions</span>

    <span style="color: green">// Both subtasks have succeeded, so compose their results</span>
    <span style="color: blue">return new</span> Response(user.get(), order.get());
}</pre>
<p>Может показаться, что в точности аналогичный код можно было бы написать с использованием классического <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code class="text-nowrap">ExecutorService</code></a> и <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"><code class="text-nowrap">submit()</code></a>, но у <code class="text-nowrap">StructuredTaskScope</code> есть несколько принципиальных отличий, которые делают код безопаснее:</p>
<ul>
  <li>Время жизни всех потоков подзадач ограничено областью видимости блока <code class="text-nowrap">try-with-resources</code>. Метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"><code class="text-nowrap">close()</code></a> гарантированно не завершится, пока не завершатся все подзадачи.</li>
  <li>Если одна из операций <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае использования дефолтного <code class="text-nowrap">Joiner</code>'а <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#awaitAllSuccessfulOrThrow()"><code class="text-nowrap">awaitAllSuccessfulOrThrow()</code></a>, но возможны другие с другим поведением).</li>
  <li>Если главный поток прерывается в процессе ожидания <code class="text-nowrap">join()</code>, то обе операции <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> отменяются при выходе из блока.</li>
  <li>В дампе потоков будет видна иерархия: потоки, выполняющие <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code>, будут отображаться как дочерние для главного потока.</li>
</ul>
<p class="mt-2">Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.</p>

<p>В Java 26 возможно будет <a href="https://openjdk.org/jeps/8366891">шестое preview</a> Structured Concurrency с мелкими изменениями в API.</p>

<h5><a href="https://openjdk.org/jeps/506">Scoped Values (JEP 506)</a></h5>
<p>Scoped Values, которые были в preview в <a href="https://openjdk.org/jeps/446">Java 21</a>, <a href="https://openjdk.org/jeps/464">Java 22</a>, <a href="https://openjdk.org/jeps/481">Java 23</a> и <a href="https://openjdk.org/jeps/487">Java 24</a>, стали постоянным API.</p>

<p>По сравнению с Java 24 есть мелкое изменение: метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#orElse(T)"><code class="text-nowrap">ScopedValue.orElse()</code></a> больше не принимает <code class="text-nowrap">null</code> в качестве аргумента.</p>

<p>Класс <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html"><code class="text-nowrap">ScopedValue</code></a> позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a>.</p>

<p>Классы <code class="text-nowrap">ThreadLocal</code> и <code class="text-nowrap">ScopedValue</code> похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае <code class="text-nowrap">ThreadLocal</code> для этого вызывается метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"><code class="text-nowrap">set()</code></a>, который кладёт значение переменной для данного потока, а потом метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html#get()"><code class="text-nowrap">get()</code></a> вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:</p>
<ul>
  <li>Неконтролируемая мутабельность (<code class="text-nowrap">set()</code> можно вызвать когда угодно и откуда угодно).</li>
  <li>Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван <code class="text-nowrap">ThreadLocal.remove()</code>, но про него часто забывают).</li>
  <li>Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).</li>
</ul>
<p>Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.</p>

<p><code class="text-nowrap">ScopedValue</code> лишён вышеперечисленных недостатков. В отличие от <code class="text-nowrap">ThreadLocal</code>, <code class="text-nowrap">ScopedValue</code> не имеет метода <code class="text-nowrap">set()</code>. Значение ассоциируется с объектом <code class="text-nowrap">ScopedValue</code> путём вызова другого метода <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"><code class="text-nowrap">where()</code></a>. Далее вызывается метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"><code class="text-nowrap">run()</code></a>, на протяжении которого это значение можно получить (через метод <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#get()"><code class="text-nowrap">get()</code></a>), но нельзя изменить. Как только исполнение метода <code class="text-nowrap">run()</code> заканчивается, значение отвязывается от объекта <code class="text-nowrap">ScopedValue</code>. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.</p>
<p>Пример использования <code class="text-nowrap">ScopedValue</code>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">private static final</span> ScopedValue&lt;FrameworkContext> CONTEXT = ScopedValue.newInstance();

<span style="color: blue">void</span> serve(Request request, Response response) {
    <span style="color: blue">var</span> context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -> Application.handle(request, response));
}

<span style="color: blue">public</span> PersistedObject readKey(String key) {
    <span style="color: blue">var</span> context = CONTEXT.get();
    <span style="color: blue">var</span> db = getDBConnection(context);
    db.readKey(key);
}</pre>
<p>В целом <code class="text-nowrap">ScopedValue</code> является предпочтительной заменой <code class="text-nowrap">ThreadLocal</code>, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них <code class="text-nowrap">ThreadLocal</code> может быть единственно возможным решением.</p>

<h5><a href="https://openjdk.org/jeps/510">Key Derivation Function API (JEP 510)</a></h5>
<p>Key Derivation Function API, которое появилось <a href="https://openjdk.org/jeps/478">в Java 24 в режиме preview</a>, стало постоянным API. Оно находится в пакете <code class="text-nowrap">javax.crypto</code>.</p>

<p><a href="https://en.wikipedia.org/wiki/Key_derivation_function">Функции выведения ключа</a> (KDF - Key Derivation Functions) могут использоваться для вывода криптографически сильных секретных ключей (например, AES) на основе материала ключа (например, пароля) и других данных (например, соли).</p>

<p>Новое KDF API является гораздо более подходящим для задач выведения ключей, чем старое API на основе классов <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KeyGenerator.html">KeyGenerator</a> и <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/SecretKeyFactory.html">SecretKeyFactory</a>.</p>

<p>Пока что единственной реализацией KDF API в JDK является HKDF (HMAC-based Extract-and-Expand Key Derivation Function), но в будущем планируется реализовать и другие KDF, например, <a href="https://www.rfc-editor.org/rfc/rfc9106.html">Argon2</a>.</p>

<p>Пример выведения секретного AES-ключа с использованием HKDF:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// Create a KDF object for the specified algorithm</span>
KDF hkdf = KDF.getInstance(<span style="color: darkred">"HKDF-SHA256"</span>);

<span style="color: green">// Create an ExtractExpand parameter specification</span>
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

<span style="color: green">// Derive a 32-byte AES key</span>
SecretKey key = hkdf.deriveKey(<span style="color: darkred">"AES"</span>, params);

<span style="color: green">// Additional deriveKey calls can be made with the same KDF object</span></pre>

<p>Ранее в Java 21 появилось API для <a href="https://openjdk.org/jeps/452">механизма инкапсуляции ключей</a> (KEM). Вместе с KDF эти два API являются важными шагами для поддержки в Java <a href="https://www.rfc-editor.org/rfc/rfc9180.html">Hybrid Public Key Encryption</a> (HPKE), криптографической схемы, устойчивой к <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">квантовым атакам</a>.</p>

<h5><a href="https://openjdk.org/jeps/470">PEM Encodings of Cryptographic Objects (Preview) (JEP 470)</a></h5>
<p>В режиме preview появилось новое API для кодирования криптографических объектов в <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%87%D1%82%D0%B0_%D1%81_%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C%D1%8E">формат PEM</a> и декодирования обратно. Криптографическими объектами могут быть самые разные сущности: открытые ключи, закрытые ключи, сертификаты и т.д.</p>

<p>Приведём пример открытого ключа, закодированного в формате PEM:</p>
<pre class="border p-lg-2 p-1">-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi/kRGOL7wCPTN4KJ2ppeSt5UYB6u
cPjjuKDtFTXbguOIFDdZ65O/8HTUqS/sVzRF+dg7H3/tkQ/36KdtuADbwQ==
-----END PUBLIC KEY-----</pre>
<p>Такой ключ можно декодировать с помощью нового класса <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMDecoder.html"><code class="text-nowrap">java.security.PEMDecoder</code></a>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
PEMDecoder decoder = PEMDecoder.of();
PublicKey key = (PublicKey) decoder.decode(data);
System.out.println(key);</pre>
<p>Кодирование происходит с помощью класса <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMEncoder.html"><code class="text-nowrap">java.security.PEMEncoder</code></a>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 25</span>
PEMEncoder encoder = PEMEncoder.of();
String data = encoder.encodeToString(key);
System.out.println(data);</pre>

<p>Список всех криптографических объектов, которые можно кодировать/декодировать, лимитирован наследниками нового <code class="text-nowrap">sealed</code> интерфейса <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DEREncodable.html"><code class="text-nowrap">java.security.DEREncodable</code></a>:</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public sealed interface</span> DEREncodable <span style="color: blue">permits</span> AsymmetricKey, KeyPair,
    PKCS8EncodedKeySpec, X509EncodedKeySpec, EncryptedPrivateKeyInfo,
    X509Certificate, X509CRL, PEMRecord {
}</pre>

<p>Среди наследников выделяется особенный класс <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMRecord.html"><code class="text-nowrap">java.security.PEMRecord</code></a>. Этот класс может содержать в себе любые PEM-данные. Он может пригодиться, когда для криптографического объекта в Java нет соответствующего API (например, <a href="https://www.rfc-editor.org/rfc/rfc7468#section-7">запрос сертификата PKCS #10</a>):</p>
<!--java--><pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> PEMRecord(String type, String content, <span style="color: blue">byte</span>[] leadingData)
    <span style="color: blue">implements</span> DEREncodable {
    ...
}</pre>
<!--java--><pre class="border p-lg-2 p-1">PEMRecord pr = PEMDecoder.of().decode(pem, PEMRecord.<span style="color: blue">class</span>);</pre>

<p>В Java 26 будет <a href="https://openjdk.org/jeps/524">второе preview</a> этого API с некоторыми изменениями (например, <code class="text-nowrap">PEMRecord</code> будет переименован в <code class="text-nowrap">PEM</code>).</p>

<h5><a href="https://openjdk.org/jeps/508">Vector API (Tenth Incubator) (JEP 508)</a></h5>
<p>Векторное API в модуле <a href="https://docs.oracle.com/en/java/javase/25/docs/api/jdk.incubator.vector/module-summary.html"><code class="text-nowrap">jdk.incubator.vector</code></a>, которое появилось ещё аж <a href="https://openjdk.org/jeps/338">в Java 16</a>, остаётся в инкубационном статусе в десятый раз с некоторыми изменениями.</p>

<p>Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта <a href="https://openjdk.org/projects/valhalla/">Valhalla</a> (главным образом, от <a href="https://openjdk.org/jeps/401">value-классов</a>), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.</p>

<h4>JVM</h4>
<h5><a href="https://openjdk.org/jeps/519">Compact Object Headers (JEP 519)</a></h5>
<p>Компактные заголовки объектов, которые появились <a href="https://openjdk.org/jeps/450">в Java 24</a> в качестве экспериментального режима, больше не являются экспериментальными. Они всё ещё не включены по умолчанию. Таким образом, чтобы их включить, теперь нужна только одна опция:</p>
<pre class="border p-lg-2 p-1">$ java -XX:+UseCompactObjectHeaders ...</pre>
<p>При указании данной опции размер заголовков объектов в JVM уменьшается с 96/128 бит до 64 бит на 64-битных платформах. Компактные заголовки не только уменьшают размер кучи, но и могут улучшить производительность благодаря более высокой скорости выделения новых объектов, более низкой нагрузки на GC и лучшей локальности данных.</p>

<p>Сжатие заголовков достигается за счёт объединения mark-слова (64 бит) и class-слова (64 или 32 бит, если включены сжатые указатели на классы) в одно 64-битное слово. В новой схеме указатели на классы всегда являются сжатыми, и количество бит для них уменьшается с 32 до 22. Identity хеш-код остаётся неизменным: 31 бит. Количество тег-битов становится на один больше (для GC self forwarding). Битов для возраста GC остаётся 4, как и было. Также 4 бита резервируются на будущее для <a href="https://openjdk.org/projects/valhalla/">Valhalla</a>.</p>

<p>Работа по сжатию заголовков в OpenJDK ведётся в проекте <a href="https://openjdk.org/projects/lilliput/">Lilliput</a>, инициированным <a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html">в марте 2021 года</a>. В дальнейшем возможно ещё большое сжатие заголовков до 32 бит, что уменьшит потребление памяти ещё сильнее.</p>

<h5><a href="https://openjdk.org/jeps/509">JFR CPU-Time Profiling (Experimental) (JEP 509)</a></h5>
<p>В JDK Flight Recorder появилось профилирование времени CPU в экспериментальном режиме (только на Linux). Для этого появилось новое событие <code class="text-nowrap">jdk.CPUTimeSample</code>:</p>
<pre class="border p-lg-2 p-1">$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true,filename=profile.jfr ...</pre>

<p>Профилирование времени CPU похоже на обычное профилирование времени выполнения, но с важной разницей: первое измеряет фактическое время, потраченное CPU, то есть исключая различные ожидания (например, чтения из сокета). Построив такой профиль, можно понять, какие методы больше всего потребляют CPU. Профилирование времени CPU в JFR использует специальный таймер в ядре Linux, который генерирует сигнал через каждый фиксированный промежуток потраченного времени CPU.</p>

<p>Несмотря на то, что фича является экспериментальной, для её включения не требуется флаг <code class="text-nowrap">-XX:+UnlockExperimentalVMOptions</code>.</p>

<h5><a href="https://openjdk.org/jeps/518">JFR Cooperative Sampling (JEP 518)</a></h5>
<p>JDK Flight Recorder теперь более стабильно выполняет снятие стек-трейсов потоков во время семплирования.</p>

<p>Чтобы точно снять стек-трейс, необходимо это делать во время сейфпоинта, иначе профилирование будет страдать от проблемы safepoint bias и давать неточный результат. Поэтому раньше JFR снимал стек-трейсы в произвольных точках, а чтобы корректно построить стек-трейс, использовались эвристики. Однако эти эвристики могли быть неэффективными и даже приводить к крешам JVM.</p>

<p>Поэтому механизм семплирования был переработан и стал более стабилен. Теперь снятие стек-трейсов происходит только в сейфпоинтах, а проблема safepoint bias решается кооперативно: вместо снятия стек-трейса в произвольном месте (не в сейфпоинте) семплирующий поток записывает запрос на семпл в локальную очередь целевого потока, а тот, доходя до сейфпоинта, достаёт запрос из очереди, реконструирует стек-трейс и выдаёт событие JFR.</p>

<p>Новый механизм всё ещё имеет некоторые недостатки. Например, когда целевой поток выполняет нативный код, новый подход не используется и применяется старый подход.</p>

<h5><a href="https://openjdk.org/jeps/520">JFR Method Timing & Tracing (JEP 520)</a></h5>
<p>Ещё одним новшеством в JDK Flight Recorder стали средства для тайминга и трассировки методов с помощью инструментации байткода.</p>

<p>В отличие от семплирующих профилировщиков (вроде async-profiler), которые периодически снимают стек-трейсы и записывают статистику для наиболее часто исполняемых методов, новый механизм в JFR позволяет сохранять полную и точную информацию для любых методов, даже если метод был вызван всего один раз и работал очень короткое время.</p>

<p>Тайминг и трассировка методов сохраняются с помощью двух новых событий <code class="text-nowrap">jdk.MethodTiming</code> и <code class="text-nowrap">jdk.MethodTrace</code>. Оба эти события принимают фильтр, в котором необходимо прописать метод (или методы).</p>

<p>В следующем примере происходит трассировка метода <code class="text-nowrap">HashMap.resize()</code> и дальнейшая распечатка через <code class="text-nowrap">jfr</code> всех его вызовов с подробной информацией (время начала вызова, длительность вызова, поток и стек-трейс):</p>
<pre class="border p-lg-2 p-1">$ java -XX:StartFlightRecording:method-trace=java.util.HashMap::resize,filename=recording.jfr ...
$ jfr print --events jdk.MethodTrace --stack-depth 20 recording.jfr
jdk.MethodTrace {
    startTime = 00:39:26.379 (2025-03-05)
    duration = 0.00113 ms
    method = java.util.HashMap.resize()
    eventThread = "main" (javaThreadId = 3)
    stackTrace = [
      java.util.HashMap.putVal(int, Object, Object, boolean, boolean) line: 636
      java.util.HashMap.put(Object, Object) line: 619
      sun.awt.AppContext.put(Object, Object) line: 598
      sun.awt.AppContext.&lt;init>(ThreadGroup) line: 240
      sun.awt.SunToolkit.createNewAppContext(ThreadGroup) line: 282
      sun.awt.AppContext.initMainAppContext() line: 260
      sun.awt.AppContext.getAppContext() line: 295
      sun.awt.SunToolkit.getSystemEventQueueImplPP() line: 1024
      sun.awt.SunToolkit.getSystemEventQueueImpl() line: 1019
      java.awt.Toolkit.getEventQueue() line: 1375
      java.awt.EventQueue.invokeLater(Runnable) line: 1257
      javax.swing.SwingUtilities.invokeLater(Runnable) line: 1415
      java2d.J2Ddemo.main(String[]) line: 674
    ]
}
...</pre>
<p>Трассировка происходит путём инструментации метода <code class="text-nowrap">HashMap.resize()</code> и внедрения в него эмиссии события <code class="text-nowrap">jdk.MethodTrace</code>.</p>

<p>Рассмотрим другой пример, где замеряется тайминг всех статических инициализаторов:</p>
<pre class="border p-lg-2 p-1">$ java '-XX:StartFlightRecording:method-timing=::&lt;clinit>,filename=clinit.jfr' ...
$ jfr view method-timing clinit.jfr

                                 Method Timing

Timed Method                                           Invocations Average Time
------------------------------------------------------ ----------- ------------
sun.font.HBShaper.&lt;clinit>()                                     1 32.500000 ms
java.awt.GraphicsEnvironment$LocalGE.&lt;clinit>()                  1 32.400000 ms
java2d.DemoFonts.&lt;clinit>()                                      1 21.200000 ms
java.nio.file.TempFileHelper.&lt;clinit>()                          1 17.100000 ms
sun.security.util.SecurityProviderConstants.&lt;clinit>()           1  9.860000 ms
java.awt.Component.&lt;clinit>()                                    1  9.120000 ms
sun.font.SunFontManager.&lt;clinit>()                               1  8.350000 ms
sun.java2d.SurfaceData.&lt;clinit>()                                1  8.300000 ms
java.security.Security.&lt;clinit>()                                1  8.020000 ms
sun.security.util.KnownOIDs.&lt;clinit>()                           1  7.550000 ms
...</pre>
<p>Здесь в качестве фильтра был указан <code class="text-nowrap">::&lt;clinit></code>, что означает все статические инициализаторы всех классов, а не один статический инициализатор конкретного класса.</p>

<p>В фильтрах могут быть указаны не только методы, но и классы. В таком случае замеряться тайминг или записываться трассировка будет для всех методов класса. Также можно указывать аннотации. В этом случае будут фильтроваться методы или классы, помеченные указанными аннотациями. Например, если указать фильтр <code class="text-nowrap">method-timing=@jakarta.ws.rs.GET</code>, то будет записываться статистика вызова эндпоинтов REST-сервиса. Или можно объявить свою аннотацию, например, <code class="text-nowrap">@StopWatch</code> и явно помечать ею методы, которые необходимо замерить:</p>
<pre class="border p-lg-2 p-1">$ java -XX:StartFlightRecording:method-timing=@com.example.StopWatch ...</pre>

<p>Конфигурацию можно осуществлять не только через командную строку, но и через конфигурационные файлы:</p>
<!--xml--><pre class="border p-lg-2 p-1"><span style="color: green">&lt;!-- timing.jfc --></span>
&lt;?xml version="1.0" encoding="UTF-8"?>
  &lt;configuration version="2.0">
  &lt;event name="jdk.MethodTiming">
    &lt;setting name="enabled">true&lt;/setting>
    &lt;setting name="filter">
      com.example.Foo::method1;
      com.example.Bar::method2;
      ...
      com.example.Baz::method17
    &lt;/setting>
  &lt;/event>
&lt;/configuration></pre>
<pre class="border p-lg-2 p-1">$ java -XX:StartFlightRecording:settings=timing.jfc,settings=default ...</pre>

<p>Также инициировать процесс записи можно на уже запущенной JVM (через <code class="text-nowrap">jcmd</code>). Кроме того, через JMX трассировку и тайминг можно передавать по сети.</p>

<h5><a href="https://openjdk.org/jeps/514">Ahead-of-Time Command-Line Ergonomics (JEP 514)</a></h5>
<p>Теперь стало проще создавать AOT-кэши, поддержка которых появилась <a href="https://openjdk.org/jeps/483">в Java 24</a>. Теперь это делается в один этап, а не в два.</p>

<p>В Java 24 AOT-кэш приходилось создавать двумя запусками, сначала записывая AOT-конфигурацию, а потом используя эту конфигурацию для создания кэша:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf \
       -cp app.jar com.example.App ...
$ java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf \
       -XX:AOTCache=app.aot -cp app.jar</pre>

<p>Теперь же второй запуск не требуется, и создать кэш можно сразу же. Для этого появился новый ключ <code class="text-nowrap">AOTCacheOutput</code>:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...</pre>

<p>Запуск приложения с кэшом проходит точно так же. Здесь ничего не изменилось:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...</pre>

<p>Напомним, что Ahead-of-Time Class Loading & Linking &ndash; это технология, которая улучшает время стартапа Java-приложений благодаря использованию уже готовых загруженных и слинкованных классов. Создание таких классов происходит во время тренировочного запуске приложения, который создаёт ahead-of-time кэш. Далее все последующие ("боевые") запуски используют этот кэш для более быстрого старта.</p>

<p>Работа над ускорением запуска JVM ведётся в проекте <a href="https://openjdk.org/projects/leyden/">Leyden</a>. Он был инициирован <a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html">в апреле 2020 года</a>.</p>

<h5><a href="https://openjdk.org/jeps/515">Ahead-of-Time Method Profiling (JEP 515)</a></h5>
<p>Ещё одно улучшение AOT в Java &ndash; это появление профилей методов в AOT-кэшах. Профили методов собираются во время тренировочного запуска и в последующих запусках используются виртуальной машиной для более быстрого прогрева. Благодаря этому программа стартует быстрее и быстрее достигает пиковой производительности.</p>

<p>Например, небольшая программа, использующая Stream API и загружающая около 900 классов JDK, выполняется за 73 миллисекунды с использованием профиля, в то время как без профиля она выполняется за 90 миллисекунд. Таким образом, улучшение составляет 19%. При этом размер кэша увеличивается всего на 2.5%.</p>

<p class="mt-2">Профилирование методов необходимо для выявления горячих методов. Такие методы потребляют больше всего CPU, и чтобы программа работала быстро, JVM должна такие методы компилировать в нативный код в первую очередь. Однако профилирование &ndash; это довольно трудоёмкий процесс, особенно в фазе прогрева, когда профили ещё отсутствуют полностью. Если собирать профили заранее, то можно сократить некоторый объём работы на старте. Благодаря этому выигрышу фаза прогрева сокращается по времени.</p>

<h5><a href="https://openjdk.org/jeps/521">Generational Shenandoah (JEP 521)</a></h5>
<p>Режим работы с поколениями в сборщике мусора Shenandoah, который появился <a href="https://openjdk.org/jeps/404">в Java 24</a>, больше не является экспериментальным. Теперь для его включения не нужен флаг <code class="text-nowrap">-XX:+UnlockExperimentalVMOptions</code>:</p>
<pre class="border p-lg-2 p-1">$ java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational ...</pre>
<p>Режим работы без поколений пока что остаётся режимом по умолчанию в Shenandoah.</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2025" role="button" aria-expanded="true" aria-controls="year2025">2025</a>
  <ul class="collapse show" id="year2025">
<li class="text-secondary"><a href="java_25.html" class="text-secondary">Вышла Java 25</a></li>
<li class="text-secondary"><a href="java_24.html" class="text-secondary">Вышла Java 24</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2024" role="button" aria-expanded="false" aria-controls="year2024">2024</a>
  <ul class="collapse" id="year2024">
<li class="text-secondary"><a href="java_23.html" class="text-secondary">Вышла Java 23</a></li>
<li class="text-secondary"><a href="java_22.html" class="text-secondary">Вышла Java 22</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="false" aria-controls="year2023">2023</a>
  <ul class="collapse" id="year2023">
<li class="text-secondary"><a href="java_21.html" class="text-secondary">Вышла Java 21</a></li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2025</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.org/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
