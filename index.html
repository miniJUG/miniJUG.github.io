<!doctype html>
<html lang="ru">
  <head>
    <title>miniJUG</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="miniJUG">
    <meta property="og:description" content="Новости Java">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2024-03-19">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="miniJUG">
    <meta name="twitter:description" content="Новости Java">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.org/minijug.png">
    <meta property="og:image:width" content="1269">
    <meta property="og:image:height" content="664">
    <meta name="twitter:image" content="https://minijug.org/minijug.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Вышла Java 22</h3>
<p class="text-secondary"><time datetime="2024-03-19">19 марта, 2024</time></p>
<article>
<p>Вышла общедоступная версия <a href="https://openjdk.org/projects/jdk/22/">Java 22</a>. В этот релиз попало около <a href="https://builds.shipilev.net/backports-monitor/release-notes-22.html">2300 закрытых задач и 12 JEP'ов</a>. Release Notes можно посмотреть <a href="http://jdk.java.net/22/release-notes">здесь</a>. Полный список изменений API &ndash; <a href="https://javaalmanac.io/jdk/22/apidiff/21/">здесь</a>.</p>

<p>Java 22 не является LTS-релизом, и у неё будут выходить обновления <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">только полгода</a> (до сентября 2024 года).</p>
<!-- cut -->
<p>Скачать JDK 22 можно по этим ссылкам:</p>
<ul>
    <li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a> (лицензия <a href="https://www.oracle.com/downloads/licenses/no-fee-license.html">NFTC</a>)</li>
    <li><a href="http://jdk.java.net/22/">OpenJDK</a> (лицензия <a href="https://openjdk.org/legal/gplv2+ce.html">GPLv2 with Classpath Exception</a>)</li>
</ul>

<p class="pt-1">Рассмотрим все JEP'ы, которые попали в Java 22.</p>

<h5><a href="https://openjdk.org/jeps/456">Unnamed Variables & Patterns (JEP 456)</a></h5>
<p>Безымянные переменные и паттерны, которые появились <a href="https://openjdk.org/jeps/443">в режиме preview в Java 21</a>, теперь стали постоянной языковой конструкцией.</p>

<p>Безымянная переменная &ndash; это переменная, которая обозначена автором как неиспользуемая и обозначаемая символом подчёркивания (<code class="text-nowrap">_</code>).</p>

<p>Неиспользуемые переменные довольно часто встречаются на практике:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">static int</span> count(Iterable&lt;Order> orders) {
    <span style="color: blue">int</span> total = 0;
    <span style="color: blue">for</span> (Order _ : orders) <span style="color: green">// order is unused</span>
        total++;
    <span style="color: blue">return</span> total;
}</pre>
<p>В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому для неё был выбран символ подчёркивания вместо имени. Другой пример:</p>
<pre class="border p-lg-2 p-1">Queue&lt;Integer> q = <span style="color: grey">...</span> <span style="color: green">// x1, y1, z1, x2, y2, z2, ...</span>
<span style="color: blue">while</span> (q.size() >= 3) {
   <span style="color: blue">var</span> x = q.remove();
   <span style="color: blue">var</span> y = q.remove();
   <span style="color: blue">var</span> _ = q.remove();
   <span style="color: grey">... new Point(x, y) ...</span>
}</pre>
<p>Здесь были необходимы только координаты <code class="text-nowrap">x</code> и <code class="text-nowrap">y</code>, поэтому для третьей координаты была явно выбрана безымянная переменная, чтобы явно продемонстрировать, что она не используется.</p>

<p>Частый случай необходимости безымянных переменных &ndash; это неиспользуемые исключения в блоке <code class="text-nowrap">catch</code>:</p>
<pre class="border p-lg-2 p-1">String s = ...
<span style="color: blue">try</span> {
    <span style="color: blue">int</span> i = Integer.parseInt(s);
    <span style="color: grey">... i ...</span>
} <span style="color: blue">catch</span> (NumberFormatException _) {
    System.out.println(<span style="color: darkred">"Bad number: "</span> + s);
}</pre>
<p>Здесь важен сам факт наличия исключения, но не само исключение.</p>

<p><code class="text-nowrap">try</code> с ресурсом:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> _ = ScopedContext.acquire()) {
    <span style="color: grey">... no use of acquired resource ...</span>
}</pre>

<p>Ну и, конечно же, неиспользуемые параметры лямбда-выражений:</p>
<pre class="border p-lg-2 p-1">...stream.collect(Collectors.toMap(String::toUpperCase, _ -> <span style="color: darkred">"NODATA"</span>))</pre>

<p>Во всех примерах выше использование символа подчёркивания делает код короче и читабельнее, явно обозначает намерения автора и уменьшает пространство для допущения ошибок. Также оно помогает инструментам статического анализа, которые могут жаловаться на неиспользуемые переменные.</p>

<p>Безымянными могут быть не только переменные, но и <i>паттерны</i>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> ColoredPoint(Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y), _)) {
    <span style="color: grey">... x ... y ...</span>
}</pre>

<p>Аналогичным образом можно извлечь только цвет, если нужен только он, но не нужны координаты:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> ColoredPoint(_, Color c)) {
    <span style="color: grey">... c ...</span>
}</pre>

<p>Также есть возможность объявлять <i>безымянные переменные паттернов</i>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">switch</span> (ball) {
    <span style="color: blue">case</span> RedBall _   -> process(ball);
    <span style="color: blue">case</span> BlueBall _  -> process(ball);
    <span style="color: blue">case</span> GreenBall _ -> stopProcessing();
}</pre>

<p>Код выше можно сократить, объединив две первые ветки <code class="text-nowrap">case</code> в одну:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">switch</span> (ball) {
    <span style="color: blue">case</span> RedBall _, BlueBall _  -> process(ball);
    <span style="color: blue">case</span> GreenBall _            -> stopProcessing();
}</pre>

<p>Заметим, что такое объединение было бы невозможным без использования безымянных паттернов, так как раньше несколько паттернов в одной ветке разрешались только при отсутствии в них переменных паттернов.</p>

<p>Более сложный пример со вложенными паттернами, где есть и безымянные паттерны, и безымянные переменные паттернов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">switch</span> (box) {
    <span style="color: blue">case</span> Box(RedBall _), Box(BlueBall _) -> processBox(box);
    <span style="color: blue">case</span> Box(GreenBall _)                -> stopProcessing();
    <span style="color: blue">case</span> Box(_)                          -> pickAnotherBox();
}</pre>

<p>В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.</p>

<h5><a href="https://openjdk.org/jeps/458">Launch Multi-File Source-Code Programs (JEP 458)</a></h5>
<p>Теперь лаунчер <code class="text-nowrap">java</code> может запускать программы, состоящие из нескольких исходных файлов Java.</p>
<p>Напомним, что ранее в Java 11 появилась возможность запускать программы, состоящие из одного файла, без необходимости самостоятельной компиляции (<a href="https://openjdk.org/jeps/330">JEP 330</a>):</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Prog.java</span>

<span style="color: blue">class</span> Prog {
    <span style="color: blue">public static void</span> main(String[] args) { Helper.run(); }
}

<span style="color: blue">class</span> Helper {
    <span style="color: blue">static void</span> run() { System.out.println(<span style="color: darkred">"Hello!"</span>); }
}
</pre>
<p>Такой файл можно было запустить, просто написав:</p>
<pre class="border p-lg-2 p-1">$ java Prog.java
Hello!</pre>

<p>А сейчас эта возможность была расширена до произвольного количества файлов:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Prog.java</span>
<span style="color: blue">class</span> Prog {
    <span style="color: blue">public static void</span> main(String[] args) { Helper.run(); }
}

<span style="color: green">// Helper.java</span>
<span style="color: blue">class</span> Helper {
    <span style="color: blue">static void</span> run() { System.out.println(<span style="color: darkred">"Hello!"</span>); }
}</pre>
<p>Если программу выше запустить через <code class="text-nowrap">java Prog.java</code>, то Java скомпилирует в память класс <code class="text-nowrap">Prog</code> и запустит его метод <code class="text-nowrap">main</code>. Так как класс <code class="text-nowrap">Prog</code> ссылается на класс <code class="text-nowrap">Helper</code>, то Java найдёт его в файле <code class="text-nowrap">Helper.java</code> и тоже скомпилирует его. Таким образом, программа, разбитая на два файла будет работать точно так же, как если бы все классы были помещены в один исходный файл. Этот алгоритм может быть расширен до произвольного количества файлов. Например, если <code class="text-nowrap">Helper</code> ссылается ещё на один класс <code class="text-nowrap">HelperAux</code>, то будет найден и скомпилирован файл <code class="text-nowrap">HelperAux.java</code>.</p>

<p>Возможность запускать без отдельного шага компиляции программы, состоящие из нескольких исходных файлов, может быть очень полезной. Главным образом, это может пригодиться для быстрого прототипирования или на ранних стадиях проектов, когда проект ещё не обрёл более-менее стабильную форму. В таких случаях у разработчика есть возможность пропустить стадию настройки сборки проекта и сразу приступить к написанию кода, не ограничиваясь при этом одним исходным файлом (что пришлось бы делать до Java 22). Для некоторых несложных проектов такая конфигурация запуска без инструментов сборки может и вовсе оставаться постоянной.</p>

<p>Программы, использующие библиотеки в виде уже скомпилированных jar-файлов, также могут быть запущены напрямую. Например, если есть структура:</p>
<ul>
    <li>Prog.java</li>
    <li>Helper.java</li>
    <li>libs/library.jar</li>
</ul>
<p>То такую программу можно запустить с помощью опции <code class="text-nowrap">--class-path</code> (или <code class="text-nowrap">-cp</code>):</p>
<pre class="border p-lg-2 p-1">$ java --class-path "libs/*" Prog.java</pre>

<h5><a href="https://openjdk.org/jeps/459">String Templates (Second Preview) (JEP 459)</a></h5>
<p>Строковые шаблоны, которые появились в режиме preview <a href="https://openjdk.org/jeps/430">в Java 21</a>, уходят на второй раунд preview без изменений.</p>
<p>Строковые шаблоны &ndash; это новая синтаксическая возможность, позволяющая встраивать в строки выражения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> x = 10;
<span style="color: blue">int</span> y = 20;
<span style="color: green">// --enable-preview --release 22</span>
String str = STR.<span style="color: darkred">"</span>\{x} <span style="color: darkred">plus</span> \{y} <span style="color: darkred">equals</span> \{x + y}<span style="color: darkred">"</span>;
<span style="color: green">// В str будет лежать "10 + 20 equals 30"</span></pre>
<p>То есть это строковая интерполяция, которая уже давно есть во многих других известных языках программирования.</p>

<p>Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html"><code class="text-nowrap">java.lang.StringTemplate</code></a>, а затем <i>процессор</i>, реализующий <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html"><code class="text-nowrap">java.lang.StringTemplate.Processor</code></a>, конвертирует этот объект в строку или объект другого класса (<i>примечание: сейчас <a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html">идут обсуждения</a> относительно отказа идеи процессоров и оставления только <code class="text-nowrap">StringTemplate</code></i>). В примере выше <code class="text-nowrap">STR."…"</code> есть ничто иное, как сокращённый вариант следующего кода:</p>
<pre class="border p-lg-2 p-1">StringTemplate template = RAW.<span style="color: darkred">"</span>\{x} <span style="color: darkred">plus</span> \{y} <span style="color: darkred">equals</span> \{x + y}<span style="color: darkred">"</span>;
String str = STR.process(template);</pre>
<p><a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#STR"><code class="text-nowrap">STR</code></a> &ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. <code class="text-nowrap">STR</code> неявно импортируется в любой исходный файл, поэтому его можно использовать без <code class="text-nowrap">import</code>.</p>
<p><a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#RAW"><code class="text-nowrap">RAW</code></a> &ndash; это процессор, который ничего не делает со <code class="text-nowrap">StringTemplate</code> и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.</p>

<p>Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/FormatProcessor.html#FMT"><code class="text-nowrap">FMT</code></a> поддерживает форматирование с использованием спецификаторов, определённых в <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html"><code class="text-nowrap">java.util.Formatter</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">double</span> length = 46;
System.out.println(FMT.<span style="color: darkred">"The length is %.2f</span>\{length} <span style="color: darkred">cm"</span>);
<span style="color: green">// The length is 46.00 cm</span></pre>
<p>Процессоры необязательно должны возвращать <code class="text-nowrap">String</code>. Вот общая сигнатура метода <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"><code class="text-nowrap">process()</code></a> интерфейса <code class="text-nowrap">Processor</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public interface</span> Processor&lt;R, E <span style="color: blue">extends</span> Throwable> {
    R process(StringTemplate stringTemplate) <span style="color: blue">throws</span> E;
}</pre>
<p>Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор <code class="text-nowrap">JSON</code> будет создавать напрямую объекты JSON (без промежуточного объекта <code class="text-nowrap">String</code>) и при этом поддерживать экранирование кавычек:</p>
<pre class="border p-lg-2 p-1">JSONObject doc = JSON.<span style="color: darkred">"""</span>
    <span style="color: darkred">{</span>
        <span style="color: darkred">"name":    "</span>\{name}<span style="color: darkred">",</span>
        <span style="color: darkred">"phone":   "</span>\{phone}<span style="color: darkred">",</span>
        <span style="color: darkred">"address": "</span>\{address}<span style="color: darkred">"</span>
    };
    <span style="color: darkred">"""</span>;</pre>
<p>Если в <code class="text-nowrap">name</code>, <code class="text-nowrap">phone</code> или <code class="text-nowrap">address</code> будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит <code class="text-nowrap">&quot;</code> на <code class="text-nowrap">\&quot;</code>.</p>
<p>Или, например, процессор <code class="text-nowrap">SQL</code> будет создавать PreparedStatement'ы, защищая от атак SQL Injection:</p>
<pre class="border p-lg-2 p-1">PreparedStatement ps = SQL.<span style="color: darkred">"SELECT * FROM Person p WHERE p.name = </span>\{name}<span style="color: darkred">"</span>;</pre>

<p>Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.</p>

<h5><a href="https://openjdk.org/jeps/447">Statements before <code class="text-nowrap">super(...)</code> (Preview) (JEP 447)</a></h5>
<p>В режиме preview теперь стало возможным писать инструкции кода в конструкторе перед явным вызовом конструктора (<code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>):</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --release 22</span>
<span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">super</span>(value);
    }
}</pre>

<p>Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">super</span>(verifyPositive(value));
    }

    <span style="color: blue">private static long</span> verifyPositive(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
    }
}</pre>

<p>Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">private</span> Sub(<span style="color: blue">int</span> i, F f) { <span style="color: green">// Auxiliary constructor</span>
        <span style="color: blue">super</span>(f, f); <span style="color: green">// f is shared here</span>
        ...
    }

    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>(i, <span style="color: blue">new</span> F());
    }
}</pre>

<p>В Java 22, включив режим preview, то же самое можно реализовать гораздо короче:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --release 22</span>
<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">var</span> f = <span style="color: blue">new</span> F();
        <span style="color: blue">super</span>(f, f); <span style="color: green">// f is shared here</span>
        ...
    }
}</pre>

<p>Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект. Это обеспечивает гарантию того, что инициализация всегда происходит сверху-вниз: инициализация полей суперкласса должна всегда выполняться раньше инициализации полей подкласса (<i>возможно такое ограничение смягчат в Java 23 <a href="https://openjdk.org/jeps/8325803">в следующем preview</a></i>). Рассмотрим несколько примеров некорректного кода:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A() {
        <span style="color: blue">this</span>.i++;               <span style="color: red">// Error</span>
        hashCode();             <span style="color: red">// Error</span>
        System.out.print(<span style="color: blue">this</span>); <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Ссылаться на поля суперкласса также нельзя (ведь это тоже часть текущего объекта):</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> D {
    <span style="color: blue">int</span> i;
}

<span style="color: blue">class</span> A <span style="color: blue">extends</span> D {
    <span style="color: blue">int</span> i;

    A() {
        i++; <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Outer {
    <span style="color: blue">class</span> Inner {
    }

    Outer() {
        <span style="color: blue">new</span> Inner(); <span style="color: red">// Error - 'this' is enclosing instance</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Интересно, что новая возможность затрагивает исключительно компилятор Java &ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом <code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).</p>

<h5><a href="https://openjdk.org/jeps/463">Implicitly Declared Classes and Instance Main Methods (Second Preview) (JEP 463)</a></h5>
<p>В Java 21 в режиме preview появились <a href="https://openjdk.org/jeps/445">Unnamed Classes and Instance Main Methods</a>. В Java 22 было принято решение оставить эту фичу на второе preview с некоторыми изменениями. Основное из них &ndash; это отказ от <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isUnnamedClass()">безымянных классов</a> в пользу неявно объявленных классов. Также упрощена процедура выбора <code class="text-nowrap">main</code>-метода для запуска: если есть метод <code class="text-nowrap">main</code> с <code class="text-nowrap">String[] args</code>, то запускается он (неважно, <code class="text-nowrap">static</code> или нет), иначе запускается метод <code class="text-nowrap">main</code> без аргументов.</p>
<p>Новый протокол запуска позволяет запускать классы, у которых метод <code class="text-nowrap">main()</code> не является <code class="text-nowrap">public static</code> и у которого нет параметра <code class="text-nowrap">String[] args</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> HelloWorld {
    <span style="color: blue">void</span> main() {
        System.out.println(<span style="color: darkred">"Hello, World!"</span>);
    }
}</pre>
<p>В таком случае во время запуска JVM сама создаст экземпляр класса <code class="text-nowrap">HelloWorld</code> и вызовет у него метод <code class="text-nowrap">main()</code>:</p>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 22 HelloWorld.java
Hello, World!</pre>

<p class="mt-2">Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// HelloWorld.java</span>

String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}</pre>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 22 HelloWorld.java
Hello, World!</pre>

<p>В таком случае виртуальная машина сама объявит неявный класс, в который помести метод <code class="text-nowrap">main()</code> и другие верхнеуровневые объявления в файле:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// class &lt;some name> { ← неявно</span>
String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}
<span style="color: green">// }</span></pre>
<p>Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:</p>
<ul>
  <li>Код в неявном классе не может ссылаться на него по имени.</li>
  <li>Неявный класс всегда имеет один неявный конструктор без аргументов.</li>
  <li>Неявный класс может находиться только в безымянном пакете.</li>
</ul>
<p>При этом неявный класс не является безымянным: у него есть <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Class.html#getName()">имя</a>, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).</p>

<p class="mt-2">Упрощение запуска Java-программ было сделано с двумя целями:</p>
<ol>
  <li>Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).</li>
  <li>Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.</li>
</ol>

<h5><a href="https://openjdk.org/jeps/461">Stream Gatherers (Preview) (JEP 461)</a></h5>
<p>Stream API был усовершенствован, чтобы поддерживать произвольные промежуточные операции, в режиме preview.</p>
<p>Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (<a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"><code class="text-nowrap">map</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"><code class="text-nowrap">flatMap</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"><code class="text-nowrap">filter</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"><code class="text-nowrap">reduce</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#limit(long)"><code class="text-nowrap">limit</code></a>,
    <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#skip(long)"><code class="text-nowrap">skip</code></a> и т.д). В Java 9 были добавлены <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"><code class="text-nowrap">takeWhile</code></a> и <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"><code class="text-nowrap">dropWhile</code></a>. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.</p>
<p>Новая точка расширения &ndash; это новый метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"><code class="text-nowrap">Stream::gather(Gatherer)</code></a>, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html"><code class="text-nowrap">Gatherer</code></a>, предоставляемого пользователем. Операция <code class="text-nowrap">gather()</code> аналогична уже имеющейся операции <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"><code class="text-nowrap">Stream::collect(Collector)</code></a>: если <code class="text-nowrap">collect()</code> и <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html"><code class="text-nowrap">Collector</code></a> определяют точку расширения для терминальных операций, то <code class="text-nowrap">gather()</code> и <code class="text-nowrap">Gatherer</code> определяют точкой расширения для промежуточных.</p>
<p><code class="text-nowrap">Gatherer</code> представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса <code class="text-nowrap">Gatherer</code>.</p>
<p><code class="text-nowrap">gather()</code> также является промежуточной операцией, поэтому может быть несколько <code class="text-nowrap">gather()</code> в одной цепочке:</p>
<pre class="border p-lg-2 p-1">source.gather(a).gather(b).gather(c).collect(...)</pre>

<p>Вместе с самим <code class="text-nowrap">Gatherer</code> было добавлено несколько готовых gatherer'ов, определённых в новом классе <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html"><code class="text-nowrap">Gatherers</code></a>. Это <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">fold</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"><code class="text-nowrap">mapConcurrent</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">scan</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"><code class="text-nowrap">windowFixed</code></a> и
    <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"><code class="text-nowrap">windowSliding</code></a>.</p>
<p>Давайте рассмотрим несколько примеров:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.fold(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .findFirst()
   <span style="color: grey">...></span>       .get();
<span style="color: grey">$1 ==></span> "123456789"</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.scan(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .toList()
<span style="color: grey">$2 ==></span> [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
<span style="color: grey">$3 ==></span> [[1, 2, 3], [4, 5, 6], [7, 8]]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
<span style="color: grey">$4 ==></span> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]</pre>

<p>Дизайн интерфейса <code class="text-nowrap">Gatherer</code> был создан под влиянием интерфейса <code class="text-nowrap">Collector</code>. Вот основная часть его сигнатуры:</p>
<pre class="border p-lg-2 p-1">public interface Gatherer&lt;T, A, R> {
    Supplier&lt;A> initializer();
    Integrator&lt;A, T, R> integrator();
    BinaryOperator&lt;A> combiner();
    BiConsumer&lt;A, Downstream&lt;? super R>> finisher();
}</pre>
<p>Если взглянуть на <code class="text-nowrap">Collector</code>, то он также имеет три параметра <code class="text-nowrap">T</code>, <code class="text-nowrap">A</code>, <code class="text-nowrap">R</code> и содержит 4 основных метода: <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#supplier()"><code class="text-nowrap">supplier</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#accumulator()"><code class="text-nowrap">accumulator</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#combiner()"><code class="text-nowrap">combiner</code></a> и <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#finisher()"><code class="text-nowrap">finisher</code></a>. Однако <code class="text-nowrap">Gatherer</code> использует два вспомогательных интерфейса <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"><code class="text-nowrap">Integrator</code></a> и
    <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"><code class="text-nowrap">Downstream</code></a>, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.</p>
<p>Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс <code class="text-nowrap">Gatherer</code> и можно воспользоваться готовыми методами-фабриками: <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::of(Integrator)</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::ofSequential(Integrator)</code></a> или другими вариациями.</p>

<h5><a href="https://openjdk.org/jeps/457">Class-File API (Preview) (JEP 457)</a></h5>
<p>В режиме preview появилось стандартное API для парсинга, генерации и трансформации class-файлов.</p>
<p>Новое API находится в пакете <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/classfile/package-summary.html"><code class="text-nowrap">java.lang.classfile</code></a>. Оно должно заменить копию библиотеки <a href="https://asm.ow2.io/">ASM</a> внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.</p>
<p>Основная проблема ASM (и других библиотек для работы с class-файлами) &ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.</p>
<p>Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.</p>

<h5><a href="https://openjdk.org/jeps/462">Structured Concurrency (Second Preview) (JEP 462)</a></h5>
<p>Structured Concurrency, которое перешло в режиме preview <a href="https://openjdk.org/jeps/453">в Java 21</a>, уходит на второй раунд preview без изменений. Ранее оно было в инкубаторе в <a href="https://openjdk.org/jeps/428">Java 19</a> и <a href="https://openjdk.org/jeps/437">Java 20</a></p>

<p>Structured Concurrency &ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.</p>
<p>В центре нового API класс <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a>, у которого есть два главных метода:</p>
<ul>
    <li><a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"><code class="text-nowrap">fork()</code></a> &ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,</li>
    <li><a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"><code class="text-nowrap">join()</code></a> &ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()">остановлен</a>.</li>
</ul>
<p>Пример использования <code class="text-nowrap">StructuredTaskScope</code>, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> scope = <span style="color: blue">new</span> StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&lt;String> user = scope.fork(() -> findUser());
    Supplier&lt;Integer> order = scope.fork(() -> fetchOrder());

    scope.join()            <span style="color: green">// Join both forks</span>
         .throwIfFailed();  <span style="color: green">// ... and propagate errors</span>

    <span style="color: blue">return new</span> Response(user.get(), order.get());
}</pre>
<p>Может показаться, что в точности аналогичный код можно было бы написать с использованием классического <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code class="text-nowrap">ExecutorService</code></a> и <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"><code class="text-nowrap">submit()</code></a>, но у <code class="text-nowrap">StructuredTaskScope</code> есть несколько принципиальных отличий, которые делают код безопаснее:</p>
<ul>
    <li>Время жизни всех потоков подзадач ограничено областью видимости блока <code class="text-nowrap">try-with-resources</code>. Метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"><code class="text-nowrap">close()</code></a> гарантированно не завершится, пока не завершатся все подзадачи.</li>
    <li>Если одна из операций <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики <code class="text-nowrap">ShutdownOnFailure</code>, возможны другие).</li>
    <li>Если главный поток прерывается в процессе ожидания <code class="text-nowrap">join()</code>, то обе операции <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> отменяются при выходе из блока.</li>
    <li>В дампе потоков будет видна иерархия: потоки, выполняющие <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code>, будут отображаться как дочерние для главного потока.</li>
</ul>
<p class="mt-2">Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.</p>

<h5><a href="https://openjdk.org/jeps/464">Scoped Values (Second Preview) (JEP 464)</a></h5>
<p>Scoped Values, которые стали preview в <a href="https://openjdk.org/jeps/446">Java 21</a>, как и Structured Concurrency, уходят на второе preview без изменений. До этого Scoped Values были в инкубаторе в <a href="https://openjdk.org/jeps/429">Java 20</a>.</p>
<p>Новый класс <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html"><code class="text-nowrap">ScopedValue</code></a> позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a>.</p>
<p>Классы <code class="text-nowrap">ThreadLocal</code> и <code class="text-nowrap">ScopedValue</code> похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае <code class="text-nowrap">ThreadLocal</code> для этого вызывается метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"><code class="text-nowrap">set()</code></a>, который кладёт значение переменной для данного потока, а потом метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#get()"><code class="text-nowrap">get()</code></a> вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:</p>
<ul>
    <li>Неконтролируемая мутабельность (<code class="text-nowrap">set()</code> можно вызвать когда угодно и откуда угодно).</li>
    <li>Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван <code class="text-nowrap">ThreadLocal.remove()</code>, но про него часто забывают).</li>
    <li>Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).</li>
</ul>
<p>Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.</p>
<p><code class="text-nowrap">ScopedValue</code> лишён вышеперечисленных недостатков. В отличие от <code class="text-nowrap">ThreadLocal</code>, <code class="text-nowrap">ScopedValue</code> не имеет метода <code class="text-nowrap">set()</code>. Значение ассоциируется с объектом <code class="text-nowrap">ScopedValue</code> путём вызова другого метода <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"><code class="text-nowrap">where()</code></a>. Далее вызывается метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"><code class="text-nowrap">run()</code></a>, на протяжении которого это значение можно получить (через метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#get()"><code class="text-nowrap">get()</code></a>), но нельзя изменить. Как только исполнение метода <code class="text-nowrap">run()</code> заканчивается, значение отвязывается от объекта <code class="text-nowrap">ScopedValue</code>. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.</p>
<p>Пример использования <code class="text-nowrap">ScopedValue</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static final</span> ScopedValue&lt;FrameworkContext> CONTEXT = ScopedValue.newInstance();

<span style="color: blue">void</span> serve(Request request, Response response) {
    <span style="color: blue">var</span> context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -> Application.handle(request, response));
}

<span style="color: blue">public</span> PersistedObject readKey(String key) {
    <span style="color: blue">var</span> context = CONTEXT.get();
    <span style="color: blue">var</span> db = getDBConnection(context);
    db.readKey(key);
}</pre>
<p>В целом <code class="text-nowrap">ScopedValue</code> является предпочтительной заменой <code class="text-nowrap">ThreadLocal</code>, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них <code class="text-nowrap">ThreadLocal</code> может быть единственно возможным решением.</p>

<h5><a href="https://openjdk.org/jeps/454">Foreign Function & Memory API (JEP 454)</a></h5>
<p>Foreign Function & Memory API, которое было долго в режиме preview (а до этого ещё дольше в инкубаторе), наконец-то стабилизировалось.</p>
<p>Главной задачей FFM API является замена устаревшего JNI, который является опасным и хрупким средством вызова нативных библиотек и обработки нативных данных. FFM API, напротив, создан как безопасное, удобное, читаемое и эффективное средство интеропа со средой вне Java.</p>
<p>FFM API находится в пакете <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html"><code class="text-nowrap">java.lang.foreign</code></a>. Оно состоит из двух частей: API для доступа к внешней памяти (foreign memory) и API для вызова внешних функций (foreign functions).</p>
<p>API для доступа к внешней памяти предоставляет классы и интерфейсы, которые позволяют выделять, освобождать внешнюю память и манипулировать ею: <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html"><code class="text-nowrap">MemorySegment</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html"><code class="text-nowrap">Arena</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SegmentAllocator.html"><code class="text-nowrap">SegmentAllocator</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemoryLayout.html"><code class="text-nowrap">MemoryLayout</code></a>. Также оно использует уже существующий класс <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/VarHandle.html"><code class="text-nowrap">VarHandle</code></a>. API для вызова внешних функций предоставляет классы и интерфейсы
    <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Linker.html"><code class="text-nowrap">Linker</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SymbolLookup.html"><code class="text-nowrap">SymbolLookup</code></a>, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/FunctionDescriptor.html"><code class="text-nowrap">FunctionDescriptor</code></a>. Для непосредственно вызовов используется привычный <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandle.html"><code class="text-nowrap">MethodHandle</code></a>.</p>
<p>Вот небольшой пример использования FFM API, в котором код на Java получает <code class="text-nowrap">MethodHandle</code> для функции <code class="text-nowrap">radixsort</code>, написанной на C, и вызывает её для сортировки массива из 4 строк:</p>

<pre class="border p-lg-2 p-1"><span style="color: green">// 1. Find foreign function on the C library path</span>
Linker linker          = Linker.nativeLinker();
SymbolLookup stdlib    = linker.defaultLookup();
MethodHandle radixsort = linker.downcallHandle(stdlib.find(<span style="color: darkred">"radixsort"</span>), ...);
<span style="color: green">// 2. Allocate on-heap memory to store four strings</span>
String[] javaStrings = { <span style="color: darkred">"mouse"</span>, <span style="color: darkred">"cat"</span>, <span style="color: darkred">"dog"</span>, <span style="color: darkred">"car"</span> };

<span style="color: green">// 3. Use try-with-resources to manage the lifetime of off-heap memory</span>
<span style="color: blue">try</span> (Arena offHeap = Arena.ofConfined()) {
    <span style="color: green">// 4. Allocate a region of off-heap memory to store four pointers</span>
    MemorySegment pointers
        = offHeap.allocate(ValueLayout.ADDRESS, javaStrings.length);
    <span style="color: green">// 5. Copy the strings from on-heap to off-heap</span>
    <span style="color: blue">for</span> (<span style="color: blue">int</span> i = 0; i < javaStrings.length; i++) {
        MemorySegment cString = offHeap.allocateFrom(javaStrings[i]);
        pointers.setAtIndex(ValueLayout.ADDRESS, i, cString);
    }
    <span style="color: green">// 6. Sort the off-heap data by calling the foreign function</span>
    radixsort.invoke(pointers, javaStrings.length, MemorySegment.NULL, <span style="color: darkred">'\0'</span>);
    <span style="color: green">// 7. Copy the (reordered) strings from off-heap to on-heap</span>
    <span style="color: blue">for</span> (<span style="color: blue">int</span> i = 0; i < javaStrings.length; i++) {
        MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);
        javaStrings[i] = cString.reinterpret(...).getString(0);
    }
} <span style="color: green">// 8. All off-heap memory is deallocated here</span>

<span style="color: blue">assert</span> Arrays.equals(javaStrings,
                     <span style="color: blue">new</span> String[] {<span style="color: darkred">"car"</span>, <span style="color: darkred">"cat"</span>, <span style="color: darkred">"dog"</span>, <span style="color: darkred">"mouse"</span>});  <span style="color: green">// true</span></pre>
<p>Этот код гораздо чище и прозрачнее, чем любое решение с использованием JNI.</p>

<p>Большая часть FFM API является безопасной по умолчанию. Многие задачи, для которых ранее необходимо было писать нативный код, вызываемый через JNI, теперь решаются написанием только Java-кода. Однако у FFM API есть <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html#restricted">ограниченные методы</a> (например, <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html#reinterpret(long)"><code class="text-nowrap">MemorySegment::reinterpret</code></a>), которые по своей сути являются небезопасными. При их использовании могут возникнуть ужасные последствия вроде краха JVM, которые виртуальная машина не в состоянии предотвратить. Поэтому при выполнении ограниченного метода JVM выдаёт предупреждение, например:</p>
<pre class="border p-lg-2 p-1">WARNING: A restricted method in java.lang.foreign.Linker has been called
WARNING: Linker::downcallHandle has been called by com.foo.Server in an unnamed module
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled</pre>
<p>Чтобы разрешить модулю использовать ограниченные методы без предупреждений, необходимо использовать опцию командной строки <code class="text-nowrap">--enable-native-access=M</code>, где <code class="text-nowrap">M</code> &ndash; имя модуля или список модулей через запятую (можно использовать <code class="text-nowrap">ALL-UNNAMED</code> для всего кода в classpath). При этом любое использование ограниченных методов вне списка модулей будет выбрасывать <code class="text-nowrap">IllegalCallerException</code>.</p>

<h5><a href="https://openjdk.org/jeps/460">Vector API (Seventh Incubator) (JEP 460)</a></h5>
<p>Векторное API в модуле <a href="https://docs.oracle.com/en/java/javase/22/docs/api/jdk.incubator.vector/module-summary.html"><code class="text-nowrap">jdk.incubator.vector</code></a>, которое появилось ещё аж <a href="https://openjdk.org/jeps/338">в Java 16</a>, остаётся в инкубационном статусе в седьмой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.</p>
<p>Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта <a href="https://openjdk.org/projects/valhalla/">Valhalla</a> (главным образом, от <a href="https://openjdk.org/jeps/401">value-классов</a>), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API тоже сразу же выйдет из инкубатора в статус preview.</p>

<h5><a href="https://openjdk.org/jeps/423">Region Pinning for G1 (JEP 423)</a></h5>
<p>В сборщике мусора G1 было реализовано <i>закрепление регионов</i>, которое предотвращает отключение сборки мусора, пока JNI находится в критическом регионе.</p>
<p>Критический регион &ndash; это код, который выполняется в промежутке между двумя событиями: захват указателя на Java-объект и его освобождение. В этом промежутке сборщик мусора не имеет права двигать Java-объект, чтобы не сломать нативный код, который полагается на то, что он будет находиться по одному и тому же адресу в течение всего времени захвата.</p>
<p>До Java 22 G1 имел простейшую стратегию: если хотя бы один из потоков находился в критическом регионе, то он просто отключал сборку мусора. Это могло приводить к различным проблемам, начиная с длительных пауз и заканчивая нехваткой памяти при её фактическом избытке.</p>
<p>Для закрепления критических объектов вовсе необязательно полностью отключать сборщик мусора: достаточно закрепить только тот регион сборщика, в котором находится объект. Это и было реализовано в JEP 423. Это было сделано путём использования счётчика, который увеличивается при захвате критического объекта и уменьшается при освобождении. Если счётчик равен нулю, то регион собирается в нормальном режиме. Если счётчик больше нуля, то регион сборщика закрепляется. Это должно решить вышеописанные проблемы.</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2024" role="button" aria-expanded="true" aria-controls="year2024">2024</a>
  <ul class="collapse show" id="year2024">
<li class="text-secondary"><a href="java_22.html" class="text-secondary">Вышла Java 22</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="false" aria-controls="year2023">2023</a>
  <ul class="collapse" id="year2023">
<li class="text-secondary"><a href="java_21.html" class="text-secondary">Вышла Java 21</a></li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2024</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.org/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
