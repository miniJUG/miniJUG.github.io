<!doctype html>
<html lang="ru">
  <head>
    <title>Вышла Java 24</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Вышла Java 24">
    <meta property="og:description" content="Вышла общедоступная версия Java 24. В этот релиз попало около 2700 закрытых задач и 24 JEP'а. Release Notes можно посмотреть здесь. Полный список изменений API &ndash; здесь&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2025-03-18">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="Вышла Java 24">
    <meta name="twitter:description" content="Вышла общедоступная версия Java 24. В этот релиз попало около 2700 закрытых задач и 24 JEP'а. Release Notes можно посмотреть здесь. Полный список изменений API &ndash; здесь&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.org/java_24.png">
    <meta property="og:image:width" content="1280">
    <meta property="og:image:height" content="720">
    <meta name="twitter:image" content="https://minijug.org/java_24.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Вышла Java 24</h3>
<p class="text-secondary"><time datetime="2025-03-18">18 марта, 2025</time></p>
<article>
<p>Вышла общедоступная версия <a href="https://openjdk.org/projects/jdk/24/">Java 24</a>. В этот релиз попало около <a href="https://builds.shipilev.net/backports-monitor/release-notes-24.html">2700 закрытых задач и 24 JEP'а</a>. Release Notes можно посмотреть <a href="http://jdk.java.net/24/release-notes">здесь</a>. Полный список изменений API &ndash; <a href="https://javaalmanac.io/jdk/24/apidiff/23/">здесь</a>.</p>

<p>Java 24 не является LTS-релизом, и у неё будут выходить обновления <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">только полгода</a> (до сентября 2025 года).</p>
<!-- cut -->
<p>Скачать JDK 24 можно по этим ссылкам:</p>
<ul>
  <li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a> (лицензия <a href="https://www.oracle.com/downloads/licenses/no-fee-license.html">NFTC</a>)</li>
  <li><a href="http://jdk.java.net/24/">OpenJDK</a> (лицензия <a href="https://openjdk.org/legal/gplv2+ce.html">GPLv2 with Classpath Exception</a>)</li>
</ul>

<p class="mt-2">Рассмотрим все JEP'ы, которые попали в Java 24.</p>

<h4>Язык</h4>
<h5><a href="https://openjdk.org/jeps/488">Primitive Types in Patterns, instanceof, and switch (Second Preview) (JEP 488)</a></h5>
<p>Примитивные типы в паттернах, <code class="text-nowrap">instanceof</code> и <code class="text-nowrap">switch</code>, которые появились <a href="https://openjdk.org/jeps/455">в Java 23</a> в режиме preview, остаются на второе preview без изменений:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>

Object obj = 42;
<span style="color: blue">if</span> (obj <span style="color: blue">instanceof int</span> i) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"int: "</span> + i);
}

<span style="color: blue">switch</span> (obj) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case double</span> d -> System.out.println(<span style="color: darkred">"double: "</span> + d);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>Проверять можно также и то, попадают ли значения в диапазон типа:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> i = 42;
<span style="color: blue">if</span> (i <span style="color: blue">instanceof byte</span> b) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"byte: "</span> + b);
}

<span style="color: blue">double</span> d = 3.0;
<span style="color: blue">switch</span> (d) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> f -> System.out.println(<span style="color: darkred">"float: "</span> + f);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>В примерах выше <code class="text-nowrap">42</code> попадает в диапазон byte (<code class="text-nowrap">[-128; 127]</code>), а <code class="text-nowrap">3.0</code> без потери точности приводится к <code class="text-nowrap">int</code>. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.</p>
<p>Подобные проверки могут быть полезны и в паттернах записей:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> JsonNumber(<span style="color: blue">double</span> d) {}

<span style="color: blue">var</span> json = <span style="color: blue">new</span> JsonNumber(3.0);
<span style="color: blue">if</span> (json <span style="color: blue">instanceof</span> JsonNumber(<span style="color: blue">int</span> i)) { <span style="color: green">// matches</span>
    <span style="color: green">// ...</span>
}</pre>

<p>Если до Java 23/24 типы выражений-селекторов в <code class="text-nowrap">switch</code> могли быть только <code class="text-nowrap">int</code>, <code class="text-nowrap">short</code>, <code class="text-nowrap">byte</code> и <code class="text-nowrap">char</code> и для них поддерживались только константные ветки (<code class="text-nowrap">case 3</code> и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">float</span> f = 1.0f;
<span style="color: blue">switch</span> (f) {
    <span style="color: blue">case</span> 0f -> System.out.println(<span style="color: darkred">"0"</span>);
    <span style="color: blue">case float</span> x <span style="color: blue">when</span> x == 1f -> System.out.println(<span style="color: darkred">"1"</span>); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> x -> System.out.println(<span style="color: darkred">"other"</span>);
}

<span style="color: blue">boolean</span> b = <span style="color: darkred">"hello"</span>.isEmpty();
<span style="color: blue">switch</span> (b) {
    <span style="color: blue">case true</span> -> System.out.println(<span style="color: darkred">"empty"</span>);
    <span style="color: blue">case false</span> -> System.out.println(<span style="color: darkred">"non-empty"</span>); <span style="color: green">// matches</span>
}</pre>

<p>В Java 25 возможно будет <a href="https://openjdk.org/jeps/8349215">третье preview</a> этой фичи.</p>

<h5><a href="https://openjdk.org/jeps/494">Module Import Declarations (Second Preview) (JEP 494)</a></h5>
<p>Module Import Declarations, которые появились <a href="https://openjdk.org/jeps/476">в Java 23</a> в режиме preview, перешли во второе превью со следующими двумя изменениями.</p>

<p>Во-первых, при импорте модуля-агрегатора <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.se/module-summary.html"><code class="text-nowrap">java.se</code></a>, теперь импортируются и классы <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/module-summary.html"><code class="text-nowrap">java.base</code></a>. В Java 23 при импорте <code class="text-nowrap">java.se</code> приходилось отдельно импортировать <code class="text-nowrap">java.base</code>, чтобы пользоваться базовыми классами Java, что выглядело странно:</p>

<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>

<span style="color: blue">import module</span> java.se;

<span style="color: blue">public class</span> Main {
  <span style="color: blue">public static void</span> main(String[] args) {
    <span style="color: red">// Нужен import module java.base, иначе будет error: cannot find symbol</span>
    System.out.println(Set.of());
  }
}</pre>

<p>В Java 24 теперь же это не нужно:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>

<span style="color: blue">import module</span> java.se;

<span style="color: blue">public class</span> Main {
  <span style="color: blue">public static void</span> main(String[] args) {
    <span style="color: green">// Работает:</span>
    System.out.println(Set.of());
  }
}</pre>

<p>Такое стало возможно благодаря тому, что в Java 24 разрешили модулям делать <code class="text-nowrap">requires transitive java.base</code> (раньше было нельзя, поскольку считалось, что любой модуль всегда и так зависит от <code class="text-nowrap">java.base</code> неявно):</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>

<span style="color: blue">module</span> M {
  <span style="color: blue">requires transitive</span> java.base; <span style="color: green">// С Java 24 можно</span>
}</pre>

<p>В декларацию <code class="text-nowrap">java.se</code> строчка <code class="text-nowrap">requires transitive java.base</code> была соответственно и добавлена.</p>

<p>Во-вторых, импорты со звёздочкой теперь могут перекрывать импорты модулей. До этого перекрывать могли только одиночные импорты:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>

<span style="color: blue">import module</span> java.desktop;
<span style="color: blue">import</span> java.util.List; <span style="color: green">// Только так можно перекрыть java.awt.List из java.desktop (import java.util.* не сработает)</span>

<span style="color: blue">public class</span> Main {
  <span style="color: blue">public static void</span> main(String[] args) {
    System.out.println(List.of()); <span style="color: green">// Резолвится java.util.List</span>
  }
}</pre>

<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>

<span style="color: blue">import module</span> java.desktop;
<span style="color: blue">import</span> java.util.*; <span style="color: green">// Теперь можно и так</span>

<span style="color: blue">public class</span> Main {
  <span style="color: blue">public static void</span> main(String[] args) {
    System.out.println(List.of()); <span style="color: green">// Резолвится java.util.List</span>
  }
}</pre>

<p class="mt-2">Напомним, что такое вообще импорт модулей. Декларация <code class="text-nowrap">import module M</code> эквивалентна импорту всех экспортированных пакетов из модуля <code class="text-nowrap">M</code> и его транзитивных зависимостей в текущий модуль.</p>
<p>Например, импорт модуля <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/module-summary.html"><code class="text-nowrap">java.base</code></a> имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">import</span> java.io.*;
<span style="color: blue">import</span> java.lang.*;
<span style="color: blue">import</span> java.lang.annotation.*;
<span style="color: green">// ... 49 packages ...</span>
<span style="color: blue">import</span> javax.security.auth.x500.*;
<span style="color: blue">import</span> javax.security.cert.*;</pre>

<p>Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как <code class="text-nowrap">List</code>, <code class="text-nowrap">Map</code>, <code class="text-nowrap">Stream</code>, <code class="text-nowrap">Path</code>, <code class="text-nowrap">Function</code> и др. без необходимости отдельного импорта их соответствующих пакетов.</p>
<p>Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую <a href="https://openjdk.org/jeps/458">без предварительной компиляции</a>.</p>
<p>При использовании <i>простых исходных файлов</i> модуль <code class="text-nowrap">java.base</code> импортируется автоматически. Об этом следующий JEP 495.</p>

<p>Планируется, что фича выйдет из preview <a href="https://openjdk.org/jeps/8344700">в Java 25</a>.</p>

<h5><a href="https://openjdk.org/jeps/495">Simple Source Files and Instance Main Methods (Fourth Preview) (JEP 495)</a></h5>
<p>Простые исходные файлы и инстанс-методы <code class="text-nowrap">main()</code> остаются в режиме preview в четвёртый раз. Эта фича появилась <a href="https://openjdk.org/jeps/445">в Java 21</a> и дважды менялась: сначала <a href="https://openjdk.org/jeps/463">в Java 22</a>, а потом <a href="https://openjdk.org/jeps/477">в Java 23</a>. На этот раз изменений нет кроме новой терминологии и названия JEP'а (в Java 25 фича возможно <a href="https://mail.openjdk.org/pipermail/amber-dev/2025-January/009198.html">опять поменяется</a>).</p>

<p>Новый протокол запуска Java-программ позволяет запускать классы, у которых метод <code class="text-nowrap">main()</code> не является <code class="text-nowrap">public static</code> (т.е. является instance-методом) и у которого нет параметра <code class="text-nowrap">String[] args</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>
<span style="color: blue">class</span> HelloWorld {
    <span style="color: blue">void</span> main() {
        System.out.println(<span style="color: darkred">"Hello, World!"</span>);
    }
}</pre>
<p>В таком случае во время запуска JVM сама создаст экземпляр класса <code class="text-nowrap">HelloWorld</code> и вызовет у него метод <code class="text-nowrap">main()</code>:</p>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 24 HelloWorld.java
Hello, World!</pre>

<p class="mt-2">Кроме того, можно запускать файлы и без объявленного класса вовсе. Такие файлы называются простыми исходными файлами:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// HelloWorld.java</span>

String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}</pre>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 24 HelloWorld.java
Hello, World!</pre>

<p>В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод <code class="text-nowrap">main()</code> и другие верхнеуровневые объявления в файле:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// class &lt;some name> { ← неявно</span>
String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    println(greeting);
}
<span style="color: green">// }</span></pre>

<p>Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:</p>
<ul>
  <li>Неявный класс может находиться только в безымянном пакете.</li>
  <li>Код в неявном классе не может ссылаться на него по имени.</li>
  <li>Неявный класс всегда имеет один дефолтный конструктор без аргументов.</li>
  <li>Неявный класс всегда является final и наследуется от <code class="text-nowrap">java.lang.Object</code>.</li>
</ul>
<p>При этом неявный класс не является безымянным: у него есть <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/Class.html#getName()">имя</a>, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).</p>

<p>В простых исходных файлах также можно обращаться напрямую к следующим 5 методам для работы с консолью:</p>
<ul>
  <li><code class="text-nowrap">public static void println(Object obj);</code></li>
  <li><code class="text-nowrap">public static void println();</code></li>
  <li><code class="text-nowrap">public static void print(Object obj);</code></li>
  <li><code class="text-nowrap">public static String readln(String prompt);</code></li>
  <li><code class="text-nowrap">public static String readln();</code></li>
</ul>

<p>То есть пример выше можно написать ещё короче:</p>
<pre class="border p-lg-2 p-1">String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    println(greeting);
}</pre>

<p>Эти методы определены в новом классе <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/IO.html"><code class="text-nowrap">java.io.IO</code></a> (каждый простой исходный файл неявно статически импортирует все его методы).</p>

<p>Также каждый простой исходный файл неявно импортирует модуль <code class="text-nowrap">java.base</code> (фича из предыдущего JEP 494). Это значит, что ко всем базовым классам Java можно обращаться без необходимости импортов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">void</span> main() {
    println(List.of(<span style="color: darkred">"James"</span>, <span style="color: darkred">"Bill"</span>, <span style="color: darkred">"Guy"</span>));
}</pre>

<p class="mt-2">Простые исходные файлы и instance методы <code class="text-nowrap">main()</code> вводятся в Java с двумя целями:</p>
<ol>
  <li>Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).</li>
  <li>Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.</li>
</ol>

<p>Планируется, что фича выйдет из preview <a href="https://openjdk.org/jeps/8344699">в Java 25</a> (и Simple Source Files будут переименованы в Compact Source Files).</p>

<h5><a href="https://openjdk.org/jeps/492">Flexible Constructor Bodies (Third Preview) (JEP 492)</a></h5>
<p>Statements before <code class="text-nowrap">super()</code>, которые появились <a href="https://openjdk.org/jeps/447">в Java 22</a> в режиме preview и были переименованы во Flexible Constructor Bodies <a href="https://openjdk.org/jeps/482">в Java 23</a>, остаются на третье preview без значительных изменений.</p>

<p>Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (<code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>):</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>
<span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">super</span>(value);
    }
}</pre>

<p>Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">super</span>(verifyPositive(value));
    }

    <span style="color: blue">private static long</span> verifyPositive(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">return</span> value;
    }
}</pre>

<p>Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Super {
    <span style="color: blue">public</span> Super(C x, C y) { ... }
}

<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">private</span> Sub(C x) { <span style="color: green">// Auxiliary constructor</span>
        <span style="color: blue">super</span>(x, x); <span style="color: green">// x is shared here</span>
    }

    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>(<span style="color: blue">new</span> C(i));
    }
}</pre>

<p>В Java 24, включив режим preview, то же самое можно реализовать гораздо короче:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 24</span>
<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">var</span> x = <span style="color: blue">new</span> C(i);
        <span style="color: blue">super</span>(x, x);
    }
}</pre>

<p>Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать инстанс-методы). Рассмотрим несколько примеров некорректного кода:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A() {
        System.out.print(<span style="color: blue">this</span>); <span style="color: red">// Error</span>
        var x = i;              <span style="color: red">// Error</span>
        hashCode();             <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> B {
    <span style="color: blue">int</span> i;
    <span style="color: blue">void</span> m() {}
}

<span style="color: blue">class</span> C <span style="color: blue">extends</span> B {
    C() {
        <span style="color: blue">var</span> x = i; <span style="color: red">// Error</span>
        m();       <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Outer {
    <span style="color: blue">class</span> Inner {
    }

    Outer() {
        <span style="color: blue">new</span> Inner(); <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Однако если читать поля конструируемого класса до вызова <code class="text-nowrap">super()</code> нельзя, то инициализировать их можно:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>.i = i; <span style="color: green">// OK</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: red">// new Sub(42) will print 0</span>
    }
}</pre>

<p>Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова <code class="text-nowrap">super()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
        <span style="color: blue">super</span>();
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: green">// new Sub(42) will print 42</span>
    }
}</pre>

<p>Также инициализация полей до <code class="text-nowrap">super()</code> можно пригодиться в проекте Valhalla для <a href="https://youtu.be/IF9l8fYfSnI?t=2006">definite assignment полей</a> null-restricted value-классов.</p>

<p>Интересно, что новая возможность затрагивает исключительно компилятор Java &ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом <code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).</p>

<p>Планируется, что фича выйдет из preview <a href="https://openjdk.org/jeps/8344702">в Java 25</a>.</p>

<h4>API</h4>
<h5><a href="https://openjdk.org/jeps/485">Stream Gatherers (JEP 485)</a></h5>
<p>Stream gatherers, которые <a href="https://openjdk.org/jeps/461">в Java 22</a> и <a href="https://openjdk.org/jeps/473">в Java 23</a> были в режиме preview, стали постоянным API.</p>

<p>Gatherers &ndash; это усовершенствование Stream API для поддержки произвольных промежуточных операций.</p>
<p>Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (<a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"><code class="text-nowrap">map</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"><code class="text-nowrap">flatMap</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"><code class="text-nowrap">filter</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"><code class="text-nowrap">reduce</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#limit(long)"><code class="text-nowrap">limit</code></a>,
  <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#skip(long)"><code class="text-nowrap">skip</code></a> и т.д). В Java 9 были добавлены <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"><code class="text-nowrap">takeWhile</code></a> и <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"><code class="text-nowrap">dropWhile</code></a>. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.</p>
<p>Новая точка расширения &ndash; это новый метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"><code class="text-nowrap">Stream::gather(Gatherer)</code></a>, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html"><code class="text-nowrap">Gatherer</code></a>, предоставляемого пользователем. Операция <code class="text-nowrap">gather()</code> аналогична уже имеющейся операции <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"><code class="text-nowrap">Stream::collect(Collector)</code></a>: если <code class="text-nowrap">collect()</code> и <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html"><code class="text-nowrap">Collector</code></a> определяют точку расширения для терминальных операций, то <code class="text-nowrap">gather()</code> и <code class="text-nowrap">Gatherer</code> определяют точку расширения для промежуточных.</p>
<p><code class="text-nowrap">Gatherer</code> представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса <code class="text-nowrap">Gatherer</code>.</p>
<p><code class="text-nowrap">gather()</code> также является промежуточной операцией, поэтому может быть несколько <code class="text-nowrap">gather()</code> в одной цепочке:</p>
<pre class="border p-lg-2 p-1">source.gather(a).gather(b).gather(c).collect(...)</pre>

<p>Вместе с самим <code class="text-nowrap">Gatherer</code> было добавлено несколько готовых gatherer'ов, определённых в новом классе <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html"><code class="text-nowrap">Gatherers</code></a>. Это <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">fold</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"><code class="text-nowrap">mapConcurrent</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">scan</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"><code class="text-nowrap">windowFixed</code></a> и
  <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"><code class="text-nowrap">windowSliding</code></a>.</p>
<p>Давайте рассмотрим несколько примеров:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.fold(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .findFirst()
   <span style="color: grey">...></span>       .get();
<span style="color: grey">$1 ==></span> "123456789"</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.scan(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .toList()
<span style="color: grey">$2 ==></span> [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
<span style="color: grey">$3 ==></span> [[1, 2, 3], [4, 5, 6], [7, 8]]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
<span style="color: grey">$4 ==></span> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]</pre>

<p>Дизайн интерфейса <code class="text-nowrap">Gatherer</code> был создан под влиянием интерфейса <code class="text-nowrap">Collector</code>. Вот основная часть его сигнатуры:</p>
<pre class="border p-lg-2 p-1">public interface Gatherer&lt;T, A, R> {
    Supplier&lt;A> initializer();
    Integrator&lt;A, T, R> integrator();
    BinaryOperator&lt;A> combiner();
    BiConsumer&lt;A, Downstream&lt;? super R>> finisher();
}</pre>
<p>Если взглянуть на <code class="text-nowrap">Collector</code>, то он также имеет три параметра <code class="text-nowrap">T</code>, <code class="text-nowrap">A</code>, <code class="text-nowrap">R</code> и содержит 4 основных метода: <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#supplier()"><code class="text-nowrap">supplier</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#accumulator()"><code class="text-nowrap">accumulator</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#combiner()"><code class="text-nowrap">combiner</code></a> и <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#finisher()"><code class="text-nowrap">finisher</code></a>. Однако <code class="text-nowrap">Gatherer</code> использует два вспомогательных интерфейса <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"><code class="text-nowrap">Integrator</code></a> и
  <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"><code class="text-nowrap">Downstream</code></a>, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.</p>
<p>Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс <code class="text-nowrap">Gatherer</code> и можно воспользоваться готовыми методами-фабриками: <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::of(Integrator)</code></a>, <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::ofSequential(Integrator)</code></a> или другими вариациями.</p>

<h5><a href="https://openjdk.org/jeps/484">Class-File API (JEP 484)</a></h5>
<p>Стандартное API для парсинга, генерации и трансформации class-файлов, которое было <a href="https://openjdk.org/jeps/457">в Java 22</a> и <a href="https://openjdk.org/jeps/466">в Java 23</a> в режиме preview, стало постоянным API.</p>
<p>Новое API находится в пакете <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/package-summary.html"><code class="text-nowrap">java.lang.classfile</code></a>. Оно должно заменить копию библиотеки <a href="https://asm.ow2.io/">ASM</a> внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.</p>
<p>Основная проблема ASM (и других библиотек для работы с class-файлами) &ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.</p>
<p>Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2025 году.</p>

<h5><a href="https://openjdk.org/jeps/498">Warn upon Use of Memory-Access Methods in sun.misc.Unsafe (JEP 498)</a></h5>
<p>При вызове методов доступа к памяти в классе <code class="text-nowrap">sun.misc.Unsafe</code> теперь выдаётся предупреждение в консоль (при первом вызове к соответствующему методу):</p>
<pre class="border p-lg-2 p-1"><span style="color: orange">WARNING: A terminally deprecated method in sun.misc.Unsafe has been called
WARNING: sun.misc.Unsafe::setMemory has been called by com.foo.bar.Server (file:/tmp/foobarserver/thing.jar)
WARNING: Please consider reporting this to the maintainers of com.foo.bar.Server
WARNING: sun.misc.Unsafe::setMemory will be removed in a future release</span></pre>

<p>До этого все эти методы стали deprecated for removal. Это произошло <a href="https://openjdk.org/jeps/471">в Java 23</a> и в <a href="https://bugs.openjdk.org/browse/JDK-8278223">Java 18</a>. Это почти все методы класса: 77 из 87 методов.</p>
<p>Также <a href="https://bugs.openjdk.org/browse/JDK-8315953">в Java 22</a> стали deprecated for removal 6 методов, не относящиеся к памяти, но в Java 24 при их вызове пока не будет предупреждения.</p>

<p>Вместо методов доступа к памяти необходимо использовать стандартное API в Java:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/invoke/VarHandle.html"><code class="text-nowrap">java.lang.invoke.VarHandle</code></a> &ndash; API для манипуляций с памятью внутри кучи, появилось <a href="https://openjdk.org/jeps/193">в Java 9</a>.</li>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/foreign/MemorySegment.html"><code class="text-nowrap">java.lang.foreign.MemorySegment</code></a> &ndash; API для доступа к памяти вне кучи (часто в кооперации с <code class="text-nowrap">VarHandle</code>), появилось <a href="https://openjdk.org/jeps/454">в Java 22</a>.</li>
</ul>

<p>В Java 23 появилась новая опция командной строки <code class="text-nowrap">--sun-misc-unsafe-memory-access={allow|warn|debug|deny}</code>:</p>
<ul>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=allow</code> &ndash; при вызове методов предупреждения нет (дефолтное значение в Java 23).</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=warn</code> &ndash; выдаётся предупреждение при первом вызове (стало дефолтным значением в Java 24).</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=debug</code> &ndash; выдаётся предупреждение при каждом вызове.</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=deny</code> &ndash; выбрасывается <code class="text-nowrap">UnsupportedOperationException</code> (станет дефолтным значением в Java 26 или позже; <code class="text-nowrap">allow</code> использовать будет нельзя).</li>
</ul>
<p>В конце концов методы доступа к памяти будут удалены совсем (опция <code class="text-nowrap">--sun-misc-unsafe-memory-access</code> будет игнорироваться какое-то время, а потом удалится).</p>

<h5><a href="https://openjdk.org/jeps/472">Prepare to Restrict the Use of JNI (JEP 472)</a></h5>
<p>С Java 24 началась подготовка к ограничению JNI (Java Native Interface). Первым шагом стало то, что при загрузке нативных библиотек через JNI и линковке теперь будут выдаваться предупреждения в консоль:</p>
<pre class="border p-lg-2 p-1"><span style="color: orange">WARNING: A restricted method in java.lang.System has been called
WARNING: System::load has been called by com.foo.Server in module com.foo (file:/path/to/com.foo.jar)
WARNING: Use --enable-native-access=com.foo to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled</span></pre>
<p>Разработчик может подавить такие предупреждения с помощью опции командной строки <code class="text-nowrap">--enable-native-access</code>, в которой необходимо будет явно перечислить модули, которым даётся разрешение на использование нативных библиотек:</p>
<pre class="border p-lg-2 p-1">java --enable-native-access=M1,M2 ...</pre>
<p>Если ваш код находится в class path, то в качестве модуля надо указать <code class="text-nowrap">ALL-UNNAMED</code>:</p>
<pre class="border p-lg-2 p-1">java --enable-native-access=ALL-UNNAMED ...</pre>

<p>Опция <code class="text-nowrap">--enable-native-access</code> не нова &ndash; она появилась в Java 22 с появлением <a href="https://openjdk.org/jeps/454">Foreign Function & Memory API</a>. Но если до Java 24 она контролировала только ограничение на использование FFM API, то теперь распространяется и на JNI.</p>

<p>В Java 24 также появилась новая опция <code class="text-nowrap">--illegal-native-access={allow,warn,deny}</code>. Она может пригодиться, если не хочется явно перечислять модули через <code class="text-nowrap">--enable-native-access</code>. Её значение по умолчанию &ndash; <code class="text-nowrap">warn</code>, но если указать <code class="text-nowrap">allow</code>, то все предупреждения о нелегальном нативном доступе в консоли будут подавлены. Если же указать <code class="text-nowrap">deny</code>, то при каждом нелегальном доступе, наоборот, будет выбрасываться исключение <code class="text-nowrap">IllegalCallerException</code>. <code class="text-nowrap">deny</code> станет значением по умолчанию в одной из будующих версий Java. Когда это случится, можно будет переключиться только на <code class="text-nowrap">warn</code> (<code class="text-nowrap">allow</code> будет удалён). Ещё позже будет недоступен уже и <code class="text-nowrap">warn</code>, и <code class="text-nowrap">--enable-native-access</code> будет единственным способом разрешения JNI.</p>

<p>Ограничение JNI &ndash; это один из этапов перехода на философию <a href="https://openjdk.org/jeps/8305968">Integrity by Default</a> в Java. Смысл её в том, что по умолчанию код, который запускает пользователь, не должен делать ничего кроме использования безопасного API. Если же нужно использовать что-то небезопасное, что потенциально может нарушить целостность, то это возможно только при условии явного разрешения со стороны пользователя.</p>

<h5><a href="https://openjdk.org/jeps/486">Permanently Disable the Security Manager (JEP 486)</a></h5>
<p>Security Manager, который стал <a href="https://openjdk.org/jeps/411">deprecated for removal</a> в Java 17, теперь полностью отключён. При попытке его включить через командную строку виртуальная машина откажется стартовать, выдав ошибку:</p>
<pre class="border p-lg-2 p-1">$ java -Djava.security.manager -jar app.jar
<span style="color: red">Error occurred during initialization of VM
java.lang.Error: A command line option has attempted to allow or enable the Security Manager. Enabling a Security Manager is not supported.
        at java.lang.System.initPhase3(java.base@24/System.java:2067)</span></pre>
<p>С любыми другими значениями свойства <code class="text-nowrap">java.security.manager</code> (кроме <code class="text-nowrap">disallow</code>) будет происходить то же самое:</p>
<ul>
  <li><code class="text-nowrap">-Djava.security.manager=""</code></li>
  <li><code class="text-nowrap">-Djava.security.manager=allow</code></li>
  <li><code class="text-nowrap">-Djava.security.manager=default</code></li>
  <li><code class="text-nowrap">-Djava.security.manager=com.foo.CustomM</code></li>
</ul>

<p>Также при попытке установки Security Manager'а в рантайме через <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"><code class="text-nowrap">System::setSecurityManager</code></a> будет всегда выбрасываться <code class="text-nowrap">UnsupportedOperationException</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: red">Exception in thread "main" java.lang.UnsupportedOperationException: Setting a Security Manager is not supported.
        at java.base/java.lang.System.setSecurityManager(System.java:286)
        ...</span></pre>

<p>Другие изменения в поведении:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#getSecurityManager()"><code class="text-nowrap">System::getSecurityManager</code></a> всегда возвращает <code class="text-nowrap">null</code>.</li>
  <li>Методы <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/AccessController.html#doPrivileged(java.security.PrivilegedAction)"><code class="text-nowrap">AccessController::doPrivileged</code></a> просто выполняют действие немедленно.</li>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/AccessController.html#checkPermission(java.security.Permission)"><code class="text-nowrap">AccessController::checkPermission</code></a> всегда выбрасывает <code class="text-nowrap">AccessControlException</code>.</li>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/Policy.html#setPolicy(java.security.Policy)"><code class="text-nowrap">Policy::setPolicy</code></a> всегда выбрасывает <code class="text-nowrap">UnsupportedOperationException</code>.</li>
  <li>Методы <code class="text-nowrap">SecurityManager::check*</code> всегда выбрасывают <code class="text-nowrap">SecurityException</code>.</li>
  <li>Игнорируются некоторые свойства, связанные с Security Manager (<code class="text-nowrap">java.security.policy</code>, <code class="text-nowrap">jdk.security.filePermCompat</code> и другие).</li>
</ul>

<p>Сами классы, связанные с Security Manager API, пока что остаются. Окончательное их удаление планируется в будущем.</p>

<p class="mt-2">Отказаться от Security Manager было решено по причине того, что он почти не имел спроса среди разработчиков и при этом слабо отвечал современным требованиям безопасности. Сейчас существуют гораздо более эффективные способы обеспечения безопасности приложений: контейнеры, гипервизоры, песочницы на уровне OS и т.д. Цена же поддержки Security Manager'а оставалось крайне высокой из-за сложной программной модели. Избавившись от необходимости поддерживать Security Manager, разработчики OpenJDK смогут лучше сфокусироваться на других более важных частях JDK, связанных с безопасностью.</p>

<h5><a href="https://openjdk.org/jeps/499">Structured Concurrency (Fourth Preview) (JEP 499)</a></h5>
<p>Structured Concurrency, которое было в режиме preview в <a href="https://openjdk.org/jeps/453">Java 21</a>, <a href="https://openjdk.org/jeps/462">Java 22</a> и <a href="https://openjdk.org/jeps/480">Java 23</a>, остаётся на четвёртый раунд preview без изменений.</p>

<p>Structured Concurrency &ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.</p>
<p>В центре нового API класс <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a>, у которого есть два главных метода:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"><code class="text-nowrap">fork()</code></a> &ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,</li>
  <li><a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"><code class="text-nowrap">join()</code></a> &ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()">остановлен</a>.</li>
</ul>
<p>Пример использования <code class="text-nowrap">StructuredTaskScope</code>, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> scope = <span style="color: blue">new</span> StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&lt;String> user = scope.fork(() -> findUser());
    Supplier&lt;Integer> order = scope.fork(() -> fetchOrder());

    scope.join()            <span style="color: green">// Join both subtasks</span>
         .throwIfFailed();  <span style="color: green">// ... and propagate errors</span>

    <span style="color: green">// Here, both subtasks have succeeded, so compose their results</span>
    <span style="color: blue">return new</span> Response(user.get(), order.get());
}</pre>
<p>Может показаться, что в точности аналогичный код можно было бы написать с использованием классического <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code class="text-nowrap">ExecutorService</code></a> и <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"><code class="text-nowrap">submit()</code></a>, но у <code class="text-nowrap">StructuredTaskScope</code> есть несколько принципиальных отличий, которые делают код безопаснее:</p>
<ul>
  <li>Время жизни всех потоков подзадач ограничено областью видимости блока <code class="text-nowrap">try-with-resources</code>. Метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"><code class="text-nowrap">close()</code></a> гарантированно не завершится, пока не завершатся все подзадачи.</li>
  <li>Если одна из операций <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики <code class="text-nowrap">ShutdownOnFailure</code>, возможны другие).</li>
  <li>Если главный поток прерывается в процессе ожидания <code class="text-nowrap">join()</code>, то обе операции <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> отменяются при выходе из блока.</li>
  <li>В дампе потоков будет видна иерархия: потоки, выполняющие <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code>, будут отображаться как дочерние для главного потока.</li>
</ul>
<p class="mt-2">Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.</p>
<p>В Java 25 возможно будет <a href="https://openjdk.org/jeps/8340343">пятое preview</a> Structured Concurrency с изменениями в API.</p>

<h5><a href="https://openjdk.org/jeps/487">Scoped Values (Fourth Preview) (JEP 487)</a></h5>
<p>Scoped Values, которые были в preview в <a href="https://openjdk.org/jeps/446">Java 21</a>, <a href="https://openjdk.org/jeps/464">Java 22</a> и <a href="https://openjdk.org/jeps/481">Java 23</a>, остаётся на четвёртый раунд preview.</p>
<p>В четвёртом preview в классе <code class="text-nowrap">ScopedValue</code> были удалены методы <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#callWhere(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp)"><code class="text-nowrap">callWhere()</code></a> и <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#runWhere(java.lang.ScopedValue,java.lang.Object,java.lang.Runnable)"><code class="text-nowrap">runWhere()</code></a>.</p>

<p>Класс <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html"><code class="text-nowrap">ScopedValue</code></a> позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a>.</p>
<p>Классы <code class="text-nowrap">ThreadLocal</code> и <code class="text-nowrap">ScopedValue</code> похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае <code class="text-nowrap">ThreadLocal</code> для этого вызывается метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"><code class="text-nowrap">set()</code></a>, который кладёт значение переменной для данного потока, а потом метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html#get()"><code class="text-nowrap">get()</code></a> вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:</p>
<ul>
  <li>Неконтролируемая мутабельность (<code class="text-nowrap">set()</code> можно вызвать когда угодно и откуда угодно).</li>
  <li>Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван <code class="text-nowrap">ThreadLocal.remove()</code>, но про него часто забывают).</li>
  <li>Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).</li>
</ul>
<p>Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.</p>
<p><code class="text-nowrap">ScopedValue</code> лишён вышеперечисленных недостатков. В отличие от <code class="text-nowrap">ThreadLocal</code>, <code class="text-nowrap">ScopedValue</code> не имеет метода <code class="text-nowrap">set()</code>. Значение ассоциируется с объектом <code class="text-nowrap">ScopedValue</code> путём вызова другого метода <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"><code class="text-nowrap">where()</code></a>. Далее вызывается метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"><code class="text-nowrap">run()</code></a>, на протяжении которого это значение можно получить (через метод <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html#get()"><code class="text-nowrap">get()</code></a>), но нельзя изменить. Как только исполнение метода <code class="text-nowrap">run()</code> заканчивается, значение отвязывается от объекта <code class="text-nowrap">ScopedValue</code>. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.</p>
<p>Пример использования <code class="text-nowrap">ScopedValue</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static final</span> ScopedValue&lt;FrameworkContext> CONTEXT = ScopedValue.newInstance();

<span style="color: blue">void</span> serve(Request request, Response response) {
    <span style="color: blue">var</span> context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -> Application.handle(request, response));
}

<span style="color: blue">public</span> PersistedObject readKey(String key) {
    <span style="color: blue">var</span> context = CONTEXT.get();
    <span style="color: blue">var</span> db = getDBConnection(context);
    db.readKey(key);
}</pre>
<p>В целом <code class="text-nowrap">ScopedValue</code> является предпочтительной заменой <code class="text-nowrap">ThreadLocal</code>, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них <code class="text-nowrap">ThreadLocal</code> может быть единственно возможным решением.</p>

<h5><a href="https://openjdk.org/jeps/478">Key Derivation Function API (Preview) (JEP 478)</a></h5>
<p>В пакете <code class="text-nowrap">javax.crypto</code> в режиме preview появилось новое API для <a href="https://en.wikipedia.org/wiki/Key_derivation_function">функций выведения ключа</a> (KDF - Key Derivation Functions). Такие функции могут использоваться для вывода криптографически сильных секретных ключей (например, AES) на основе материала ключа (например, пароля) и других данных (например, соли).</p>
<p>Новое KDF API является гораздо более подходящим для задач выведения ключей, чем старое API на основе классов <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/KeyGenerator.html">KeyGenerator</a> и <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/SecretKeyFactory.html">SecretKeyFactory</a>.</p>
<p>Пока что единственной реализацией KDF API в JDK является HKDF (HMAC-based Extract-and-Expand Key Derivation Function), но в будущем планируется реализовать и другие KDF, например, <a href="https://www.rfc-editor.org/rfc/rfc9106.html">Argon2</a>.</p>
<p>Пример выведения секретного AES-ключа с использованием HKDF:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Create a KDF object for the specified algorithm</span>
KDF hkdf = KDF.getInstance(<span style="color: darkred">"HKDF-SHA256"</span>);

<span style="color: green">// Create an ExtractExpand parameter specification</span>
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

<span style="color: green">// Derive a 32-byte AES key</span>
SecretKey key = hkdf.deriveKey(<span style="color: darkred">"AES"</span>, params);

<span style="color: green">// Additional deriveKey calls can be made with the same KDF object</span></pre>

<p>Ранее в Java 21 появилось API для <a href="https://openjdk.org/jeps/452">механизма инкапсуляции ключей</a> (KEM). Вместе с KDF эти два API являются важными шагами для поддержки в Java <a href="https://www.rfc-editor.org/rfc/rfc9180.html">Hybrid Public Key Encryption</a> (HPKE), криптографической схемы, устойчивой к <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">квантовым атакам</a>.</p>

<h5><a href="https://openjdk.org/jeps/496">Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism (JEP 496)</a></h5>
<p>В Java появилась реализация механизма инкапсуляции ключей <a href="https://csrc.nist.gov/pubs/fips/203/final">ML-KEM</a>. Это современный криптографический алгоритм обмена ключей, устойчивый к квантовым атакам.</p>
<p>Реализация ML-KEM использует <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/KEM.html">KEM API</a>, появившееся <a href="https://openjdk.org/jeps/452">в Java 21</a>. Поддерживается три набора параметров: ML-KEM-512, ML-KEM-768 и ML-KEM-1024.</p>
<p>Пример генерации симметричного ключа и его передачи:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Receiver side</span>
KeyPairGenerator g = KeyPairGenerator.getInstance(<span style="color: darkred">"ML-KEM"</span>);
KeyPair kp = g.generateKeyPair(); <span style="color: green">// По умолчанию создаёт пару ML-KEM-768</span>

<span style="color: green">// Sender side</span>
KEM kem1 = KEM.getInstance(<span style="color: darkred">"ML-KEM"</span>);
KEM.Encapsulator enc = kem1.newEncapsulator(kp.getPublic());
KEM.Encapsulated encapsulated = enc.encapsulate();
<span style="color: blue">byte</span>[] msg = encapsulated.encapsulation(); <span style="color: green">// Send this to receiver</span>
SecretKey k1 = encapsulated.key(); <span style="color: green">// Generated symmetric key</span>

<span style="color: green">// Receiver side</span>
KEM kem2 = KEM.getInstance(<span style="color: darkred">"ML-KEM"</span>);
KEM.Decapsulator dec = kem2.newDecapsulator(kp.getPrivate());
SecretKey k2 = dec.decapsulate(msg);

<span style="color: green">// k1 и k2 должны быть равны</span></pre>

<h5><a href="https://openjdk.org/jeps/497">Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm (JEP 497)</a></h5>
<p>В Java появилась реализация механизма цифровой подписи <a href="https://csrc.nist.gov/pubs/fips/204/final">ML-DSA</a>. Это современный алгоритм цифровой подписи, устойчивый к квантовым атакам.</p>
<p>Поддерживается три набора параметров: ML-DSA-44, ML-DSA-65 и ML-DSA-87.</p>
<p>Пример подписи сообщения и её верификации:</p>
<pre class="border p-lg-2 p-1">KeyPairGenerator g = KeyPairGenerator.getInstance(<span style="color: darkred">"ML-DSA"</span>);
KeyPair kp = g.generateKeyPair(); <span style="color: green">// По умолчанию создаёт пару ML-DSA-65</span>

<span style="color: green">// Подпись</span>
<span style="color: blue">byte</span>[] msg = ...;
Signature ss = Signature.getInstance(<span style="color: darkred">"ML-DSA"</span>);
ss.initSign(kp.getPrivate());
ss.update(msg);
<span style="color: blue">byte</span>[] sig = ss.sign();

<span style="color: green">// Верификация</span>
<span style="color: blue">byte</span>[] msg = ...;
<span style="color: blue">byte</span>[] sig = ...;
Signature sv = Signature.getInstance(<span style="color: darkred">"ML-DSA"</span>);
sv.initVerify(kp.getPublic());
sv.update(msg);
<span style="color: blue">boolean</span> verified = sv.verify(sig);</pre>

<h5><a href="https://openjdk.org/jeps/489">Vector API (Ninth Incubator) (JEP 489)</a></h5>
<p>Векторное API в модуле <a href="https://docs.oracle.com/en/java/javase/24/docs/api/jdk.incubator.vector/module-summary.html"><code class="text-nowrap">jdk.incubator.vector</code></a>, которое появилось ещё аж <a href="https://openjdk.org/jeps/338">в Java 16</a>, остаётся в инкубационном статусе в девятый раз с некоторыми изменениями.</p>
<p>Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта <a href="https://openjdk.org/projects/valhalla/">Valhalla</a> (главным образом, от <a href="https://openjdk.org/jeps/401">value-классов</a>), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.</p>

<h4>JVM</h4>
<h5><a href="https://openjdk.org/jeps/491">Synchronize Virtual Threads without Pinning (JEP 491)</a></h5>
<p>Виртуальные потоки больше не пинятся на свои потоки-носители внутри блоков <code class="text-nowrap">synchronized</code>. Такое ограничение существовало с Java 21 по Java 23, где виртуальный поток, захватив монитор, не мог размонтироваться и освободить платформенный поток для другой работы. Особенно плохо это проявлялось в ситуации, в которой код внутри блока <code class="text-nowrap">synchronized</code> вызывает долгую блокирующую операцию:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">synchronized byte</span>[] getData() {
    <span style="color: blue">byte</span>[] buf = ...;
    <span style="color: blue">int</span> nread = socket.getInputStream().read(buf); <span style="color: red">// Can block here</span>
    ...
}</pre>
<p>Когда платформенный поток пинится на всё время выполнения блока synchronized, он не может быть использован для других виртуальных потоков. Это может сильно навредить масштабируемости приложений, а иногда даже приводить к дедлокам.</p>
<p>Ещё одним случаем пиннинга было ожидание освобождения монитора при входе в блок synchronized виртуальным потоком. Здесь тоже поток-носитель не мог размонтироваться, до тех пор пока поток не захватит монитор.</p>
<p>Чтобы предотвратить пиннинг, пользователям и авторам библиотек приходилось переписывать код с <code class="text-nowrap">synchronized</code> на классы из пакета <a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/locks/package-summary.html"><code class="text-nowrap">java.util.concurrent.locks</code></a>, которые не имеют вышеописанных проблем (но код становится более громоздким). С Java 24 это больше не требуется.</p>
<p class="mt-2">Виртуальные потоки появились <a href="https://openjdk.org/jeps/444  ">в Java 21</a>. Они являются легковесной заменой потоков операционной системы, и их можно создавать в огромном количестве (миллионы экземпляров), что облегчает написание конкурентных программ. Их разработка ведётся в проекте <a href="https://openjdk.org/projects/loom/">Loom</a>, который был инициирован <a href="https://mail.openjdk.org/pipermail/discuss/2017-September/004390.html">в сентябре 2017 года</a>. </p>

<h5><a href="https://openjdk.org/jeps/450">Compact Object Headers (Experimental) (JEP 450)</a></h5>
<p>В экспериментальном режиме появилась опция, уменьшающая размер заголовков объектов в JVM с 96/128 бит до 64 бит на 64-битных платформах:</p>
<pre class="border p-lg-2 p-1">-XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders</pre>
<p>Заголовки объектов занимают достаточно большой процент памяти, потребляемой JVM. Эксперименты показывают, что в большинстве случаев объекты занимают от 256 до 512 бит. То есть уменьшив заголовки до 64 бит, можно уменьшить потребление памяти на 6-12%. Кроме уменьшения кучи это может улучшить и производительность благодаря более высокой скорости выделения новых объектов, более низкой нагрузки на GC и лучшей локальности данных.</p>
<p>Сжатие заголовков достигается за счёт объединения mark-слова (64 бит) и class-слова (64 или 32 бит, если включены сжатые указатели на классы) в одно 64-битное слово. В новой схеме указатели на классы всегда являются сжатыми, и количество бит для них уменьшается с 32 до 22. Identity хеш-код остаётся неизменным: 31 бит. Количество тег-битов становится на один больше (для GC self forwarding). Битов для возраста GC остаётся 4, как и было. Также 4 бита резервируются на будущее для <a href="https://openjdk.org/projects/valhalla/">Valhalla</a>.</p>
<p>Работа по сжатию заголовков в OpenJDK ведётся в проекте <a href="https://openjdk.org/projects/lilliput/">Lilliput</a>, инициированным <a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html">в марте 2021 года</a>. JEP 450 является первым результатом работы, попавшим в мейнстрим. В дальнейшем возможно ещё большое сжатие заголовков до 32 бит, что уменьшит потребление памяти ещё сильнее.</p>

<h5><a href="https://openjdk.org/jeps/483">Ahead-of-Time Class Loading & Linking (JEP 483)</a></h5>
<p>Появилась возможность запускать приложения с уже загруженными и слинкованными классами, вследствие чего время старта может заметно снизиться. Для этого необходим тренировочный запуск приложения со следующими ключами:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf \
       -cp app.jar com.example.App ...</pre>
<p>После такого запуска генерируется AOT-конфигурация в файле <code class="text-nowrap">app.aotconf</code>, которую нужно преобразовать в AOT-кэш:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf \
       -XX:AOTCache=app.aot -cp app.jar</pre>
<p>(второй шаг не запускает приложение, а только создаёт кэш)</p>
<p>Далее все последующие запуски приложения с использованием кэша <code class="text-nowrap">app.aot</code> должны быть быстрее:</p>
<pre class="border p-lg-2 p-1">$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...</pre>
<p>Запуск приложения становится быстрее благодаря тому, что вся работа по чтению, парсингу, загрузке и линковке классов была сделана ahead-of-time, и JVM уже можно её не делать just-in-time.</p>
<p>Замеры показывают, что простое приложение, использующее Stream API, выполняется на 42% быстрее, если его запустить с использованием AOT-кэша. Другое серверное приложение Spring PetClinic стартует также на 42% быстрее с использованием кэша.</p>
<p>У технологии есть ряд ограничений:</p>
<ul>
  <li>Все последующие запуски должны выполняться на том же релизе JDK и той же архитектуре.</li>
  <li>Class path должен быть консистентен тому, что использовался для тренировки.</li>
  <li>Граф модулей должен быть идентичен. Аргументы <code class="text-nowrap">-m</code>, <code class="text-nowrap">--module</code>, <code class="text-nowrap">-p</code>, <code class="text-nowrap">--module-path</code>, <code class="text-nowrap">--add-modules</code> и <code class="text-nowrap">--enable-native-access</code> должны быть одинаковы. Аргументы <code class="text-nowrap">--add-exports</code>, <code class="text-nowrap">--add-opens</code>, <code class="text-nowrap">--add-reads</code>, <code class="text-nowrap">--illegal-native-access</code>, <code class="text-nowrap">--limit-modules</code>, <code class="text-nowrap">--patch-module</code> и  <code class="text-nowrap">--upgrade-module-path</code> не должны использоваться.</li>
  <li>Сборщик мусора ZGC пока не поддерживается.</li>
  <li>Могут быть закэшированы только классы, загруженные встроенными загрузчиками классов (пользовательские загрузчики пока не поддерживаются).</li>
</ul>
<p class="mt-2">Ahead-of-Time Class Loading & Linking &ndash; это дальнейшее развитие технологии <a href="https://dev.java/learn/jvm/cds-appcds/">CDS</a> (Class Data Sharing), которая уже давно есть в Java. До этого CDS могла использоваться только для чтения и парсинга class-файлов. Сейчас же поддерживается их загрузка и линковка.</p>
<p>Работа над ускорением запуска JVM ведётся в проекте <a href="https://openjdk.org/projects/leyden/">Leyden</a>. Он был инициирован <a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html">в апреле 2020 года</a>.</p>

<h5><a href="https://openjdk.org/jeps/490">ZGC: Remove the Non-Generational Mode (JEP 490)</a></h5>
<p>Режим работы с поколениями в сборщике мусора ZGC (<code class="text-nowrap">-XX:+UseZGC</code>), который появился <a href="https://openjdk.org/jeps/439">в Java 21</a> и стал включённым по умолчанию <a href="https://openjdk.org/jeps/474">в Java 23</a>, теперь стал единственным режимом работы. Режим работы без поколений был удалён, и опция <code class="text-nowrap">-XX:&pm;ZGenerational</code> более не имеет эффекта. В будущем при использовании этой опции JVM будет выбрасывать ошибку и будет отказываться стартовать.</p>
<p>Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора <a href="https://openjdk.org/jeps/248">в Java 9</a> (до него дефолтным был Parallel GC).</p>

<h5><a href="https://openjdk.org/jeps/404">Generational Shenandoah (Experimental) (JEP 404)</a></h5>
<p>Сборщик мусора Shenandoah стал поддерживать поколения в экспериментальном режиме:</p>
<pre class="border p-lg-2 p-1">java -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational</pre>
<p>Режим работы без поколений остаётся режимом по умолчанию в Shenandoah. Планируется, что режим с поколениями станет дефолтным в будущем.</p>

<h5><a href="https://openjdk.org/jeps/479">Remove the Windows 32-bit x86 Port (JEP 479)</a></h5>
<p>32-битный порт OpenJDK под Windows был полностью удалён. Это означает, что из кодовой базы OpenJDK были удалены части кода, отвечающие за Windows 32-бит. Собрать JDK под эту платформу больше нельзя.</p>
<p>32-битный порт под Windows был помечен как <a href="https://openjdk.org/jeps/449">deprecated for removal</a> в Java 21. Главной причиной удаления порта стало желание упростить и ускорить разработку платформы. Также в 32-битной версии нет эффективной реализации виртуальных потоков: в ней они мапятся 1:1 на платформенные потоки. Кроме того, 32-битная версия Windows сама доживает свои последние дни: Microsoft прекращает поддержку Windows 10 <a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro">в октябре</a> (последняя версия Windows, поддерживающая 32 бит).</p>

<h5><a href="https://openjdk.org/jeps/501">Deprecate the 32-bit x86 Port for Removal (JEP 501)</a></h5>
<p>Вместе с полным удалением 32-битного порта под Windows вся 32-битная x86 архитектура стала deprecated for removal. Практически это означает, что подлежит удалению порт OpenJDK под Linux 32-бит x86, так как это единственная оставшаяся операционная система, для которой есть 32-битный x86 порт.</p>
<p>Причины такого решения те же самые, что и у удаления 32-битного порта Windows: сложность поддержки, отсутствие эффективной реализации виртуальных потоков и скорое <a href="https://lists.debian.org/debian-devel-announce/2023/12/msg00003.html">прекращение поддержки 32-бит x86 в Debian</a>.</p>
<p>Полностью удалить 32-битный x86 порт планируется в Java 25. После полного удаления единственным способом запуска Java на 32-бит x86 процессорах будет использование <a href="https://openjdk.org/projects/zero/">порта Zero</a>.</p>

<h5><a href="https://openjdk.org/jeps/493">Linking Run-Time Images without JMODs (JEP 493)</a></h5>
<p>JDK теперь может иметь примерно на 25% меньший размер, если в нём будет включена опция, позволяющая собирать кастомные образы с помощью утилиты <code class="text-nowrap">jlink</code> без использования JMOD-файлов. Такая опция указывается при сборке JDK, и она выключена по умолчанию, но вендоры JDK могут ей воспользоваться, если захотят предоставлять более лёгкие образы JDK.</p>
<p>В некоторых случаях размер JDK является критичным параметром, например, в облачных окружениях, где JDK часто передаётся по сети. Уменьшение размера JDK может улучшить эффективность этих операций. JMOD-файлы, находящиеся в директории <code class="text-nowrap">jmods</code> &ndash; это одна из причин слишком большой "раздутости" JDK, так как в них содержатся копии всех class-файлов, нативных библиотек и прочих ресурсов, которые уже и так есть внутри образа. Избавиться от JMOD-файлов можно добавив возможность линковать кастомные образы, вытаскивая эти файлы из самого образа, а не из JMOD-файлов. Что и было сделано в JEP 493.</p>
<p>Проверить, поддерживает ли ваш образ JDK создание кастомных образов без использования JMOD-файлов, можно запустив команду <code class="text-nowrap">jlink --help</code> и посмотреть, что написано в Capabilities:</p>
<pre class="border p-lg-2 p-1">$ jlink --help
Usage: jlink &lt;options> --module-path &lt;modulepath> --add-modules &lt;module>[,&lt;module>...]
...
Capabilities:
      <b>Linking from run-time image enabled</b></pre>

<p class="mt-2">Образы JDK с включённой опцией имеют ряд ограничений:</p>
<ul>
  <li>Сама утилита <code class="text-nowrap">jlink</code> не может быть в сгенерированном образе после запуска <code class="text-nowrap">jlink</code>.</li>
  <li><code class="text-nowrap">jlink</code> выдаст ошибку, если были изменения в конфигурационных файлах.</li>
  <li>Кросс-линковка (например, запуск <code class="text-nowrap">jlink</code> на Linux/x64 для создания образа под Windows/x64) не поддерживается.</li>
  <li>Линковка не будет работать, если образ использует опцию <code class="text-nowrap">--patch-module</code>.</li>
  <li>Линковка с извлечением модулей из другого образа не поддерживается.</li>
</ul>
<p class="mt-2">Опция может быть включена по умолчанию в будущем.</p>

<h5><a href="https://openjdk.org/jeps/475">Late Barrier Expansion for G1 (JEP 475)</a></h5>
<p>Реализация барьеров в сборщике мусора G1 была упрощена путём перемещения экспансии барьеров с ранней фазы JIT-компилятора C2 на позднюю.</p>
<p>Ранняя экспансия барьеров требует от разработчика глубокого знания внутренностей C2, что может замедлить эволюцию и оптимизацию G1. Кроме того, ранняя экспансия увеличивает накладные расходы C2 на 10-20% из-за сложности промежуточного представления (IR) барьеров.</p>
<p>В Java 24 экспансия барьеров перемещена с самой первой фазы (парсинга байткода в IR) на самую последнюю (эмиссия машинного кода). Такая схема существует в другом сборщике мусора ZGC c Java 14 и доказала свою успешность: экспансия барьеров в самый последний момент не требует никаких специфичных для C2 знаний и не имеет практически никаких накладных расходов на JIT-компиляцию.</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2025" role="button" aria-expanded="true" aria-controls="year2025">2025</a>
  <ul class="collapse show" id="year2025">
<li>Вышла Java 24</li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2024" role="button" aria-expanded="false" aria-controls="year2024">2024</a>
  <ul class="collapse" id="year2024">
<li class="text-secondary"><a href="java_23.html" class="text-secondary">Вышла Java 23</a></li>
<li class="text-secondary"><a href="java_22.html" class="text-secondary">Вышла Java 22</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="false" aria-controls="year2023">2023</a>
  <ul class="collapse" id="year2023">
<li class="text-secondary"><a href="java_21.html" class="text-secondary">Вышла Java 21</a></li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2025</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.org/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
