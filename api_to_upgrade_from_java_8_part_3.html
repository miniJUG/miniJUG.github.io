<!doctype html>
<html>
  <head>
    <title>API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 3">
    <meta property="og:description" content="Какие есть причины переходить на новые версии Java? Кто-то это сделает из-за новых языковых возможностей вроде выражений switch, блоков текста или записей. Кому-то понадобятся новые интересные&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2021-04-24">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 3">
    <meta name="twitter:description" content="Какие есть причины переходить на новые версии Java? Кто-то это сделает из-за новых языковых возможностей вроде выражений switch, блоков текста или записей. Кому-то понадобятся новые интересные&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.ru/api_to_upgrade_from_java_8_part_3.jpg">
    <meta property="og:image:width" content="1280">
    <meta property="og:image:height" content="634">
    <meta name="twitter:image" content="https://minijug.ru/api_to_upgrade_from_java_8_part_3.jpg">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
  </head>
  <body class="bg-light">
    <div class="container">
      <div class="row">
        <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</h3>
<p class="text-secondary"><time datetime="2021-04-24">24 апреля, 2021</time></p>
<article>
<p>Какие есть причины переходить на новые версии Java? Кто-то это сделает из-за новых языковых возможностей вроде <a href="https://openjdk.java.net/jeps/361">выражений <code class="text-nowrap">switch</code></a>, <a href="https://openjdk.java.net/jeps/378">блоков текста</a> или <a href="https://openjdk.java.net/jeps/395">записей</a>. Кому-то понадобятся новые интересные возможности вроде <a href="https://openjdk.java.net/jeps/261">модулей</a> или <a href="https://openjdk.java.net/jeps/379">низкопаузных сборщиков мусора</a>. Кто-то это сделает просто из-за того, что обновив версию Java, их программа <a href="https://openjdk.java.net/jeps/341">станет быстрее</a> и будет <a href="https://openjdk.java.net/jeps/254">есть меньше памяти</a>. Но есть ещё одна, не менее важная причина. Это новые API, которые позволят писать меньше кода и избежать траты времени на поиск нужной функциональности во внешних библиотеках. А в некоторых случаях сделают ваш код быстрее.</p>
<p>В предыдущих двух частях мы уже рассмотрели по 10 новых API, которые появились в Java 9 и более поздних версиях (<a href="api_to_upgrade_from_java_8.html">часть 1</a>, <a href="api_to_upgrade_from_java_8_part_2.html">часть 2</a>). Сегодня мы рассмотрим ещё 10.</p>
<!-- cut -->

<h4>1. <code class="text-nowrap">Stream.toList()</code></h4>
<h5>Появился в: <a href="java_16.html">Java 16</a></h5>
<p>Для какой задачи чаще всего используется <code class="text-nowrap">Stream</code> в Java? Конечно же, для трансформации списков: у нас есть список, над которым нужно совершить какое-то преобразование и вернуть новый. Такой паттерн вы наверняка видели в своём проекте множество раз:</p>
<pre class="border p-lg-2 p-1">List&lt;T&gt; targetList = sourceList
        .stream()
        <span style="color: green">// промежуточные операции</span>
        .collect(Collectors.toList());</pre>
<p>Нельзя сказать, что <code class="text-nowrap">collect(Collectors.toList())</code> является очень уж громоздкой конструкцией, но всё же хочется для такой частой операции писать поменьше кода. И в Java 16 это стало возможно с помощью нового метода <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"><code class="text-nowrap">Stream.toList()</code></a>:</p>
<pre class="border p-lg-2 p-1">List&lt;T&gt; targetList = sourceList
        .stream()
        <span style="color: green">// промежуточные операции</span>
        .toList();</pre>
<p>Есть ли какая-то разница между <code class="text-nowrap">toList()</code> и <code class="text-nowrap">collect(Collectors.toList())</code>? Оба ли способа ведут себя одинаково? С практической точки зрения можно сказать, что нет: если <code class="text-nowrap">toList()</code> возвращает неизменяемый список, то <code class="text-nowrap">collect(Collectors.toList())</code> возвращает некий список, о котором неизвестно, неизменяемый он или нет. То есть если вы нигде в коде не используете негарантированную вам спецификацией изменяемость списка (надеюсь, вы из такой категории людей), то смело можете заменять <code class="text-nowrap">collect(Collectors.toList())</code> на <code class="text-nowrap">toList()</code>.</p>
<p>Однако <code class="text-nowrap">Stream.toList()</code> делает код не только короче, но и эффективнее! Дело в том, что <code class="text-nowrap">Stream.toList()</code> использует внутри себя <code class="text-nowrap">Stream.toArray()</code>, который выделяет массив точной длины, если <code class="text-nowrap">Spliterator</code> имеет характеристику <code class="text-nowrap">SIZED</code>. В то время как <code class="text-nowrap">Collectors.toList()</code> никак эту характеристику не использует и всегда начинает с пустого <code class="text-nowrap">ArrayList</code>, накапливая в нём элементы с постоянными переаллокациями.</p>
<p>Давайте напишем несколько бенчмарков. Для начала рассмотрим самый простейший случай: замерим, как быстро создаётся копия исходного списка, т.е. проверим цепочку вообще без промежуточных операций. Так как для такого сценария <code class="text-nowrap">Stream</code> по идее вообще не нужен, и того же самого можно добиться просто вызвав <code class="text-nowrap">new ArrayList<>(sourceList)</code> или <code class="text-nowrap">List.copyOf(sourceList)</code>, то замерим и эти два случая тоже:</p>
<details><summary><i>Полный код JMH-бенчмарка</i></summary><pre class="border p-lg-2 p-1">import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToList {

    @Param({"10", "100", "1000"})
    private int size;

    private List&lt;Integer&gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&lt;Integer&gt; newArrayList() {
        return new ArrayList&lt;&gt;(sourceList);
    }

    @Benchmark
    public List&lt;Integer&gt; toList() {
        return sourceList.stream().toList();
    }

    @Benchmark
    public List&lt;Integer&gt; copyOf() {
        return List.copyOf(sourceList);
    }

    @Benchmark
    public List&lt;Integer&gt; collectToList() {
        return sourceList.stream().collect(Collectors.toList());
    }

    @Benchmark
    public List&lt;Integer&gt; collectToUnmodifiableList() {
        return sourceList.stream().collect(Collectors.toUnmodifiableList());
    }
}</pre></details>
<details><summary><i>Детали запуска бенчмарка</i></summary><pre class="border p-lg-2 p-1">OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC</pre></details>
<img src="stream_tolist_benchmark1.png" class="img-fluid" />
<p class="pt-2">Результаты говорят нам о том, что <code class="text-nowrap">Stream.toList()</code> не только существенно быстрее <code class="text-nowrap">collect(Collectors.toList())</code>, но и может быть быстрее даже <code class="text-nowrap">List.copyOf()</code>! Это объясняется тем, что в <code class="text-nowrap">List.copyOf()</code> существенное время тратится на проверку <code class="text-nowrap">requireNonNull</code> для каждого входного элемента, поскольку он запрещает <code class="text-nowrap">null</code>-элементы, в то время как <code class="text-nowrap">Stream.toList()</code> не запрещает <code class="text-nowrap">null</code> и в нём такая проверка не нужна. На малых размерах <code class="text-nowrap">List.copyOf()</code> всё же выигрывает, потому что проверка нескольких элементов на <code class="text-nowrap">null</code> быстрее церемоний, которые есть у <code class="text-nowrap">Stream</code>: создание <code class="text-nowrap">Spliterator</code>, <code class="text-nowrap">ReferencePipeline</code> и т.д.</p>
<p>Теперь рассмотрим случай, когда точный размер неизвестен. Например, добавим одну промежуточную операцию <code class="text-nowrap">filter()</code>:</p>
<details><summary><i>Полный код JMH-бенчмарка</i></summary><pre class="border p-lg-2 p-1">import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToListFilter {

    @Param({"10", "100", "1000"})
    private int size;

    private List&lt;Integer&gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&lt;Integer&gt; toList() {
        return sourceList.stream().filter(i -&gt; i % 2 == 0).toList();
    }

    @Benchmark
    public List&lt;Integer&gt; newArrayList() {
        var list = new ArrayList&lt;Integer&gt;();
        for (var i : sourceList) {
            if (i % 2 == 0) {
                list.add(i);
            }
        }
        return list;
    }

    @Benchmark
    public List&lt;Integer&gt; collectToList() {
        return sourceList.stream().filter(i -&gt; i % 2 == 0).collect(Collectors.toList());
    }

    @Benchmark
    public List&lt;Integer&gt; collectToUnmodifiableList() {
        return sourceList.stream().filter(i -&gt; i % 2 == 0).collect(Collectors.toUnmodifiableList());
    }
}
</pre></details>
<details><summary><i>Детали запуска бенчмарка</i></summary><pre class="border p-lg-2 p-1">OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC</pre></details>
<img src="stream_tolist_benchmark2.png" class="img-fluid" />
<p class="pt-2">В этом случае мы тоже получили большое ускорение! И в этот раз <code class="text-nowrap">Stream.toList()</code> на большом количестве элементов выиграл даже у простого <code class="text-nowrap">new ArrayList()</code> с последующим заполнением в цикле. Как так получается? Дело в том, что при неизвестном размере <code class="text-nowrap">Stream.toArray()</code> использует структуру данных <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/stream/SpinedBuffer.java"><code class="text-nowrap">SpinedBuffer</code></a>, которая более эффективна для накопления элементов, чем <code class="text-nowrap">ArrayList</code>. Она представляет собой массив массивов, где подмассивы имеют длины в виде возрастающих степеней двойки (каждый следующий chunk в два раза больше предыдущего). Структуру <code class="text-nowrap">SpinedBuffer</code> можно легко понять из этого рисунка, где изображён буфер со 100 элементами (<code class="text-nowrap">Integer</code> от 0 до 99):</p>
<img src="spined_buffer.png" class="img-fluid" />
<p class="pt-2">Также <code class="text-nowrap">ArrayList</code> проигрывает ещё и потому, что расширяется всего лишь в 1.5 раза при заполнении внутреннего массива, а значит делает это намного чаще, что приводит к дополнительным накладным расходам. <code class="text-nowrap">ArrayList</code> вынужден балансировать между экономией памяти и скоростью операции <code class="text-nowrap">add()</code>, поэтому и проигрывает <code class="text-nowrap">SpinedBuffer</code>, который заточен исключительно на скорость. Излишний расход памяти для него не играет роли, так как это недолгоживующая структура, которая сразу же отбрасывается после завершения терминальной операции.</p>
<p>Вывод: <code class="text-nowrap">Stream.toList()</code> короче, чище и почти всегда быстрее, чем <code class="text-nowrap">collect(Collectors.toList())</code>. Так что о втором способе можно забыть и использовать всегда первый (хотя <code class="text-nowrap">Collectors.toList()</code> сам по себе всё ещё может быть нужен, например как downstream <code class="text-nowrap">Collector</code> для других <code class="text-nowrap">Collector</code>'ов). Если же нужен гарантированно изменяемый список, то можно использовать <code class="text-nowrap">collect(Collectors.toCollection(ArrayList::new))</code>.</p>

<h4>2. <code class="text-nowrap">String</code>: <code class="text-nowrap">formatted()</code>, <code class="text-nowrap">stripIndent()</code> и  <code class="text-nowrap">translateEscapes()</code></h4>
<h5>Появились в: Java 15</h5>
<p>В Java 15 появились <a href="https://openjdk.java.net/jeps/378">блоки текста</a> &ndash; строковые литералы, которые могут состоять из одной или нескольких линий:</p>
<pre class="border p-lg-2 p-1">String str = <span style="color: darkred">"""
        Привет,
        Юзер!"""</span>;</pre>
<p>При этом довольно часто блоки будут использоваться в качестве шаблонов с последующей заменой:</p>
<pre class="border p-lg-2 p-1">String str = String.format(<span style="color: darkred">"""
        Привет,
        %s!"""</span>, user);</pre>
<p>Не кажется ли вам, что код выше выглядит несколько громоздким? Мне вот тоже кажется. Но у нас есть способ, как сделать его немножко чище. Это новый метод <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object...)"><code class="text-nowrap">String.formatted()</code></a>, который является нестатическим эквивалентом <code class="text-nowrap">String.format()</code>:</p>
<pre class="border p-lg-2 p-1">String str = <span style="color: darkred">"""
        Привет,
        %s!"""</span>.formatted(user);</pre>
<p>Вы, конечно, скажете, что разница лишь в трёх символах сэкономленного кода, но, во-первых, второй вариант гораздо проще печатать на клавиатуре (проверьте сами), а во-вторых, он более читабелен.</p>
<p>Кстати, <code class="text-nowrap">formatted()</code> никто не запрещает использовать и с обычными литералами:</p>
<pre class="border p-lg-2 p-1">String str = <span style="color: darkred">"Привет, %s!"</span>.formatted(user);</pre>
<p>Лично мне метод очень нравится, и я планирую взять его на вооружение в качестве основного рабочего варианта.</p>

<p class="pt-2">Второй метод, появившийся в Java 15 &ndash; это <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#stripIndent()"><code class="text-nowrap">String.stripIndent()</code></a>, который удаляет общие пробельные символы в начале всех линий. К примеру, если есть файл <code class="text-nowrap">hello.txt</code> с такими строками:</p>
<pre class="border p-lg-2 p-1">    Привет,
    Юзер!</pre>
<p>Тогда чтобы убрать пробелы слева, как раз и можно воспользоваться <code class="text-nowrap">stripIndent()</code>:</p>
<pre class="border p-lg-2 p-1">String str = Files.readString(Path.of(<span style="color: darkred">"hello.txt"</span>)).stripIndent();
System.out.println(str);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">Привет,
Юзер!</pre>

<p class="pt-2">Наконец, третий метод &ndash; это <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#translateEscapes()"><code class="text-nowrap">String.translateEscapes()</code></a>. Он делает простую вещь: заменяет экранирующие последовательности на их соответствующие символы.</p>
<p>Например, есть файл hello.txt:</p>
<pre class="border p-lg-2 p-1">Привет,\nЮзер!</pre>
<pre class="border p-lg-2 p-1">String str = Files.readString(Path.of(<span style="color: darkred">"hello.txt"</span>)).translateEscapes();
System.out.println(str);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">Привет,
Юзер!</pre>

<h4>3. <code class="text-nowrap">CharSequence.isEmpty()</code>, <code class="text-nowrap">CharSequence.compare()</code> и <code class="text-nowrap">StringBuilder.compareTo()</code></h4>
<h5>Появились в: Java 15 / Java 11</h5>
<p>Если уж мы начали тему строк, то давайте добьём её до конца.</p>
<p>Тот, кто писал на Java 1.5 или на более старых версиях, должен помнить, что в классе <code class="text-nowrap">String</code> в те времена не было метода <code class="text-nowrap">isEmpty()</code>. Поэтому для проверки строки на пустоту каждый раз приходилось использовать <code class="text-nowrap">length()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (str.length() != 0) {
    ...
}</pre>
<p>Это было не совсем удобно, и в Java 1.6 метод <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#isEmpty()"><code class="text-nowrap">String.isEmpty()</code></a> наконец-то завезли:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (!str.isEmpty()) {
    ...
}</pre>
<p>Однако про то, что <code class="text-nowrap">String</code> &ndash; далеко не единственная реализация <code class="text-nowrap">CharSequence</code> (хоть и самая популярная), почему-то не подумали, и этот метод туда добавлять не стали (впрочем, без <code class="text-nowrap">default</code>-методов они бы этого сделать и не смогли). Например, для проверки на пустоту <code class="text-nowrap">StringBuilder</code> всё ещё приходилось использовать <code class="text-nowrap">length()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (stringBuilder.length() != 0) {
    ...
}</pre>
<p>Но спустя 14 лет всё-таки решили исправить и это: начиная с Java 15, метод <code class="text-nowrap">isEmpty()</code> есть не только у <code class="text-nowrap">String</code>, но и у любой <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/CharSequence.html#isEmpty()"><code class="text-nowrap">CharSequence</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (!stringBuilder.isEmpty()) {
    ...
}</pre>

<p class="pt-2">Также иногда приходится тестировать два <code class="text-nowrap">CharSequence</code> на равенство. Метод <code class="text-nowrap">equals()</code> использовать нельзя: а вдруг он не переопределён в реализации? Поэтому приходится изворачиваться: либо конвертировать каждый <code class="text-nowrap">CharSequence</code> в <code class="text-nowrap">String</code> и сравнивать их, что может быть накладно, либо писать свою реализацию посимвольного сравнения.</p>
<p>Однако, начиная с Java 11, всё это не нужно, потому что появился метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html#compare(java.lang.CharSequence,java.lang.CharSequence)"><code class="text-nowrap">CharSequence.compare()</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (CharSequence.compare(charSeq1, charSeq2) == 0) {
    ...
}</pre>
<p>Метод <code class="text-nowrap">compare()</code> также можно использовать не только для просто теста на равенство, но и для лексикографического сравнения.</p>
<p>Также в Java 11 класс <code class="text-nowrap">StringBuilder</code> стал реализовывать интерфейс <code class="text-nowrap">Comparable</code>, а значит для сравнения двух <code class="text-nowrap">StringBuilder</code> можно использовать <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html#compareTo(java.lang.StringBuilder)"><code class="text-nowrap">compareTo()</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (stringBuilder1.compareTo(stringBuilder2) == 0) {
    ...
}</pre>

<h4>4. <code class="text-nowrap">Collectors.filtering()</code> и <code class="text-nowrap">Collectors.flatMapping()</code></h4>
<h5>Появились в: Java 9</h5>
<p>Часто ли вам приходится использовать <code class="text-nowrap">Collectors.groupingBy()</code>? К примеру, вы ведёте базу данных фильмов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Movie(String title, String genre, <span style="color: blue">double</span> rating) {
}</pre>
<p>Допустим, вы хотите сгруппировать фильмы по жанру:</p>
<pre class="border p-lg-2 p-1">Stream&lt;Movie&gt; allMovies = Stream.of(
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Коммандо"</span>, <span style="color: darkred">"Боевик"</span>, 7.385),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Терминатор"</span>, <span style="color: darkred">"Боевик"</span>, 7.974),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Терминатор 2"</span>, <span style="color: darkred">"Боевик"</span>, 8.312),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Молчание ягнят"</span>, <span style="color: darkred">"Триллер"</span>, 8.33),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Криминальное чтиво"</span>, <span style="color: darkred">"Триллер"</span>, 8.619),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Титаник"</span>, <span style="color: darkred">"Мелодрама"</span>, 8.363),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Семьянин"</span>, <span style="color: darkred">"Комедия"</span>, 7.699)
);

Map&lt;String, List&lt;Movie&gt;&gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre));

groups.forEach((genre, movies) -> {
    System.out.println(genre + <span style="color: darkred">":"</span>);
    movies.forEach(movie ->
        System.out.printf(<span style="color: darkred">"    %s: %.2f%n"</span>, movie.title(), movie.rating()));
});</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">Мелодрама:
    Титаник: 8.36
Боевик:
    Коммандо: 7.39
    Терминатор: 7.97
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    Семьянин: 7.70</pre>
<p>Однако, допустим, вы не хотите видеть все фильмы, а только те, у кого рейтинг выше 8. Какой метод вы в этом случае используете? Конечно же, <code class="text-nowrap">Stream.filter()</code>:</p>
<pre class="border p-lg-2 p-1">Map&lt;String, List&lt;Movie&gt;&gt; groups = allMovies
    .filter(movie -> movie.rating() > 8)
    .collect(Collectors.groupingBy(Movie::genre));</pre>
<pre class="border p-lg-2 p-1">Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62</pre>
<p>Но вот проблема: вам вдруг захотелось видеть все жанры, даже те, в которые не попало ни одного фильма с рейтингом выше 8. Что делать? Ответ: перейти на новую версию Java, потому что в ней есть <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#filtering(java.util.function.Predicate,java.util.stream.Collector)"><code class="text-nowrap">Collectors.filtering()</code></a>:</p>
<pre class="border p-lg-2 p-1">Map&lt;String, List&lt;Movie&gt;&gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.filtering(movie -> movie.rating() > 8,
            Collectors.toList())));

groups.forEach((genre, movies) -> {
    System.out.println(genre + <span style="color: darkred">":"</span>);
    <span style="color: blue">if</span> (movies.isEmpty()) {
        System.out.println(<span style="color: darkred">"    &lt;Фильмов с рейтингом выше 8 нет&gt;"</span>);
    } <span style="color: blue">else</span> {
        movies.forEach(movie ->
            System.out.printf(<span style="color: darkred">"    %s: %.2f%n"</span>, movie.title(), movie.rating()));
    }
});</pre>
<p>В этом случае фильтрация будет перенесена внутрь <code class="text-nowrap">groupingBy()</code>, и потери жанров не произойдёт:</p>
<pre class="border p-lg-2 p-1">Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    &lt;Фильмов с рейтингом выше 8 нет&gt;</pre>

<p class="pt-2">Очень хорошо. Теперь добавим в фильмы актёров:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Movie(String title, String genre, <span style="color: blue">double</span> rating, List&lt;String&gt; actors) {
}</pre>
<p>И теперь хотите увидеть всех актёров с группировкой по жанру:</p>
<pre class="border p-lg-2 p-1">Stream&lt;Movie&gt; allMovies = Stream.of(
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Коммандо"</span>, <span style="color: darkred">"Боевик"</span>, 7.385,
        List.of(<span style="color: darkred">"Шварценеггер"</span>, <span style="color: darkred">"Чонг"</span>, <span style="color: darkred">"Хедайя"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Терминатор"</span>, <span style="color: darkred">"Боевик"</span>, 7.974,
        List.of(<span style="color: darkred">"Шварценеггер"</span>, <span style="color: darkred">"Бин"</span>, <span style="color: darkred">"Хэмилтон"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Терминатор 2"</span>, <span style="color: darkred">"Боевик"</span>, 8.312,
        List.of(<span style="color: darkred">"Шварценеггер"</span>, <span style="color: darkred">"Хэмилтон"</span>, <span style="color: darkred">"Ферлонг"</span>, <span style="color: darkred">"Патрик"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Молчание ягнят"</span>, <span style="color: darkred">"Триллер"</span>, 8.33,
        List.of(<span style="color: darkred">"Фостер"</span>, <span style="color: darkred">"Хопкинс"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Криминальное чтиво"</span>, <span style="color: darkred">"Триллер"</span>, 8.619,
        List.of(<span style="color: darkred">"Траволта"</span>, <span style="color: darkred">"Уиллис"</span>, <span style="color: darkred">"Джексон"</span>, <span style="color: darkred">"Турман"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Титаник"</span>, <span style="color: darkred">"Мелодрама"</span>, 8.363,
        List.of(<span style="color: darkred">"ДиКаприо"</span>, <span style="color: darkred">"Уинслет"</span>)),
    <span style="color: blue">new</span> Movie(<span style="color: darkred">"Семьянин"</span>, <span style="color: darkred">"Комедия"</span>, 7.699,
        List.of(<span style="color: darkred">"Кейдж"</span>, <span style="color: darkred">"Леони"</span>))
);</pre>
<p>Но какой коллектор нужно подсунуть в <code class="text-nowrap">groupingBy()</code>, чтобы собрать всех актёров в <code class="text-nowrap">Set</code>? Можно попробовать <code class="text-nowrap">Collectors.mapping()</code>:</p>
<pre class="border p-lg-2 p-1">Map&lt;String, Set&lt;List&lt;String&gt;&gt;&gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.mapping(Movie::actors, Collectors.toSet())));</pre>
<p>Но смотрите, у нас получилось множество списков, а нужно просто множество. Что же делать? И тут на помощь приходит <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#flatMapping(java.util.function.Function,java.util.stream.Collector)"><code class="text-nowrap">Collectors.flatMapping()</code></a>, ещё один новый метод, появившийся в Java 9:</p>
<pre class="border p-lg-2 p-1">Map&lt;String, Set&lt;String&gt;&gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.flatMapping(movie -> movie.actors().stream(),
            Collectors.toSet())));</pre>
<p>И вот сейчас тип правильный! Если вывести это, то получится:</p>
<pre class="border p-lg-2 p-1">Мелодрама:
    ДиКаприо
    Уинслет
Боевик:
    Бин
    Ферлонг
    Хедайя
    Патрик
    Шварценеггер
    Хэмилтон
    Чонг
Триллер:
    Траволта
    Уиллис
    Хопкинс
    Фостер
    Джексон
    Турман
Комедия:
    Кейдж
    Леони</pre>
<p>Что и требовалось.</p>

<h4>5. <code class="text-nowrap">StackWalker</code></h4>
<h5>Появился в: Java 9</h5>
<p>Приходилось ли вам иметь дело со стеками? Не со стеками в смысле структур данных, а со стеком потоков? Например, вы пишете простенький логгер:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public final class</span> MyLogger {
    <span style="color: blue">public static void</span> log(String message) {
        System.out.println(message);
    }
}</pre>
<p>Однако вы хотите писать в консоль не просто голое сообщение, а ещё имя класса, метода, файла и номер строки, откуда вызывается метод <code class="text-nowrap">log()</code>. В Java 8 единственным стандартным способом для этого является получение массива <code class="text-nowrap">StackTraceElement[]</code>, например, с помощью метода <code class="text-nowrap">Thread.getStackTrace()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static void</span> log(String message) {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    String msg = stackTraceElement.getClassName() + <span style="color: darkred">"."</span>
               + stackTraceElement.getMethodName() + <span style="color: darkred">"("</span>
               + stackTraceElement.getFileName() + <span style="color: darkred">":"</span>
               + stackTraceElement.getLineNumber() + <span style="color: darkred">") "</span>
               + message;
    System.out.println(msg);
}</pre>
<p>Можно предположить, что такой способ получения получения номеров строк является довольно дорогим. Ведь нам надо заполнить полностью весь стек, который может быть очень глубоким (особенно в энтерпрайзе, где фреймворк на фреймворке), а потом ещё и сконвертировать внутренние структуры JVM в Java-массив. И всё это ради того, чтобы отбросить его почти полностью и достать только второй элемент. Давайте замерим производительность такого подхода:</p>
<pre class="border p-lg-2 p-1"><span style="color: gold">@Benchmark</span>
<span style="color: blue">public</span> String stackTrace() {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    <span style="color: blue">return</span> stackTraceElement.getClassName() + <span style="color: darkred">"."</span>
         + stackTraceElement.getMethodName() + <span style="color: darkred">"("</span>
         + stackTraceElement.getFileName() + <span style="color: darkred">":"</span>
         + stackTraceElement.getLineNumber() + <span style="color: darkred">")"</span>;
}</pre>
<details><summary><i>Детали запуска бенчмарка</i></summary><pre class="border p-lg-2 p-1">OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6</pre></details>
<pre class="border p-lg-2 p-1">Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op</pre>
<p>104 микросекунды на каждый вызов! Это невероятно медленно! Есть ли возможность это ускорить? Есть: с помощью нового класса <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html"><code class="text-nowrap">StackWalker</code></a>, который появился в Java 9. Давайте рассмотрим этот класс поподробнее.</p>
<p><code class="text-nowrap">StackWalker</code> предоставляет возможность &laquo;гулять&raquo; по стеку. Чтобы это сделать, сначала нужно получить экземпляр <code class="text-nowrap">StackWalker</code> с помощью метода <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getInstance()"><code class="text-nowrap">StackWalker.getInstance()</code></a>. Этот метод возвращает <code class="text-nowrap">StackWalker</code> по умолчанию. Также есть возможность передать в метод <code class="text-nowrap">getInstance()</code> опции и получить <code class="text-nowrap">StackWalker</code> с более богатыми возможностями. Но об этом чуть позже.</p>
<p>После того, как мы получил объект <code class="text-nowrap">StackWalker</code>, у нас есть следующие варианты:</p>
<ul>
    <li>Выполнить на нём метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#forEach(java.util.function.Consumer)"><code class="text-nowrap">forEach()</code></a> и пройтись по всем фреймам стека.</li>
    <li>Вызвать метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"><code class="text-nowrap">getCallerClass()</code></a> и получить класс, который вызвал наш метод (работает только с опцией <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.Option.html#RETAIN_CLASS_REFERENCE"><code class="text-nowrap">RETAIN_CLASS_REFERENCE</code></a>).</li>
    <li>Вызвать метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#walk(java.util.function.Function)"><code class="text-nowrap">walk()</code></a>, который принимает функцию из <code class="text-nowrap">Stream&lt;StackFrame&gt;</code> в <code class="text-nowrap">T</code>, где <code class="text-nowrap">T</code> &ndash; это что угодно. Это самый гибкий метод.</li>
</ul>
<p>Для нашего логгера мы воспользуемся третьим вариантом. Вот как будет выглядеть реализация метода <code class="text-nowrap">log()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static void</span> log(String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&lt;StackFrame&gt; frames) -> {
            StackFrame frame = frames.skip(2).findFirst().get();
            <span style="color: blue">return</span> frame.getClassName() + <span style="color: darkred">"."</span>
                 + frame.getMethodName() + <span style="color: darkred">"("</span>
                 + frame.getFileName() + <span style="color: darkred">":"</span>
                 + frame.getLineNumber() + <span style="color: darkred">") "</span>
                 + message;
        });
    System.out.println(msg);
}</pre>
<p>Теперь давайте замерим производительность варианта со <code class="text-nowrap">StackWalker</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: gold">@Benchmark</span>
<span style="color: blue">public</span> String stackWalker() {
    <span style="color: blue">return</span> StackWalker
        .getInstance()
        .walk(frames -> {
            StackFrame frame = frames.skip(2).findFirst().get();
            <span style="color: blue">return</span> frame.getClassName() + <span style="color: darkred">"."</span>
                 + frame.getMethodName() + <span style="color: darkred">"("</span>
                 + frame.getFileName() + <span style="color: darkred">":"</span>
                 + frame.getLineNumber() + <span style="color: darkred">")"</span>;
        });
}</pre>
<details><summary><i>Детали запуска бенчмарка</i></summary><pre class="border p-lg-2 p-1">OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6</pre></details>
<pre class="border p-lg-2 p-1">Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op
Stack.stackWalker  avgt    5    2,781 ? 0,156  us/op</pre>
<p>Скорость выросла в 37 раз! Это огромный выигрыш. Конечно, 2.8 микросекунды это всё ещё далеко не бесплатно, но такой вариант кажется уже вполне приемлемым, чтобы включить его в боевом приложении.</p>
<p>Так как метод <code class="text-nowrap">StackWalker.walk()</code> даёт нам <code class="text-nowrap">Stream</code>, то наши возможности по обходу стека практически безграничны: можно получить все фреймы, можно отфильтровать, можно пропустить сколько-то. Например, усложним наш логирующий &laquo;фреймворк&raquo;, добавив туда уровни:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">package</span> org.mylogger;

<span style="color: blue">public final class</span> MyLogger {
    <span style="color: blue">public enum</span> Level {
        ERROR, WARN, INFO
    }

    <span style="color: blue">public static void</span> error(String message) {
        log(Level.ERROR, message);
    }

    <span style="color: blue">public static void</span> warn(String message) {
        log(Level.WARN, message);
    }

    <span style="color: blue">public static void</span> info(String message) {
        log(Level.INFO, message);
    }

    <span style="color: blue">public static void</span> log(Level level, String message) {
        ...
    }
}</pre>
<p>Сейчас мы уже не можем использовать конструкцию <code class="text-nowrap">frames.skip(2)</code>, потому что метод <code class="text-nowrap">log()</code> может быть вызван как напрямую, так и через методы <code class="text-nowrap">error()</code>, <code class="text-nowrap">warn()</code>, <code class="text-nowrap">log()</code>, а значит фрейм надо искать немножко умнее. Самое простое &ndash; через <code class="text-nowrap">Stream.dropWhile()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public static void</span> log(Level level, String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&lt;StackFrame&gt; frames) -> {
            StackFrame frame = frames
                .dropWhile(f -> f.getClassName().startsWith(<span style="color: darkred">"org.mylogger"</span>))
                .findFirst()
                .get();
            <span style="color: blue">return</span> level + <span style="color: darkred">" "</span>
                 + frame.getClassName() + <span style="color: darkred">"."</span>
                 + frame.getMethodName() + <span style="color: darkred">"("</span>
                 + frame.getFileName() + <span style="color: darkred">":"</span>
                 + frame.getLineNumber() + <span style="color: darkred">") "</span>
                 + message;
        });
    System.out.println(msg);
}</pre>

<p class="pt-2">Какие ещё применения есть у <code class="text-nowrap">StackWalker</code>?</p>
<p>Как вы знаете, в Java 9 появились модули. Но мало кто использует их в своих проектах, и подавляющее большинство всё ещё препочитает класть всё в classpath. Но тогда у нас теряется весьма ценная возможность &ndash; экспортировать из модуля часть пакетов, а остальные скрывать. Представим, что у нас есть пакет <code class="text-nowrap">org.example.mylib.internal</code>, который мы хотим, чтобы не использовал никто кроме нашего модуля:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">package</span> org.example.mylib.internal;

<span style="color: blue">public final class</span> Handler {
    <span style="color: blue">public static void</span> handle() {
        ...
    }
}</pre>
<p>Класс <code class="text-nowrap">Handler</code> публичный, а значит компилятор уже никак не помешает кому угодно использовать этот класс. Но, может быть, можно сделать хотя бы проверку в рантайме? И действительно, это можно сделать через <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"><code class="text-nowrap">StackWalker.getCallerClass()</code></a>, и выглядеть этот будет примерно так:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">package</span> org.example.mylib.internal;

<span style="color: blue">public final class</span> Handler {
    <span style="color: blue">public static void</span> handle() {
        <span style="color: blue">if</span> (!StackWalker
            .getInstance(Option.RETAIN_CLASS_REFERENCE)
            .getCallerClass()
            .getPackageName()
            .startsWith(<span style="color: darkred">"org.example.mylib."</span>)) {
            <span style="color: blue">throw new</span> RuntimeException(<span style="color: darkred">"Security error"</span>);
        }
        ...
    }
}</pre>
<p>Здесь мы использовали опцию <code class="text-nowrap">RETAIN_CLASS_REFERENCE</code>, иначе получить Class не получилось бы. В принципе, подобную функциональность можно было бы реализовать и через <code class="text-nowrap">Stream.walk()</code>, но <code class="text-nowrap">getCallerClass()</code> работает немного быстрее.</p>

<h4>6. <code class="text-nowrap">System.Logger</code></h4>
<h5>Появился в: Java 9</h5>
<p>Если уж мы начали говорить про логирование, то нельзя не рассказать про <a href="https://openjdk.java.net/jeps/264">новое стандартное API для логирования</a>, которое появилось в Java 9. Это API очень маленькое и состоит всего из трёх классов: интерфейса <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.html"><code class="text-nowrap">System.Logger</code></a>, абстрактного класса <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.LoggerFinder.html"><code class="text-nowrap">System.LoggerFinder</code></a> и перечисления <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.Level.html"><code class="text-nowrap">System.Logger.Level</code></a>.</p>
<p>Использовать <code class="text-nowrap">System.Logger</code> чрезвычайно просто:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public final class</span> Main {
    <span style="color: blue">private static final</span> Logger LOGGER = System.getLogger(<span style="color: darkred">""</span>);

    <span style="color: blue">public static void</span> main(String[] args)  {
        LOGGER.log(Level.ERROR, <span style="color: darkred">"Critical error!"</span>);
    }
}</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1"><span style="color: darkred">апр. 17, 2021 6:24:57 PM org.example.Main main
SEVERE: Critical error!</span></pre>
<p><code class="text-nowrap">System.Logger</code> &ndash; это не новый очередной фреймворк для логирования, как вы могли бы подумать сначала, а только <b>фронтенд</b> для логирования. Если вы знакомы с существующими фреймворками, то вам должно быть это знакомо: например, <a href="http://www.slf4j.org/">SLF4J</a> &ndash; это фронтенд, а его соответствующим бэкендом является <a href="http://logback.qos.ch/">Logback</a>. Или <a href="https://logging.apache.org/log4j/2.x/">Log4j API</a> &ndash; это фронтенд для Log4j Core. Так вот, <code class="text-nowrap">System.Logger</code> &ndash; это фронтенд для знакомого вам фреймворка <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/package-summary.html"><code class="text-nowrap">java.util.logging</code></a>, который находится в отдельном модуле <code class="text-nowrap">java.logging</code>.</p>
<p>При этом нам ничего не мешает для SLF4J использовать другой бэкенд, например, <a href="https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/">Log4j</a> или <a href="https://search.maven.org/artifact/org.slf4j/slf4j-jdk14"><code class="text-nowrap">java.util.logging</code></a>. Или для Log4j API использовать <a href="https://logging.apache.org/log4j/2.x/log4j-to-slf4j/index.html">SLF4J</a> как бэкенд или <a href="https://logging.apache.org/log4j/2.x/log4j-jul/index.html"><code class="text-nowrap">java.util.logging</code></a>. Точно так же и с <code class="text-nowrap">System.Logger</code>: он спроектирован так, чтобы реализация могла быть абсолютно любой. Если не нравится неудобный и старый <code class="text-nowrap">java.util.logging</code>, то можно использовать что-то другое. Например, можно его настроить на современный Log4j, для чего потребуется подключить следующие зависимости:</p>
<pre class="border p-lg-2 p-1">&lt;<span style="color: darkred">dependency</span>&gt;
    &lt;<span style="color: darkred">groupId</span>&gt;org.apache.logging.log4j&lt;/<span style="color: darkred">groupId</span>&gt;
    &lt;<span style="color: darkred">artifactId</span>&gt;log4j-api&lt;/<span style="color: darkred">artifactId</span>&gt;
    &lt;<span style="color: darkred">version</span>&gt;2.14.1&lt;/<span style="color: darkred">version</span>&gt; <span style="color: grey">&lt;!-- Последняя версия на момент написания статьи --&gt;</span>
    &lt;<span style="color: darkred">scope</span>&gt;runtime&lt;/<span style="color: darkred">scope</span>&gt;
&lt;/<span style="color: darkred">dependency</span>&gt;
&lt;<span style="color: darkred">dependency</span>&gt;
    &lt;<span style="color: darkred">groupId</span>&gt;org.apache.logging.log4j&lt;/<span style="color: darkred">groupId</span>&gt;
    &lt;<span style="color: darkred">artifactId</span>&gt;log4j-core&lt;/<span style="color: darkred">artifactId</span>&gt;
    &lt;<span style="color: darkred">version</span>&gt;2.14.1&lt;/<span style="color: darkred">version</span>&gt;
    &lt;<span style="color: darkred">scope</span>&gt;runtime&lt;/<span style="color: darkred">scope</span>&gt;
&lt;/<span style="color: darkred">dependency</span>&gt;
&lt;<span style="color: darkred">dependency</span>&gt;
    &lt;<span style="color: darkred">groupId</span>&gt;org.apache.logging.log4j&lt;/<span style="color: darkred">groupId</span>&gt;
    &lt;<span style="color: darkred">artifactId</span>&gt;log4j-jpl&lt;/<span style="color: darkred">artifactId</span>&gt;
    &lt;<span style="color: darkred">version</span>&gt;2.14.1&lt;/<span style="color: darkred">version</span>&gt;
    &lt;<span style="color: darkred">scope</span>&gt;runtime&lt;/<span style="color: darkred">scope</span>&gt;
&lt;/<span style="color: darkred">dependency</span>&gt;
</pre>
<p>При этом саму программу изменять не потребуется: то, что <code class="text-nowrap">log4j-jpl</code> окажется в classpath, уже будет достаточно. Java через <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html"><code class="text-nowrap">ServiceLoader</code></a> найдёт нужную реализацию <code class="text-nowrap">LoggerFinder</code> в виде <code class="text-nowrap">Log4jSystemLoggerFinder</code> и будет направлять логи в Log4j:</p>
<pre class="border p-lg-2 p-1">18:24:57.941 [main] ERROR  - Critical error!</pre>
<p>После этого модуль <code class="text-nowrap">java.logging</code> можно будет даже вообще <a href="https://openjdk.java.net/jeps/282">исключить</a> из JRE/JDK, ведь он больше не нужен (если вы конечно нигде не вызываете <code class="text-nowrap">java.util.logging</code> напрямую).</p>
<p>К сожалению, адаптера <code class="text-nowrap">System.Logger</code> для SLF4J/Logback нет. Но тут проблема более глобальная &ndash; похоже, что сам проект SLF4J мёртв. Последний коммит в <a href="https://github.com/qos-ch/slf4j">GitHub</a> был полтора года назад. Так что Log4j сейчас это самый нормальный вариант &ndash; он активно развивается и поддерживается.</p>
<p>Несколько примеров использования <code class="text-nowrap">System.Logger</code>:</p>
<pre class="border p-lg-2 p-1">LOGGER.log(Level.INFO, <span style="color: darkred">"Information"</span>);
LOGGER.log(Level.DEBUG, <span style="color: darkred">"Sum of {} and {} is {}:"</span>, 2, 3, 2+3);
LOGGER.log(Level.TRACE, () -> <span style="color: darkred">"Lazy message"</span>);
LOGGER.log(Level.ERROR, <span style="color: darkred">"Log exception"</span>, <span style="color: blue">new</span> Exception());</pre>

<h4>7. <code class="text-nowrap">Lookup.defineHiddenClass()</code></h4>
<h5>Появился в: Java 15</h5>
<p>В <a href="api_to_upgrade_from_java_8_part_2.html">прошлый раз</a> мы рассказывали про метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineClass(byte[])"><code class="text-nowrap">MethodHandles.Lookup.defineClass()</code></a>, с помощью которого можно во время выполнения легко загрузить класс в том же пакете, не создавая при этом новый загрузчик класса. Это очень удобный метод, но у него есть существенный минус: класс, который загружен таким образом, будет до конца жизни висеть в памяти (по крайней мере до конца жизни текущего загрузчика класса). Это не очень подходит для приложений, которым требуется динамически генерировать и загружать много временных классов на лету. Но с Java 15 появилась альтернатива в виде нового вида классов, которые называются <a href="https://openjdk.java.net/jeps/371"><i>скрытыми</i></a>.</p>
<p>Скрытые классы создаются с помощью нового метода <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte[],boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)"><code class="text-nowrap">Lookup.defineHiddenClass()</code></a>. По сути этот метод очень похож на старый нестандартный метод <code class="text-nowrap">Unsafe.defineAnonymousClass()</code>, который много лет используется различными фреймворками, поскольку решает проблему неконтролируемого роста количества временных классов в памяти. При этом сам <code class="text-nowrap">Unsafe.defineAnonymousClass()</code> с Java 15 стал deprecated for removal.</p>
<p>Скрытые классы имеют следующие особенности:</p>
<ul>
    <li>На них не могут прямо ссылаться другие классы. Всё их использование может осуществляться исключительно через рефлексию.</li>
    <li>Они являются необнаружимыми. Их нельзя найти ни по имени, ни обнаружить с помощью загрузчиков классов (через <code class="text-nowrap">Class.forName()</code>, <code class="text-nowrap">ClassLoader.loadClass()</code>, <code class="text-nowrap">ClassLoader.findLoadedClass()</code> и т.д.). Однако скрытые классы не являются анонимными и всё-таки имеют имя в формате <code class="text-nowrap">&lt;имя класса в байт-коде&gt;/&lt;suffix&gt;</code> (например, <code class="text-nowrap">org.example.Temp/0x0000000800cb8000</code>).</li>
    <li>Они реализованы таким способом, что не связаны сильной ссылкой с загрузчиком класса, а значит могут быть собраны сборщиком мусора, когда их <code class="text-nowrap">Class</code> становится недостижимым (но если хочется, то это можно переопределить, передав опцию <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.ClassOption.html#STRONG"><code class="text-nowrap">ClassOption.STRONG</code></a> в <code class="text-nowrap">defineHiddenClass()</code>).</li>
    <li>Они не появляются в стектрейсах, если только не включить опции <code class="text-nowrap">-XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames</code>.</li>
</ul>
<p>Кстати, вы уже должны быть хорошо знакомы со скрытыми классами, поскольку используете их каждый день. Это лямбды:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Runnable runnable = () -> {}
runnable ==> $Lambda$26/0x0000000800c0aa00@443b7951

<span style="color: grey">jshell></span> runnable.getClass().isHidden()
$2 ==> true</pre>

<p>Давайте создадим небольшой примерчик и определим свой скрытый класс &laquo;с нуля&raquo;. Пусть он для простоты складывает два <code class="text-nowrap">int</code>'а. Для разнообразия будем это делать не с помощью javac, а через <a href="https://bytebuddy.net/#/">ByteBuddy</a>.</p>
<p>Для начала нужно создать представление класса в байт-коде в виде массива байтов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">byte</span>[] bytes = <span style="color: blue">new</span> ByteBuddy()
        .subclass(Object.<span style="color: blue">class</span>)
        .name(<span style="color: darkred">"org.example.Temp"</span>)
        .defineMethod(<span style="color: darkred">"sum"</span>, <span style="color: blue">int</span>.class, Modifier.PUBLIC)
        .withParameters(<span style="color: blue">int</span>.<span style="color: blue">class</span>, <span style="color: blue">int</span>.<span style="color: blue">class</span>)
        .intercept(<span style="color: blue">new</span> Implementation.Simple(
                MethodVariableAccess.INTEGER.loadFrom(1),
                MethodVariableAccess.INTEGER.loadFrom(2),
                Addition.INTEGER,
                MethodReturn.INTEGER))
        .make()
        .getBytes();</pre>
<p>По сути мы скомпилировали вот такой класс, но сделали это в рантайме непосредственно через манипуляции с байт-кодом:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">package</span> org.example;
<span style="color: blue">public class</span> Temp {
    <span style="color: blue">public int</span> sum(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) {
        <span style="color: blue">return</span> x + y;
    }
}</pre>
<p>Теперь, когда у нас есть байт-код класса, можно его загружать и что-то с ним делать:</p>
<pre class="border p-lg-2 p-1">Lookup lookup = MethodHandles
        .lookup()
        .defineHiddenClass(bytes, <span style="color: blue">false</span>);

<span style="color: green">// Для разнообразия будем использовать MethodHandle вместо reflection</span>
Object obj = lookup
        .findConstructor(lookup.lookupClass(), MethodType.methodType(<span style="color: blue">void</span>.<span style="color: blue">class</span>))
        .invoke();

MethodHandle sumHandle = lookup.findVirtual(lookup.lookupClass(), <span style="color: darkred">"sum"</span>,
        MethodType.methodType(<span style="color: blue">int</span>.<span style="color: blue">class</span>, <span style="color: blue">int</span>.<span style="color: blue">class</span>, <span style="color: blue">int</span>.<span style="color: blue">class</span>));

<span style="color: green">// Вызовем метод sum. Должен напечатать 5</span>
System.out.println(sumHandle.invoke(obj, 3, 2));</pre>
<p>Вот и всё.</p>

<p>Кстати, так как скрытые классы необнаружимы, то загружать один и тот же класс можно сколько угодно раз. По сути каждый раз будет определяться новый уникальный скрытый класс:</p>
<pre class="border p-lg-2 p-1">Lookup lookup1 = MethodHandles.lookup().defineHiddenClass(bytes, <span style="color: blue">false</span>);
Lookup lookup2 = MethodHandles.lookup().defineHiddenClass(bytes, <span style="color: blue">false</span>);
Lookup lookup3 = MethodHandles.lookup().defineHiddenClass(bytes, <span style="color: blue">false</span>);
System.out.println(lookup1.lookupClass()); <span style="color: green">// class org.example.Temp/0x0000000800cb4000</span>
System.out.println(lookup2.lookupClass()); <span style="color: green">// class org.example.Temp/0x0000000800cb4400</span>
System.out.println(lookup3.lookupClass()); <span style="color: green">// class org.example.Temp/0x0000000800cb4800</span></pre>



<h4>8. Новые методы в <code class="text-nowrap">Math</code></h4>
<h5>Появились в: Java 9 / Java 15</h5>
<p>Наверное, практически все, кто начинал работать с большими числами в Java, совершал вот такую ошибку:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> x = ...
<span style="color: blue">int</span> y = ...
<span style="color: blue">long</span> z = x * y;</pre>
<p>Это один из тех примеров в Java, когда можно угодить в ловушку даже на простом умножении: произведение двух <code class="text-nowrap">int</code> &ndash; это тоже <code class="text-nowrap">int</code>, а значит то, что переменная <code class="text-nowrap">z</code> имеет тип <code class="text-nowrap">long</code>, от переполнения никак не спасает. Для исправления этой ошибки нужно явно прикастовать хотя бы один из множителей к <code class="text-nowrap">long</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">long</span> z = (<span style="color: blue">long</span>) x * y;</pre>
<p>В то время как такое решение абсолютно рабочее, у меня в моём перфекционистском подсознании остаётся какой-то мелкий осадок. Во-первых, мне не нравится этот явный каст, который применяется то ли к первому множителю, то ли ко всему произведению. Во-вторых, не нравится эта асимметрия, что одна из переменных кастуется, а другая нет. В общем, я хочу кристальную ясность и отсутствие магии. Способ написать вот такое:</p>
<pre class="border p-lg-2 p-1">Возьми два int и перемножь их в long с учётом переполнения</pre>
<p>И с Java 9 такой способ есть. Это метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#multiplyFull(int,int)"><code class="text-nowrap">Math.multiplyFull()</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">long</span> z = Math.multiplyFull(x, y);</pre>

<p class="pt-2">Вообще обработка переполнений в Java реализуется довольно муторно, и чтобы облегчить жизнь программистам, в Java 8 появилась целая пачка методов для этого в классе <code class="text-nowrap">Math</code>:</p>
<ul>
    <li><code class="text-nowrap"><span style="color: blue">int</span> toIntExact(<span style="color: blue">long</span> value)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> incrementExact(<span style="color: blue">int</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> incrementExact(<span style="color: blue">long</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> decrementExact(<span style="color: blue">int</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> decrementExact(<span style="color: blue">long</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> negateExact(<span style="color: blue">int</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> negateExact(<span style="color: blue">long</span> a)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> addExact(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> addExact(<span style="color: blue">long</span> x, <span style="color: blue">long</span> y)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> subtractExact(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> subtractExact(<span style="color: blue">long</span> x, <span style="color: blue">long</span> y)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">int</span> multiplyExact(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y)</code></li>
    <li><code class="text-nowrap"><span style="color: blue">long</span> multiplyExact(<span style="color: blue">long</span> x, <span style="color: blue">long</span> y)</code></li>
</ul>
<p>Все эти методы выбрасывают ошибку в случае переполнения, что во многих случаях лучше, чем просто тихое переполнение &ndash; лучше уж упадёт сразу, чем где-нибудь позже с совсем другой ошибкой. Но все ли возможные случаи тут покрыты? Похоже, что нет. Например, я не вижу модуль, который хоть и в очень редком случае, но всё же может переполниться:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Math.abs(Integer.MIN_VALUE)
$1 ==> -2147483648</pre>
<p>Как же так, ведь модуль &ndash; это положительное число? Это так, но дело в том, что 2147483648 просто не влезает в <code class="text-nowrap">int</code>, поэтому этот отдельный случай является исключением. Чтобы вот так по чистой случайности не напороться на такое, можно обезопасить себя методом <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#absExact(int)"><code class="text-nowrap">Math.absExact()</code></a>, который появился в Java 15:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Math.absExact(Integer.MIN_VALUE)
|  <span style="color: red">Exception java.lang.ArithmeticException: Overflow to represent absolute value of Integer.MIN_VALUE</span>
|        <span style="color: red">at Math.absExact (Math.java:1392)</span>
|        <span style="color: red">at (#1:1)</span>

<span style="color: grey">jshell></span> Math.absExact(Long.MIN_VALUE)
|  <span style="color: red">Exception java.lang.ArithmeticException: Overflow to represent absolute value of Long.MIN_VALUE</span>
|        <span style="color: red">at Math.absExact (Math.java:1438)</span>
|        <span style="color: red">at (#2:1)</span></pre>

<p class="pt-2">А знаете ли вы, сколько будет, если найти целое от деления -11 на 3? А остаток? Давайте проверим:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> -11 / 3
$1 ==> -3

<span style="color: grey">jshell></span> -11 % 3
$2 ==> -2</pre>
<p>Ну вроде бы логично, ведь <code class="text-nowrap">-11 = 3 * (-3) - 2</code>. Однако если вы выполните то же самое, например, на Python, то получите совсем иной результат:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">>>></span> -11 / 3
-4
<span style="color: grey">>>></span> -11 % 3
1</pre>
<p>И этот результат тоже по-своему верный: <code class="text-nowrap">-11 = 3 * (-4) + 1</code>. Дело в том, что есть два способа деления целых чисел: с обрезанием в сторону нуля и с обрезанием в сторону минус бесконечности. Java выбрала первый способ, Python &ndash; второй. Ну а что делать, если я хочу в Java делить по-питоновски? Для этого в Java 9 появились методы <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorDiv(int,int)"><code class="text-nowrap">Math.floorDiv()</code></a> и <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorMod(int,int)"><code class="text-nowrap">Math.floorMod()</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Math.floorDiv(-11, 3)
$1 ==> -4

<span style="color: grey">jshell></span> Math.floorMod(-11, 3)
$2 ==> 1</pre>

<p class="pt-2">Также для совсем упоротых математиков в Java 9 появились два метода <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(float,float,float)"><code class="text-nowrap">Math.fma(float, float, float)</code></a> и <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(double,double,double)"><code class="text-nowrap">Math.fma(double, double, double)</code></a>, которые делают то же самое, что и <code class="text-nowrap">a * b + c</code>, но только точнее, потому что используют специальную отдельную инструкцию процессора:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Math.fma(2.99, 5.91, 7.1)
$1 ==> 24.7709

<span style="color: grey">jshell></span> 2.99 * 5.91 + 7.1
$2 ==> 24.770900000000005</pre>

<h4>9. Аннотация <code class="text-nowrap">java.io.Serial</code></h4>
<h5>Появилась в: Java 14</h5>
<p>Используете ли вы стандартную сериализацию в Java? Этот механизм далеко не идеальный и со своими <a href="https://www.youtube.com/watch?v=dOgfWXw9VrI">недостатками</a>, но иногда он может быть очень удобным, потому что позволяет из коробки очень просто сделать сереализацию и десериализацию Java-объектов. Рассмотрим пример:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Point {
    <span style="color: blue">private static final long</span> serialVersionUID = 1L;

    <span style="color: blue">public</span> int x;
    <span style="color: blue">public</span> int y;
}</pre>
<p>Чтобы сконвертировать объект <code class="text-nowrap">Point</code> в массив байтов, нужно написать всего несколько строчек:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">var</span> point = <span style="color: blue">new</span> Point();
point.x = 1;
point.y = 2;

<span style="color: blue">var</span> baos = new ByteArrayOutputStream();
<span style="color: blue">try</span> (<span style="color: blue">var</span> oos = <span style="color: blue">new</span> ObjectOutputStream(baos)) {
    oos.writeObject(point);
}
<span style="color: blue">byte</span>[] bytes = baos.toByteArray();</pre>

<p>Очень удобно. Кстати, вы заметили ошибку в моём коде? Конечно же, я забыл реализовать интерфейс <code class="text-nowrap">Serializable</code>! (Я специально добавил поле <code class="text-nowrap">serialVersionUID</code>, чтобы отвлечь ваше внимание.)</p>
<p>Правильный код будет таким:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Point <span style="color: blue">implements</span> Serializable {
    <span style="color: blue">private static final long</span> serialVersionUID = 1;

    <span style="color: blue">public</span> int x;
    <span style="color: blue">public</span> int y;
}</pre>
<p>И вот это как раз и есть одна из главных проблем сериализации &ndash; при её использовании можно очень легко допустить ошибку: забыть <code class="text-nowrap">Serializable</code>, опечататься в названии поля <code class="text-nowrap">serialVersionUID</code>, забыть сделать его статическим и т.д. Чтобы немного обезопаситься от такого, в Java 14 ввели новую аннотацию <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Serial.html"><code class="text-nowrap">Serial</code></a>.</p>
<p>Этой аннотацией теперь рекомендуется помечать все поля и методы, относящиеся к механизму сериализации:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Point <span style="color: blue">implements</span> Serializable {
    <span style="color: grey">@Serial</span>
    <span style="color: blue">private static final long</span> serialVersionUID = 1;
    ...
}</pre>
<p>Теперь, если будет допущена ошибка, то появится предупреждение:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Point {
    <span style="color: grey">@Serial</span> <span style="color: red">// Annotated member is not a part of the serialization mechanism</span>
    <span style="color: blue">private static final long</span> serialVersionUID = 1;
    ...
}</pre>
<p>Или:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Point <span style="color: blue">implements</span> Serializable {
    <span style="color: grey">@Serial</span> <span style="color: red">// Annotated member is not a part of the serialization mechanism</span>
    <span style="color: blue">private static final int</span> serialVersionUID = 1;
    ...
}</pre>
<p>Аннотация будет делать проверки на всех полях и методах, которые относятся к сериализации: <code class="text-nowrap">serialVersionUID</code>, <code class="text-nowrap">serialPersistentFields</code>, <code class="text-nowrap">writeObject()</code>, <code class="text-nowrap">readObject()</code> и т.д.</p>
<p>К сожалению, на текущий момент предупреждения хорошо работают только в IntelliJ IDEA. В компиляторе JDK 16 проверки выполняются только с включённым флагом <code class="text-nowrap">-Xlint:serial</code> и работают не все. Например, для двух примеров выше <code class="text-nowrap">javac</code> ругается только во втором случае:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">></span> javac -Xlint:serial Point.java
Point.java:6: warning: [serial] serialVersionUID must be of type long in class Point
    private static final int serialVersionUID = 1;
                             ^</pre>
<p>Возможно, это <a href="https://bugs.openjdk.java.net/browse/JDK-8202056">исправят в Java 17</a>.</p>

<h4>10. Методы <code class="text-nowrap">Objects</code>: <code class="text-nowrap">checkIndex()</code>, <code class="text-nowrap">checkFromIndexSize()</code>, <code class="text-nowrap">checkFromToIndex()</code></h4>
<h5>Появились в: Java 9 / Java 16</h5>
<p>Завершим нашу статью несколькими полезными методами для проверки индексов.</p>
<p>Иногда приходится писать функции, принимающие в качестве входных параметров индексы или диапазоны индексов, и чтобы начать использовать эти индексы, нужно сначала убедиться, что они не выходят за границы. То есть приходится писать подобные проверки в начале методов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static void</span> getAt(<span style="color: blue">int</span> index, <span style="color: blue">int</span> length) {
    <span style="color: blue">if</span> (index < 0) {
        <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"index < 0"</span>);
    }
    <span style="color: blue">if</span> (index >= length) {
        <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"index >= length"</span>);
    }
    ...
}</pre>
<p>Если подобных функций в проекте становится уже несколько, то чтобы не повторяться, такие проверки удобнее вынести в отдельные утилитные методы:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public final class</span> PreconditionUtils {
    <span style="color: blue">public static void</span> checkIndex(<span style="color: blue">int</span> index, <span style="color: blue">int</span> length) {
        <span style="color: blue">if</span> (index < 0) {
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"index < 0"</span>);
        }
        <span style="color: blue">if</span> (index >= length) {
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"index >= length"</span>);
        }
    }
}</pre>

<p>Но с Java 9 теперь это больше не нужно, потому что в классе <code class="text-nowrap">Objects</code> теперь есть стандартные методы проверок индексов.</p>
<p>Метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkIndex(int,int)"><code class="text-nowrap">Objects.checkIndex()</code></a> проверяет, что индекс находится в диапазоне <code class="text-nowrap">[0, length)</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Objects.checkIndex(-3, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Index -3 out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)</span>
|        <span style="color: red">at Preconditions.checkIndex (Preconditions.java:248)</span>
|        <span style="color: red">at Objects.checkIndex (Objects.java:372)</span>
|        <span style="color: red">at (#1:1)</span>

<span style="color: grey">jshell></span> Objects.checkIndex(10, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Index 10 out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)</span>
|        <span style="color: red">at Preconditions.checkIndex (Preconditions.java:248)</span>
|        <span style="color: red">at Objects.checkIndex (Objects.java:372)</span>
|        <span style="color: red">at (#2:1)</span></pre>

<p>Метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(int,int,int)"><code class="text-nowrap">Objects.checkFromIndexSize()</code></a> проверяет, что диапазон <code class="text-nowrap">[fromIndex, fromIndex + size)</code> находится в диапазоне <code class="text-nowrap">[0, length)</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Objects.checkFromIndexSize(3, 8, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + 8) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)</span>
|        <span style="color: red">at Preconditions.checkFromIndexSize (Preconditions.java:343)</span>
|        <span style="color: red">at Objects.checkFromIndexSize (Objects.java:424)</span>
|        <span style="color: red">at (#3:1)</span>

<span style="color: grey">jshell></span> Objects.checkFromIndexSize(-2, 8, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [-2, -2 + 8) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)</span>
|        <span style="color: red">at Preconditions.checkFromIndexSize (Preconditions.java:343)</span>
|        <span style="color: red">at Objects.checkFromIndexSize (Objects.java:424)</span>
|        <span style="color: red">at (#4:1)</span>

<span style="color: grey">jshell></span> Objects.checkFromIndexSize(3, -4, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + -4) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)</span>
|        <span style="color: red">at Preconditions.checkFromIndexSize (Preconditions.java:343)</span>
|        <span style="color: red">at Objects.checkFromIndexSize (Objects.java:424)</span>
|        <span style="color: red">at (#5:1)</span></pre>

<p>Наконец, метод <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromToIndex(int,int,int)"><code class="text-nowrap">Objects.checkFromToIndex()</code></a> проверяет, что диапазон <code class="text-nowrap">[fromIndex, toIndex)</code> находится в диапазоне <code class="text-nowrap">[0, length)</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Objects.checkFromToIndex(3, 11, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [3, 11) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)</span>
|        <span style="color: red">at Preconditions.checkFromToIndex (Preconditions.java:295)</span>
|        <span style="color: red">at Objects.checkFromToIndex (Objects.java:398)</span>
|        <span style="color: red">at (#6:1)</span>

<span style="color: grey">jshell></span> Objects.checkFromToIndex(-4, 8, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [-4, 8) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)</span>
|        <span style="color: red">at Preconditions.checkFromToIndex (Preconditions.java:295)</span>
|        <span style="color: red">at Objects.checkFromToIndex (Objects.java:398)</span>
|        <span style="color: red">at (#7:1)</span>

<span style="color: grey">jshell></span> Objects.checkFromToIndex(6, 4, 10)
|  <span style="color: red">Exception java.lang.IndexOutOfBoundsException: Range [6, 4) out of bounds for length 10</span>
|        <span style="color: red">at Preconditions.outOfBounds (Preconditions.java:64)</span>
|        <span style="color: red">at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)</span>
|        <span style="color: red">at Preconditions.checkFromToIndex (Preconditions.java:295)</span>
|        <span style="color: red">at Objects.checkFromToIndex (Objects.java:398)</span>
|        <span style="color: red">at (#8:1)</span></pre>

<p>Кроме того, в Java 16 появились перегрузки этих функций для <code class="text-nowrap">long</code>:</p>
<ul>
    <li><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkIndex(long,long)"><code class="text-nowrap">checkIndex(long, long)</code></a></li>
    <li><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(long,long,long)"><code class="text-nowrap">checkFromIndexSize(long, long, long)</code></a></li>
    <li><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromToIndex(long,long,long)"><code class="text-nowrap">checkFromToIndex(long, long, long)</code></a></li>
</ul>

<h4>Заключение</h4>
<p>Сегодня я рассказал про 10 интересных API, некоторые из которых появились в буквально только что <a href="java_16.html">вышедшей Java 16</a>, а некоторые уже присутствуют довольно давно ещё с 9-й версии. Надеюсь, что после прочтения данной статьи вы стали более заинтересованными в миграции на последнюю версию Java. Помните, что в новых версиях Java появляются не только новые возможности, но и изменения, ломающие обратную совместимость (<a href="https://openjdk.java.net/jeps/260">1</a>, <a href="https://openjdk.java.net/jeps/322">2</a>, <a href="https://openjdk.java.net/jeps/320">3</a>, <a href="https://openjdk.java.net/jeps/372">4</a>, <a href="https://openjdk.java.net/jeps/396">5</a>, <a href="https://openjdk.java.net/jeps/363">6</a>, <a href="http://openjdk.java.net/jeps/367">7</a>, <a href="http://openjdk.java.net/jeps/403">8</a>). И чем больше вы тянете с переходом с Java 8 на последнюю версию, тем сложнее вам будет осуществить этот переход.</p>
<p>Продолжение следует...</p>
</article>
  <p class="pt-4 font-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2021" role="button" aria-expanded="true" aria-controls="year2021">2021</a>
  <ul class="collapse show" id="year2021">
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li>API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
</div>
      </div>
    </div>
    <div class="container d-md-flex flex-row">
      <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
      <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2021</div>
      <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.ru/feed.xml">Feed</a></div>
    </div>
    <script src="jquery-3.3.1.slim.min.js"></script>
    <script src="popper.min.js"></script>
    <script src="bootstrap.min.js"></script>
  </body>
</html>
