<!doctype html>
<html lang="ru">
  <head>
    <title>Вышла Java 21</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Вышла Java 21">
    <meta property="og:description" content="Вышла общедоступная версия Java 21. В этот релиз попало около 2500 закрытых задач и 15 JEP'ов. Release Notes можно посмотреть здесь. Изменения API &ndash; здесь&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2023-09-19">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="Вышла Java 21">
    <meta name="twitter:description" content="Вышла общедоступная версия Java 21. В этот релиз попало около 2500 закрытых задач и 15 JEP'ов. Release Notes можно посмотреть здесь. Изменения API &ndash; здесь&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.ru/java_21.png">
    <meta property="og:image:width" content="1480">
    <meta property="og:image:height" content="774">
    <meta name="twitter:image" content="https://minijug.ru/java_21.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Вышла Java 21</h3>
<p class="text-secondary"><time datetime="2023-09-19">19 сентября, 2023</time></p>
<article>
<p>Вышла общедоступная версия <a href="https://openjdk.org/projects/jdk/21/">Java 21</a>. В этот релиз попало около <a href="https://builds.shipilev.net/backports-monitor/release-notes-21.html">2500 закрытых задач и 15 JEP'ов</a>. Release Notes можно посмотреть <a href="http://jdk.java.net/21/release-notes">здесь</a>. Изменения API &ndash; <a href="https://javaalmanac.io/jdk/21/apidiff/20/">здесь</a>.</p>
<p>Java 21 является LTS-релизом, а значит у него будут выходить обновления <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">как минимум 5 лет</a> с момента выхода.</p>
<!-- cut -->
<p>Скачать JDK 21 можно по этим ссылкам:</p>
<ul>
  <li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a> (лицензия <a href="https://www.oracle.com/downloads/licenses/no-fee-license.html">NFTC</a>)</li>
  <li><a href="http://jdk.java.net/21/">OpenJDK</a> (лицензия <a href="https://openjdk.org/legal/gplv2+ce.html">GPLv2 with Classpath Exception</a>)</li>
</ul>

<p class="pt-1">Вот список JEP'ов, которые попали в Java 21.</p>
<h4>Язык</h4>
<h5><a href="https://openjdk.org/jeps/441">Pattern Matching for <code class="text-nowrap">switch</code> (JEP 441)</a></h5>
<p>Паттерн-матчинг для <code class="text-nowrap">switch</code> наконец-то был финализирован и стал стабильной конструкцией языка. Напомним, что он появился в <a href="java_17.html">Java 17</a> и был в состоянии <a href="https://openjdk.org/jeps/12">preview</a> четыре релиза: <a href="https://openjdk.org/jeps/406">17</a>, <a href="https://openjdk.org/jeps/420">18</a>, <a href="https://openjdk.org/jeps/427">19</a> и <a href="https://openjdk.org/jeps/433">20</a>.</p>
<p>Новый паттерн-матчинг существенно расширяет возможности оператора <code class="text-nowrap">switch</code>. Начиная с Java 1.0, <code class="text-nowrap">switch</code> поддерживал только сравнение с примитивными константами. Позже список типов был расширен (Java 5 &ndash; перечисления, Java 7 &ndash; строки), но в ветках <code class="text-nowrap">case</code> всё ещё могли быть только константы.</p>
<p>Теперь же <code class="text-nowrap">switch</code> поддерживает в ветках <code class="text-nowrap">case</code> так называемые <i>паттерны</i>:</p>
<pre class="border p-lg-2 p-1">Object obj = …
<span style="color: blue">return switch</span> (obj) {
    <span style="color: blue">case</span> Integer i -> String.format(<span style="color: darkred">"int %d"</span>, i);
    <span style="color: blue">case</span> Long l -> String.format(<span style="color: darkred">"long %d"</span>, l);
    <span style="color: blue">case</span> Double d -> String.format(<span style="color: darkred">"double %f"</span>, d);
    <span style="color: blue">case</span> String s -> String.format(<span style="color: darkred">"String %s"</span>, s);
    <span style="color: blue">default</span> -> obj.toString();
};</pre>
<p>Паттерны могут снабжаться условиями с использованием нового ключевого слова <code class="text-nowrap">when</code>:</p>
<pre class="border p-lg-2 p-1">Object obj = …
<span style="color: blue">return switch</span> (obj) {
    <span style="color: blue">case</span> Integer i <span style="color: blue">when</span> i > 0 -> String.format(<span style="color: darkred">"positive int %d"</span>, i);
    <span style="color: blue">case</span> Integer i -> String.format(<span style="color: darkred">"int %d"</span>, i);
    <span style="color: blue">case</span> String s -> String.format(<span style="color: darkred">"String %s"</span>, s);
    <span style="color: blue">default</span> -> obj.toString();
};</pre>
<p>Также добавлена поддержка матчинга <code class="text-nowrap">null</code>. Сделать это можно с помощью явной отдельной ветки <code class="text-nowrap">case null</code>:</p>
<pre class="border p-lg-2 p-1">Object obj = …
<span style="color: blue">switch</span> (obj) {
    <span style="color: blue">case null</span> -> System.out.println(<span style="color: darkred">"Null"</span>);
    <span style="color: blue">case</span> String s -> System.out.println(<span style="color: darkred">"String: "</span> + s);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"Other"</span>);
}</pre>
<p>Если ветка <code class="text-nowrap">case null</code> отсутствует, то <code class="text-nowrap">switch</code> с переданным в него <code class="text-nowrap">null</code> всегда будет выбрасывать <code class="text-nowrap">NullPointerException</code> (даже если есть ветка <code class="text-nowrap">default</code>):</p>
<pre class="border p-lg-2 p-1">Object obj = <span style="color: blue">null</span>;
<span style="color: blue">switch</span> (obj) { <span style="color: red">// NullPointerException</span>
    <span style="color: blue">case</span> String s -> System.out.println(<span style="color: darkred">"String: "</span> + s);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"Other"</span>);
}</pre>
<p>Ветки <code class="text-nowrap">null</code> и <code class="text-nowrap">default</code> можно объединять друг с другом:</p>
<pre class="border p-lg-2 p-1">String str = …
<span style="color: blue">switch</span> (str) {
    <span style="color: blue">case</span> <span style="color: darkred">"Foo"</span>, <span style="color: darkred">"Bar"</span> -> System.out.println(<span style="color: darkred">"Foo or Bar"</span>);
    <span style="color: blue">case null, default</span> -> System.out.println(<span style="color: darkred">"Null or other"</span>);
}</pre>

<p class="mt-2">Новый паттерн-матчинг обладает рядом ограничений.</p>
<p>Во-первых, все <code class="text-nowrap">switch</code> (кроме тех, что были корректными до Java 21) должны быть <i>исчерпывающими</i>. Т.е. в ветках должны покрываться все возможные случаи:</p>
<pre class="border p-lg-2 p-1">Object obj = …
<span style="color: blue">switch</span> (obj) { <span style="color: red">// error: the switch statement does not cover all possible input values</span>
    <span style="color: blue">case</span> String s -> System.out.println(s.length());
    <span style="color: blue">case</span> Integer i -> System.out.println(i);
};</pre>
<p>Пример выше можно исправить, добавив ветку <code class="text-nowrap">Object o</code> или <code class="text-nowrap">default</code>.</p>
<p class="mt-2">Во-вторых, все ветки <code class="text-nowrap">case</code> должны располагаться в таком порядке, что ни перед одной веткой нет <i>доминирующей</i> ветки:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">return switch</span> (obj) {
    <span style="color: blue">case</span> CharSequence cs ->
        <span style="color: darkred">"sequence of length "</span> + cs.length();
    <span style="color: blue">case</span> String s -> <span style="color: red">// error: this case label is dominated by a preceding case label</span>
        <span style="color: darkred">"string of length "</span> + s.length();
    <span style="color: blue">default</span> -> <span style="color: darkred">"other"</span>;
 };</pre>
<p>Так как <code class="text-nowrap">CharSequence</code> это более широкий тип, чем <code class="text-nowrap">String</code>, то его ветка должна быть расположена ниже.</p>

<p class="mt-2">В-третьих, несколько паттернов в одной ветке работать не будут:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">return switch</span> (obj) {
    <span style="color: blue">case</span> String s, Integer i -> <span style="color: darkred">"string or integer"</span>; <span style="color: red">// error: illegal fall-through from a pattern</span>
    <span style="color: blue">default</span> -> <span style="color: darkred">"other"</span>;
 };</pre>
<p>Т.е. сделать тест по нескольким типам в одной ветке пока что нельзя (хотя грамматика языка это позволяет). Это можно обойти, только включив режим preview и заменив <code class="text-nowrap">s</code> и <code class="text-nowrap">i</code> на символы подчёркивания (см. JEP про безымянные переменные ниже).</p>

<p class="mt-2">В целом новый паттерн-матчинг значительно увеличивает выразительность языка. Особенно хорошо он сочетается с записями. Паттерны записей мы рассмотрим отдельно, поскольку про них есть свой собственный JEP (см. следующий раздел).</p>

<h5><a href="https://openjdk.org/jeps/440">Record Patterns (JEP 440)</a></h5>
<p>Отдельным видом паттернов являются <i>паттерны записей</i>. Они появились в <a href="https://openjdk.org/jeps/405">Java 19</a> в режиме preview и стали стабильными в Java 21.</p>
<p>Паттерны записей позволяют осуществлять деконструкцию значений записей чрезвычайно компактно:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) {}

<span style="color: blue">static void</span> printSum(Object obj) {
    <span style="color: blue">if</span> (obj <span style="color: blue">instanceof</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y)) {
        System.out.println(x + y);
    }
}</pre>

<p>Или через оператор <code class="text-nowrap">switch</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">static void</span> printSum(Object obj) {
    <span style="color: blue">switch</span> (obj) {
        <span style="color: blue">case</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) -> System.out.println(x + y);
        <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"Not a point"</span>);
    }
}</pre>

<p>Особая мощь паттернов записей состоит в том, что они могут быть вложенными:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) {}
<span style="color: blue">enum</span> Color { RED, GREEN, BLUE }
<span style="color: blue">record</span> ColoredPoint(Point p, Color c) {}
<span style="color: blue">record</span> Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}

<span style="color: blue">static void</span> printColorOfUpperLeftPoint(Rectangle r) {
    <span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr)) {
        System.out.println(c);
    }
}</pre>

<p>Используя <code class="text-nowrap">var</code>, можно сократить код ещё сильнее:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">static void</span> printColorOfUpperLeftPoint(Rectangle r) {
    <span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> Rectangle(ColoredPoint(<span style="color: blue">var</span> p, <span style="color: blue">var</span> c), <span style="color: blue">var</span> lr)) {
        System.out.println(c);
    }
}</pre>

<p>Паттерны записей отлично сочетаются с паттернами по типу:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Box(Object obj) {}

<span style="color: blue">static void</span> test(Box box) {
    <span style="color: blue">switch</span> (box) {
        <span style="color: blue">case</span> Box(String s) -> System.out.println(<span style="color: darkred">"string: "</span> + s);
        <span style="color: blue">case</span> Box(Object o) -> System.out.println(<span style="color: darkred">"other: "</span> + o);
    }
}</pre>

<p>Поддерживается вывод типов записей-дженериков:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Box&lt;T>(T t) {}

<span style="color: blue">static void</span> test(Box&lt;Box&lt;String>> box) {
    <span style="color: blue">if</span> (box <span style="color: blue">instanceof</span> Box(Box(<span style="color: blue">var</span> s))) { <span style="color: green">// Infers Box&lt;Box&lt;String>>(Box&lt;String>(String s))</span>
        System.out.println(<span style="color: darkred">"String "</span> + s);
    }
}</pre>

<p class="mt-2">К сожалению, паттерны записей могут использоваться только в <code class="text-nowrap">instanceof</code> и <code class="text-nowrap">switch</code>, но не могут использоваться сами по себе:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">static void</span> usePoint(Point p) {
    Point(<span style="color: blue">var</span> x, <span style="color: blue">var</span> y) = p; <span style="color: red">// Не сработает</span>
    <span style="color: green">// Use x and y</span>
}</pre>

<p>Будем надеяться, что когда-нибудь добавят и такую возможность.</p>

<h5><a href="https://openjdk.org/jeps/430">String Templates (Preview) (JEP 430)</a></h5>
<p>Строковые шаблоны &ndash; новая синтаксическая возможность, позволяющая встраивать в строки выражения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> x = 10;
<span style="color: blue">int</span> y = 20;
String str = STR.<span style="color: darkred">"</span>\{x} <span style="color: darkred">plus</span> \{y} <span style="color: darkred">equals</span> \{x + y}<span style="color: darkred">"</span>;
<span style="color: green">// В str будет лежать "10 + 20 equals 30"</span></pre>
<p>Таким образом, в Java появилась строковая интерполяция, которая уже давно есть во многих других известных языках программирования. Однако в Java она работает только в режиме <a href="https://openjdk.org/jeps/12">preview</a>, т.е. использовать в Java 21 её можно только с включенным флагом <code class="text-nowrap">--enable-preview</code>.</p>
<p>Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html"><code class="text-nowrap">java.lang.StringTemplate</code></a>, а затем <i>процессор</i>, реализующий <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html"><code class="text-nowrap">java.lang.StringTemplate.Processor</code></a>, конвертирует этот объект в строку (или объект другого класса). В примере выше <code class="text-nowrap">STR."…"</code> есть ничто иное, как сокращённый вариант следующего кода:</p>
<pre class="border p-lg-2 p-1">StringTemplate template = RAW.<span style="color: darkred">"</span>\{x} <span style="color: darkred">plus</span> \{y} <span style="color: darkred">equals</span> \{x + y}<span style="color: darkred">"</span>;
String str = STR.process(template);</pre>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#STR"><code class="text-nowrap">STR</code></a> &ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. <code class="text-nowrap">STR</code> неявно импортируется в любой исходный файл, поэтому его можно использовать без <code class="text-nowrap">import</code>.</p>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#RAW"><code class="text-nowrap">RAW</code></a> &ndash; это процессор, который ничего не делает со <code class="text-nowrap">StringTemplate</code> и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.</p>
<p>Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/FormatProcessor.html#FMT"><code class="text-nowrap">FMT</code></a> поддерживает форматирование с использованием спецификаторов, определённых в <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html"><code class="text-nowrap">java.util.Formatter</code></a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">double</span> length = 46;
System.out.println(FMT.<span style="color: darkred">"The length is %.2f</span>\{length} <span style="color: darkred">cm"</span>);
<span style="color: green">// The length is 46.00 cm</span></pre>
<p>Процессоры необязательно должны возвращать <code class="text-nowrap">String</code>. Вот общая сигнатура метода <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"><code class="text-nowrap">process()</code></a> интерфейса <code class="text-nowrap">Processor</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public interface</span> Processor&lt;R, E <span style="color: blue">extends</span> Throwable> {
    R process(StringTemplate stringTemplate) <span style="color: blue">throws</span> E;
}</pre>
<p>Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор <code class="text-nowrap">JSON</code> будет создавать напрямую объекты JSON (без промежуточного объекта <code class="text-nowrap">String</code>) и при этом поддерживать экранирование кавычек:</p>
<pre class="border p-lg-2 p-1">JSONObject doc = JSON.<span style="color: darkred">"""</span>
    <span style="color: darkred">{</span>
        <span style="color: darkred">"name":    "</span>\{name}<span style="color: darkred">",</span>
        <span style="color: darkred">"phone":   "</span>\{phone}<span style="color: darkred">",</span>
        <span style="color: darkred">"address": "</span>\{address}<span style="color: darkred">"</span>
    };
    <span style="color: darkred">"""</span>;</pre>
<p>Если в <code class="text-nowrap">name</code>, <code class="text-nowrap">phone</code> или <code class="text-nowrap">address</code> будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит <code class="text-nowrap">&quot;</code> на <code class="text-nowrap">\&quot;</code>.</p>
<p>Или, например, процессор <code class="text-nowrap">SQL</code> будет создавать PreparedStatement'ы, защищая от атак SQL Injection:</p>
<pre class="border p-lg-2 p-1">PreparedStatement ps = SQL.<span style="color: darkred">"SELECT * FROM Person p WHERE p.name = </span>\{name}<span style="color: darkred">"</span>;</pre>
<p>Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.</p>

<h5><a href="https://openjdk.org/jeps/443">Unnamed Patterns and Variables (Preview) (JEP 443)</a></h5>
<p>Ещё одно новшество в режиме preview: теперь можно объявлять так называемые безымянные переменные и паттерны. Делается это с помощью символа подчеркивания (<code class="text-nowrap">_</code>). Это часто необходимо, когда переменная или паттерн не используются:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> acc = 0;
<span style="color: blue">for</span> (Order _ : orders) {
    <span style="color: blue">if</span> (acc < LIMIT) {
        … acc++ …
    }
}</pre>
<p>В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому, чтобы не придумывать этой переменной название, было использовано подчеркивание вместо имени.</p>
<p>Довольно частый пример нужности безымянных переменных &ndash; блок <code class="text-nowrap">catch</code> с неиспользуемым исключением:</p>
<pre class="border p-lg-2 p-1">String s = …
try {
    <span style="color: blue">int</span> i = Integer.parseInt(s);
    …
} <span style="color: blue">catch</span> (NumberFormatException _) {
    System.out.println(<span style="color: darkred">"Bad number: "</span> + s);
}</pre>
<p>Полный список случаев, в которых можно использовать безымянные переменные:</p>
<ul>
  <li>Локальная переменная в блоке,</li>
  <li>Объявление ресурса в <code class="text-nowrap">try-with-resources</code>,</li>
  <li>Заголовок <code class="text-nowrap">for</code> statement,</li>
  <li>Заголовок улучшенного цикла <code class="text-nowrap">for</code>,</li>
  <li>Исключение в блоке <code class="text-nowrap">catch</code>,</li>
  <li>Параметр лямбда-выражения,</li>
  <li>Переменная паттерна (см. ниже).</li>
</ul>
<p>Внимательный читатель заметит, что в списке выше отсутствуют параметры методов. Действительно, они не могут быть безымянными, и для любых методов (как интерфейсов, так и классов) по-прежнему всегда нужно указывать имена параметров.</p>

<p class="mt-2">Символы подчёркивания также можно использовать для указания <i>безымянных паттернов</i>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> ColoredPoint(Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y), _)) {
    <span style="color: green">// Используются только x и y</span>
}</pre>
<p>Здесь разработчику понадобились только координаты точки, но не её цвет. Без безымянного паттерна ему пришлось бы объявлять неиспользуемую переменную типа <code class="text-nowrap">Color</code> и придумывать ей имя:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> ColoredPoint(Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y), Color c)) { <span style="color: orange">// Warning: unused c</span>
    <span style="color: green">// Используются только x и y</span>
}</pre>
<p>Такой код менее читабелен и хуже позволяет сфокусироваться на главном (координатах). Кроме того, некоторые IDE подсветили бы неиспользуемую переменную <code class="text-nowrap">c</code>, что ещё одно дополнительное неудобство.</p>
<p>Есть также возможность объявлять <i>безымянные переменные паттернов</i>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">if</span> (r <span style="color: blue">instanceof</span> ColoredPoint(Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y), Color _)) {
    …
}</pre>
<p>Безымянные паттерны и переменные паттернов прекрасно сочетаются и со <code class="text-nowrap">switch</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">switch</span> (box) {
    <span style="color: blue">case</span> Box(RedBall _), Box(BlueBall _) -> processBox(box);
    <span style="color: blue">case</span> Box(GreenBall _)                -> stopProcessing();
    <span style="color: blue">case</span> Box(_)                          -> pickAnotherBox();
}</pre>
<p>В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.</p>

<h5><a href="https://openjdk.org/jeps/445">Unnamed Classes and Instance Main Methods (Preview) (JEP 445)</a></h5>
<p>Теперь в режиме preview можно запускать программы с методами <code class="text-nowrap">main()</code>, которые не являются <code class="text-nowrap">public static</code> и у которых нет параметра <code class="text-nowrap">String[] args</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> HelloWorld {
    <span style="color: blue">void</span> main() {
        System.out.println(<span style="color: darkred">"Hello, World!"</span>);
    }
}</pre>
<p>В таком случае JVM сама создаст экземпляр класса (у него должен быть не-<code class="text-nowrap">private</code> конструктор без параметров) и вызовет у него метод <code class="text-nowrap">main()</code>.</p>
<p>Протокол запуска будет выбирать метод <code class="text-nowrap">main()</code> согласно следующему приоритету:</p>
<ol>
    <li><code class="text-nowrap">static void main(String[] args)</code></li>
    <li><code class="text-nowrap">static void main()</code></li>
    <li><code class="text-nowrap">void main(String[] args)</code></li>
    <li><code class="text-nowrap">void main()</code></li>
</ol>
<p class="mt-2">Кроме того, можно писать программы и без объявления класса вовсе:</p>
<pre class="border p-lg-2 p-1">String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}</pre>
<p>В таком случае будет создан неявный безымянный класс (не путать с анонимным классом), которому будут принадлежать метод <code class="text-nowrap">main()</code> и другие верхнеуровневые объявления в файле:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// class &lt;some name> { ← неявно</span>
String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    System.out.println(greeting);
}
<span style="color: green">// }</span></pre>
<p>Безымянный класс является <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isSynthetic()">синтетическим</a> и <code class="text-nowrap">final</code>. Его <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getSimpleName()">simple name</a> является пустой строкой:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">void</span> main() {
    System.out.println(getClass().isUnnamed()); <span style="color: green">// true</span>
    System.out.println(getClass().isSynthetic()); <span style="color: green">// true</span>
    System.out.println(getClass().getSimpleName()); <span style="color: green">// ""</span>
    System.out.println(getClass().getCanonicalName()); <span style="color: green">// null</span>
}</pre>
<p>При этом <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getName()">имя</a> класса совпадает с именем файла, но такое поведение не гарантируется.
<p class="mt-2">Такое упрощение запуска Java-программ было сделано с двумя целями:</p>
<ol>
    <li>Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).</li>
    <li>Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.</li>
</ol>

<h4>API</h4>
<h5><a href="https://openjdk.org/jeps/444">Virtual Threads (JEP 444)</a></h5>
<p>Виртуальные потоки, которые много лет разрабатывались в рамках проекта <a href="https://openjdk.org/projects/loom/">Loom</a> и появились в <a href="https://openjdk.org/jeps/425">Java 19</a> в режиме preview, теперь наконец-то стали стабильными.</p>
<p>Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &ndash; один поток" (или "одна задача &ndash; один поток") и не прибегать к более сложным асинхронному или реактивному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html"><code class="text-nowrap">java.lang.Thread</code></a> и практически полностью совместимы с классическими потоками: поддерживают стек-трейсы, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#interrupt()"><code class="text-nowrap">interrupt()</code></a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a> и т.д.</p>
<p>Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент выполняется виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"><code class="text-nowrap">ForkJoinPool</code></a>. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и дешевизна виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: <code class="text-nowrap">synchronized</code> блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать <code class="text-nowrap">synchronized</code> блоков и операции JNI, которые выполняются часто или занимают длительное время.</p>
<p>Несмотря на привлекательность виртуальных потоков, вовсе необязательно предпочитать только их и всегда избегать классических потоков. Например, для задач, интенсивно и долго использующих CPU, лучше подойдут обычные потоки. Или если нужен поток, не являющийся <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)">демоном</a>, то также придётся использовать обычный поток, потому что виртуальный поток всегда является демоном.</p>
<p>Для создания виртуальных потоков и работы с ними появилось следующее API:</p>
<ul>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html"><code class="text-nowrap">Thread.Builder</code></a> &ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова <code class="text-nowrap">Thread.ofVirtual().name("name").unstarted(runnable)</code>.</li>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"><code class="text-nowrap">Thread.startVirtualThread(Runnable)</code></a> &ndash; создаёт и сразу же запускает виртуальный поток.</li>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#isVirtual()"><code class="text-nowrap">Thread.isVirtual()</code></a> &ndash; проверяет, является ли поток виртуальным.</li>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"><code class="text-nowrap">Executors.newVirtualThreadPerTaskExecutor()</code></a> &ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.</li>
</ul>
<p>Для виртуальных потоков также добавилась поддержка в инструментарии JDK (дебаггер, JVM TI, Java Flight Recorder).</p>

<h5><a href="https://openjdk.org/jeps/431">Sequenced Collections (JEP 431)</a></h5>
<p>Появились три новых интерфейса <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"><code class="text-nowrap">SequencedCollection</code></a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"><code class="text-nowrap">SequencedSet</code></a> и <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"><code class="text-nowrap">SequencedMap</code></a>.</p>
<p><code class="text-nowrap">SequencedCollection</code> является наследником <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html"><code class="text-nowrap">Collection</code></a> и представляет собой коллекцию с установленным порядком элементов. Такими коллекциями являются <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashSet.html"><code class="text-nowrap">LinkedHashSet</code></a> и все реализации <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html"><code class="text-nowrap">List</code></a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedSet.html"><code class="text-nowrap">SortedSet</code></a> и <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Deque.html"><code class="text-nowrap">Deque</code></a>. У этих коллекций есть общее свойство последовательности элементов, но до Java 21 их общим родителем был <code class="text-nowrap">Collection</code>, который является слишком общим интерфейсом и не содержит многих методов, характерных для последовательностей (<code class="text-nowrap">getFirst()</code>, <code class="text-nowrap">getLast()</code>, <code class="text-nowrap">addFirst()</code>, <code class="text-nowrap">addLast()</code>, <code class="text-nowrap">reversed()</code> и т.д). При этом у самих вышеописанных коллекций такие методы были несогласованны друг с другом (например, <code class="text-nowrap">list.get(0)</code> против <code class="text-nowrap">sortedSet.first()</code> против <code class="text-nowrap">deque.getFirst()</code>), либо вовсе отсутствовали (например, <code class="text-nowrap">linkedHashSet.getLast()</code>).</p>
<p><code class="text-nowrap">SequencedCollection</code> закрыла эту дыру в иерархии и привела API к общему знаменателю:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">interface</span> SequencedCollection&lt;E> <span style="color: blue">extends</span> Collection&lt;E> {
    E getFirst();
    E getLast();
    <span style="color: blue">void</span> addFirst(E);
    <span style="color: blue">void</span> addLast(E);
    E removeFirst();
    E removeLast();
    SequencedCollection&lt;E> reversed();
}</pre>
<p>Теперь больше не надо думать, как для конкретной коллекции получить последний элемент, потому что есть универсальный метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#getLast()"><code class="text-nowrap">getLast()</code></a>, который есть и у <code class="text-nowrap">ArrayList</code>, и у <code class="text-nowrap">TreeSet</code>, и у <code class="text-nowrap">ArrayDeque</code>.</p>
<p>Особый интерес представляет метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#reversed()"><code class="text-nowrap">reversed()</code></a>, который возвращает view коллекции с обратным порядком. Это делает обратный обход коллекции гораздо более лаконичным:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">var</span> linkedList = new LinkedList<>(…);

<span style="color: green">// До Java 21</span>
<span style="color: blue">for</span> (<span style="color: blue">var</span> it = linkedList.descendingIterator(); it.hasNext();) {
    <span style="color: blue">var</span> e = it.next();
    …
}

<span style="color: green">// С Java 21</span>
<span style="color: blue">for</span> (<span style="color: blue">var</span> element : linkedList.reversed()) {
    …
}</pre>
<p>Для <code class="text-nowrap">LinkedHashSet</code> эффективного способа обратного обхода и вовсе не было.</p>
<p class="mt-2">Для последовательных множеств ввели интерфейс <code class="text-nowrap">SequencedSet</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">interface</span> SequencedSet&lt;E> <span style="color: blue">extends</span> Set&lt;E>, SequencedCollection&lt;E> {
    SequencedSet&lt;E> reversed();
}</pre>
<p>Его реализациями являются <code class="text-nowrap">LinkedHashSet</code> и наследники <code class="text-nowrap">SortedSet</code>.</p>
<p class="mt-2">Также ввели интерфейс <code class="text-nowrap">SequencedMap</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">interface</span> SequencedMap&lt;K,V> <span style="color: blue">extends</span> Map&lt;K,V> {
    Entry&lt;K, V> firstEntry();
    Entry&lt;K, V> lastEntry();
    Entry&lt;K, V> pollFirstEntry();
    Entry&lt;K, V> pollLastEntry();
    V putFirst(K, V);
    V putLast(K, V);
    SequencedSet&lt;K> sequencedKeySet();
    SequencedCollection&lt;V> sequencedValues();
    SequencedSet&lt;Entry&lt;K,V>> sequencedEntrySet();
    SequencedMap&lt;K,V> reversed();
}</pre>
<p>Его реализациями являются <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashMap.html"><code class="text-nowrap">LinkedHashMap</code></a> и наследники <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedMap.html"><code class="text-nowrap">SortedMap</code></a>.</p>

<h5><a href="https://openjdk.org/jeps/446">Scoped Values (Preview) (JEP 446)</a></h5>
<p>Scoped Values, которые появились в <a href="https://openjdk.org/jeps/429">Java 20</a> в <a href="https://openjdk.org/jeps/11">инкубационном статусе</a>, теперь стали Preview API.</p>
<p>Новый класс <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html"><code class="text-nowrap">ScopedValue</code></a> позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a>.</p>
<p>Классы <code class="text-nowrap">ThreadLocal</code> и <code class="text-nowrap">ScopedValue</code> похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае <code class="text-nowrap">ThreadLocal</code> для этого вызывается метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"><code class="text-nowrap">set()</code></a>, который кладёт значение переменной для данного потока, а потом метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#get()"><code class="text-nowrap">get()</code></a> вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:</p>
<ul>
    <li>Неконтролируемая мутабельность (<code class="text-nowrap">set()</code> можно вызвать когда угодно и откуда угодно).</li>
    <li>Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван <code class="text-nowrap">ThreadLocal.remove()</code>, но про него часто забывают).</li>
    <li>Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).</li>
</ul>
<p>Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.</p>
<p><code class="text-nowrap">ScopedValue</code> лишён вышеперечисленных недостатков. В отличие от <code class="text-nowrap">ThreadLocal</code>, <code class="text-nowrap">ScopedValue</code> не имеет метода <code class="text-nowrap">set()</code>. Значение ассоциируется с объектом <code class="text-nowrap">ScopedValue</code> путём вызова другого метода <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"><code class="text-nowrap">where()</code></a>. Далее вызывается метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"><code class="text-nowrap">run()</code></a>, на протяжении которого это значение можно получить (через метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#get()"><code class="text-nowrap">get()</code></a>), но нельзя изменить. Как только исполнение метода <code class="text-nowrap">run()</code> заканчивается, значение отвязывается от объекта <code class="text-nowrap">ScopedValue</code>. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.</p>
<p>Пример использования <code class="text-nowrap">ScopedValue</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static final</span> ScopedValue&lt;FrameworkContext> CONTEXT = ScopedValue.newInstance();

<span style="color: blue">void</span> serve(Request request, Response response) {
    <span style="color: blue">var</span> context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -> Application.handle(request, response));
}

<span style="color: blue">public</span> PersistedObject readKey(String key) {
    <span style="color: blue">var</span> context = CONTEXT.get();
    <span style="color: blue">var</span> db = getDBConnection(context);
    db.readKey(key);
}</pre>
<p>В целом <code class="text-nowrap">ScopedValue</code> является предпочтительной заменой <code class="text-nowrap">ThreadLocal</code>, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда неприменим для некоторых задач, и для них <code class="text-nowrap">ThreadLocal</code> может быть единственно возможным решением.</p>

<h5><a href="https://openjdk.org/jeps/453">Structured Concurrency (Preview) (JEP 453)</a></h5>
<p>Ещё одно API, которое ранее было в инкубационном статусе (Java <a href="https://openjdk.org/jeps/428">19</a> и <a href="https://openjdk.org/jeps/437">20</a>), а теперь стало Preview API &ndash; это Structured Concurrency.</p>
<p>Structured Concurrency &ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.</p>
<p>В центре нового API класс <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a>, у которого есть два главных метода:</p>
<ul>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"><code class="text-nowrap">fork()</code></a> &ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,</li>
    <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"><code class="text-nowrap">join()</code></a> &ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()">остановлен</a>.</li>
</ul>
<p>Пример использования <code class="text-nowrap">StructuredTaskScope</code>, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> scope = <span style="color: blue">new</span> StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&lt;String> user = scope.fork(() -> findUser());
    Supplier&lt;Integer> order = scope.fork(() -> fetchOrder());

    scope.join()            <span style="color: green">// Join both forks</span>
         .throwIfFailed();  <span style="color: green">// ... and propagate errors</span>

    <span style="color: blue">return new</span> Response(user.get(), order.get());
}</pre>
<p>Может показаться, что в точности аналогичный код можно было бы написать с использованием классического <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code class="text-nowrap">ExecutorService</code></a> и <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"><code class="text-nowrap">submit()</code></a>, но у <code class="text-nowrap">StructuredTaskScope</code> есть несколько принципиальных отличий, которые делают код безопаснее:</p>
<ul>
    <li>Время жизни всех потоков подзадач ограничено областью видимости блока <code class="text-nowrap">try-with-resources</code>. Метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"><code class="text-nowrap">close()</code></a> гарантированно не завершится, пока не завершатся все подзадачи.</li>
    <li>Если одна из операций <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики <code class="text-nowrap">ShutdownOnFailure</code>, возможны другие).</li>
    <li>Если главный поток прерывается в процессе ожидания <code class="text-nowrap">join()</code>, то обе операции <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> отменяются при выходе из блока.</li>
    <li>В дампе потоков будет видна иерархия: потоки, выполняющие <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code>, будут отображаться как дочерние для главного потока.</li>
</ul>
<p class="mt-2">Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.</p>

<h5><a href="https://openjdk.org/jeps/442">Foreign Function & Memory API (Third Preview) (JEP 442)</a></h5>
<p>Foreign Function & Memory API, ставшее preview <a href="https://openjdk.org/jeps/424">в Java 19</a>, продолжает находиться в этом статусе. API находится в пакете <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/package-summary.html"><code class="text-nowrap">java.lang.foreign</code></a>.</p>
<p>Напомним, что FFM API много лет разрабатывается в проекте <a href="https://openjdk.org/projects/panama/">Panama</a> с целью заменить JNI. В <a href="https://openjdk.org/jeps/454">Java 22</a> API выйдет из состояния preview.</p>

<h5><a href="https://openjdk.org/jeps/448">Vector API (Sixth Incubator) (JEP 448)</a></h5>
<p>Векторное API в модуле <a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.incubator.vector/module-summary.html"><code class="text-nowrap">jdk.incubator.vector</code></a>, которое появилось ещё аж <a href="https://openjdk.org/jeps/338">в Java 16</a>, остаётся в инкубационном статусе в шестой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.</p>
<p>Векторное API останется в инкубаторе, пока необходимые фичи проекта <a href="https://openjdk.org/projects/valhalla/">Valhalla</a> не станут preview.</p>

<h5><a href="https://openjdk.org/jeps/452">Key Encapsulation Mechanism API (JEP 452)</a></h5>
<p>В пакете <code class="text-nowrap">javax.crypto</code> появилось новое API, реализующее <a href="https://en.wikipedia.org/wiki/Key_encapsulation_mechanism">механизм инкапсуляции ключей</a>.</p>
<p>Механизм инкапсуляции ключей (KEM) &ndash; это современная криптографическая техника, позволяющая обмениваться симметричными ключами, используя асимметричное шифрование. Если в традиционной технике симметричный ключ генерируется случайным образом и шифруется с помощью открытого ключа (что требует паддинга), то в KEM симметричный ключ выводится из самого открытого ключа.</p>
<p>В Java KEM API состоит из трёх главных классов.</p>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html"><code class="text-nowrap">KEM</code></a> &ndash; входная точка API. У него есть метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html#getInstance(java.lang.String)"><code class="text-nowrap">getInstance()</code></a>, возвращающий объект <code class="text-nowrap">KEM</code> для указанного алгоритма.</p>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html"><code class="text-nowrap">Encapsulator</code></a> &ndash; представляет собой функцию инкапсуляции, которая вызывается отправителем. У этого класса есть метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html#encapsulate()"><code class="text-nowrap">encapsulate()</code></a>, который принимает открытый ключ и возвращает секретный ключ, а также key encapsulation message (которое шлётся принимающей стороне).</p>
<p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html"><code class="text-nowrap">Decapsulator</code></a> &ndash; функция декапсуляции, которая вызывается принимающей стороной. У класса есть метод <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html#decapsulate(byte%5B%5D)"><code class="text-nowrap">decapsulate()</code></a>, который принимает key encapsulation message и возвращает секретный ключ. Таким образом, у обеих сторон теперь есть одинаковый симметричный ключ, с помощью которого можно дальше обмениваться данными с помощью обычного симметричного шифрования.</p>
<p>Пример генерации симметричного ключа и его передачи:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Receiver side</span>
<span style="color: blue">var</span> kpg = KeyPairGenerator.getInstance(<span style="color: darkred">"X25519"</span>);
<span style="color: blue">var</span> kp = kpg.generateKeyPair();

<span style="color: green">// Sender side</span>
<span style="color: blue">var</span> kem1 = KEM.getInstance(<span style="color: darkred">"DHKEM"</span>);
<span style="color: blue">var</span> sender = kem1.newEncapsulator(kp.getPublic());
<span style="color: blue">var</span> encapsulated = sender.encapsulate();
<span style="color: blue">var</span> k1 = encapsulated.key();

<span style="color: green">// Receiver side</span>
<span style="color: blue">var</span> kem2 = KEM.getInstance(<span style="color: darkred">"DHKEM"</span>);
<span style="color: blue">var</span> receiver = kem2.newDecapsulator(kp.getPrivate());
<span style="color: blue">var</span> k2 = receiver.decapsulate(encapsulated.encapsulation());

<span style="color: blue">assert</span> Arrays.equals(k1.getEncoded(), k2.getEncoded());</pre>

<p class="mt-2">Для KEM также добавлен интерфейс <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEMSpi.html"><code class="text-nowrap">KEMSpi</code></a>, позволяющий предоставлять пользовательские реализации алгоритмов KEM.</p>

<h4>JVM</h4>
<h5><a href="https://openjdk.org/jeps/439">Generational ZGC (JEP 439)</a></h5>
<p>В сборщик мусора ZGC, который появился в <a href="https://openjdk.org/jeps/377">Java 15</a>, добавили поддержку поколений. Поколения в ZGC пока что отключены по умолчанию, и для их включения требуется ключ <code class="text-nowrap">-XX:+ZGenerational</code>:</p>
<pre class="border p-lg-2 p-1">java -XX:+UseZGC -XX:+ZGenerational ...</pre>
<p>В будущих версиях Java режим работы с поколениями будет по умолчанию, и ключ <code class="text-nowrap">-XX:+ZGenerational</code> уже требоваться не будет.</p>
<p>Поколения в ZGC должны улучшить производительность Java-программ, т.к. молодые объекты, которые склонны умирать рано согласно слабой гипотезе о поколениях, будут собираться чаще, а старые объекты &ndash; более редко. При этом характеристики ZGC не должны от этого пострадать: время отклика по-прежнему должно быть сверхнизким (< 1ms) и кучи гигантских размеров (несколько терабайт) должны продолжать поддерживаться.</p>
<p>Напомним, что также <a href="https://openjdk.org/jeps/404">ведётся работа</a> над поддержкой поколений в другом сборщике мусора <a href="https://openjdk.org/jeps/379">Shenandoah</a>, похожем по характеристикам на ZGC. Однако в Java 21 Generational Shenandoah попасть не успел.</p>
<p>Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в <a href="https://openjdk.org/jeps/248">Java 9</a> (до него дефолтным был Parallel GC)</p>

<h5><a href="https://openjdk.org/jeps/451">Prepare to Disallow the Dynamic Loading of Agents (JEP 451)</a></h5>
<p>При динамической загрузке агентов теперь выдаётся предупреждение:</p>
<pre class="border p-lg-2 p-1">WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release</pre>
<p>Агент &ndash; это компонент, который может изменять (инструментировать) код Java-приложения во время работы. Поддержка агентов появилась в Java 5, чтобы была возможность писать продвинутые инструменты вроде профилировщиков, которым необходимо добавлять эмиссию событий в классы, или AOP-библиотек. Для включения агентов требовались опции командной строки <code class="text-nowrap">-javaagent</code> или <code class="text-nowrap">-agentlib</code>, поэтому все агенты тогда могли включаться только явно при старте приложения.</p>
<p>Однако в Java 6 появился <a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html">Attach API</a>, который, кроме всего прочего, позволил загружать агенты динамически прямо в работающий JVM. Благодаря этому библиотеки получили возможность подключаться к приложению и по-тихому изменять классы, не имея на то согласия от владельца приложения. Причём изменяться могут не только классы приложения, но и классы JDK. Таким образом, подвергается риску строгая инкапсуляция, которая является одним из краеугольных камней Java.</p>
<p>Чтобы закрыть такую потенциально опасную дыру, в Java 9 вместе с появлением модулей было предложено запретить динамическую загрузку агентов по умолчанию. Однако тогда было решено отложить на неопределённое время такое радикальное решение, чтобы дать авторам инструментов время подготовиться. В итоге, изменение дожило до наших дней, и было реализовано лишь в Java 21, но в <i>виде предупреждения</i>.</p>
<p>Чтобы подавить предупреждение, необходимо запускать JVM с опцией <code class="text-nowrap">-XX:+EnableDynamicAgentLoading</code>, либо загружать агенты при старте JVM, явно перечисляя их с помощью опций <code class="text-nowrap">-javaagent</code> или <code class="text-nowrap">-agentlib</code>.</p>
<p>В будущих версиях Java планируется полностью отключить динамическую загрузку по умолчанию, и она уже не будет работать без <code class="text-nowrap">-XX:+EnableDynamicAgentLoading</code>.</p>

<h5><a href="https://openjdk.org/jeps/449">Deprecate the Windows 32-bit x86 Port for Removal (JEP 449)</a></h5>
<p>32-битный порт OpenJDK под Windows стал deprecated for removal. В будущем планируется избавиться от него полностью.</p>
<p>Удаление порта позволит ускорить разработку платформы. Также причиной стало отсутствие нативной реализации виртуальных потоков на 32-битной версии JDK 21 под Windows: виртуальные потоки в этой версии реализованы через платформенные потоки.</p>

<p class="mt-4">Полный список JEP'ов, попавших в JDK 21, начиная с JDK 17: <a href="https://openjdk.org/projects/jdk/21/jeps-since-jdk-17">ссылка</a>.</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="true" aria-controls="year2023">2023</a>
  <ul class="collapse show" id="year2023">
<li>Вышла Java 21</li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2023</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.ru/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
