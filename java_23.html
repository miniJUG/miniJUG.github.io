<!doctype html>
<html lang="ru">
  <head>
    <title>Вышла Java 23</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Вышла Java 23">
    <meta property="og:description" content="Вышла общедоступная версия Java 23. В этот релиз попало около 2400 закрытых задач и 12 JEP'ов. Release Notes можно посмотреть здесь. Полный список изменений API &ndash; здесь&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2024-09-17">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="Вышла Java 23">
    <meta name="twitter:description" content="Вышла общедоступная версия Java 23. В этот релиз попало около 2400 закрытых задач и 12 JEP'ов. Release Notes можно посмотреть здесь. Полный список изменений API &ndash; здесь&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.org/java_23.png">
    <meta property="og:image:width" content="1280">
    <meta property="og:image:height" content="720">
    <meta name="twitter:image" content="https://minijug.org/java_23.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Вышла Java 23</h3>
<p class="text-secondary"><time datetime="2024-09-17">17 сентября, 2024</time></p>
<article>
<p>Вышла общедоступная версия <a href="https://openjdk.org/projects/jdk/23/">Java 23</a>. В этот релиз попало около <a href="https://builds.shipilev.net/backports-monitor/release-notes-23.html">2400 закрытых задач и 12 JEP'ов</a>. Release Notes можно посмотреть <a href="http://jdk.java.net/23/release-notes">здесь</a>. Полный список изменений API &ndash; <a href="https://javaalmanac.io/jdk/23/apidiff/22/">здесь</a>.</p>

<p>Java 23 не является LTS-релизом, и у неё будут выходить обновления <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html">только полгода</a> (до марта 2025 года).</p>
<!-- cut -->
<p>Скачать JDK 23 можно по этим ссылкам:</p>
<ul>
  <li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a> (лицензия <a href="https://www.oracle.com/downloads/licenses/no-fee-license.html">NFTC</a>)</li>
  <li><a href="http://jdk.java.net/23/">OpenJDK</a> (лицензия <a href="https://openjdk.org/legal/gplv2+ce.html">GPLv2 with Classpath Exception</a>)</li>
</ul>

<p class="pt-1">Рассмотрим все JEP'ы, которые попали в Java 23.</p>

<h5><a href="https://openjdk.org/jeps/467">Markdown Documentation Comments (JEP 467)</a></h5>
<p>Теперь JavaDoc поддерживает формат Markdown. Для его использования документация должна начинаться с <code class="text-nowrap">///</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">/// Returns `true` if, and only if, [#length()] is `0`.
///
/// @return `true` if [#length()] is `0`, otherwise `false`</span>
<span style="color: blue">public boolean</span> isEmpty() {
    <span style="color: green">// ...</span>
}</pre>

<p>Markdown компактнее, читабельнее и удобнее для написания, чем существующий формат HTML. Рассмотрим несколько примеров элементов, написанных в формате HTML и Markdown:</p>
<table class="table">
  <thead>
    <tr>
      <th>HTML</th>
      <th>Markdown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="text-nowrap">{@link java.util.List}</code></td>
      <td><code class="text-nowrap">[java.util.List]</code></td>
    </tr>
    <tr>
      <td><code class="text-nowrap">{@code true}</code></td>
      <td><code class="text-nowrap">`true`</code></td>
    </tr>
    <tr>
      <td><code class="text-nowrap">&lt;em>warning&lt;/em></code></td>
      <td><code class="text-nowrap">_warning_</code></td>
    </tr>
    <tr>
      <td><code class="text-nowrap">&lt;b>error&lt;/b></code></td>
      <td><code class="text-nowrap">**error**</code></td>
    </tr>
    <tr>
      <td>
<pre class="border p-lg-2 p-1">&lt;ul>
  &lt;li>Item 1&lt;/li>
  &lt;li>Item 2&lt;/li>
  &lt;li>Item 3&lt;/li>
&lt;/ul></pre>
      </td>
      <td>
<pre class="border p-lg-2 p-1">- Item 1
- Item 2
- Item 3</pre>
      </td>
    </tr>
    <tr>
      <td><code class="text-nowrap">&lt;p></code></td>
      <td>Не нужен (просто необходимо вставить новую строку)</td>
    </tr>
  </tbody>
</table>

<p>При этом JavaDoc-теги, такие как <code class="text-nowrap">{@inheritDoc}</code>, <code class="text-nowrap">@param</code>, <code class="text-nowrap">@return</code>, <code class="text-nowrap">@throws</code>, остаются прежними:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">/// {@inheritDoc}
/// In addition, this method calls [#wait()].
///
/// @param i the index</span>
<span style="color: blue">public void</span> m(<span style="color: blue">int</span> i) {
    <span style="color: green">// ...</span>
}</pre>

<p>Кроме компактности и удобства новый формат также решает проблему сочетания двух символов <code class="text-nowrap">*/</code>, которые в формате HTML означают окончание документации:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">/**
 * &lt;pre>
 * var pattern = Pattern.compile("\\w*/"); // Проблема
 * &lt;/pre>
 */</span></pre>

<p>В Markdown-документации же можно не только использовать эту последовательность символов, но и вставлять целые блоки HTML-комментариев:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">/// Here is an example:
///
/// ```
/// /** Hello World! */
/// public class HelloWorld {
///     public static void main(String... args) {
///         System.out.println("Hello World!"); // the traditional example
///     }
/// }
/// ```</span></pre>

<h5><a href="https://openjdk.org/jeps/455">Primitive Types in Patterns, instanceof, and switch (Preview) (JEP 455)</a></h5>
<p>Теперь в режиме preview паттерны и операторы <code class="text-nowrap">instanceof</code> / <code class="text-nowrap">switch</code> поддерживают примитивные типы:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>

Object obj = 42;
<span style="color: blue">if</span> (obj <span style="color: blue">instanceof int</span> i) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"int: "</span> + i);
}

<span style="color: blue">switch</span> (obj) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case double</span> d -> System.out.println(<span style="color: darkred">"double: "</span> + d);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>Проверять можно также и то, попадают ли значения в диапазон типа:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">int</span> i = 42;
<span style="color: blue">if</span> (i <span style="color: blue">instanceof byte</span> b) { <span style="color: green">// matches</span>
    System.out.println(<span style="color: darkred">"byte: "</span> + b);
}

<span style="color: blue">double</span> d = 3.0;
<span style="color: blue">switch</span> (d) {
    <span style="color: blue">case int</span> i -> System.out.println(<span style="color: darkred">"int: "</span> + i); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> f -> System.out.println(<span style="color: darkred">"float: "</span> + f);
    <span style="color: blue">default</span> -> System.out.println(<span style="color: darkred">"other"</span>);
}</pre>

<p>В примерах выше <code class="text-nowrap">42</code> попадает в диапазон byte (<code class="text-nowrap">[-128; 127]</code>), а <code class="text-nowrap">3.0</code> без потери точности приводится к <code class="text-nowrap">int</code>. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.</p>
<p>Подобные проверки могут быть полезны и в паттернах записей:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> JsonNumber(<span style="color: blue">double</span> d) {}

<span style="color: blue">var</span> json = <span style="color: blue">new</span> JsonNumber(3.0);
<span style="color: blue">if</span> (json <span style="color: blue">instanceof</span> JsonNumber(<span style="color: blue">int</span> i)) { <span style="color: green">// matches</span>
    <span style="color: green">// ...</span>
}</pre>

<p>Если раньше типы выражений-селекторов в <code class="text-nowrap">switch</code> могли быть только <code class="text-nowrap">int</code>, <code class="text-nowrap">short</code>, <code class="text-nowrap">byte</code> и <code class="text-nowrap">char</code> и для них поддерживались только константные ветки (<code class="text-nowrap">case 3</code> и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">float</span> f = 1.0f;
<span style="color: blue">switch</span> (f) {
    <span style="color: blue">case</span> 0f -> System.out.println(<span style="color: darkred">"0"</span>);
    <span style="color: blue">case float</span> x <span style="color: blue">when</span> x == 1f -> System.out.println(<span style="color: darkred">"1"</span>); <span style="color: green">// matches</span>
    <span style="color: blue">case float</span> x -> System.out.println(<span style="color: darkred">"other"</span>);
}

<span style="color: blue">boolean</span> b = <span style="color: darkred">"hello"</span>.isEmpty();
<span style="color: blue">switch</span> (b) {
    <span style="color: blue">case true</span> -> System.out.println(<span style="color: darkred">"empty"</span>);
    <span style="color: blue">case false</span> -> System.out.println(<span style="color: darkred">"non-empty"</span>); <span style="color: green">// matches</span>
}</pre>

<h5><a href="https://openjdk.org/jeps/476">Module Import Declarations (Preview) (JEP 476)</a></h5>
<p>В режиме preview появилась возможность импортировать модули:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">import module</span> M;</pre>
<p>Такой импорт эквивалентен импорту всех экспортированных пакетов из модуля <code class="text-nowrap">M</code> и его транзитивных зависимостей в текущий модуль.</p>
<p>Например, импорт модуля <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/module-summary.html"><code class="text-nowrap">java.base</code></a> имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">import</span> java.io.*;
<span style="color: blue">import</span> java.lang.*;
<span style="color: blue">import</span> java.lang.annotation.*;
<span style="color: green">// ... 49 packages ...</span>
<span style="color: blue">import</span> javax.security.auth.x500.*;
<span style="color: blue">import</span> javax.security.cert.*;</pre>

<p>Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как <code class="text-nowrap">List</code>, <code class="text-nowrap">Map</code>, <code class="text-nowrap">Stream</code>, <code class="text-nowrap">Path</code>, <code class="text-nowrap">Function</code> и др. без необходимости отдельного импорта их соответствующих пакетов.</p>
<p>Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую <a href="https://openjdk.org/jeps/458">без предварительной компиляции</a>.</p>
<p>При использовании <i>неявно объявленных классов</i> модуль <code class="text-nowrap">java.base</code> импортируется автоматически. Об этом следующий JEP 477.</p>

<h5><a href="https://openjdk.org/jeps/477">Implicitly Declared Classes and Instance Main Methods (Third Preview) (JEP 477)</a></h5>
<p>В Java 21 в режиме preview появились <a href="https://openjdk.org/jeps/445">безымянные классы и инстанс-методы <code class="text-nowrap">main()</code></a>. В Java 22 они были оставлены <a href="https://openjdk.org/jeps/463">на второе preview</a> с несколькими изменениями, среди которых самым важным был отказ от безымянных классов в пользу неявно объявленных классов.</p>
<p>В Java 23 теперь выходит третье preview этой фичи ещё с несколькими изменениями:</p>
<ul>
  <li>Появился новый класс <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html"><code class="text-nowrap">java.io.IO</code></a> с тремя публичными статическими методами, которые автоматически импортируются во все неявно объявленные классы:
    <ul>
      <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#print(java.lang.Object)"><code class="text-nowrap">void print(Object obj)</code></a>,</li>
      <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#println(java.lang.Object)"><code class="text-nowrap">void println(Object obj)</code></a>,</li>
      <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#readln(java.lang.String)"><code class="text-nowrap">String readln(String prompt)</code></a>.</li>
    </ul>
  </li>
  <li>Неявно объявленные классы автоматически импортируют модуль <code class="text-nowrap">java.base</code> (см. JEP 476 выше). То есть автоматически будут видны все публичные верхнеуровневые классы и интерфейсы всех экспортированных пакетов модуля <code class="text-nowrap">java.base</code>.</li>
</ul>

<p>Новый протокол запуска Java-программ позволяет запускать классы, у которых метод <code class="text-nowrap">main()</code> не является <code class="text-nowrap">public static</code> (т.е. является instance-методом) и у которого нет параметра <code class="text-nowrap">String[] args</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>
<span style="color: blue">class</span> HelloWorld {
    <span style="color: blue">void</span> main() {
        System.out.println(<span style="color: darkred">"Hello, World!"</span>);
    }
}</pre>
<p>В таком случае во время запуска JVM сама создаст экземпляр класса <code class="text-nowrap">HelloWorld</code> и вызовет у него метод <code class="text-nowrap">main()</code>:</p>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 23 HelloWorld.java
Hello, World!</pre>

<p class="mt-2">Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// HelloWorld.java</span>

String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    println(greeting);
}</pre>
<pre class="border p-lg-2 p-1">$ java --enable-preview --source 23 HelloWorld.java
Hello, World!</pre>

<p>В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод <code class="text-nowrap">main()</code> и другие верхнеуровневые объявления в файле:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// import module java.base; ← неявно
// import static java.io.IO.*; ← неявно

// class &lt;some name> { ← неявно</span>
String greeting = <span style="color: darkred">"Hello, World!"</span>;

<span style="color: blue">void</span> main() {
    println(greeting);
}
<span style="color: green">// }</span></pre>

<p>Заметьте, что второй пример стал короче не только из-за отсутствия объявления класса, но и из-за использования метода <code class="text-nowrap">println()</code> вместо <code class="text-nowrap">System.out.println()</code>.</p>

<p>Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:</p>
<ul>
  <li>Код в неявном классе не может ссылаться на него по имени.</li>
  <li>Неявный класс всегда имеет один неявный конструктор без аргументов.</li>
  <li>Неявный класс может находиться только в безымянном пакете.</li>
</ul>
<p>При этом неявный класс не является безымянным: у него есть <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Class.html#getName()">имя</a>, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).</p>

<p class="mt-2">Упрощение запуска Java-программ было сделано с двумя целями:</p>
<ol>
  <li>Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).</li>
  <li>Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.</li>
</ol>

<h5><a href="https://openjdk.org/jeps/482">Flexible Constructor Bodies (Second Preview) (JEP 482)</a></h5>
<p>Statements before <code class="text-nowrap">super()</code>, которые появились <a href="https://openjdk.org/jeps/447">в Java 22</a> в режиме preview, остаются на второе preview и теперь называются Flexible Constructor Bodies. По сравнению с Java 22 есть одно важное изменение: теперь можно инициализировать поля до вызова конструктора. Про это будет подробнее рассказано дальше.</p>

<p>Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (<code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>):</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>
<span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
        <span style="color: blue">super</span>(value);
    }
}</pre>

<p>Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> PositiveBigInteger <span style="color: blue">extends</span> BigInteger {
    <span style="color: blue">public</span> PositiveBigInteger(<span style="color: blue">long</span> value) {
        <span style="color: blue">super</span>(verifyPositive(value));
    }

    <span style="color: blue">private static long</span> verifyPositive(<span style="color: blue">long</span> value) {
        <span style="color: blue">if</span> (<span style="color: blue">value</span> <= 0)
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"non-positive value"</span>);
    }
}</pre>

<p>Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Super {
    <span style="color: blue">public</span> Super(C x, C y) { ... }
}

<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">private</span> Sub(C x) { <span style="color: green">// Auxiliary constructor</span>
        <span style="color: blue">super</span>(x, x); <span style="color: green">// x is shared here</span>
    }

    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>(<span style="color: blue">new</span> C(i));
    }
}</pre>

<p>В Java 23, включив режим preview, то же самое можно реализовать гораздо короче:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// --enable-preview --source 23</span>
<span style="color: blue">public class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">public</span> Sub(<span style="color: blue">int</span> i) {
        <span style="color: blue">var</span> x = <span style="color: blue">new</span> C(i);
        <span style="color: blue">super</span>(x, x);
    }
}</pre>

<p>Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать инстанс-методы). Рассмотрим несколько примеров некорректного кода:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A() {
        System.out.print(<span style="color: blue">this</span>); <span style="color: red">// Error</span>
        var x = i;              <span style="color: red">// Error</span>
        hashCode();             <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> B {
    <span style="color: blue">int</span> i;
    <span style="color: blue">void</span> m() {}
}

<span style="color: blue">class</span> C <span style="color: blue">extends</span> B {
    C() {
        <span style="color: blue">var</span> x = i; <span style="color: red">// Error</span>
        m();       <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Outer {
    <span style="color: blue">class</span> Inner {
    }

    Outer() {
        <span style="color: blue">new</span> Inner(); <span style="color: red">// Error</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Однако если читать поля конструируемого класса до вызова <code class="text-nowrap">super()</code> нельзя, то инициализировать их можно:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> A {
    <span style="color: blue">int</span> i;

    A(<span style="color: blue">int</span> i) {
        <span style="color: blue">this</span>.i = i; <span style="color: green">// OK</span>
        <span style="color: blue">super</span>();
    }
}</pre>

<p>Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: red">// new Sub(42) will print 0</span>
    }
}</pre>

<p>Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова <code class="text-nowrap">super()</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Super {
    Super() { overriddenMethod(); }

    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(<span style="color: darkred">"hello"</span>);
    }
}

<span style="color: blue">class</span> Sub <span style="color: blue">extends</span> Super {
    <span style="color: blue">final int</span> x;

    Sub(<span style="color: blue">int</span> x) {
        <span style="color: blue">this</span>.x = x;
        <span style="color: blue">super</span>();
    }

    @Override
    <span style="color: blue">void</span> overriddenMethod() {
        System.out.println(x); <span style="color: green">// new Sub(42) will print 42</span>
    }
}</pre>

<p>Также инициализация полей до <code class="text-nowrap">super()</code> можно пригодиться в проекте Valhalla для <a href="https://youtu.be/IF9l8fYfSnI?t=2006">definite assignment полей</a> null-restricted value-классов.</p>

<p>Интересно, что новая возможность затрагивает исключительно компилятор Java &ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом <code class="text-nowrap">super()</code> или <code class="text-nowrap">this()</code>, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).</p>

<h5><a href="https://openjdk.org/jeps/473">Stream Gatherers (Second Preview) (JEP 473)</a></h5>
<p>Stream gatherers, которые <a href="https://openjdk.org/jeps/461">появились в Java 22</a> в режиме preview, остаются на второе preview без изменений.</p>

<p>Gatherers &ndash; это усовершенствование Stream API для поддержки произвольных промежуточных операций.</p>
<p>Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (<a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"><code class="text-nowrap">map</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"><code class="text-nowrap">flatMap</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"><code class="text-nowrap">filter</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"><code class="text-nowrap">reduce</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#limit(long)"><code class="text-nowrap">limit</code></a>,
  <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#skip(long)"><code class="text-nowrap">skip</code></a> и т.д). В Java 9 были добавлены <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"><code class="text-nowrap">takeWhile</code></a> и <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"><code class="text-nowrap">dropWhile</code></a>. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.</p>
<p>Новая точка расширения &ndash; это новый метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"><code class="text-nowrap">Stream::gather(Gatherer)</code></a>, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html"><code class="text-nowrap">Gatherer</code></a>, предоставляемого пользователем. Операция <code class="text-nowrap">gather()</code> аналогична уже имеющейся операции <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"><code class="text-nowrap">Stream::collect(Collector)</code></a>: если <code class="text-nowrap">collect()</code> и <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html"><code class="text-nowrap">Collector</code></a> определяют точку расширения для терминальных операций, то <code class="text-nowrap">gather()</code> и <code class="text-nowrap">Gatherer</code> определяют точку расширения для промежуточных.</p>
<p><code class="text-nowrap">Gatherer</code> представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса <code class="text-nowrap">Gatherer</code>.</p>
<p><code class="text-nowrap">gather()</code> также является промежуточной операцией, поэтому может быть несколько <code class="text-nowrap">gather()</code> в одной цепочке:</p>
<pre class="border p-lg-2 p-1">source.gather(a).gather(b).gather(c).collect(...)</pre>

<p>Вместе с самим <code class="text-nowrap">Gatherer</code> было добавлено несколько готовых gatherer'ов, определённых в новом классе <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html"><code class="text-nowrap">Gatherers</code></a>. Это <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">fold</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"><code class="text-nowrap">mapConcurrent</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"><code class="text-nowrap">scan</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"><code class="text-nowrap">windowFixed</code></a> и
  <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"><code class="text-nowrap">windowSliding</code></a>.</p>
<p>Давайте рассмотрим несколько примеров:</p>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.fold(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .findFirst()
   <span style="color: grey">...></span>       .get();
<span style="color: grey">$1 ==></span> "123456789"</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8,9)
   <span style="color: grey">...></span>       .gather(Gatherers.scan(() -> "", (str, n) -> str + n))
   <span style="color: grey">...></span>       .toList()
<span style="color: grey">$2 ==></span> [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
<span style="color: grey">$3 ==></span> [[1, 2, 3], [4, 5, 6], [7, 8]]</pre>
<pre class="border p-lg-2 p-1"><span style="color: grey">jshell></span> Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
<span style="color: grey">$4 ==></span> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]</pre>

<p>Дизайн интерфейса <code class="text-nowrap">Gatherer</code> был создан под влиянием интерфейса <code class="text-nowrap">Collector</code>. Вот основная часть его сигнатуры:</p>
<pre class="border p-lg-2 p-1">public interface Gatherer&lt;T, A, R> {
    Supplier&lt;A> initializer();
    Integrator&lt;A, T, R> integrator();
    BinaryOperator&lt;A> combiner();
    BiConsumer&lt;A, Downstream&lt;? super R>> finisher();
}</pre>
<p>Если взглянуть на <code class="text-nowrap">Collector</code>, то он также имеет три параметра <code class="text-nowrap">T</code>, <code class="text-nowrap">A</code>, <code class="text-nowrap">R</code> и содержит 4 основных метода: <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#supplier()"><code class="text-nowrap">supplier</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#accumulator()"><code class="text-nowrap">accumulator</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#combiner()"><code class="text-nowrap">combiner</code></a> и <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#finisher()"><code class="text-nowrap">finisher</code></a>. Однако <code class="text-nowrap">Gatherer</code> использует два вспомогательных интерфейса <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"><code class="text-nowrap">Integrator</code></a> и
  <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"><code class="text-nowrap">Downstream</code></a>, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.</p>
<p>Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс <code class="text-nowrap">Gatherer</code> и можно воспользоваться готовыми методами-фабриками: <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::of(Integrator)</code></a>, <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"><code class="text-nowrap">Gatherer::ofSequential(Integrator)</code></a> или другими вариациями.</p>

<p>Stream gatherers станут постоянным API <a href="https://openjdk.org/jeps/485">в Java 24</a>.</p>

<h5><a href="https://openjdk.org/jeps/466">Class-File API (Second Preview) (JEP 466)</a></h5>
<p>Стандартное API для парсинга, генерации и трансформации class-файлов, которое <a href="https://openjdk.org/jeps/457">появилось в Java 22</a>, остаётся на второе preview с несколькими изменениями.</p>
<p>Новое API находится в пакете <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/classfile/package-summary.html"><code class="text-nowrap">java.lang.classfile</code></a>. Оно должно заменить копию библиотеки <a href="https://asm.ow2.io/">ASM</a> внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.</p>
<p>Основная проблема ASM (и других библиотек для работы с class-файлами) &ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.</p>
<p>Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.</p>

<p>Class-File API станет постоянным API <a href="https://openjdk.org/jeps/484">в Java 24</a>.</p>

<h5><a href="https://openjdk.org/jeps/471">Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (JEP 471)</a></h5>
<p>В классе <code class="text-nowrap">sun.misc.Unsafe</code> все методы доступа к памяти стали deprecated for removal. Это 77 из 87 методов (в JEP написано 79 из 87, но, похоже, автор посчитал неправильно). При этом 3 из них стали deprecated for removal ещё <a href="https://bugs.openjdk.org/browse/JDK-8278223">в Java 18</a>: <code class="text-nowrap">objectFieldOffset()</code>, <code class="text-nowrap">staticFieldOffset()</code> и <code class="text-nowrap">staticFieldBase()</code>. Также <a href="https://bugs.openjdk.org/browse/JDK-8315953">в Java 22</a> стали deprecated for removal 6 методов, не относящиеся к памяти: <code class="text-nowrap">park()</code>, <code class="text-nowrap">unpark()</code>, <code class="text-nowrap">fullFence()</code>, <code class="text-nowrap">loadFence()</code>, <code class="text-nowrap">storeFence()</code> и <code class="text-nowrap">getLoadAverage()</code>.</p>
<p>Таким образом, в <code class="text-nowrap">sun.misc.Unsafe</code> остаётся всего 4 метода, которые пока не являются deprecated, причём один из них &ndash; это <code class="text-nowrap">getUnsafe()</code>, который получает сам объект <code class="text-nowrap">Unsafe</code>.</p>
<p>По факту всё это означает, что <code class="text-nowrap">Unsafe</code> больше крайне не рекомендуется использовать. Вместо методов доступа к памяти необходимо использовать стандартное API в Java:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/invoke/VarHandle.html"><code class="text-nowrap">java.lang.invoke.VarHandle</code></a> &ndash; API для манипуляций с памятью внутри кучи, появилось <a href="https://openjdk.org/jeps/193">в Java 9</a>.</li>
  <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/MemorySegment.html"><code class="text-nowrap">java.lang.foreign.MemorySegment</code></a> &ndash; API для доступа к памяти вне кучи (часто в кооперации с <code class="text-nowrap">VarHandle</code>), появилось <a href="https://openjdk.org/jeps/454">в Java 22</a>.</li>
</ul>
<p>Использования deprecated методов в <code class="text-nowrap">sun.misc.Unsafe</code> будут вызывать предупреждения во время компиляции:</p>
<pre class="border p-lg-2 p-1">HelloWorld.java:4: warning: [removal] getByte(long) in Unsafe has been deprecated and marked for removal
        unsafe.getByte(address);
              ^</pre>

<p>В дополнение к предупреждениям на этапе компиляции появится возможность включать предупреждения в рантайме при использовании методов доступа к памяти. Для этого появилась новая опция командной строки <code class="text-nowrap">--sun-misc-unsafe-memory-access={allow|warn|debug|deny}</code>:</p>
<ul>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=allow</code> &ndash; при вызове методов предупреждения нет (дефолтное значение в Java 23).</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=warn</code> &ndash; выдаётся предупреждение при первом вызове (станет дефолтным значением в Java 24 или 25).</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=debug</code> &ndash; выдаётся предупреждение при каждом вызове.</li>
  <li><code class="text-nowrap">--sun-misc-unsafe-memory-access=deny</code> &ndash; выбрасывается <code class="text-nowrap">UnsupportedOperationException</code> (станет дефолтным значением в Java 26 или позже; <code class="text-nowrap">allow</code> использовать будет нельзя).</li>
</ul>
<p>В конце концов методы доступа к памяти будут удалены совсем (опция <code class="text-nowrap">--sun-misc-unsafe-memory-access</code> будет игнорироваться какое-то время, а потом удалится).</p>

<h5><a href="https://openjdk.org/jeps/480">Structured Concurrency (Third Preview) (JEP 480)</a></h5>
<p>Structured Concurrency, которое находится в режиме preview <a href="https://openjdk.org/jeps/453">с Java 21</a>, остаётся на третий раунд preview без изменений (<a href="https://openjdk.org/jeps/462">в Java 22</a> также не было изменений). До этого оно было в инкубаторе в <a href="https://openjdk.org/jeps/428">Java 19</a> и <a href="https://openjdk.org/jeps/437">Java 20</a></p>

<p>Structured Concurrency &ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.</p>
<p>В центре нового API класс <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"><code class="text-nowrap">StructuredTaskScope</code></a>, у которого есть два главных метода:</p>
<ul>
  <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"><code class="text-nowrap">fork()</code></a> &ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,</li>
  <li><a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"><code class="text-nowrap">join()</code></a> &ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()">остановлен</a>.</li>
</ul>
<p>Пример использования <code class="text-nowrap">StructuredTaskScope</code>, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> scope = <span style="color: blue">new</span> StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&lt;String> user = scope.fork(() -> findUser());
    Supplier&lt;Integer> order = scope.fork(() -> fetchOrder());

    scope.join()            <span style="color: green">// Join both forks</span>
         .throwIfFailed();  <span style="color: green">// ... and propagate errors</span>

    <span style="color: blue">return new</span> Response(user.get(), order.get());
}</pre>
<p>Может показаться, что в точности аналогичный код можно было бы написать с использованием классического <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html"><code class="text-nowrap">ExecutorService</code></a> и <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"><code class="text-nowrap">submit()</code></a>, но у <code class="text-nowrap">StructuredTaskScope</code> есть несколько принципиальных отличий, которые делают код безопаснее:</p>
<ul>
  <li>Время жизни всех потоков подзадач ограничено областью видимости блока <code class="text-nowrap">try-with-resources</code>. Метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"><code class="text-nowrap">close()</code></a> гарантированно не завершится, пока не завершатся все подзадачи.</li>
  <li>Если одна из операций <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики <code class="text-nowrap">ShutdownOnFailure</code>, возможны другие).</li>
  <li>Если главный поток прерывается в процессе ожидания <code class="text-nowrap">join()</code>, то обе операции <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code> отменяются при выходе из блока.</li>
  <li>В дампе потоков будет видна иерархия: потоки, выполняющие <code class="text-nowrap">findUser()</code> и <code class="text-nowrap">fetchOrder()</code>, будут отображаться как дочерние для главного потока.</li>
</ul>
<p class="mt-2">Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.</p>

<h5><a href="https://openjdk.org/jeps/481">Scoped Values (Third Preview) (JEP 481)</a></h5>
<p>Scoped Values, которые стали preview в <a href="https://openjdk.org/jeps/446">Java 21</a> и остались на второе preview в <a href="https://openjdk.org/jeps/464">Java 22</a>, уходят на третье preview. До этого Scoped Values были в инкубаторе в <a href="https://openjdk.org/jeps/429">Java 20</a>.</p>
<p>В третье preview было внесено пару изменений: метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#callWhere(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp)"><code class="text-nowrap">callWhere()</code></a> третьим аргументом теперь принимает новый функциональный интерфейс <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.CallableOp.html"><code class="text-nowrap">CallableOp</code></a> вместо <code class="text-nowrap">Callable</code>, а также удалён метод <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#getWhere(java.lang.ScopedValue,T,java.util.function.Supplier)"><code class="text-nowrap">getWhere()</code></a>.</p>

<p>Класс <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html"><code class="text-nowrap">ScopedValue</code></a> позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html"><code class="text-nowrap">ThreadLocal</code></a>.</p>
<p>Классы <code class="text-nowrap">ThreadLocal</code> и <code class="text-nowrap">ScopedValue</code> похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае <code class="text-nowrap">ThreadLocal</code> для этого вызывается метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"><code class="text-nowrap">set()</code></a>, который кладёт значение переменной для данного потока, а потом метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#get()"><code class="text-nowrap">get()</code></a> вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:</p>
<ul>
  <li>Неконтролируемая мутабельность (<code class="text-nowrap">set()</code> можно вызвать когда угодно и откуда угодно).</li>
  <li>Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван <code class="text-nowrap">ThreadLocal.remove()</code>, но про него часто забывают).</li>
  <li>Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).</li>
</ul>
<p>Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.</p>
<p><code class="text-nowrap">ScopedValue</code> лишён вышеперечисленных недостатков. В отличие от <code class="text-nowrap">ThreadLocal</code>, <code class="text-nowrap">ScopedValue</code> не имеет метода <code class="text-nowrap">set()</code>. Значение ассоциируется с объектом <code class="text-nowrap">ScopedValue</code> путём вызова другого метода <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"><code class="text-nowrap">where()</code></a>. Далее вызывается метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"><code class="text-nowrap">run()</code></a>, на протяжении которого это значение можно получить (через метод <a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#get()"><code class="text-nowrap">get()</code></a>), но нельзя изменить. Как только исполнение метода <code class="text-nowrap">run()</code> заканчивается, значение отвязывается от объекта <code class="text-nowrap">ScopedValue</code>. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.</p>
<p>Пример использования <code class="text-nowrap">ScopedValue</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">private static final</span> ScopedValue&lt;FrameworkContext> CONTEXT = ScopedValue.newInstance();

<span style="color: blue">void</span> serve(Request request, Response response) {
    <span style="color: blue">var</span> context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -> Application.handle(request, response));
}

<span style="color: blue">public</span> PersistedObject readKey(String key) {
    <span style="color: blue">var</span> context = CONTEXT.get();
    <span style="color: blue">var</span> db = getDBConnection(context);
    db.readKey(key);
}</pre>
<p>В целом <code class="text-nowrap">ScopedValue</code> является предпочтительной заменой <code class="text-nowrap">ThreadLocal</code>, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них <code class="text-nowrap">ThreadLocal</code> может быть единственно возможным решением.</p>

<h5><a href="https://openjdk.org/jeps/469">Vector API (Eighth Incubator) (JEP 469)</a></h5>
<p>Векторное API в модуле <a href="https://docs.oracle.com/en/java/javase/23/docs/api/jdk.incubator.vector/module-summary.html"><code class="text-nowrap">jdk.incubator.vector</code></a>, которое появилось ещё аж <a href="https://openjdk.org/jeps/338">в Java 16</a>, остаётся в инкубационном статусе в восьмой раз без изменений.</p>
<p>Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта <a href="https://openjdk.org/projects/valhalla/">Valhalla</a> (главным образом, от <a href="https://openjdk.org/jeps/401">value-классов</a>), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.</p>

<h5><a href="https://openjdk.org/jeps/474">ZGC: Generational Mode by Default (JEP 474)</a></h5>
<p>Режим работы с поколениями, который появился в сборщике мусора ZGC <a href="https://openjdk.org/jeps/439">в Java 21</a>, стал включённым по умолчанию. То есть теперь опция <code class="text-nowrap">-XX:+UseZGC</code> автоматически включает опцию <code class="text-nowrap">-XX:+ZGenerational</code>. Для выключения режима необходимо указать опцию <code class="text-nowrap">-XX:-ZGenerational</code>. Однако режим без поколений стал deprecated, и в будущем планируется его окончательное удаление (вместе с опцией <code class="text-nowrap">-XX:&pm;ZGenerational</code>).</p>
<p>Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в <a href="https://openjdk.org/jeps/248">Java 9</a> (до него дефолтным был Parallel GC)</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2025" role="button" aria-expanded="false" aria-controls="year2025">2025</a>
  <ul class="collapse" id="year2025">
<li class="text-secondary"><a href="java_25.html" class="text-secondary">Вышла Java 25</a></li>
<li class="text-secondary"><a href="java_24.html" class="text-secondary">Вышла Java 24</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2024" role="button" aria-expanded="true" aria-controls="year2024">2024</a>
  <ul class="collapse show" id="year2024">
<li>Вышла Java 23</li>
<li class="text-secondary"><a href="java_22.html" class="text-secondary">Вышла Java 22</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="false" aria-controls="year2023">2023</a>
  <ul class="collapse" id="year2023">
<li class="text-secondary"><a href="java_21.html" class="text-secondary">Вышла Java 21</a></li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2025</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.org/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
