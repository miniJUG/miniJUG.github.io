<!doctype html>
<html lang="ru">
  <head>
    <title>Исследуем записи в Java 14</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Исследуем записи в Java 14">
    <meta property="og:description" content="В прошлый раз мы тестировали улучшенный оператор instanceof, который появится в грядущей, 14-й версии Java (выйдет в марте 2020). Сегодня я хотел бы исследовать в деталях вторую синтаксическую&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2019-12-30">
    <meta property="article:author" content="miniJUG">
    <meta property="article:author_url" content="https://twitter.com/mini_JUG">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@mini_JUG">
    <meta name="twitter:title" content="Исследуем записи в Java 14">
    <meta name="twitter:description" content="В прошлый раз мы тестировали улучшенный оператор instanceof, который появится в грядущей, 14-й версии Java (выйдет в марте 2020). Сегодня я хотел бы исследовать в деталях вторую синтаксическую&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.ru/trying_records_in_java14.png">
    <meta property="og:image:width" content="1177">
    <meta property="og:image:height" content="504">
    <meta name="twitter:image" content="https://minijug.ru/trying_records_in_java14.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
    <style>
      a { text-decoration: none }
      a:hover { text-decoration: underline }
      code { color:var(--bs-body-color) }
    </style>
  </head>
  <body class="bg-light">
<div class="container">
  <div class="row gx-5">
    <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">Исследуем записи в Java 14</h3>
<p class="text-secondary"><time datetime="2019-12-30">30 декабря, 2019</time></p>
<article>
<p><a href="trying_new_instanceof_in_java_14.html">В прошлый раз</a> мы тестировали улучшенный оператор <code class="text-nowrap">instanceof</code>, который появится в грядущей, <a href="https://openjdk.org/projects/jdk/14/">14-й версии Java</a> (выйдет в марте 2020). Сегодня я хотел бы исследовать в деталях вторую синтаксическую возможность, которая также появится в Java 14: записи (records).</p>
<p>У записей есть <a href="https://openjdk.org/jeps/359">свой JEP</a>, однако он не сильно блещет подробностями, поэтому многое придётся пробовать и проверять самим. Да, можно конечно, открыть <a href="http://cr.openjdk.java.net/~gbierman/jep359/jep359-20191125/specs/records-jls.html#jls-8.10">спецификацию</a> Java SE, но, мне кажется, гораздо интереснее самим начать писать код и смотреть на поведение компилятора в тех или иных ситуациях. Так что заваривайте чаёк и располагайтесь поудобнее. Поехали.</p>
<p>В отличие от прошлого раза, когда мне пришлось собирать специальную ветку JDK для тестирования <code class="text-nowrap">instanceof</code>, сейчас всё это уже присутствует в главной ветке и доступно в <a href="http://jdk.java.net/14/">ранней сборке JDK 14</a>, которую я и скачал.</p>
<p>Для начала реализуем классический пример с <code class="text-nowrap">Point</code> и скомпилируем его:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
}</pre>
<pre class="border p-lg-2 p-1">&gt; javac --enable-preview --release 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.</pre>
<p><code class="text-nowrap">javac</code> успешно скомпилировал файл <code class="text-nowrap">Point.class</code>. Давайте его дизассемблируем и посмотрим, что нам там нагенерировал компилятор:</p>
<pre class="border p-lg-2 p-1">&gt; javap -private Point.class
Compiled from "Point.java"
final class Point extends java.lang.Record {
  private final float x;
  private final float y;
  public Point(float, float);
  public java.lang.String toString();
  public final int hashCode();
  public final boolean equals(java.lang.Object);
  public float x();
  public float y();
}</pre>
<p>Ага, компилятор создал следующее:</p>
<ul>
  <li>Финальный класс, отнаследованный от <a href="https://download.java.net/java/early_access/jdk14/docs/api/java.base/java/lang/Record.html">java.lang.Record</a> (по аналогии с <code class="text-nowrap">enum</code>, которые наследуются от <code class="text-nowrap">java.lang.Enum</code>).</li>
  <li>Приватные финальные поля <code class="text-nowrap">x</code> и <code class="text-nowrap">y</code>.</li>
  <li>Публичный конструктор, совпадающий с сигнатурой самой записи. Такой конструктор называется <i>каноническим</i>.</li>
  <li>Реализации <code class="text-nowrap">toString()</code>, <code class="text-nowrap">hashCode()</code> и <code class="text-nowrap">equals()</code>. Интересно, что <code class="text-nowrap">hashCode()</code> и <code class="text-nowrap">equals()</code> являются <code class="text-nowrap">final</code>, а <code class="text-nowrap">toString()</code> – нет. Это вряд ли на что-то может повлиять, так как сам класс <code class="text-nowrap">final</code>, но кто-нибудь знает, зачем так сделали? (Я нет)</li>
  <li>Методы чтения полей.</li>
</ul>
<p>С конструктором и методами чтения всё понятно, но интересно, как именно реализованы <code class="text-nowrap">toString()</code>, <code class="text-nowrap">hashCode()</code> и <code class="text-nowrap">equals()</code>? Давайте посмотрим. Для этого запустим <code class="text-nowrap">javap</code> с флагом <code class="text-nowrap">-verbose</code>:</p>
<details><summary><i>Длинный вывод дизассемблера</i></summary><pre class="border p-lg-2 p-1">&gt; javap -private -verbose Point.class
Classfile Point.class
  Last modified 29 дек. 2019 г.; size 1157 bytes
  SHA-256 checksum 24fe5489a6a01a7232f45bd7739a961c30d7f6e24400a3e3df2ec026cc94c0eb
  Compiled from "Point.java"
final class Point extends java.lang.Record
  minor version: 65535
  major version: 58
  flags: (0x0030) ACC_FINAL, ACC_SUPER
  this_class: #8                          // Point
  super_class: #2                         // java/lang/Record
  interfaces: 0, fields: 2, methods: 6, attributes: 4
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Record."&lt;init&gt;":()V
   #2 = Class              #4             // java/lang/Record
   #3 = NameAndType        #5:#6          // "&lt;init&gt;":()V
   #4 = Utf8               java/lang/Record
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Fieldref           #8.#9          // Point.x:F
   #8 = Class              #10            // Point
   #9 = NameAndType        #11:#12        // x:F
  #10 = Utf8               Point
  #11 = Utf8               x
  #12 = Utf8               F
  #13 = Fieldref           #8.#14         // Point.y:F
  #14 = NameAndType        #15:#12        // y:F
  #15 = Utf8               y
  #16 = Fieldref           #8.#9          // Point.x:F
  #17 = Fieldref           #8.#14         // Point.y:F
  #18 = InvokeDynamic      #0:#19         // #0:toString:(LPoint;)Ljava/lang/String;
  #19 = NameAndType        #20:#21        // toString:(LPoint;)Ljava/lang/String;
  #20 = Utf8               toString
  #21 = Utf8               (LPoint;)Ljava/lang/String;
  #22 = InvokeDynamic      #0:#23         // #0:hashCode:(LPoint;)I
  #23 = NameAndType        #24:#25        // hashCode:(LPoint;)I
  #24 = Utf8               hashCode
  #25 = Utf8               (LPoint;)I
  #26 = InvokeDynamic      #0:#27         // #0:equals:(LPoint;Ljava/lang/Object;)Z
  #27 = NameAndType        #28:#29        // equals:(LPoint;Ljava/lang/Object;)Z
  #28 = Utf8               equals
  #29 = Utf8               (LPoint;Ljava/lang/Object;)Z
  #30 = Utf8               (FF)V
  #31 = Utf8               Code
  #32 = Utf8               LineNumberTable
  #33 = Utf8               MethodParameters
  #34 = Utf8               ()Ljava/lang/String;
  #35 = Utf8               ()I
  #36 = Utf8               (Ljava/lang/Object;)Z
  #37 = Utf8               ()F
  #38 = Utf8               SourceFile
  #39 = Utf8               Point.java
  #40 = Utf8               Record
  #41 = Utf8               BootstrapMethods
  #42 = MethodHandle       6:#43          // REF_invokeStatic java/lang/runtime/ObjectMethods.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;
  #43 = Methodref          #44.#45        // java/lang/runtime/ObjectMethods.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;
  #44 = Class              #46            // java/lang/runtime/ObjectMethods
  #45 = NameAndType        #47:#48        // bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;
  #46 = Utf8               java/lang/runtime/ObjectMethods
  #47 = Utf8               bootstrap
  #48 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;
  #49 = String             #50            // x;y
  #50 = Utf8               x;y
  #51 = MethodHandle       1:#7           // REF_getField Point.x:F
  #52 = MethodHandle       1:#13          // REF_getField Point.y:F
  #53 = Utf8               InnerClasses
  #54 = Class              #55            // java/lang/invoke/MethodHandles$Lookup
  #55 = Utf8               java/lang/invoke/MethodHandles$Lookup
  #56 = Class              #57            // java/lang/invoke/MethodHandles
  #57 = Utf8               java/lang/invoke/MethodHandles
  #58 = Utf8               Lookup
{
  private final float x;
    descriptor: F
    flags: (0x0012) ACC_PRIVATE, ACC_FINAL

  private final float y;
    descriptor: F
    flags: (0x0012) ACC_PRIVATE, ACC_FINAL

  public Point(float, float);
    descriptor: (FF)V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Record."&lt;init&gt;":()V
         4: aload_0
         5: fload_1
         6: putfield      #7                  // Field x:F
         9: aload_0
        10: fload_2
        11: putfield      #13                 // Field y:F
        14: return
      LineNumberTable:
        line 1: 0
    MethodParameters:
      Name                           Flags
      x
      y

  public java.lang.String toString();
    descriptor: ()Ljava/lang/String;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokedynamic #18,  0             // InvokeDynamic #0:toString:(LPoint;)Ljava/lang/String;
         6: areturn
      LineNumberTable:
        line 1: 0

  public final int hashCode();
    descriptor: ()I
    flags: (0x0011) ACC_PUBLIC, ACC_FINAL
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokedynamic #22,  0             // InvokeDynamic #0:hashCode:(LPoint;)I
         6: ireturn
      LineNumberTable:
        line 1: 0

  public final boolean equals(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Z
    flags: (0x0011) ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: invokedynamic #26,  0             // InvokeDynamic #0:equals:(LPoint;Ljava/lang/Object;)Z
         7: ireturn
      LineNumberTable:
        line 1: 0

  public float x();
    descriptor: ()F
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #16                 // Field x:F
         4: freturn
      LineNumberTable:
        line 1: 0

  public float y();
    descriptor: ()F
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #17                 // Field y:F
         4: freturn
      LineNumberTable:
        line 1: 0
}
SourceFile: "Point.java"
Record:
  float x;
    descriptor: F

  float y;
    descriptor: F

BootstrapMethods:
  0: #42 REF_invokeStatic java/lang/runtime/ObjectMethods.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/TypeDescriptor;Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/Object;
    Method arguments:
      #8 Point
      #49 x;y
      #51 REF_getField Point.x:F
      #52 REF_getField Point.y:F
InnerClasses:
  public static final #58= #54 of #56;    // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</pre></details>
<br/>
<p>В реализации <code class="text-nowrap">toString()</code>, <code class="text-nowrap">hashCode()</code> и <code class="text-nowrap">equals()</code> мы видим <code class="text-nowrap">invokedynamic</code>. Значит, логика этих методов будет генерироваться лениво самой виртуальной машиной. Я не большой специалист по рантайму, но думаю, что это сделано для лучшей эффективности. Например, если в будущем придумают какой-нибудь более быстрый хеш, то в таком подходе старый скомпилированный код получит все преимущества новой версии. Также это уменьшает размер class-файлов.</p>
<p>Но что-то мы слишком сильно углубились. Вернёмся к нашим <del>баранам</del> записям. Давайте попробуем создать экземпляр <code class="text-nowrap">Point</code> и посмотрим, как работают методы. С этого момента я больше не буду использовать <code class="text-nowrap">javac</code> и просто буду запускать java-файл напрямую:</p>
<pre class="border p-lg-2 p-1">…
<span style="color: blue">public class</span> Main {
    <span style="color: blue">public static void</span> main(String[] args) {
        <span style="color: blue">var</span> point = <span style="color: blue">new</span> Point(1, 2);
        System.out.println(point);
        System.out.println(<span style="color: darkred">"hashCode = "</span> + point.hashCode());
        System.out.println(<span style="color: darkred">"hashCode2 = "</span> + Objects.hash(point.x(), point.y()));

        <span style="color: blue">var</span> point2 = <span style="color: blue">new</span> Point(1, 2);
        System.out.println(point.equals(point2));
    }
}

<span style="color: blue">record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Main.java
Note: Main.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
Point[x=1.0, y=2.0]
hashCode = -260046848
hashCode2 = -260045887
true</pre>
<p>Таким образом, <code class="text-nowrap">toString()</code> и <code class="text-nowrap">equals()</code> работают как я и ожидал (ну разве что <code class="text-nowrap">toString()</code> использует квадратные скобки, а я хотел бы фигурные). А вот <code class="text-nowrap">hashCode()</code> работает иначе. Я почему-то полагал, что он будет совместимым с <code class="text-nowrap">Objects.hash()</code>. Но ничто нам не мешает создать свою реализацию <code class="text-nowrap">hashCode()</code>. Давайте так и сделаем, а заодно перенесём метод <code class="text-nowrap">main()</code> внутрь:</p>
<pre class="border p-lg-2 p-1">…
<span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    @Override
    <span style="color: blue">public int</span> hashCode() {
        <span style="color: blue">return</span> Objects.hash(x, y);
    }

    <span style="color: blue">public static void</span> main(String[] args) {
        System.out.println(<span style="color: blue">new</span> Point(1, 2).hashCode());
    }
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
-260045887</pre>
<p>ОК. А теперь давайте проверим компилятор на стойкость. Сделаем что-нибудь некорректное, например, добавим поле:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">private float</span> z;
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: field declaration must be static
    private float z;
                  ^
  (consider replacing field with record component)</pre>
<p>Значит, можно добавлять только статические поля.</p>
<p>Интересно, что будет, если сделать компоненты <code class="text-nowrap">final</code>? Станут ещё финальнее?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">final float</span> x, <span style="color: blue">final float</span> y) {
}</pre>
<pre class="border p-lg-2 p-1">Point.java:1: error: record components cannot have modifiers
public record Point(final float x, final float y) {
                    ^
Point.java:1: error: record components cannot have modifiers
public record Point(final float x, final float y) {
                                   ^</pre>
<p>Пожалуй, это логичный запрет. Чтобы не было иллюзии того, будто бы компоненты станут изменяемыми, если убрать <code class="text-nowrap">final</code>. Да и аналогичное правило есть у <code class="text-nowrap">enum</code>, так что ничего нового:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">enum</span> A {
    <span style="color: blue">final</span> X;
    <span style="color: green">// No modifiers allowed for enum constants</span>
}</pre>
<p>Что если переопределить тип метода доступа?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public double</span> x() {
        <span style="color: blue">return</span> x;
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: invalid accessor method in record Point
    public double x() {
                  ^
  (return type of accessor method x() is not compatible with type of record component x)</pre>
<p>Это абсолютно логично.</p>
<p>А если изменить видимость?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">private float</span> x() {
        <span style="color: blue">return</span> x;
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: invalid accessor method in record Point
    private float x() {
                  ^
  (accessor method must be public)</pre>
<p>Тоже нельзя.</p>
<p>Наследоваться от классов запрещено, даже от <code class="text-nowrap">Object</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) <span style="color: blue">extends</span> Object {
}</pre>
<pre class="border p-lg-2 p-1">Point.java:1: error: '{' expected
public record Point(float x, float y) extends Object {
                                     ^</pre>
<p>А вот реализовывать интерфейсы можно:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) <span style="color: blue">implements</span> PointLike {
    <span style="color: blue">public static void</span> main(String[] args) {
        PointLike point = <span style="color: blue">new</span> Point(1, 2);
        System.out.println(point.x());
        System.out.println(point.y());
    }
}

<span style="color: blue">public interface</span> PointLike {
    <span style="color: blue">float</span> x();
    <span style="color: blue">float</span> y();
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
1.0
2.0</pre>
<p>Интересно немного поиграться с каноническим конструктором. Во-первых, давайте напишем компактный канонический конструктор, т.е. канонический конструктор без аргументов, и добавим туда валидацию входных параметров:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public</span> Point {
        <span style="color: blue">if</span> (Float.isNaN(x) || Float.isNaN(y)) {
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"NaN"</span>);
        }
    }

    <span style="color: blue">public static void</span> main(String[] args) {
        System.out.println(<span style="color: blue">new</span> Point(Float.NaN, 2));
    }
}</pre>
<pre class="border p-lg-2 p-1">…
Exception in thread "main" java.lang.IllegalArgumentException: NaN
        at Point.&lt;init&gt;(Point.java:4)
        at Point.main(Point.java:9)</pre>
<p>Заработало. А вот интересно, заработает ли, если написать тот же самый код, но через <code class="text-nowrap">return</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public</span> Point {
        <span style="color: blue">if</span> (!Float.isNaN(x) && !Float.isNaN(y)) {
            <span style="color: blue">return</span>;
        }
        <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"NaN"</span>);
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: invalid compact constructor in record Point(float,float)
    public Point {
           ^
  (compact constructor must not have return statements)</pre>
<p>Интересная деталь. Вряд ли мне это сильно помешает в жизни, так как я не любитель писать <code class="text-nowrap">return</code>, но всяким разработчикам IDE это нужно иметь в виду.</p>
<p>Давайте попробуем явный канонический конструктор. Интересно, можно ли переименовать параметры?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public</span> Point(<span style="color: blue">float</span> _x, <span style="color: blue">float</span> _y) {
        <span style="color: blue">if</span> (Float.isNaN(_x) || Float.isNaN(_y)) {
            <span style="color: blue">throw new</span> IllegalArgumentException(<span style="color: darkred">"NaN"</span>);
        }
        <span style="color: blue">this</span>.x = _x;
        <span style="color: blue">this</span>.y = _y;
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: invalid canonical constructor in record Point
    public Point(float _x, float _y) {
           ^
  (invalid parameter names in canonical constructor)</pre>
<p>Оказывается, нельзя переименовать. Но я не вижу ничего плохого в таком ограничении. Код чище будет.</p>
<p>А что там с порядком инициализации?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public</span> Point {
        System.out.println(<span style="color: blue">this</span>);
    }

    <span style="color: blue">public static void</span> main(String[] args) {
        System.out.println(<span style="color: blue">new</span> Point(-1, 2));
    }
}</pre>
<pre class="border p-lg-2 p-1">…
Point[x=0.0, y=0.0]
Point[x=-1.0, y=2.0]</pre>
<p>Сначала напечатался <code class="text-nowrap">Point</code> с нулями, значит присваивание полей произошло в самом конце конструктора, после <code class="text-nowrap">System.out.println(this)</code>.</p>
<p>Хорошо. Как насчёт добавления неканонического конструктора? Например, конструктора без аргументов:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public</span> Point() {
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:2: error: constructor is not canonical, so its first statement must invoke another constructor
    public Point() {
           ^</pre>
<p>Ага, забыли написать <code class="text-nowrap">this(0, 0)</code>. Но не будем пробовать исправлять и проверять это.</p>
<p>Что насчёт дженериков?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point&lt;A <span style="color: blue">extends</span> Number&gt;(A x, A y) {
    <span style="color: blue">public static void</span> main(String[] args) {
        System.out.println(<span style="color: blue">new</span> Point<>(-1, 2));
    }
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
Point[x=-1, y=2]</pre>
<p>Ничего сверхъестественного. Ну разве что надо помнить, что параметры типа нужно ставить раньше параметров записи.</p>
<p>Можно ли создать запись без компонент?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> None() {
    <span style="color: blue">public static void</span> main(String[] args) {
        System.out.println(<span style="color: blue">new</span> None());
    }
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 None.java
Note: None.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
None[]</pre>
<p>Почему нет.</p>
<p>Какие вещи мы ещё не попробовали? Что там со вложенными записями?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">record</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) {
    <span style="color: blue">record</span> Nested(<span style="color: blue">int</span> z) {
        <span style="color: blue">void</span> print() {
            System.out.println(x);
        }
    }
}</pre>
<pre class="border p-lg-2 p-1">Point.java:4: error: non-static record component x cannot be referenced from a static context
            System.out.println(x);
                               ^</pre>
<p>Значит, вложенные записи всегдя являются статическими (как и <code class="text-nowrap">enum</code>). Если это так, то что если объявить локальную запись? По идее, тогда она не должна захватывать внешний нестатический контекст:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Main {
    <span style="color: blue">public static void</span> main(String[] args) {
        <span style="color: blue">record</span> Point(<span style="color: blue">int</span> x, <span style="color: blue">int</span> y) {
            <span style="color: blue">void</span> print() {
                System.out.println(Arrays.toString(args));
            }
        }

        <span style="color: blue">new</span> Point(1, 2).print();
    }
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Main.java
Note: Main.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
[]</pre>
<p>Хм, сработало. Думаю, это баг. Или просто недоделка: такое поведение унаследовалось от обычных локальных классов, которые умеют захватывать внешние effectively <code class="text-nowrap">final</code> переменные, а для записей поправить забыли.</p>
<p>Один больной вопрос, который меня интересует: можно ли создать несколько публичных записей в одном файле?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
}

<span style="color: blue">public record</span> Point2(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
}</pre>
<pre class="border p-lg-2 p-1">&gt; javac --enable-preview --release 14 Point.java
Point.java:4: error: class Point2 is public, should be declared in a file named Point2.java
public record Point2(float x, float y) {
       ^</pre>
<p>Нельзя. Интересно, будет ли это проблемой в реальных проектах? Наверняка многие захотят писать очень много записей, чтобы моделировать свои сущности. Тогда придётся всех их раскладывать по собственным файлам, либо использовать вложенные записи.</p>
<p>Напоследок я ещё хотел бы поиграться с рефлексией. Как во время выполнения узнать информацию о компонентах, которые содержит запись? Для это можно использовать метод <a href="https://download.java.net/java/early_access/jdk14/docs/api/java.base/java/lang/Class.html#getRecordComponents()">Class.getRecordComponents()</a>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">import</span> java.lang.reflect.RecordComponent;

<span style="color: blue">public record</span> Point(<span style="color: blue">float</span> x, <span style="color: blue">float</span> y) {
    <span style="color: blue">public static void</span> main(String[] args) {
        <span style="color: blue">var</span> point = <span style="color: blue">new</span> Point(1, 2);
        <span style="color: blue">for</span> (RecordComponent component : point.getClass().getRecordComponents()) {
            System.out.println(component);
        }
    }
}</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
float x
float y</pre>
<p>Также я заметил, что в Java 14 появился новый тип аннотации специально для компонентов записей: <code class="text-nowrap"><a href="https://download.java.net/java/early_access/jdk14/docs/api/java.base/java/lang/annotation/ElementType.html#RECORD_COMPONENT">ElementType.RECORD_COMPONENT</a></code>. А что будет, если использовать старые типы <code class="text-nowrap">FIELD</code> и <code class="text-nowrap">PARAMETER</code>? Ведь компоненты вроде бы как и не поля, и не параметры:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(
        @FieldAnnotation @ComponentAnnotation <span style="color: blue">float</span> x,
        @ParamAnnotation @ComponentAnnotation <span style="color: blue">float</span> y) {
}

@Target(ElementType.FIELD)
<span style="color: blue">@interface</span> FieldAnnotation { }

@Target(ElementType.PARAMETER)
<span style="color: blue">@interface</span> ParamAnnotation { }

@Target(ElementType.RECORD_COMPONENT)
<span style="color: blue">@interface</span> ComponentAnnotation { }</pre>
<p>Ага, код компилируется, значит работают все три. Ну это логично. Интересно, а будут ли они &laquo;протаскиваться&raquo; на поля?</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public record</span> Point(
        @FieldAnnotation @ComponentAnnotation <span style="color: blue">float</span> x,
        @ParamAnnotation @ComponentAnnotation <span style="color: blue">float</span> y) {
    <span style="color: blue">public static void</span> main(String[] args) {
        <span style="color: blue">var</span> point = <span style="color: blue">new</span> Point(1, 2);
        Field[] fields = point.getClass().getDeclaredFields();
        <span style="color: blue">for</span> (Field field : fields) {
            <span style="color: blue">for</span> (Annotation annotation : field.getAnnotations()) {
                System.out.println(field + <span style="color: darkred">": "</span> + annotation);
            }
        }
    }
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
<span style="color: blue">@interface</span> FieldAnnotation { }

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
<span style="color: blue">@interface</span> ParamAnnotation { }

@Target(ElementType.RECORD_COMPONENT)
@Retention(RetentionPolicy.RUNTIME)
<span style="color: blue">@interface</span> ComponentAnnotation { }</pre>
<pre class="border p-lg-2 p-1">&gt; java --enable-preview --source 14 Point.java
Note: Point.java uses preview language features.
Note: Recompile with -Xlint:preview for details.
private final float Point.x: @FieldAnnotation()</pre>
<p>Значит, &laquo;протаскиваются&raquo; только аннотации <code class="text-nowrap">FIELD</code>, но не <code class="text-nowrap">RECORD_COMPONENT</code> и <code class="text-nowrap">PARAMETER</code>.</p>
<p>На этом, пожалуй, я закончу, потому что статья и так уже вышла довольно громоздкой. Можно было бы &laquo;копать&raquo; ещё долго и глубоко, тестируя всякие разные краевые случаи, но думаю, текущего уровня глубины более чем достаточно.</p>
<h4>Заключение</h4>
<p>Записи – это несомненно крутая и очень ожидаемая сообществом вещь, которая в будущем будет экономить нам время и избавит нас от огромного количества шаблонного кода. Сейчас записи уже практически готовы, и осталось только подождать, когда починят <a href="https://bugs.openjdk.java.net/browse/JDK-8236005">некоторые</a> <a href="https://bugs.openjdk.java.net/browse/JDK-8236210">шероховатости</a> и выпустят общедоступный релиз Java 14. Правда, потом ещё нужно будет подождать 1-2 релиза, когда записи станут стабильными, но при большом желании их можно использовать в preview-режиме.</p>
<p>А те, кто не спешат переходить с Java 8, думаю, надо дождаться сентября 2021 года, и сразу перейти на Java 17, где уже будут стабильные <a href="switch_expressions.html">выражения <code class="text-nowrap">switch</code></a>, <a href="text_blocks.html">блоки текста</a>, <a href="trying_new_instanceof_in_java_14.html">улучшенный <code class="text-nowrap">instanceof</code></a>, <a href="records_and_sealed_types.html">записи и запечатанные типы</a> (с большой вероятностью).</p>
  </article>
  <p class="pt-4 fst-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2024" role="button" aria-expanded="false" aria-controls="year2024">2024</a>
  <ul class="collapse" id="year2024">
<li class="text-secondary"><a href="java_22.html" class="text-secondary">Вышла Java 22</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2023" role="button" aria-expanded="false" aria-controls="year2023">2023</a>
  <ul class="collapse" id="year2023">
<li class="text-secondary"><a href="java_21.html" class="text-secondary">Вышла Java 21</a></li>
<li class="text-secondary"><a href="java_news_57.html" class="text-secondary">Новости Java #57</a></li>
<li class="text-secondary"><a href="java_news_56.html" class="text-secondary">Новости Java #56</a></li>
<li class="text-secondary"><a href="java_20.html" class="text-secondary">Вышла Java 20</a></li>
<li class="text-secondary"><a href="java_news_55.html" class="text-secondary">Новости Java #55</a></li>
<li class="text-secondary"><a href="java_news_54.html" class="text-secondary">Новости Java #54</a></li>
<li class="text-secondary"><a href="java_news_53.html" class="text-secondary">Новости Java #53</a></li>
<li class="text-secondary"><a href="java_news_52.html" class="text-secondary">Новости Java #52</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2022" role="button" aria-expanded="false" aria-controls="year2022">2022</a>
  <ul class="collapse" id="year2022">
<li class="text-secondary"><a href="java_news_51.html" class="text-secondary">Новости Java #51</a></li>
<li class="text-secondary"><a href="java_news_50.html" class="text-secondary">Новости Java #50</a></li>
<li class="text-secondary"><a href="java_news_49.html" class="text-secondary">Новости Java #49</a></li>
<li class="text-secondary"><a href="java_news_48.html" class="text-secondary">Новости Java #48</a></li>
<li class="text-secondary"><a href="java_news_47.html" class="text-secondary">Новости Java #47</a></li>
<li class="text-secondary"><a href="java_news_46.html" class="text-secondary">Новости Java #46</a></li>
<li class="text-secondary"><a href="java_news_45.html" class="text-secondary">Новости Java #45</a></li>
<li class="text-secondary"><a href="java_19.html" class="text-secondary">Вышла Java 19</a></li>
<li class="text-secondary"><a href="java_news_44.html" class="text-secondary">Новости Java #44</a></li>
<li class="text-secondary"><a href="java_news_43.html" class="text-secondary">Новости Java #43</a></li>
<li class="text-secondary"><a href="java_news_42.html" class="text-secondary">Новости Java #42</a></li>
<li class="text-secondary"><a href="java_news_41.html" class="text-secondary">Новости Java #41</a></li>
<li class="text-secondary"><a href="java_news_40.html" class="text-secondary">Новости Java #40</a></li>
<li class="text-secondary"><a href="java_news_39.html" class="text-secondary">Новости Java #39</a></li>
<li class="text-secondary"><a href="java_news_38.html" class="text-secondary">Новости Java #38</a></li>
<li class="text-secondary"><a href="java_news_37.html" class="text-secondary">Новости Java #37</a></li>
<li class="text-secondary"><a href="java_18.html" class="text-secondary">Вышла Java 18</a></li>
<li class="text-secondary"><a href="java_news_36.html" class="text-secondary">Новости Java #36</a></li>
<li class="text-secondary"><a href="java_news_35.html" class="text-secondary">Новости Java #35</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_34.html" class="text-secondary">Новости Java #34</a></li>
<li class="text-secondary"><a href="java_news_33.html" class="text-secondary">Новости Java #33</a></li>
<li class="text-secondary"><a href="java_news_32.html" class="text-secondary">Новости Java #32</a></li>
<li class="text-secondary"><a href="java_news_31.html" class="text-secondary">Новости Java #31</a></li>
<li class="text-secondary"><a href="java_news_30.html" class="text-secondary">Новости Java #30</a></li>
<li class="text-secondary"><a href="java_news_29.html" class="text-secondary">Новости Java #29</a></li>
<li class="text-secondary"><a href="java_news_28.html" class="text-secondary">Новости Java #28</a></li>
<li class="text-secondary"><a href="java_17.html" class="text-secondary">Вышла Java 17</a></li>
<li class="text-secondary"><a href="java_news_27.html" class="text-secondary">Новости Java #27</a></li>
<li class="text-secondary"><a href="java_news_26.html" class="text-secondary">Новости Java #26</a></li>
<li class="text-secondary"><a href="java_news_25.html" class="text-secondary">Новости Java #25</a></li>
<li class="text-secondary"><a href="java_news_24.html" class="text-secondary">Новости Java #24</a></li>
<li class="text-secondary"><a href="java_news_23.html" class="text-secondary">Новости Java #23</a></li>
<li class="text-secondary"><a href="java_news_22.html" class="text-secondary">Новости Java #22</a></li>
<li class="text-secondary"><a href="java_news_21.html" class="text-secondary">Новости Java #21</a></li>
<li class="text-secondary"><a href="java_news_20.html" class="text-secondary">Новости Java #20</a></li>
<li class="text-secondary"><a href="java_news_19.html" class="text-secondary">Новости Java #19</a></li>
<li class="text-secondary"><a href="java_news_18.html" class="text-secondary">Новости Java #18</a></li>
<li class="text-secondary"><a href="java_news_17.html" class="text-secondary">Новости Java #17</a></li>
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2020" role="button" aria-expanded="false" aria-controls="year2020">2020</a>
  <ul class="collapse" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</a></li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2019" role="button" aria-expanded="true" aria-controls="year2019">2019</a>
  <ul class="collapse show" id="year2019">
<li>Исследуем записи в Java 14</li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-bs-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
    </div>
  </div>
</div>
<div class="container d-md-flex flex-row">
  <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
  <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/mini_JUG">Евгений Козлов</a>, 2017-2023</div>
  <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.ru/feed.xml">Feed</a></div>
  <div class="p-lg-4 p-3 text-secondary"><a href="jeps.html">Table of JEPs</a></div>
</div>
    <script src="bootstrap.bundle.min.js"></script>
    <script></script>
  </body>
</html>
