<!doctype html>
<html>
  <head>
    <title>API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:type" content="article">
    <meta property="og:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 1">
    <meta property="og:description" content="На сегодняшний день Java 8 является самой популярной версией Java и ещё довольно долго будет ей оставаться. Однако с тех пор уже выпущено пять новых версий Java (9, 10, 11, 12, 13), и совсем скоро&hellip;">
    <meta property="og:site_name" content="miniJUG">
    <meta property="article:published_time" content="2020-01-28">
    <meta property="article:author" content="Zheka Kozlov">
    <meta property="article:author_url" content="https://twitter.com/ZhekaKozlov">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@ZhekaKozlov">
    <meta name="twitter:title" content="API, ради которых наконец-то стоит обновиться с Java 8. Часть 1">
    <meta name="twitter:description" content="На сегодняшний день Java 8 является самой популярной версией Java и ещё довольно долго будет ей оставаться. Однако с тех пор уже выпущено пять новых версий Java (9, 10, 11, 12, 13), и совсем скоро&hellip;">
    <meta name="telegram:channel" content="@miniJUG">
    <meta property="og:image" content="https://minijug.ru/api_to_upgrade_from_java_8.png">
    <meta property="og:image:width" content="879">
    <meta property="og:image:height" content="462">
    <meta name="twitter:image" content="https://minijug.ru/api_to_upgrade_from_java_8.png">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="/favicon192.png" type="image/png" sizes="192x192">
    <link rel="stylesheet" href="bootstrap.min.css">
  </head>
  <body class="bg-light">
    <div class="container">
      <div class="row">
        <div class="p-lg-4 p-3 bg-white rounded col-lg-8" style="font-size: 1.15rem">
<h3 id="title">API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</h3>
<p class="text-secondary"><time datetime="2020-01-28">28 января, 2020</time></p>
<article>
<p>На сегодняшний день Java 8 является самой популярной версией Java и ещё довольно долго будет ей оставаться. Однако с тех пор уже выпущено пять новых версий Java (9, 10, 11, 12, 13), и совсем скоро выйдет ещё одна, Java 14. В этих новых версиях появилось гигантское количество новых возможностей. Например, если считать в JEP'ах, то в сумме их было реализовано 141:</p>
<ul>
  <li>99 в <a href="https://openjdk.java.net/projects/jdk9/">JDK 9</a></li>
  <li>12 в <a href="https://openjdk.java.net/projects/jdk/10/">JDK 10</a></li>
  <li>17 в <a href="https://openjdk.java.net/projects/jdk/11/">JDK 11</a></li>
  <li>8 в <a href="https://openjdk.java.net/projects/jdk/12/">JDK 12</a></li>
  <li>5 в <a href="https://openjdk.java.net/projects/jdk/13/">JDK 13</a></li>
  <li class="text-secondary">(+14 в <a href="https://openjdk.java.net/projects/jdk/14/">JDK 14</a>)</li>
</ul>
<p>Однако в этом цикле статей не будет никакого сухого перечисления JEP'ов. Вместо этого я хочу просто рассказать об интересных API, которые появились в новых версиях. Каждая статья будет содержать по 10 API. В выборе и порядке этих API не будет какой-то определённой логики и закономерности. Это будет просто 10 случайных API, не ТОП 10 и без сортировки от наиболее важного API к наименее важному. Давайте начнём.</p>
<!-- cut -->
<h4>1. Методы <code class="text-nowrap">Objects.requireNonNullElse()</code> и <code class="text-nowrap">Objects.requireNonNullElseGet()</code></h4>
<h5>Появились в: Java 9</h5>
<p>Начнём мы наш список с двух очень простеньких, но очень полезных методов в классе <code class="text-nowrap">java.util.Objects</code>: <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html#requireNonNullElse(T,T)">requireNonNullElse()</a></code> и <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html#requireNonNullElseGet(T,java.util.function.Supplier)">requireNonNullElseGet()</a></code>. Эти методы позволяют вернуть передаваемый объект, если он не <code class="text-nowrap">null</code>, а если он <code class="text-nowrap">null</code>, то вернуть объект по умолчанию. Например:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> MyCoder {
    <span style="color: blue">private final</span> Charset charset;

    MyCoder(Charset charset) {
        <span style="color: blue">this</span>.charset = Objects.requireNonNullElse(
                charset, StandardCharsets.UTF_8);
    }
}</pre>
<p><code class="text-nowrap">requireNonNullElseGet()</code> &ndash; это не что иное, как просто ленивая версия <code class="text-nowrap">requireNonNullElse()</code>. Она может пригодиться, если вычисление аргумента по умолчанию является затратным:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> MyCoder {
    <span style="color: blue">private final</span> Charset charset;

    MyCoder(Charset charset) {
        <span style="color: blue">this</span>.charset = Objects.requireNonNullElseGet(
                charset, MyCoder::defaultCharset);
    }

    <span style="color: blue">private static</span> Charset defaultCharset() {
        <span style="color: green">// long operation...</span>
    }
}</pre>
<p>Да, конечно же в обоих случаях можно было бы легко обойтись и без этих функций, например, использовать обычный тернарный оператор или <code class="text-nowrap">Optional</code>, но всё же использование специальной функции делает код немножко короче и чище. А если использовать статический импорт и писать просто <code class="text-nowrap">requireNonNullElse()</code> вместо <code class="text-nowrap">Objects.requireNonNullElse()</code>, то код код можно сократить ещё сильнее.</p>

<h4>2. Методы-фабрики, возвращающие неизменяемые коллекции</h4>
<h5>Появились в: Java 9</h5>
<p>Если предыдущие два метода – это просто косметика, то статические методы-фабрики коллекций позволяют действительно сильно сократить код и даже улучшить его безопасность. Речь о следующих методах, <a href="https://openjdk.java.net/jeps/269">появившихся</a> в Java 9:</p>
<ul>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html#of(E...)">List.of(E... elements)</a></code> (и перегрузки)</li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html#of(E...)">Set.of(E... elements)</a></code> (и перегрузки)</li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html#of(K,V,K,V)">Map.of(K k1, V v1, K k2, V v2, ...)</a></code> (и перегрузки)</li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html#ofEntries(java.util.Map.Entry...)">Map.ofEntries(Entry&lt;? extends K, ? extends V&gt;... entries)</a></code></li>
</ul>
<p>К этому же списку можно добавить сопутствующий метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html#entry(K,V)">Map.entry(K k, V v)</a></code>, создающий <code class="text-nowrap">Entry</code> из ключа и значения, а также методы копирования коллекций, которые <a href="unmodifiable_collections_enhancements_in_java_10.html">появились</a> в Java 10:</p>
<ul>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html#copyOf(java.util.Collection)">List.copyOf(Collection&lt;? extends E&gt; coll)</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html#copyOf(java.util.Collection)">Set.copyOf(Collection&lt;? extends E&gt; coll)</a></code></li>
  <li><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html#copyOf(java.util.Map)">Map.copyOf(Map&lt;? extends K,​? extends V&gt; map)</a></code></li>
</ul>
<p>Статические методы-фабрики позволяют создать неизменяемую коллекцию и инициализировать её в одно действие:</p>
<pre class="border p-lg-2 p-1">List&lt;String&gt; imageExtensions = List.of(<span style="color: darkred">"bmp"</span>, <span style="color: darkred">"jpg"</span>, <span style="color: darkred">"png"</span>, <span style="color: darkred">"gif"</span>);</pre>
<p>Если не пользоваться сторонними библиотеками, то аналогичный код на Java 8 выглядит гораздо более громоздким:</p>
<pre class="border p-lg-2 p-1">List&lt;String&gt; imageExtensions = Collections.unmodifiableList(
        Arrays.asList(<span style="color: darkred">"bmp"</span>, <span style="color: darkred">"jpg"</span>, <span style="color: darkred">"png"</span>, <span style="color: darkred">"gif"</span>));</pre>
<p>А в случае с <code class="text-nowrap">Set</code> или <code class="text-nowrap">Map</code> всё ещё печальнее, потому что аналогов <code class="text-nowrap">Arrays.asList()</code> для <code class="text-nowrap">Set</code> и <code class="text-nowrap">Map</code> не существует.</p>
<p>Такая громоздкость провоцирует многих людей, пишуших на Java 8, вообще отказываться от неизменяемых коллекций и всегда использовать обычные <code class="text-nowrap">ArrayList</code>, <code class="text-nowrap">HashSet</code> и <code class="text-nowrap">HashMap</code>, причём даже там, где по смыслу нужны неизменяемые коллекции. В результате это ломает концепцию immutable-by-default и снижает безопасность кода.</p>
<p>Если же наконец обновиться с Java 8, то работать с неизменяемыми коллекциями становится намного проще и приятнее благодаря методам-фабрикам.</p>

<h4>3. <code class="text-nowrap">Files.readString()</code> и <code class="text-nowrap">Files.writeString()</code></h4>
<h5>Появились в: Java 11</h5>
<p>Java всегда была известна своей неспешностью вводить готовые методы для частых операций. Например, для одной из самых востребованных операций в программировании, чтения файла, очень долго не было готового метода. Лишь спустя 15 лет после выхода Java 1.0 появилось NIO, где был введён метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html#readAllBytes(java.nio.file.Path)">Files.readAllBytes()</a></code> для чтения файла в массив байтов.</p>
<p>Но этого всё ещё не хватало, потому что людям часто приходится работать с текстовыми файлами и для этого нужно читать из файла строки, а не байты. Поэтому в Java 8 добавили метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html#readAllLines(java.nio.file.Path)">Files.readAllLines()</a></code>, возвращающий <code class="text-nowrap">List&lt;String&gt;</code>.</p>
<p>Однако и этого было недостаточно, так как люди спрашивали, как просто прочитать весь файл в виде одной строки. В итоге, для полноты картины в Java 11 добавили долгожданный метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path)">Files.readString()</a></code>, тем самым окончательно закрыв этот вопрос. Удивительно, что если аналогичный метод присутствовал во многих других языках с самого начала, то Java для этого потребовалось больше 20 лет.</p>
<p>Вместе с <code class="text-nowrap">readString()</code> конечно же ввели и симметричный метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html#writeString(java.nio.file.Path,java.lang.CharSequence,java.nio.file.OpenOption...)">writeString()</a></code>. Также у этих методов есть перегрузки, позволяющие указать <code class="text-nowrap">Charset</code>. В совокупности всё это делает работу с текстовыми файлами чрезвычайно удобной. Пример:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">/** Перекодировать файл из одной кодировки в другую */</span>
<span style="color: blue">private void</span> reencodeFile(Path path,
                          Charset from,
                          Charset to) <span style="color: blue">throws</span> IOException {
    String content = Files.readString(path, from);
    Files.writeString(path, content, to);
}</pre>

<h4>4. <code class="text-nowrap">Optional.ifPresentOrElse()</code> и <code class="text-nowrap">Optional.stream()</code></h4>
<h5>Появились в: Java 9</h5>
<p>Когда <code class="text-nowrap">Optional</code> появился в Java 8, для него не сделали удобного способа выполнить два разных действия в зависимости от того, есть ли в нём значение или нет. В итоге людям приходится прибегать к обычной цепочке <code class="text-nowrap">isPresent()</code> и <code class="text-nowrap">get()</code>:</p>
<pre class="border p-lg-2 p-1">Optional&lt;String&gt; opt = ...
<span style="color: blue">if</span> (opt.isPresent()) {
    log.info(<span style="color: darkred">"Value = "</span> + opt.get());
} <span style="color: blue">else</span> {
    log.error(<span style="color: darkred">"Empty"</span>);
}</pre>
<p>Либо можно извернуться ещё таким образом:</p>
<pre class="border p-lg-2 p-1">Optional&lt;String&gt; opt = ...
opt.ifPresent(str ->
    log.info(<span style="color: darkred">"Value = "</span> + str));
<span style="color: blue">if</span> (opt.isEmpty()) {
    log.error(<span style="color: darkred">"Empty"</span>);
}</pre>
<p>Оба варианта не идеальны. Но, начиная с Java 9, такое можно сделать элегантно с помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html#ifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)">Optional.ifPresentOrElse()</a></code>:</p>
<pre class="border p-lg-2 p-1">Optional&lt;String&gt; opt = ...
opt.ifPresentOrElse(
    str -> log.info(<span style="color: darkred">"Value = "</span> + str),
    () -> log.error(<span style="color: darkred">"Empty"</span>));</pre>
<p>Ещё одним новым интересным методом в Java 9 стал <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html#stream()">Optional.stream()</a></code>, который возвращает <code class="text-nowrap">Stream</code> из одного элемента, если значение присутствует, и пустой <code class="text-nowrap">Stream</code>, если отсутствует. Такой метод может быть очень полезен в цепочках с <code class="text-nowrap">flatMap()</code>. Например, в этом примере очень просто получить список всех телефонных номеров компании:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Employee {
    Optional&lt;String&gt; getPhoneNumber() { ... }
}

<span style="color: blue">class</span> Department {
    List&lt;Employee&gt; getEmployees() { ... }
}

<span style="color: blue">class</span> Company {
    List&lt;Department&gt; getDepartments() { ... }

    Set&lt;String&gt; getAllPhoneNumbers() {
        <span style="color: blue">return</span> getDepartments()
            .stream()
            .flatMap(d -> d.getEmployees().stream())
            .flatMap(e -> e.getPhoneNumber().stream())
            .collect(Collectors.toSet());
    }
}</pre>
<p>В Java 8 пришлось бы писать что-нибудь вроде:</p>
<pre class="border p-lg-2 p-1">e -> e.getPhoneNumber().map(Stream::of).orElse(Stream.empty())</pre>
<p>Это выглядит громоздко и не очень читабельно.</p>

<h4>5. <code class="text-nowrap">Process.pid()</code>, <code class="text-nowrap">Process.info()</code> и <code class="text-nowrap">ProcessHandle</code></h4>
<h5>Появились в: Java 9</h5>
<p>Если без предыдущих API обойтись худо-бедно ещё можно, то вот замену метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html#pid()">Process.pid()</a></code> в Java 8 найти будет довольно проблематично, особенно кроссплатформенную. Этот метод возвращает нативный ID процесса:</p>
<pre class="border p-lg-2 p-1">Process process = Runtime.getRuntime().exec(<span style="color: darkred">"java -version"</span>);
System.out.println(process.pid());</pre>
<p>Также с помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html#info()">Process.info()</a></code> можно узнать дополнительную полезную информацию о процессе. Он возвращает объект типа <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.Info.html">ProcessHandle.Info</a></code>. Давайте посмотрим, что он вернёт нам для процесса выше:</p>
<pre class="border p-lg-2 p-1">Process process = Runtime.getRuntime().exec(<span style="color: darkred">"java -version"</span>);
ProcessHandle.Info info = process.info();
System.out.println(<span style="color: darkred">"PID = "</span> + process.pid());
System.out.println(<span style="color: darkred">"User = "</span> + info.user());
System.out.println(<span style="color: darkred">"Command = "</span> + info.command());
System.out.println(<span style="color: darkred">"Args = "</span> + info.arguments().map(Arrays::toString));
System.out.println(<span style="color: darkred">"Command Line = "</span> + info.commandLine());
System.out.println(<span style="color: darkred">"Start Time = "</span> + info.startInstant());
System.out.println(<span style="color: darkred">"Total Time = "</span> + info.totalCpuDuration());</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">PID = 174
User = Optional[orionll]
Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java]
Args = Optional[[-version]]
Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java -version]
Start Time = Optional[2020-01-24T05:54:25.680Z]
Total Time = Optional[PT0.01S]</pre>
<p>Что делать, если процесс был запущен не из текущего Java-процесса? Для этого на помощь приходит <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html">ProcessHandle</a></code>. Например, давайте достанем всю ту же самую информацию для текущего процесса с помощью метода <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html#current()">ProcessHandle.current()</a></code>:</p>
<pre class="border p-lg-2 p-1">ProcessHandle handle = ProcessHandle.current();
ProcessHandle.Info info = handle.info();

System.out.println(<span style="color: darkred">"PID="</span> + handle.pid());
System.out.println(<span style="color: darkred">"User="</span> + info.user());
System.out.println(<span style="color: darkred">"Command="</span> + info.command());
System.out.println(<span style="color: darkred">"Args="</span> + info.arguments().map(Arrays::toString));
System.out.println(<span style="color: darkred">"Command Line="</span> + info.commandLine());
System.out.println(<span style="color: darkred">"Start Time="</span> + info.startInstant());
System.out.println(<span style="color: darkred">"Total Time="</span> + info.totalCpuDuration());</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">PID = 191
User = Optional[orionll]
Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java]
Args = Optional[[Main.java]]
Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java Main.java]
Start Time = Optional[2020-01-24T05:59:17.060Z]
Total Time = Optional[PT1.56S]</pre>
<p>Чтобы получить <code class="text-nowrap">ProcessHandle</code> для любого процесса по его PID, можно использовать метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html#of(long)">ProcessHandle.of()</a></code> (он вернёт <code class="text-nowrap">Optional.empty</code>, если процесса не существует).</p>
<p>Также в <code class="text-nowrap">ProcessHandle</code> есть много других интересных методов, например, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html#allProcesses()">ProcessHandle.allProcesses()</a></code>.</p>

<h4>6. Методы <code class="text-nowrap">String</code>: <code class="text-nowrap">isBlank()</code>, <code class="text-nowrap">strip()</code>, <code class="text-nowrap">stripLeading()</code>, <code class="text-nowrap">stripTrailing()</code>, <code class="text-nowrap">repeat()</code> и <code class="text-nowrap">lines()</code></h4>
<h5>Появились в: Java 11</h5>
<p>Целая гора полезных методов для строк появилась в Java 11.</p>
<p>Метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#isBlank()">String.isBlank()</a></code> позволяет узнать, является ли строка состоящей исключительно из whitespace:</p>
<pre class="border p-lg-2 p-1">System.out.println(<span style="color: darkred">"</span> <span style="color: darkblue">\n</span><span style="color: darkblue">\r</span><span style="color: darkblue">\t</span><span style="color: darkred">"</span>.isBlank()); <span style="color: green">// true</span></pre>
<p>Методы <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#stripLeading()">String.stripLeading()</a></code>, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#stripTrailing()">String.stripTrailing()</a></code> и <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#strip()">String.strip()</a></code> удаляют символы whitespace в начале строки, в конце строки или с обоих концов:</p>
<pre class="border p-lg-2 p-1">String str = <span style="color: darkred">"</span> <span style="color: darkblue">\t</span><span style="color: darkred">Hello, world!</span><span style="color: darkblue">\t</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span>;

String str1 = str.stripLeading(); <span style="color: green">// "Hello, world!\t\n"</span>
String str2 = str.stripTrailing(); <span style="color: green">// " \tHello, world!"</span>
String str3 = str.strip(); // <span style="color: green">"Hello, world!"</span></pre>
<p>Заметьте, что <code class="text-nowrap">String.strip()</code> не то же самое, что <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#trim()">String.trim()</a></code>: второй удаляет только символы, чей код меньше или равен U+0020, а первый удаляет также пробелы из Юникода:</p>
<pre class="border p-lg-2 p-1">System.out.println(<span style="color: darkred">"str</span><span style="color: darkblue">\u2000</span><span style="color: darkred">"</span>.strip()); <span style="color: green">// "str"</span>
System.out.println(<span style="color: darkred">"str</span><span style="color: darkblue">\u2000</span><span style="color: darkred">"</span>.trim()); <span style="color: green">// "str\u2000"</span></pre>

<p>Метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#repeat(int)">String.repeat()</a></code> конкатенирует строку саму с собой <code class="text-nowrap">n</code> раз:</p>
<pre class="border p-lg-2 p-1">System.out.print(<span style="color: darkred">"Hello, world!</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span>.repeat(3));</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">Hello, world!
Hello, world!
Hello, world!</pre>
<p>Наконец, метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#lines()">String.lines()</a></code> разбивает строку на линии. До свидания <code class="text-nowrap">String.split()</code>, с которым люди постоянно путают, какой аргумент для него использовать, то ли <code class="text-nowrap">"\n"</code>, то ли <code class="text-nowrap">"\r"</code> то ли <code class="text-nowrap">"\n\r"</code> (на самом деле, лучше всего использовать регулярное выражение <code class="text-nowrap">"\R"</code>, которое покрывает все комбинации). Кроме того, <code class="text-nowrap">String.lines()</code> зачастую может быть более эффективен, поскольку он возвращает линии лениво.</p>
<pre class="border p-lg-2 p-1">System.out.println(<span style="color: darkred">"line1</span><span style="color: darkblue">\n</span><span style="color: darkred">line2</span><span style="color: darkblue">\n</span><span style="color: darkred">line3</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span>
    .lines()
    .map(String::toUpperCase)
    .collect(Collectors.joining(<span style="color: darkred">"</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span>)));</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">LINE1
LINE2
LINE3</pre>

<h4>7. <code class="text-nowrap">String.indent()</code></h4>
<h5>Появился в: Java 12</h5>
<p>Давайте разбавим наш рассказ чем-нибудь свежим, что появилось совсем недавно. Встречайте: метод <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html#indent(int)">String.indent()</a></code>, который увеличивает (или уменьшает) отступ каждой линии в данной строке на указанную величину. Например:</p>
<pre class="border p-lg-2 p-1">String body = <span style="color: darkred">"&lt;h1&gt;Title&lt;/h1&gt;</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span> +
              <span style="color: darkred">"&lt;p&gt;Hello, world!&lt;/p&gt;"</span>;

System.out.println(<span style="color: darkred">"&lt;html&gt;</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span> +
                   <span style="color: darkred">"  &lt;body&gt;</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span> +
                   body.indent(4) +
                   <span style="color: darkred">"  &lt;/body&gt;</span><span style="color: darkblue">\n</span><span style="color: darkred">"</span> +
                   <span style="color: darkred">"&lt;/html&gt;"</span>);</pre>
<p>Вывод:</p>
<pre class="border p-lg-2 p-1">&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Hello, world!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>Заметьте, что для последней линии <code class="text-nowrap">String.indent()</code> сам вставил перевод строки, поэтому нам не пришлось добавлять <code class="text-nowrap">'\n'</code> после <code class="text-nowrap">body.indent(4)</code>.</p>
<p>Конечно, наибольшый интерес такой метод будет представлять в сочетании с <a href="text_blocks.html">блоками текста</a>, когда они станут стабильными, но ничто не мешает использовать его уже прямо сейчас без всяких блоков текста.</p>

<h4>8. Методы <code class="text-nowrap">Stream</code>: <code class="text-nowrap">takeWhile()</code>, <code class="text-nowrap">dropWhile()</code>, <code class="text-nowrap">iterate()</code> с предикатом и <code class="text-nowrap">ofNullable()</code></h4>
<h5>Появились в: Java 9</h5>
<p><code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)">Stream.takeWhile()</a></code> похож на <code class="text-nowrap">Stream.limit()</code>, но ограничивает <code class="text-nowrap">Stream</code> не по количеству, а по предикату. Такая необходимость в программировании возникает очень часто. Например, если нам надо получить все записи в дневнике за текущий год:</p>
<pre class="border p-lg-2 p-1">[
  { "date" : "2020-01-27", "text" : "..." },
  { "date" : "2020-01-25", "text" : "..." },
  { "date" : "2020-01-22", "text" : "..." },
  { "date" : "2020-01-17", "text" : "..." },
  { "date" : "2020-01-11", "text" : "..." },
  { "date" : "2020-01-02", "text" : "..." },
  { "date" : "2019-12-30", "text" : "..." },
  { "date" : "2019-12-27", "text" : "..." },
  ...
]</pre>
<p><code class="text-nowrap">Stream</code> записей является почти бесконечным, поэтому <code class="text-nowrap">filter()</code> использовать не получится. Тогда на помощь приходит <code class="text-nowrap">takeWhile()</code>:</p>
<pre class="border p-lg-2 p-1">getNotesStream()
    .takeWhile(note -> note.getDate().getYear() == 2020);</pre>
<p>А если мы хотим получить записи за 2019 год, то можно использовать <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)">dropWhile()</a></code>:</p>
<pre class="border p-lg-2 p-1">getNotesStream()
    .dropWhile(note -> note.getDate().getYear() == 2020)
    .takeWhile(note -> note.getDate().getYear() == 2019);</pre>
<p>В Java 8 <code class="text-nowrap">Stream.iterate()</code> мог генерировать только бесконечный <code class="text-nowrap">Stream</code>. Но в Java 9 у этого метода появилась <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html#iterate(T,java.util.function.Predicate,java.util.function.UnaryOperator)">перегрузка</a></code>, которая принимает предикат. Благодаря этому многие циклы <code class="text-nowrap">for</code> теперь можно заменить на <code class="text-nowrap">Stream</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: green">// Java 8</span>
<span style="color: blue">for</span> (<span style="color: blue">int</span> i = 1; i < 100; i *= 2) {
    System.out.println(i);
}</pre>
<pre class="border p-lg-2 p-1"><span style="color: green">// Java 9+</span>
IntStream
    .iterate(1, i -> i < 100, i -> i * 2)
    .forEach(System.out::println);</pre>
<p>Обе этих версии печатают все степени двойки, которые не превышают <code class="text-nowrap">100</code>:</p>
<pre class="border p-lg-2 p-1">1
2
4
8
16
32
64</pre>
<p>Кстати, последний код можно было бы переписать с использованием <code class="text-nowrap">takeWhile()</code>:</p>
<pre class="border p-lg-2 p-1">IntStream
    .iterate(1, i -> i * 2)
    .takeWhile(i -> i < 100)
    .forEach(System.out::println);</pre>
<p>Однако вариант с трёхаргументным <code class="text-nowrap">iterate()</code> всё-таки чище (и IntelliJ IDEA <a href="https://youtrack.jetbrains.com/issue/IDEA-214960">предлагает</a> его исправить обратно).</p>
<p>Наконец, <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html#ofNullable(T)">Stream.ofNullable()</a></code> возвращает <code class="text-nowrap">Stream</code> с одним элементом, если он не <code class="text-nowrap">null</code>, и пустой <code class="text-nowrap">Stream</code>, если он <code class="text-nowrap">null</code>. Этот метод отлично подойдёт в примере выше с телефонами компании, если <code class="text-nowrap">getPhoneNumber()</code> будет возвращать nullable <code class="text-nowrap">String</code> вместо <code class="text-nowrap">Optional&lt;String&gt;</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">class</span> Employee {
    <b>String</b> getPhoneNumber() { ... }
}

<span style="color: blue">class</span> Department {
    List&lt;Employee&gt; getEmployees() { ... }
}

<span style="color: blue">class</span> Company {
    List&lt;Department&gt; getDepartments() { ... }

    Set&lt;String&gt; getAllPhoneNumbers() {
        <span style="color: blue">return</span> getDepartments()
            .stream()
            .flatMap(d -> d.getEmployees().stream())
            .flatMap(e -> <b>Stream.ofNullable</b>(e.getPhoneNumber()))
            .collect(Collectors.toSet());
    }
}</pre>

<h4>9. <code class="text-nowrap">Predicate.not()</code></h4>
<h5>Появился в: Java 11</h5>
<p>Этот метод не вносит ничего принципиально нового и носит скорее косметический, нежели фундаментальный характер. И всё же возможность немного подсократить код всегда очень приятна. С помощью <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/function/Predicate.html#not(java.util.function.Predicate)">Predicate.not()</a></code> лямбды, в которых есть отрицание, можно заменить на ссылки на методы:</p>
<pre class="border p-lg-2 p-1">Files.lines(path)
     .filter(str -> !str.isEmpty())
     .forEach(System.out::println);</pre>
<p>А теперь используя <code class="text-nowrap">not()</code>:</p>
<pre class="border p-lg-2 p-1">Files.lines(path)
     .filter(not(String::isEmpty))
     .forEach(System.out::println);</pre>
<p>Да, экономия не такая уж и огромная, а если использовать <code class="text-nowrap">s -> !s.isEmpty()</code>, то количество символов, наоборот, становится больше. Но даже в этом случае я всё равно предпочту второй вариант, так как он более декларативен и в нём не используется переменная, а значит не захламляется пространство имён.</p>

<h4>10. Cleaner</h4>
<h5>Появился в: Java 9</h5>
<p>Сегодняшний рассказ я хочу завершить новым интересным API, появившимся в Java 9 и служащим для очистки ресурсов перед их утилизацией сборщиком мусора. <code class="text-nowrap"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ref/Cleaner.html">Cleaner</a></code> является безопасной заменой метода <code class="text-nowrap">Object.finalize()</code>, который сам стал deprecated в Java 9.</p>
<p>С помощью <code class="text-nowrap">Cleaner</code> можно зарегистрировать очистку ресурса, которая произойдёт, если её забыли сделать явно (например, забыли вызвать метод <code class="text-nowrap">close()</code> или не использовали <code class="text-nowrap">try-with-resources</code>). Вот пример абстрактного ресурса, для которого в конструкторе регистрируется очищающее действие:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">public class</span> Resource <span style="color: blue">implements</span> Closeable {
    <span style="color: blue">private static final</span> Cleaner CLEANER = Cleaner.create();
    <span style="color: blue">private final</span> Cleaner.Cleanable cleanable;
    <span style="color: blue">public</span> Resource() {
        cleanable = CLEANER.register(<span style="color: blue">this</span>, () -> {
            <span style="color: green">// Очищающее действие</span>
            <span style="color: green">// (например, закрытие соединения)</span>
        });
    }

    @Override
    <span style="color: blue">public void</span> close() {
        cleanable.clean();
    }
}</pre>
<p>По-хорошему, такой ресурс пользователи должны создавать в блоке <code class="text-nowrap">try</code>:</p>
<pre class="border p-lg-2 p-1"><span style="color: blue">try</span> (<span style="color: blue">var</span> resource = <span style="color: blue">new</span> Resource()) {
    <span style="color: green">// Используем ресурс</span>
}</pre>
<p>Однако могут найтись пользователи, которые забудут это делать и будут писать просто <code class="text-nowrap">var resource = new Resource()</code>. В таких случаях очистка выполнится не сразу, а позовётся позже в одном из следующих циклов сборки мусора. Это всё же лучше, чем ничего.</p>
<p>Если вы хотите изучить <code class="text-nowrap">Cleaner</code> получше и узнать, почему никогда не стоит использовать <code class="text-nowrap">finalize()</code>, то рекомендую вам послушать <a href="https://www.youtube.com/watch?v=K5IctLPem0c">мой доклад</a> на эту тему.</p>

<h4>Заключение</h4>
<p>Java не стоит на месте и постепенно развивается. Пока вы сидите на Java 8, с каждым релизом появляется всё больше и больше новых интересных API. Сегодня мы рассмотрели 10 таких API. И вы сможете использовать их все, если наконец решитесь мигрировать с Java 8.</p>
<p><a href="api_to_upgrade_from_java_8_part_2.html">В следующий раз</a> мы рассмотрим ещё 10 новых API.</p>
</article>
  <p class="pt-4 font-italic">Подписывайтесь на <a href="https://t.me/miniJUG">канал в Telegram</a>, чтобы не пропускать новости.</p>
</div>
<div class="pl-4 pt-5 col-lg-4">
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2021" role="button" aria-expanded="false" aria-controls="year2021">2021</a>
  <ul class="collapse" id="year2021">
<li class="text-secondary"><a href="java_news_16.html" class="text-secondary">Новости Java #16</a></li>
<li class="text-secondary"><a href="java_news_15.html" class="text-secondary">Новости Java #15</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_3.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</a></li>
<li class="text-secondary"><a href="java_news_14.html" class="text-secondary">Новости Java #14</a></li>
<li class="text-secondary"><a href="java_news_13.html" class="text-secondary">Новости Java #13</a></li>
<li class="text-secondary"><a href="java_news_12.html" class="text-secondary">Новости Java #12</a></li>
<li class="text-secondary"><a href="java_news_11.html" class="text-secondary">Новости Java #11</a></li>
<li class="text-secondary"><a href="java_16.html" class="text-secondary">Вышла Java 16</a></li>
<li class="text-secondary"><a href="java_news_10.html" class="text-secondary">Новости Java #10</a></li>
<li class="text-secondary"><a href="java_news_9.html" class="text-secondary">Новости Java #9</a></li>
<li class="text-secondary"><a href="java_news_8.html" class="text-secondary">Новости Java #8</a></li>
<li class="text-secondary"><a href="java_news_7.html" class="text-secondary">Новости Java #7</a></li>
<li class="text-secondary"><a href="java_news_6.html" class="text-secondary">Новости Java #6</a></li>
<li class="text-secondary"><a href="java_news_5.html" class="text-secondary">Новости Java #5</a></li>
<li class="text-secondary"><a href="java_news_4.html" class="text-secondary">Новости Java #4</a></li>
<li class="text-secondary"><a href="java_news_3.html" class="text-secondary">Новости Java #3</a></li>
<li class="text-secondary"><a href="java_news_2.html" class="text-secondary">Новости Java #2</a></li>
<li class="text-secondary"><a href="java_news_1.html" class="text-secondary">Новости Java #1</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2020" role="button" aria-expanded="true" aria-controls="year2020">2020</a>
  <ul class="collapse show" id="year2020">
<li class="text-secondary"><a href="java_15_is_out.html" class="text-secondary">Вышла Java 15</a></li>
<li class="text-secondary"><a href="trying_sealed_classes_in_java_15.html" class="text-secondary">Исследуем <code>sealed</code> классы в Java 15</a></li>
<li class="text-secondary"><a href="java_celebrates_25_years.html" class="text-secondary">Java исполняется 25 лет</a></li>
<li class="text-secondary"><a href="local_interfaces_and_enums.html" class="text-secondary">В Java можно будет объявлять локальные интерфейсы и перечисления</a></li>
<li class="text-secondary"><a href="deconstruction_patterns.html" class="text-secondary">В Java появятся паттерны деконструкции</a></li>
<li class="text-secondary"><a href="java_14_is_out.html" class="text-secondary">Вышла Java 14</a></li>
<li class="text-secondary"><a href="remove_nashorn.html" class="text-secondary">Из Java исчезнет Nashorn</a></li>
<li class="text-secondary"><a href="api_to_upgrade_from_java_8_part_2.html" class="text-secondary">API, ради которых наконец-то стоит обновиться с Java 8. Часть 2</a></li>
<li>API, ради которых наконец-то стоит обновиться с Java 8. Часть 1</li>
<li class="text-secondary"><a href="hidden_classes.html" class="text-secondary">В Java появятся скрытые классы</a></li>
<li class="text-secondary"><a href="introducing_minijug_website.html" class="text-secondary">У miniJUG появился сайт</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2019" role="button" aria-expanded="false" aria-controls="year2019">2019</a>
  <ul class="collapse" id="year2019">
<li class="text-secondary"><a href="trying_records_in_java14.html" class="text-secondary">Исследуем записи в Java 14</a></li>
<li class="text-secondary"><a href="trying_new_instanceof_in_java_14.html" class="text-secondary">Пробуем улучшенный оператор <code>instanceof</code> в Java 14</a></li>
<li class="text-secondary"><a href="java_13_is_out.html" class="text-secondary">Вышла Java 13</a></li>
<li class="text-secondary"><a href="escape_sequences_for_line_continuation_and_whitespace.html" class="text-secondary">В Java появятся две новые экранирующие последовательности для продолжения строки и пробела</a></li>
<li class="text-secondary"><a href="towards_better_serialization.html" class="text-secondary">В Java может появиться новая сериализация</a></li>
<li class="text-secondary"><a href="scala_2_13_is_out.html" class="text-secondary">Вышла Scala 2.13</a></li>
<li class="text-secondary"><a href="yield_in_switch.html" class="text-secondary">В <code>switch</code>-выражениях <code>break</code> будет заменён на <code>yield</code></a></li>
<li class="text-secondary"><a href="text_blocks.html" class="text-secondary">В Java появятся блоки текста</a></li>
<li class="text-secondary"><a href="records_and_sealed_types.html" class="text-secondary">В Java появятся записи и запечатанные типы</a></li>
<li class="text-secondary"><a href="java_is_dead.html" class="text-secondary">Oracle прекращает поддержку Java</a></li>
<li class="text-secondary"><a href="npe_detailed_messages.html" class="text-secondary">В Java у <code>NullPointerException</code> могут появиться детальные сообщения</a></li>
<li class="text-secondary"><a href="java_12_is_out.html" class="text-secondary">Вышла Java 12</a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2018" role="button" aria-expanded="false" aria-controls="year2018">2018</a>
  <ul class="collapse" id="year2018">
<li class="text-secondary"><a href="java_11_is_out.html" class="text-secondary">Вышла Java 11</a></li>
<li class="text-secondary"><a href="concise_method_bodies.html" class="text-secondary">В Java появятся компактные тела методов</a></li>
<li class="text-secondary"><a href="java_10_is_out.html" class="text-secondary">Вышла Java 10</a></li>
<li class="text-secondary"><a href="no_more_free_oracle_jdk.html" class="text-secondary">Oracle JDK станет платным</a></li>
<li class="text-secondary"><a href="launch_single_file_source_code_programs.html" class="text-secondary">В Java можно будет исполнять исходные файлы напрямую</a></li>
<li class="text-secondary"><a href="raw_string_literals.html" class="text-secondary">В Java могут появиться сырые строковые литералы, и какие проблемы это может принести</a></li>
<li class="text-secondary"><a href="unmodifiable_collections_enhancements_in_java_10.html" class="text-secondary">В Java 10 будет улучшена поддержка неизменяемых коллекций</a></li>
<li class="text-secondary"><a href="switch_expressions.html" class="text-secondary"><code>switch</code> в Java сможет возвращать значения</a></li>
<li class="text-secondary"><a href="code_before_this_super.html" class="text-secondary">В конструкторах классов можно будет писать код перед <code>this()</code> и <code>super()</code></a></li>
  </ul>
</div>
<div class="mt-3">
  <a class="dropdown-toggle text-body" data-toggle="collapse" href="#year2017" role="button" aria-expanded="false" aria-controls="year2017">2017</a>
  <ul class="collapse" id="year2017">
<li class="text-secondary"><a href="var_in_lambdas.html" class="text-secondary">В лямбдах можно будет использовать <code>var</code></a></li>
<li class="text-secondary"><a href="http_client.html" class="text-secondary">В Java появится стандартный HTTP-клиент</a></li>
<li class="text-secondary"><a href="nestmates.html" class="text-secondary">В Java исчезнет необходимость в генерации синтетических методов доступа между вложенными типами</a></li>
<li class="text-secondary"><a href="remove_java_ee_and_corba_modules.html" class="text-secondary">Модули Java EE и CORBA исчезнут из Java</a></li>
<li class="text-secondary"><a href="kotlin_1_2_is_out.html" class="text-secondary">Вышел Kotlin 1.2</a></li>
<li class="text-secondary"><a href="epsilon_gc.html" class="text-secondary">В Java появится сборщик мусора, который не будет собирать мусор</a></li>
<li class="text-secondary"><a href="java_10_release_date.html" class="text-secondary">Стала известна дата выхода Java 10</a></li>
<li class="text-secondary"><a href="pattern_matching.html" class="text-secondary">В Java появится паттерн-матчинг</a></li>
<li class="text-secondary"><a href="yegor256_data_classes.html" class="text-secondary">Егор Бугаенко раскритиковал идею введения data-классов в Java</a></li>
<li class="text-secondary"><a href="new_integer_is_deprecated.html" class="text-secondary">Конструкторы Integer, Long, Float, Double, Boolean, Byte, Short, Character стали deprecated в Java 9</a></li>
<li class="text-secondary"><a href="jdk_10_early_access.html" class="text-secondary">Ранние сборки JDK 10 уже доступны для скачивания</a></li>
<li class="text-secondary"><a href="data_classes.html" class="text-secondary">В Java появятся data-классы</a></li>
<li class="text-secondary"><a href="new_java_version_proposal.html" class="text-secondary">Java всё-таки не будет версионироваться годом и месяцем выхода релизов</a></li>
<li class="text-secondary"><a href="java_18_3.html" class="text-secondary">Java переходит на 6-месячный релизный цикл и меняет схему версионирования</a></li>
<li class="text-secondary"><a href="project_loom.html" class="text-secondary">В Java появятся легковесные нити и корутины</a></li>
<li class="text-secondary"><a href="zgc.html" class="text-secondary">В Oracle разрабатывают новый сборщик мусора ZGC</a></li>
  </ul>
</div>
</div>
      </div>
    </div>
    <div class="container d-md-flex flex-row">
      <div class="p-lg-4 p-3 text-secondary">Все материалы на этом сайте выложены под лицензией <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div>
      <div class="p-lg-4 p-3 text-secondary">&copy; <a href="https://twitter.com/ZhekaKozlov">Евгений Козлов</a>, 2017-2021</div>
      <div class="p-lg-4 p-3 text-secondary"><img src="feed.svg" style="height: 1em"/> <a href="https://minijug.ru/feed.xml">Feed</a></div>
    </div>
    <script src="jquery-3.3.1.slim.min.js"></script>
    <script src="popper.min.js"></script>
    <script src="bootstrap.min.js"></script>
  </body>
</html>
