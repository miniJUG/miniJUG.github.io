<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2023-01-29T18:00:00Z</updated>
  <entry>
    <title>Новости Java #53</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_53.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_53.html</id>
    <updated>2023-01-29T18:00:00Z</updated>
    <published>2023-01-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-2-relnotes.html"&gt;JDK 19.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-6-relnotes.html"&gt;JDK 17.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020011.html"&gt;JDK 13.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020012.html"&gt;JDK 15.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-18-relnotes.html"&gt;JDK 11.0.18&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2023-January/016479.html"&gt;JDK 8u362&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8300786"&gt;No longer require &lt;code&gt;super()&lt;/code&gt; and &lt;code&gt;this()&lt;/code&gt; to appear first in a constructor&lt;/a&gt;. В нём предлагается разрешить писать инструкции кода до вызова &lt;code&gt;super()&lt;/code&gt; и &lt;code&gt;this()&lt;/code&gt; в конструкторах.&lt;/p&gt;
&lt;p&gt;Напомним, что сейчас эти вызовы всегда должны быть первыми вызовами в конструкторах, иначе код не скомпилируется:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (value &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value); &lt;span style="color: red"&gt;// error: call to super must be first statement in constructor&lt;/span&gt;
    }
}&lt;/pre&gt;
&lt;p&gt;Такое ограничение иногда создаёт неудобства, например, при необходимости проверять входные аргументы до вызова суперконструктора (как в примере выше), при передаче одного и того же вычисляемого параметра в суперконструктор несколько раз или при нетривиальной подготовке параметра перед передачей его в суперконструктор.&lt;/p&gt;
&lt;p&gt;JEP предлагает это ограничение снять и позволить писать инструкции до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;. Однако для кода до вызова остаётся ограничение, что он должен быть в статическом контексте, то есть не должен ссылаться на текущий объект явно или неявно (использовать &lt;code&gt;this&lt;/code&gt;, вызывать нестатические методы и так далее).&lt;/p&gt;
&lt;p&gt;Любопытно, что в спецификации JVM подобного ограничения нет, и она разрешает произвольный код до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;, если он не ссылается на конструируемый объект. Таким образом, предлагаемое изменение будет чисто языковым изменением, без необходимости менять что-то в виртуальной машине.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Черновик JEP "Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns", о котором мы писали в &lt;a href="java_news_49.html"&gt;выпуске #49&lt;/a&gt;, был переименован в &lt;a href="https://openjdk.org/jeps/8288476"&gt;"Primitive types in patterns, &lt;code&gt;instanceof&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;"&lt;/a&gt;. Добавилось важное дополнение, что примитивные типы смогут появляться в ветках &lt;code&gt;switch&lt;/code&gt;. Например:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (i) {
    &lt;span style="color: blue"&gt;case byte&lt;/span&gt; b -&gt; ... ;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; ... ;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;p&gt;Кроме того, список типов константных выражений в ветках будет расширен до всех примитивных типов, включая &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;boolean&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.0f -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.5f -&gt; ...
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; g -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; x = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (x) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 10_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 20_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; ...
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Oracle &lt;a href="https://houseofbrick.com/blog/oracle-java-pricing/"&gt;изменила правила&lt;/a&gt; платной подписки на Java SE. Теперь единицей, по которой рассчитывается стоимость, становится сотрудник компании, а не процессор. Таким образом, теперь на цену подписки влияет только количество сотрудников, а не количество серверов и настольных компьютеров, на которых запущена Java (если только у вас не больше 50000 процессоров на серверах). Это приведёт к подорожанию подписки для большинства случаев. В некоторых случаях такой рост будет на порядок.&lt;/p&gt;
&lt;p&gt;Напомним, что Java была и остаётся свободным ПО, и вышеупомянутое изменение ценовой политики Oracle никак не повлияет на пользователей &lt;a href="https://openjdk.org/"&gt;OpenJDK&lt;/a&gt;, которая продолжает оставаться бесплатной. Останется бесплатной и &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;Oracle JDK 17&lt;/a&gt;, в том числе и для коммерческого использования. Повышение тарифных планов коснётся только компаний, имеющих &lt;a href="https://www.oracle.com/java/java-se-subscription/#rc30p3"&gt;Oracle Java SE Universal Subscription&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #52</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_52.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_52.html</id>
    <updated>2023-01-17T18:00:00Z</updated>
    <published>2023-01-17T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://kotlinlang.org/docs/whatsnew18.html"&gt;Kotlin 1.8.0&lt;/a&gt;. Некоторые заметные нововведения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новые экспериментальные функции &lt;code&gt;copyToRecursively()&lt;/code&gt; and &lt;code&gt;deleteRecursively()&lt;/code&gt; для директорий.&lt;/li&gt;
  &lt;li&gt;Улучшенная производительность kotlin-reflect.&lt;/li&gt;
  &lt;li&gt;Новая опция &lt;code&gt;-Xdebug&lt;/code&gt;, подавляющая оптимизации, для более удобной отладки.&lt;/li&gt;
  &lt;li&gt;Больше не поддерживается таргетирование в байткод 1.6 и 1.7. Вследствие этого, стандартные библиотеки скомпилированы только в 1.8, и более нет разделения на &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, а есть единый &lt;code&gt;kotlin-stdlib&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Улучшена интероперабельность с Objective-C/Swift.&lt;/li&gt;
  &lt;li&gt;Совместимость с Gradle 7.3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/01/java-annotated-monthly-january-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за январь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/maven/releases/tag/maven-3.8.7"&gt;Apache Maven 3.8.7&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/mockito/mockito/releases/tag/v5.0.0"&gt;Mockito 5.0.0&lt;/a&gt;. Новая версия библиотеки требует Java 11 в качестве минимальной версии.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #51</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_51.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_51.html</id>
    <updated>2022-12-25T18:00:00Z</updated>
    <published>2022-12-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 перешёл в &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-December/007233.html"&gt;первую фазу Rampdown&lt;/a&gt;. Окончательный список JEP'ов, которые попадут в релиз, следующий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;JEP 433: Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK предложен &lt;a href="https://mail.openjdk.org/pipermail/discuss/2022-December/006164.html"&gt;новый проект Galahad&lt;/a&gt;, целью которого будет внедрение в OpenJDK технологий GraalVM, связанных с Java, а именно JIT-компилятора GraalVM (полностью написанного на Java) в качестве альтернативы существующему JIT-компилятору HotSpot. Затем, следующим шагом будет использование AOT-компилятора GraalVM для компиляции JIT-компилятора, а позднее &amp;ndash; портирование Native Image в качестве общего решения для любых Java-приложений.&lt;/p&gt;
&lt;p&gt;Напомним, что GraalVM уже однажды был частью OpenJDK (с &lt;a href="https://openjdk.org/jeps/317"&gt;Java 10&lt;/a&gt; по &lt;a href="https://openjdk.org/jeps/410"&gt;Java 16&lt;/a&gt;) в качестве экспериментальной технологии, но был убран из-за сложности поддержки и малой используемости. Новой целью будет превращение GraalVM в downstream-репозиторий (GraalVM EE и CE будут полностью основаны на исходном коде OpenJDK), а значит, не будет проблемы дублирования усилий.&lt;/p&gt;
&lt;p class="pt-1"&gt;Также стали известны &lt;a href="https://medium.com/graalvm/graalvm-galahad-and-a-new-release-schedule-d081d1031bba"&gt;подробности&lt;/a&gt; относительно согласования релизных циклов GraalVM и OpenJDK: начиная с JDK 20, GraalVM будет выходить 2 раза в год (а не 4, как раньше). Следующая версия GraalVM выйдет одновременно с JDK 20 в марте и будет называться &lt;i&gt;GraalVM for JDK 20&lt;/i&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=jJau4kUoLrA"&gt;Eclipse 2022-12&lt;/a&gt;. Что нового появилось в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка Java 19, включая экспериментальные возможности (паттерны записей и паттер-матчинг для &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Более умный &lt;i&gt;Extract Local Variable&lt;/i&gt;, учитывающий проверки на &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Три новых quick fixes для классов: &lt;i&gt;Create getters and setters&lt;/i&gt;, &lt;i&gt;Create &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;&lt;/i&gt; и &lt;i&gt;Create &lt;code&gt;toString()&lt;/code&gt;&lt;/i&gt;.&lt;/li&gt;
  &lt;li&gt;Галочка &lt;i&gt;Automatically update Maven projects configuration&lt;/i&gt; больше не является экспериментальной и включена по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшение редактора XML: автоматическая вставка закрывающего XML-элемента и удаление закрывающего XML-элемента, если вставляется символ &lt;code&gt;/&lt;/code&gt; в конец открывающего элемента.&lt;/li&gt;
  &lt;li&gt;Поддержка RelaxNG в качестве языка схемы XML (в дополнение к существующим DTD и XSD).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse/microprofile/releases/tag/6.0"&gt;MicroProfile 6.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.0"&gt;GlassFish 7&lt;/a&gt;, поддерживающий спецификацию Jakarta EE 10.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.infoq.com/news/2022/12/resilience4j-2-0-0"&gt;Resilience4j 2.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #50</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_50.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_50.html</id>
    <updated>2022-12-04T18:00:00Z</updated>
    <published>2022-12-04T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 пополнился ещё четырьмя JEP'ами:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007215.html"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007223.html"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007225.html"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007224.html"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, на текущий момент у Java 20 шесть JEP'ов, и только один из них &amp;ndash; это полностью новая фича (Scoped Values), а не следующая итерация уже существующей. До первый фазы Rampdown &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-October/007108.html"&gt;остаётся 3 дня&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/11/intellij-idea-2022-3/"&gt;IntelliJ IDEA 2022.3&lt;/a&gt;. Перечислим некоторые нововведения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый полностью переработанный Look &amp; Feel, который можно включить в настройках (галочка &lt;i&gt;Enable new UI&lt;/i&gt; во вкладке &lt;i&gt;New UI Preview&lt;/i&gt;).&lt;/li&gt;
  &lt;li&gt;Возможность синхронизации настроек между устройствами (Settings Sync).&lt;/li&gt;
  &lt;li&gt;Новый способ автоподстановки бинов Spring, Micronaut и Jakarta EE CDI (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Автогенерация схемы OpenAPI из контроллера Spring или ресурса JAX-RS (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Поддержка Redis (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Возможность пристыковывать окна инструментов к плавающим вкладкам редакторов.&lt;/li&gt;
  &lt;li&gt;Предпросмотр результата Intention action теперь включён по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшенный UX в Search Everywhere.&lt;/li&gt;
  &lt;li&gt;Категоризация результатов в Find Usages по сходству использований.&lt;/li&gt;
  &lt;li&gt;Улучшенные Tips of the Day.&lt;/li&gt;
  &lt;li&gt;Улучшенные Bookmarks&lt;/li&gt;
  &lt;li&gt;Возможность просмотра кода библиотек в предпочитаемом стиле с переформатированием.&lt;/li&gt;
  &lt;li&gt;Улучшения производительности (старт и отзывчивость UI).&lt;/li&gt;
  &lt;li&gt;Новые инспекции Java (похожие инструкции в &lt;code&gt;switch&lt;/code&gt;, лишние проверки на длины массивов, ненужный &lt;code&gt;stream.parallel()&lt;/code&gt; и т.д.).&lt;/li&gt;
  &lt;li&gt;Поддержка синтаксических возможностей Java 19 (паттерны записей и изменения в паттерн-матчинге &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;В режиме отладки: если анализатор может предсказать, что ветка не будет исполнена, то она окрашивается в серый цвет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/12/java-annotated-monthly-december-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за декабрь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/11/24/spring-boot-3-0-goes-ga"&gt;Spring Boot 3.0&lt;/a&gt;. Главные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется Spring 6.0.&lt;/li&gt;
  &lt;li&gt;Java 17 &amp;ndash; минимальная версия.&lt;/li&gt;
  &lt;li&gt;Генерация нативных образов GraalVM.&lt;/li&gt;
  &lt;li&gt;Улучшения в observability через Micrometer и Micrometer Tracing.&lt;/li&gt;
  &lt;li&gt;Полный переход от Java EE к Jakarta EE. Jakarta EE 9 &amp;ndash; минимальная версия. Есть поддержка Jakarta EE 10.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v2.9"&gt;Async Profiler 2.9&lt;/a&gt; с новым профайлером утечек в куче.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #49</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_49.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_49.html</id>
    <updated>2022-11-20T18:00:00Z</updated>
    <published>2022-11-20T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а предложены к выходу в &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;JDK 20&lt;/a&gt;. Это &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007198.html"&gt;432: Record Patterns (Second Preview)&lt;/a&gt; и &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007199.html"&gt;433: Pattern Matching for switch (Fourth Preview)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли два новых JEP'а. Это &lt;a href="https://openjdk.org/jeps/436"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел черновик JEP: &lt;a href="https://openjdk.org/jeps/8288476"&gt;Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns&lt;/a&gt;. В нём предлагается расширить возможности оператора &lt;code&gt;instanceof&lt;/code&gt; и паттернов типов, позволив делать проверки не только для ссылочных, но и для примитивных типов:&lt;/p&gt;
&lt;pre&gt;Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) {
    ...
}&lt;/pre&gt;
&lt;p&gt;В случае сужающей конверсии такие тесты будут дополнительно проверять, проходит ли конверсия без потери точности. Например, в данном случае условие не выполнится, потому что &lt;code&gt;500&lt;/code&gt; не попадает в диапазон &lt;code&gt;byte&lt;/code&gt; (от &lt;code&gt;-128&lt;/code&gt; до &lt;code&gt;127&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 500;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) {
    &lt;span style="color: green"&gt;// Не будет выполнено&lt;/span&gt;
    ...
}&lt;/pre&gt;
&lt;p&gt;А в данном примере условие выполнится, потому что &lt;code&gt;500&lt;/code&gt; попадает в диапазон &lt;code&gt;short&lt;/code&gt; (от &lt;code&gt;-32678&lt;/code&gt; до &lt;code&gt;32677&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 500;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof short&lt;/span&gt; s) {
    &lt;span style="color: green"&gt;// Выполнится&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/11/16/spring-framework-6-0-goes-ga"&gt;Spring 6.0&lt;/a&gt;. Новая версия фреймворка требует Java 17 и использует пространство имён Jakarta EE 9+ (&lt;code&gt;jakarta.*&lt;/code&gt;). При этом есть поддержка API Jakarta EE 10, например, &lt;a href="https://jakarta.ee/specifications/servlet/6.0/"&gt;Jakarta Servlet 6.0&lt;/a&gt; и &lt;a href="https://jakarta.ee/specifications/persistence/3.1/"&gt;Jakarta Persistence 3.1&lt;/a&gt;. Это позволяет использовать последние веб-контейнеры, такие как Tomcat 10.1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.wildfly.org/news/2022/11/09/WildFly27-Final-Released/"&gt;WildFly 27&lt;/a&gt; с поддержкой Jakarta EE 10.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jmh-dev/2022-November/003553.html"&gt;JMH 1.36&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #48</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_48.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_48.html</id>
    <updated>2022-11-06T18:00:00Z</updated>
    <published>2022-11-06T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли два новых JEP.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="https://openjdk.org/jeps/434"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Второй &amp;ndash; &lt;a href="https://openjdk.org/jeps/435"&gt;JEP 435: Asynchronous Stack Trace VM API&lt;/a&gt;. В нём предлагается добавить в JDK публичное и хорошо протестированное нативное API для получения стек-трейсов с возможностью асинхронного использования. В OpenJDK уже существует API &lt;code&gt;AsyncGetCallTrace&lt;/code&gt;, которое широко используется во многих профилировщиках (например, &lt;a href="https://github.com/jvm-profiling-tools/async-profiler"&gt;async-profiler&lt;/a&gt;), но это API является внутренним и не поддерживает нативные фреймы. JEP 435 предлагает ввести новый метод &lt;code&gt;AsyncGetStackTrace&lt;/code&gt;, который будет экспортирован в заголовке &lt;code&gt;include/profile.h&lt;/code&gt; и будет иметь возможность включать фреймы C/C++ в результат.&lt;/p&gt;
&lt;p class="pt-1"&gt;Кроме того, ещё вышло два новых черновика JEP: &lt;a href="https://openjdk.org/jeps/8295817"&gt;Virtual Threads (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8296037"&gt;Structured Concurrency (Second Incubator)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На сайте Oracle стали публиковаться &lt;a href="https://jdk.java.net/javafx20/"&gt;ранние сборки JavaFX 20&lt;/a&gt;. Скачать можно как JavaFX SDK, так и файлы JMOD.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JUG.ru &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b8OCdXV_tqP8YrMIlgB_BER"&gt;выложил&lt;/a&gt; доклады с конференции JPoint 2022.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.14"&gt;Jackson 2.14&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #47</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_47.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_47.html</id>
    <updated>2022-10-23T18:00:00Z</updated>
    <published>2022-10-23T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-1-relnotes.html"&gt;JDK 19.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-5-relnotes.html"&gt;JDK 17.0.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-October/017943.html"&gt;JDK 13.0.13&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-October/017944.html"&gt;JDK 15.0.9&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-17-relnotes.html"&gt;JDK 11.0.17&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-October/015706.html"&gt;JDK 8u352&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышли три новых JEP'а. Это &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/432"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/433"&gt;JEP 433: Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;. Про record patterns и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; мы писали в &lt;a href="java_news_46.html#record_patterns"&gt;прошлом выпуске&lt;/a&gt;, когда они были ещё черновиками, а вот sequenced collections упоминали совсем давно (в &lt;a href="java_news_35.html#sequenced_collections"&gt;выпуске #35&lt;/a&gt;), поэтому давайте рассмотрим его снова и более подробно.&lt;/p&gt;
&lt;p&gt;В JEP 431 предлагается ввести три новых интерфейса в пакет &lt;code&gt;java.util&lt;/code&gt;, которые будет представлять собой коллекции или словари с определённым порядком элементов: &lt;code&gt;SequencedCollection&lt;/code&gt;, &lt;code&gt;SequencedSet&lt;/code&gt; и &lt;code&gt;SequencedMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; будет наследоваться от интерфейса &lt;code&gt;Collection&lt;/code&gt;, и его наследниками будут &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Deque&lt;/code&gt; и &lt;code&gt;SequencedSet&lt;/code&gt;. Примерами такого типа коллекции будут &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;LinkedList&lt;/code&gt;, &lt;code&gt;ArrayDeque&lt;/code&gt;, &lt;code&gt;LinkedHashSet&lt;/code&gt; и &lt;code&gt;TreeSet&lt;/code&gt; (то есть коллекции, в которых есть определённый порядок элементов). Пример коллекции, которая не является &lt;code&gt;SequencedCollection&lt;/code&gt; &amp;ndash; &lt;code&gt;HashSet&lt;/code&gt; (в нём порядок элементов не определён).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedSet&lt;/code&gt; будет наследоваться от &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;SequencedCollection&lt;/code&gt;. Его наследником будет &lt;code&gt;SortedSet&lt;/code&gt;. Примеры конкретных множеств такого типа: &lt;code&gt;TreeSet&lt;/code&gt; и &lt;code&gt;LinkedHashSet&lt;/code&gt;.&lt;/p&gt;
&lt;img src="sequenced_collection.png" class="img-fluid" /&gt;
&lt;p&gt;&lt;code&gt;SequencedMap&lt;/code&gt; будет наследоваться от &lt;code&gt;Map&lt;/code&gt;. Его наследником будет &lt;code&gt;SortedMap&lt;/code&gt;. Примеры конкретных реализаций: &lt;code&gt;TreeMap&lt;/code&gt; и &lt;code&gt;LinkedHashMap&lt;/code&gt;. В &lt;code&gt;HashMap&lt;/code&gt; нет определённого порядка элементов, поэтому она не будет являться &lt;code&gt;SequencedMap&lt;/code&gt;.&lt;/p&gt;
&lt;img src="sequenced_map.png" class="img-fluid" /&gt;
&lt;p&gt;В &lt;code&gt;SequencedCollection&lt;/code&gt; будут новые методы, которых нет в &lt;code&gt;Collection&lt;/code&gt;: &lt;code&gt;getFirst()&lt;/code&gt;, &lt;code&gt;getLast()&lt;/code&gt;, &lt;code&gt;addFirst()&lt;/code&gt;, &lt;code&gt;addLast()&lt;/code&gt;, &lt;code&gt;removeFirst()&lt;/code&gt;, &lt;code&gt;removeLast()&lt;/code&gt;. Также будет новый метод &lt;code&gt;reversed()&lt;/code&gt;, который будет возвращать view с обратным порядком элементов.&lt;/p&gt;
&lt;p&gt;В &lt;code&gt;SequencedMap&lt;/code&gt; будут новые методы &lt;code&gt;firstEntry()&lt;/code&gt;, &lt;code&gt;lastEntry()&lt;/code&gt;, &lt;code&gt;pollFirstEntry()&lt;/code&gt;, &lt;code&gt;pollLastEntry()&lt;/code&gt;, &lt;code&gt;firstKey()&lt;/code&gt;, &lt;code&gt;lastKey()&lt;/code&gt;, &lt;code&gt;putFirst()&lt;/code&gt;, &lt;code&gt;putLast()&lt;/code&gt;, &lt;code&gt;reversed()&lt;/code&gt;, &lt;code&gt;sequencedKeySet()&lt;/code&gt;, &lt;code&gt;sequencedValues()&lt;/code&gt; и &lt;code&gt;sequencedEntrySet()&lt;/code&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; GraalVM CE станет частью OpenJDK. Такое заявление появилось в &lt;a href="https://twitter.com/graalvm/status/1582441450796900354"&gt;Твиттере&lt;/a&gt; проекта GraalVM. На данный момент других деталей нет кроме тех, о которых заявлено в твите. Из того, что известно сейчас:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;В OpenJDK переедут JIT-компилятор и Native Image, входящие в состав GraalVM Community Edition.&lt;/li&gt;
  &lt;li&gt;GraalVM Enterprise Edition остаётся отдельным продуктом с коммерческой лицензией. У GraalVM EE больше оптимизаций, чем у CE, и &lt;a href="https://www.graalvm.org/downloads/"&gt;выше производительность&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;В GraalVM будут использоваться те же процессы разработки и тот же релизный цикл, что и у JDK. Модели лицензирования также будут согласованы.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В ближайшее время ожидается более подробная информация на сайте проекта.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Новая среда разработки Fleet от JetBrains &lt;a href="https://blog.jetbrains.com/fleet/2022/10/introducing-the-fleet-public-preview/"&gt;перешла&lt;/a&gt; в стадию Public Preview и теперь доступна для скачивания неограниченному кругу пользователей.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появились первые &lt;a href="https://jdk.java.net/genzgc/"&gt;EA-сборки&lt;/a&gt; Generational ZGC. Добавление &lt;a href="https://openjdk.org/jeps/8272979"&gt;поколений&lt;/a&gt; в сборщик мусора ZGC должно уменьшить накладные расходы на сборку мусора и увеличить скорость выделения памяти под объекты при длительном режиме аллокации.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Андрей Паньгин выпустил библиотеку &lt;a href="https://github.com/apangin/nalim"&gt;nalim&lt;/a&gt; для быстрых нативных вызовов из Java, которая не использует JNI и не страдает от его накладных расходов. Библиотека может позиционироваться как замена JNI Critical Natives, которые были удалены в JDK 18. Кроме того, JNI Critical Natives были приватным API, а nalim использует стандартный интерфейс JVMCI (который, правда, требует флагов &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Как &lt;a href="https://twitter.com/AndreiPangin/status/1581383155822776320"&gt;утверждает&lt;/a&gt; Андрей, он написал библиотеку за две ночи.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse-ee4j/eclipselink/releases/tag/4.0.0"&gt;EclipseLink 4&lt;/a&gt;. Он полностью поддерживает спецификацию &lt;a href="https://newsroom.eclipse.org/eclipse-newsletter/2022/march/what%E2%80%99s-new-jakarta-persistence-31"&gt;Jakarta Persistence API 3.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #46</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_46.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_46.html</id>
    <updated>2022-10-09T18:00:00Z</updated>
    <published>2022-10-09T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло несколько новых черновиков JEP. Рассмотрим каждый из них.&lt;/p&gt;
&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294349"&gt;Unnamed local variables and patterns&lt;/a&gt;. В этом JEP предлагается добавить в язык безымянные переменные и паттерны, которые будут обозначаться символом &lt;code&gt;_&lt;/code&gt; (подчёркивание).&lt;/p&gt;
&lt;p&gt;Это очень полезное улучшение: оно позволит не давать имя переменной, которая в дальнейшем не будет использоваться. Такая ситуация возникает довольно часто, например, в блоке &lt;code&gt;try-catch&lt;/code&gt;, когда важен только тип исключения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    ...
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Другой частый случай &amp;ndash; лямбда-выражения:&lt;/p&gt;
&lt;pre&gt;map.computeIfAbsent(k, _ -&gt; &lt;span style="color: blue"&gt;new&lt;/span&gt; ArrayList&lt;&gt;());&lt;/pre&gt;
&lt;p&gt;Ещё один пример &amp;ndash; паттерн-матчинг:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; pingDevice(Device d) {
    String ip = &lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Printer(_, _, _, String ipp) -&gt; ipp;
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Server(_, String ips) -&gt; ips;
    };

    ping(ip);
}&lt;/pre&gt;
&lt;p&gt;Полный список случаев, когда можно будет использовать подчёркивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Объявление локальной переменной в блоке.&lt;/li&gt;
  &lt;li&gt;Спецификация ресурса в &lt;code&gt;try-with-resources&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Объявление базового цикла &lt;code&gt;for&lt;/code&gt; или улучшенного цикла &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Переменная паттерна.&lt;/li&gt;
  &lt;li&gt;Параметр &lt;code&gt;catch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Параметр лямбда-выражения.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Заметим, что в данный список не входят параметры методов классов и интерфейсов. В них по прежнему придётся давать имена всем параметрам. Почему такое решение было принято, можно почитать в &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-September/003485.html"&gt;этой ветке&lt;/a&gt; рассылки проекта Amber.&lt;/p&gt;

&lt;p class="pt-1" id="record_patterns"&gt;&lt;a href="https://openjdk.org/jeps/8294078"&gt;Record Patterns (Second Preview)&lt;/a&gt;. Это второе preview паттернов записей (первое попало в &lt;a href="https://openjdk.org/jeps/405"&gt;Java 19&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;В этой итерации три главных изменения.&lt;/p&gt;
&lt;p&gt;Во-первых, добавляется поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей смогут присутствовать в объявлениях улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;T, U&gt;(T first, U second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; loop(List&amp;lt;Pair&amp;lt;String, Integer&gt;&gt; pairs) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; first, &lt;span style="color: blue"&gt;var&lt;/span&gt; second) : pairs) {
        System.out.println(first + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + second);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, исчезает поддержка именованных паттернов записей. Это значит, что такой код уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако по этому пункту возникла &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-October/thread.html#3582"&gt;дискуссия в рассылке&lt;/a&gt;, и пока непонятно, действительно ли примут решение убрать такую полезную возможность языка. Брайн Гетц &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-October/003587.html"&gt;считает&lt;/a&gt;, что с введением такой возможности поспешили и что если её откатить, то это позволит более тщательно её продумать и вернуть обратно в будущем в этой или иной форме.&lt;/p&gt;

&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294285"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;. Это уже четвёртая итерация паттернов записей (предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;). В новой версии два главных изменения: упрощённая грамматика switch labels и поддержка вывода типов для паттернов дженериков.&lt;/p&gt;
&lt;p&gt;Упрощённая грамматика большее значение представляет для разработчиков компиляторов и IDE. А вывод типов в &lt;code&gt;switch&lt;/code&gt; выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;Collection&amp;lt;String&gt; collection = ...;

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (collection) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; List&amp;lt;&gt; l -&gt; ... &lt;span style="color: green"&gt;// Выводится List&amp;lt;String&gt;&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Set&amp;lt;&gt; s  -&gt; ... &lt;span style="color: green"&gt;// Выводится Set&amp;lt;String&gt;&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Queue q  -&gt; ... &lt;span style="color: green"&gt;// Ничего не выводится, сырой тип Queue&lt;/span&gt;
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако для записей diamond-оператор необязателен:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;T, U&gt;(T first, U second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(var fst, var snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;То же самое касается и паттерн-матчинга через &lt;code&gt;instanceof&lt;/code&gt;, пример которого уже был приведён выше (см. пример с &lt;code&gt;Box&amp;lt;T&gt;&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294992"&gt;64 bit object headers&lt;/a&gt;. Цель этого JEP &amp;ndash; уменьшение размера заголовков с 96/128 до 64 бит. Это позволит уменьшить потребление памяти кучей приблизительно на 6-12%, что, в свою очередь, уменьшит нагрузку на GC и CPU.&lt;/p&gt;
&lt;p&gt;Работа по сжатию заголовков ведётся в проекте &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt;, который был &lt;a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html"&gt;предложен&lt;/a&gt; в марте 2021 года Романом Кеннке, впоследствии и ставшим лидером проекта. Ранее Роман &lt;a href="https://mail.openjdk.org/pipermail/lilliput-dev/2022-May/000457.html"&gt;сообщил&lt;/a&gt;, что в проекте удалось добиться значительных успехов и что уже ведётся работа над следующим этапом: сжатием заголовка до 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Брайан Гетц &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-September/003552.html"&gt;предложил&lt;/a&gt; внести изменения в Java, облегчающие вхождение новичков в язык. Он выложил документ с заголовком &lt;a href="https://openjdk.org/projects/amber/design-notes/on-ramp"&gt;"Paving the on-ramp"&lt;/a&gt; ("прокладывая заезд на автостраду"), где изложил свои мысли относительно возможных упрощений, которые сделают кривую изучения языка более пологой.&lt;/p&gt;
&lt;p&gt;Когда новичок впервые изучает Java, он сразу же сталкивается с большим числом незнакомых концепций, которых нельзя избежать при написании даже самой простой программы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Для полного понимания этого кода придётся разобраться чуть ли не со всеми основными аспектами языка:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Уровни видимости (&lt;code&gt;public&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Классы.&lt;/li&gt;
  &lt;li&gt;Методы.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;static&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;main&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Строки.&lt;/li&gt;
  &lt;li&gt;Массивы (&lt;code&gt;String[]&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Поля (&lt;code&gt;out&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Константы (&lt;code&gt;out&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Брайан Гетц предлагает три упрощения, которые помогут изучающим язык начать с минимально короткой программы и постепенно переходить к более сложным концепциям.&lt;/p&gt;
&lt;p&gt;Во-первых, можно сделать &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; и параметр &lt;code&gt;args&lt;/code&gt; опциональными. Тогда код упростится до следующего:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, можно ввести концепцию безымянных классов, что позволит объявлять поля и методы без объявления класса. Это позволит упростить код ещё сильнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Наконец, можно сделать некоторые наиболее часто используемые методы статическими (&lt;code&gt;println&lt;/code&gt;, &lt;code&gt;readln&lt;/code&gt;) и импортировать их автоматически (как автоматически импортируются все классы в &lt;code&gt;java.lang&lt;/code&gt;). В итоге код сократится до самого минимума:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p class="pt-1"&gt;Сейчас всё это существует исключительно на уровне концепции, которая активно обсуждается в рассылке, но возможно что-то из предложенных идей будет в будущем реализовано в языке.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/10/java-annotated-monthly-october-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за октябрь.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #45</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_45.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_45.html</id>
    <updated>2022-09-25T18:00:00Z</updated>
    <published>2022-09-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt;. Про шаблонные строки мы писали в &lt;a href="java_news_28.html"&gt;выпуске #28&lt;/a&gt;, когда они были предложены в рассылке проекта Amber. С тех пор концепция шаблонных строк дозрела до JEP-кандидата, и возможно, они попадут в следующий релиз &lt;a href="https://jdk.java.net/20/"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://jakarta.ee/release/10/"&gt;Jakarta EE 10&lt;/a&gt;. В этом релизе теперь требуется Java 11 в качестве минимальной версии, а также есть поддержка Java 17. В Jakarta EE 10 более 20 спецификаций получили обновления, а также появилась новая спецификация CDI Lite 4.0. Из принципиальных нововведений также стало появление &lt;a href="https://jakarta.ee/specifications/coreprofile/10/"&gt;Core Profile&lt;/a&gt;, минимального набора спецификаций, созданного специально для микросервисов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Lightbend &lt;a href="https://www.lightbend.com/blog/why-we-are-changing-the-license-for-akka"&gt;объявила&lt;/a&gt; об изменении лицензии у Akka, инструментария, реализующего программную модель на основе акторов.&lt;/p&gt;
&lt;p&gt;Начиная с версии 2.7, которая выйдет в октябре, Akka будет иметь коммерческую лицензию BSL 1.1. Это значит, что Akka будет иметь не open-source, а так называемую source-available модель, при которой исходные коды будут всё ещё доступны, но Akka можно будет использовать бесплатно только для разработки и других непроизводственных целей. Для производственных целей придётся приобретать коммерческую лицензию, которая, однако, будет бесплатной для компаний с годовым оборотом меньше 25 миллионов долларов. Кроме того, через 3 года после выхода код Akka становится полностью свободным под лицензией Apache 2.0. Также исключением является Play Framework, который внутри себя использует Akka: его также можно использовать бесплатно. Akka 2.6 &lt;a href="https://www.lightbend.com/akka/license-faq"&gt;будет оставаться&lt;/a&gt; под лицензией Apache 2.0 и будет получать критические обновления до сентября 2023 года.&lt;/p&gt;
&lt;p&gt;Йонас Бонер, создатель Akka, объяснил такое решение тем, что большое количество крупных компаний, таких как Apple, Disney и GM, используют Akka совершенно бесплатно, но все усилия и затраты несёт на себе небольшая компания Lightbend. Новая лицензия позволит сдвинуть баланс в сторону других участников, которые будут обязаны платить и тем самым вносить вклад в будущее Akka.&lt;/p&gt;
&lt;p&gt;Цены на Akka уже &lt;a href="https://www.lightbend.com/akka#pricing"&gt;опубликованы&lt;/a&gt; и составляют от 1995 до 2995 долларов в год за одно ядро в зависимости от лицензии.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=eEXvOjtauxI"&gt;Eclipse 2022-09&lt;/a&gt;. Вот некоторые улучшения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Более быстрый поиск по подстроке в workspace.&lt;/li&gt;
  &lt;li&gt;Поддержка цветного вывода в консоли.&lt;/li&gt;
  &lt;li&gt;Новая галочка "Enable word wrap when opening an editor".&lt;/li&gt;
  &lt;li&gt;Улучшения в Clean Up Actions "Convert to switch expression" и "Convert to enhanced 'for' loops".&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 19</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_19.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_19.html</id>
    <updated>2022-09-19T18:00:00Z</updated>
    <published>2022-09-19T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;Java 19&lt;/a&gt;. В этот релиз попало более &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-19.html"&gt;двух тысяч закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/19/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/19/apidiff/18/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/19/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вот список JEP'ов, которые попали в Java 19.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/427"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Third Preview) (JEP 427)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt;, который &lt;a href="https://openjdk.org/jeps/406"&gt;появился в Java 17&lt;/a&gt; в режиме preview и остался на &lt;a href="https://openjdk.org/jeps/420"&gt;второе preview в Java 18&lt;/a&gt;, всё ещё остаётся в этом статусе. Это первый случай в Java, когда языковой конструкции не хватило двух релизов, чтобы стать стабильной: ранее все конструкции укладывались в два preview.&lt;/p&gt;
&lt;p&gt;В этом релизе в паттерн-матчинг было внесено два главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, охранные паттерны &lt;code&gt;&amp;&amp;&lt;/code&gt; были заменены на условия &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &amp;&amp; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;

&lt;p&gt;О мотивации такого изменения можно прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003195.html"&gt;в рассылке проекта Amber&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Во-вторых, было изменено поведение матчинга &lt;code&gt;null&lt;/code&gt;. Теперь &lt;code&gt;null&lt;/code&gt; матчится только в ветке &lt;code&gt;case null&lt;/code&gt; и большие ни в каких других, включая тотальных:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: green"&gt;// matches because total pattern&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;// NPE&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; ...; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Про причины такого изменения можно также прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003194.html"&gt;в рассылке&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/405"&gt;Паттерны записей (Preview) (JEP 405)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг дополнился новым видом паттерна: паттерн записей.&lt;/p&gt;
&lt;p&gt;Раньше для паттерн-матчинга записей был доступен только паттерн по типу с дальнейшим ручным извлечением компонентов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point p) {
        &lt;span style="color: blue"&gt;int&lt;/span&gt; x = p.x();
        &lt;span style="color: blue"&gt;int&lt;/span&gt; y = p.y();
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;С паттернами записей код становится существенно компактнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printCoordinatesAndColor(ColoredPoint cp) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (cp &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y), &lt;span style="color: blue"&gt;var&lt;/span&gt; c)) {
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
        System.out.println(&lt;span style="color: darkred"&gt;"color = "&lt;/span&gt; + c);
    }
}&lt;/pre&gt;

&lt;p&gt;Также паттерны записей могут быть именованными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) {
        System.out.println(&lt;span style="color: darkred"&gt;"point = "&lt;/span&gt; + p);
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Кроме того, паттерны записей хорошо сочетаются со &lt;code&gt;switch&lt;/code&gt; из предыдущего JEP'а:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 &amp;&amp; y &gt; 0 -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Positive point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/425"&gt;Virtual Threads (Preview) (JEP 425)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появились виртуальные потоки в режиме preview.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" и не прибегать к более сложному асинхронному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt;, а значит, большую часть существующего кода не придётся переписывать.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент работает виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и малый размер виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоки и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в дебаггере, JVM TI и Java Flight Recorder.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки разрабатываются &lt;a href="https://mail.openjdk.org/pipermail/announce/2017-October/000238.html"&gt;с 2017 года&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/428"&gt;Structured Concurrency (Incubator) (JEP 428)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одним результатом работы над проектом Loom стало добавление в Java нового API для Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;. Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Future&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Future&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join();           &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
    scope.throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.resultNow(), order.resultNow());
}&lt;/pre&gt;

&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием &lt;code&gt;ExecutorService&lt;/code&gt; и &lt;code&gt;submit()&lt;/code&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;code&gt;close()&lt;/code&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новое API должно облегчить написание многопоточных программ благодаря знакомому структурному подходу. Пока API имеет инкубационный статус, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; и одноимённом пакете.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/424"&gt;Foreign Function &amp; Memory API (Preview) (JEP 424)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, которое было в инкубационном статусе &lt;a href="https://openjdk.org/jeps/412"&gt;в Java 17&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/419"&gt;Java 18&lt;/a&gt;, теперь стало Preview API. Оно находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;


&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/426"&gt;Vector API (Fourth Incubator) (JEP 426)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API, которое уже было в инкубационном статусе три релиза (&lt;a href="https://openjdk.org/jeps/338"&gt;Java 16&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/414"&gt;Java 17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/417"&gt;Java 18&lt;/a&gt;), продолжает в нём находиться. Пока API не выйдет из инкубационного статуса, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/422"&gt;Linux/RISC-V Port (JEP 422)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь официально портирован под архитектуру Linux/RISC-V.&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 19 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до марта 2023 года). Однако Azul обещает выпускать обновления Zulu как минимум &lt;a href="https://www.azul.com/products/azul-support-roadmap/"&gt;до марта 2025 года&lt;/a&gt; (2.5 года).&lt;/p&gt;</content>
  </entry>
</feed>
