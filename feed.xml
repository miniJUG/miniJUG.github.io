<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.org" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.org/feed.xml</id>
  <updated>2025-09-15T19:00:00Z</updated>
  <entry>
    <title>Вышла Java 25</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_25.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_25.html</id>
    <updated>2025-09-15T19:00:00Z</updated>
    <published>2025-09-15T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/25/"&gt;Java 25&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-25.html"&gt;2600 закрытых задач и 18 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/25/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/25/apidiff/24/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 25 является LTS-релизом, а значит у него будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;как минимум 5 лет&lt;/a&gt; с момента выхода (до сентября 2030 года).&lt;/p&gt;

&lt;p&gt;Скачать JDK 25 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/25/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="mt-2"&gt;Рассмотрим все JEP'ы, которые попали в Java 25.&lt;/p&gt;

&lt;h4&gt;Язык&lt;/h4&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/511"&gt;Module Import Declarations (JEP 511)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Module Import Declarations, которые были в режиме preview в &lt;a href="https://openjdk.org/jeps/476"&gt;Java 23&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/494"&gt;Java 24&lt;/a&gt;, стали постоянной языковой конструкцией. По сравнению с Java 24 фича осталась без изменений.&lt;/p&gt;

&lt;p class="mt-2"&gt;Декларация &lt;code&gt;import module M&lt;/code&gt; эквивалентна импорту всех экспортированных пакетов из модуля &lt;code&gt;M&lt;/code&gt; и его транзитивных зависимостей в текущий модуль.&lt;/p&gt;
&lt;p&gt;Например, импорт модуля &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/module-summary.html"&gt;&lt;code&gt;java.base&lt;/code&gt;&lt;/a&gt; имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;import&lt;/span&gt; java.io.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.annotation.*;
&lt;span style="color: green"&gt;// ... 49 packages ...&lt;/span&gt;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.auth.x500.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.cert.*;&lt;/pre&gt;

&lt;p&gt;Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt;, &lt;code&gt;Path&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; и др. без необходимости отдельного импорта их с указанием соответствующих пакетов.&lt;/p&gt;

&lt;p&gt;Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую &lt;a href="https://openjdk.org/jeps/458"&gt;без предварительной компиляции&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;При использовании &lt;i&gt;компактных исходных файлов&lt;/i&gt; модуль &lt;code&gt;java.base&lt;/code&gt; импортируется автоматически. Об этом следующий JEP 512.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/512"&gt;Compact Source Files and Instance Main Methods (JEP 512)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Компактные исходные файлы и instance-методы &lt;code&gt;main()&lt;/code&gt; стали постоянными. Среди рассматриваемых сегодня эта языковая фича была в preview дольше всех, появившись ещё аж в прошлом LTS-релизе: &lt;a href="https://openjdk.org/jeps/445"&gt;Java 21&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/463"&gt;Java 22&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/477"&gt;Java 23&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/495"&gt;Java 24&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;В этом релизе есть несколько изменений:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Название "простые исходные файлы" поменялось на "компактные исходные файлы".&lt;/li&gt;
  &lt;li&gt;Класс &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/IO.html"&gt;&lt;code&gt;java.io.IO&lt;/code&gt;&lt;/a&gt; теперь стал &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/IO.html"&gt;&lt;code&gt;java.lang.IO&lt;/code&gt;&lt;/a&gt;. Значит, он теперь импортируется неявно в любой исходный файл (необязательно компактный).&lt;/li&gt;
  &lt;li&gt;Статические методы класса &lt;code&gt;IO&lt;/code&gt; больше не импортируются неявно в компактных исходных файлах. Теперь придётся указывать класс (например, &lt;code&gt;IO.println("Hello, world!")&lt;/code&gt;), либо вручную статически импортировать методы.&lt;/li&gt;
  &lt;li&gt;Реализация класса &lt;code&gt;IO&lt;/code&gt; теперь базируется на &lt;code&gt;System.out&lt;/code&gt; и &lt;code&gt;System.in&lt;/code&gt;, а не на &lt;code&gt;java.io.Console&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Какие возможности даёт JEP 512?&lt;/p&gt;

&lt;p&gt;Теперь можно запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; (т.е. является instance-методом) и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 25 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, можно запускать файлы и без объявленного класса вовсе. Такие файлы называются &lt;i&gt;компактными исходными файлами&lt;/i&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 25 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один дефолтный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда является final и наследуется от &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p&gt;Наконец, с помощью класса &lt;code&gt;java.lang.IO&lt;/code&gt; можно в примере выше заменить магический &lt;code&gt;System.out.println()&lt;/code&gt; на более короткий и понятный &lt;code&gt;IO.println()&lt;/code&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    IO.println(greeting);
}&lt;/pre&gt;

&lt;p&gt;Ещё одной особенностью компактных исходных файлов является то, что каждый такой файл неявно импортирует модуль &lt;code&gt;java.base&lt;/code&gt; (фича из предыдущего JEP 511). Это значит, что ко всем базовым классам Java можно обращаться без необходимости импортов:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    IO.println(List.of(&lt;span style="color: darkred"&gt;"James"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bill"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Guy"&lt;/span&gt;));
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Компактные исходные файлы и instance-методы &lt;code&gt;main()&lt;/code&gt; вводятся в Java с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/513"&gt;Flexible Constructor Bodies (JEP 513)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Flexible Constructor Bodies, которые были в preview три релиза (&lt;a href="https://openjdk.org/jeps/447"&gt;Java 22&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/482"&gt;Java 23&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/492"&gt;Java 24&lt;/a&gt;), стали постоянной фичей языка. По сравнению с Java 24 изменений нет.&lt;/p&gt;

&lt;p&gt;Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;return&lt;/span&gt; value;
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Super(C x, C y) { ... }
}

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(C x) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x); &lt;span style="color: green"&gt;// x is shared here&lt;/span&gt;
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(&lt;span style="color: blue"&gt;new&lt;/span&gt; C(i));
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 25 то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = &lt;span style="color: blue"&gt;new&lt;/span&gt; C(i);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x);
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать instance-методы). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        var x = i;              &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; B {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
    &lt;span style="color: blue"&gt;void&lt;/span&gt; m() {}
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; B {
    C() {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = i; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        m();       &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Однако если читать поля конструируемого класса до вызова &lt;code&gt;super()&lt;/code&gt; нельзя, то инициализировать их можно:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i = i; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: red"&gt;// new Sub(42) will print 0&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова &lt;code&gt;super()&lt;/code&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: green"&gt;// new Sub(42) will print 42&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Также инициализация полей до &lt;code&gt;super()&lt;/code&gt; можно пригодиться в проекте Valhalla для &lt;a href="https://youtu.be/IF9l8fYfSnI?t=2006"&gt;definite assignment полей&lt;/a&gt; null-restricted value-классов.&lt;/p&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/507"&gt;Primitive Types in Patterns, instanceof, and switch (Third Preview) (JEP 507)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Примитивные типы в паттернах, &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;switch&lt;/code&gt;, которые были в режиме preview в &lt;a href="https://openjdk.org/jeps/455"&gt;Java 23&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/488"&gt;Java 24&lt;/a&gt;, остаются на третье preview без изменений:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;

Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i);
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case double&lt;/span&gt; d -&gt; System.out.println(&lt;span style="color: darkred"&gt;"double: "&lt;/span&gt; + d);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Проверять можно также и то, попадают ли значения в диапазон типа:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"byte: "&lt;/span&gt; + b);
}

&lt;span style="color: blue"&gt;double&lt;/span&gt; d = 3.0;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"float: "&lt;/span&gt; + f);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;В примерах выше &lt;code&gt;42&lt;/code&gt; попадает в диапазон byte (&lt;code&gt;[-128; 127]&lt;/code&gt;), а &lt;code&gt;3.0&lt;/code&gt; без потери точности приводится к &lt;code&gt;int&lt;/code&gt;. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.&lt;/p&gt;

&lt;p&gt;Подобные проверки могут быть полезны и в паттернах записей:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;double&lt;/span&gt; d) {}

&lt;span style="color: blue"&gt;var&lt;/span&gt; json = &lt;span style="color: blue"&gt;new&lt;/span&gt; JsonNumber(3.0);
&lt;span style="color: blue"&gt;if&lt;/span&gt; (json &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;int&lt;/span&gt; i)) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Если до Java 23-25 типы выражений-селекторов в &lt;code&gt;switch&lt;/code&gt; могли быть только &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; и для них поддерживались только константные ветки (&lt;code&gt;case 3&lt;/code&gt; и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = 1.0f;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 0f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"0"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x == 1f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"1"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}

&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = &lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;.isEmpty();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"empty"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"non-empty"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
}&lt;/pre&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/502"&gt;Stable Values (Preview) (JEP 502)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java в режиме preview появилось новое API для &lt;i&gt;стабильных значений&lt;/i&gt;. С помощью них можно создавать иммутабельные данные с отложенной инициализацией, то есть в момент первого обращения. При этом они имеют такую же производительность, как и final поля.&lt;/p&gt;

&lt;p&gt;Вспомним, как в Java можно реализовать отложенную инициализацию классическими средствами:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; OrderController {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Logger logger = &lt;span style="color: blue"&gt;null&lt;/span&gt;;

    Logger getLogger() {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (logger == &lt;span style="color: blue"&gt;null&lt;/span&gt;) {
            logger = Logger.create(OrderController.&lt;span style="color: blue"&gt;class&lt;/span&gt;);
        }
        &lt;span style="color: blue"&gt;return&lt;/span&gt; logger;
    }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; submitOrder(User user, List&amp;lt;Product&gt; products) {
        getLogger().info(&lt;span style="color: darkred"&gt;"order started"&lt;/span&gt;);
        ...
        getLogger().info(&lt;span style="color: darkred"&gt;"order submitted"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше объект &lt;code&gt;logger&lt;/code&gt; инициализируется в момент первого обращения. У такого подхода есть несколько проблем:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Любой доступ к полю &lt;code&gt;logger&lt;/code&gt; должен происходить через метод &lt;code&gt;getLogger()&lt;/code&gt;. Это можно забыть сделать.&lt;/li&gt;
  &lt;li&gt;Код не является потокобезопасным: объект &lt;code&gt;logger&lt;/code&gt; может инициализироваться несколько раз.&lt;/li&gt;
  &lt;li&gt;Компилятор не может применить оптимизацию constant folding, так как поле &lt;code&gt;logger&lt;/code&gt; не является final.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Частично проблем выше можно избежать, прибегнув к другим более сложным идиомам, например, double-checked locking или class holder. Однако с double-checked locking код становится невероятно громоздким и хрупким (например, можно забыть вставить ключевое слово &lt;code&gt;volatile&lt;/code&gt;), а так же отсутствует constant folding. С class holder код становится более-менее простым и надёжным (и есть constant folding), но у этой идиомы есть серьёзные ограничения: она применима только к статическим полям и для каждого поля приходится объявлять свой собственный класс. Также можно использовать &lt;code&gt;ConcurrentHashMap&lt;/code&gt;, однако и у неё есть недостатки: отсутствует constant folding и есть проблемы, если функция возвращает &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Теперь посмотрим, как код будет выглядеть с новым интерфейсом &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html"&gt;&lt;code&gt;StableValue&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; OrderController {
    &lt;span style="color: blue"&gt;private final&lt;/span&gt; StableValue&amp;lt;Logger&gt; logger = StableValue.of();

    Logger getLogger() {
        &lt;span style="color: blue"&gt;return&lt;/span&gt; logger.orElseSet(() -&gt; Logger.create(OrderController.&lt;span style="color: blue"&gt;class&lt;/span&gt;));
    }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; submitOrder(User user, List&amp;lt;Product&gt; products) {
        getLogger().info(&lt;span style="color: darkred"&gt;"order started"&lt;/span&gt;);
        ...
        getLogger().info(&lt;span style="color: darkred"&gt;"order submitted"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Метод &lt;code&gt;orElseSet()&lt;/code&gt; вызывается, чтобы получить содержимое объекта &lt;code&gt;logger&lt;/code&gt;. Если содержимое уже получено, то оно просто возвращается. Если нет, то содержимое вычисляется путём вызова переданного &lt;code&gt;Supplier&lt;/code&gt;'а. &lt;code&gt;StableValue&lt;/code&gt; гарантирует, что &lt;code&gt;Supplier&lt;/code&gt; вызовется не более одного раза, тем самым обеспечивая потокобезопасность.&lt;/p&gt;

&lt;p&gt;Под капотом &lt;code&gt;StableValue&lt;/code&gt; реализован таким образом, что использует внутреннюю для JDK аннотацию &lt;code&gt;@Stable&lt;/code&gt; для хранения содержимого в поле, не являющееся final. Эта аннотация даёт сигнал виртуальной машине, что поле не будет меняться более одного раза, а значит виртуальная машина после установки может считать его константным значением, что открывает возможность для constant folding. Таким образом, &lt;code&gt;StableValue&lt;/code&gt; позволяет добиваться одновременно гибкости инициализации и хорошей производительности.&lt;/p&gt;

&lt;p&gt;Часто удобно создать стабильное значение и сразу же в месте объявления передать &lt;code&gt;Supplier&lt;/code&gt; для инициализации. Для этого есть метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html#supplier(java.util.function.Supplier)"&gt;&lt;code&gt;StableValue.supplier()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; OrderController {
    &lt;span style="color: blue"&gt;private final&lt;/span&gt; Supplier&amp;lt;Logger&gt; logger
        = StableValue.supplier(() -&gt; Logger.create(OrderController.&lt;span style="color: blue"&gt;class&lt;/span&gt;));

    &lt;span style="color: blue"&gt;void&lt;/span&gt; submitOrder(User user, List&amp;lt;Product&gt; products) {
        logger.get().info(&lt;span style="color: darkred"&gt;"order started"&lt;/span&gt;);
        ...
        logger.get().info(&lt;span style="color: darkred"&gt;"order submitted"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше объект &lt;code&gt;StableValue&amp;lt;Logger&gt;&lt;/code&gt; заменился на &lt;code&gt;Supplier&amp;lt;Logger&gt;&lt;/code&gt;, а код стал короче, потому что исчез метод &lt;code&gt;getLogger()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;API также позволяет создавать не только значения с единичным содержимым, но и различные стабильные коллекции и стабильные функции. Приведём пример стабильного списка:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; Application {
    &lt;span style="color: blue"&gt;private static final&lt;/span&gt; List&amp;lt;OrderController&gt; ORDERS
        = StableValue.list(POOL_SIZE, _ -&gt; &lt;span style="color: blue"&gt;new&lt;/span&gt; OrderController());

    &lt;span style="color: blue"&gt;public static&lt;/span&gt; OrderController orders() {
        &lt;span style="color: blue"&gt;long&lt;/span&gt; index = Thread.currentThread().threadId() % POOL_SIZE;
        &lt;span style="color: blue"&gt;return&lt;/span&gt; ORDERS.get((&lt;span style="color: blue"&gt;int&lt;/span&gt;)index);
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше список &lt;code&gt;ORDERS&lt;/code&gt; &amp;ndash; это список, который для каждого индекса вычисляет значение в момент обращения и не более одного раза. Таким образом, &lt;code&gt;StableValue&lt;/code&gt; &amp;ndash; это ещё и хороший вариант для написания кэшей.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/503"&gt;Remove the 32-bit x86 Port (JEP 503)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;32-битный x86 порт OpenJDK был окончательно удалён. Это означает, что из кодовой базы удалены части кода, отвечающие за 32 бит x86. Собрать JDK под эту платформу больше нельзя.&lt;/p&gt;

&lt;p&gt;Ранее 32-битный x86 порт был помечен как &lt;a href="https://openjdk.org/jeps/501"&gt;deprecated for removal&lt;/a&gt; в Java 24. Причинами удаления порта являются сложность поддержки, отсутствие на ней эффективной реализации виртуальных потоков, окончание поддержки &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;Windows 10 в октябре 2025&lt;/a&gt; (последняя версия Windows, поддерживающая 32 бит), скорое &lt;a href="https://lists.debian.org/debian-devel-announce/2023/12/msg00003.html"&gt;прекращение поддержки 32 бит x86 в Debian&lt;/a&gt; и др. Удаление 32 бит x86 поможет упростить и ускорить разработку OpenJDK, в частности таких API как Loom, Foreign Function &amp; Memory API, Vector API и т.д.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/505"&gt;Structured Concurrency (Fifth Preview) (JEP 505)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое было в режиме preview в &lt;a href="https://openjdk.org/jeps/453"&gt;Java 21&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/462"&gt;Java 22&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/480"&gt;Java 23&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/499"&gt;Java 24&lt;/a&gt;, остаётся в режиме preview в пятый раз.&lt;/p&gt;

&lt;p&gt;По сравнению с Java 24 есть важное изменение в API: &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt; теперь создаётся не через публичные конструкторы, а через различные перегрузки статического метода &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#open()"&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;

&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;закрыт&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = StructuredTaskScope.open()) {
    Subtask&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Subtask&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join(); &lt;span style="color: green"&gt;// Join subtasks, propagating exceptions&lt;/span&gt;

    &lt;span style="color: green"&gt;// Both subtasks have succeeded, so compose their results&lt;/span&gt;
    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае использования дефолтного &lt;code&gt;Joiner&lt;/code&gt;'а &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.Joiner.html#awaitAllSuccessfulOrThrow()"&gt;&lt;code&gt;awaitAllSuccessfulOrThrow()&lt;/code&gt;&lt;/a&gt;, но возможны другие с другим поведением).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;p&gt;В Java 26 возможно будет &lt;a href="https://openjdk.org/jeps/8366891"&gt;шестое preview&lt;/a&gt; Structured Concurrency с мелкими изменениями в API.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/506"&gt;Scoped Values (JEP 506)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые были в preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/464"&gt;Java 22&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/481"&gt;Java 23&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/487"&gt;Java 24&lt;/a&gt;, стали постоянным API.&lt;/p&gt;

&lt;p&gt;По сравнению с Java 24 есть мелкое изменение: метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#orElse(T)"&gt;&lt;code&gt;ScopedValue.orElse()&lt;/code&gt;&lt;/a&gt; больше не принимает &lt;code&gt;null&lt;/code&gt; в качестве аргумента.&lt;/p&gt;

&lt;p&gt;Класс &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
  &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
  &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/510"&gt;Key Derivation Function API (JEP 510)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Key Derivation Function API, которое появилось &lt;a href="https://openjdk.org/jeps/478"&gt;в Java 24 в режиме preview&lt;/a&gt;, стало постоянным API. Оно находится в пакете &lt;code&gt;javax.crypto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function"&gt;Функции выведения ключа&lt;/a&gt; (KDF - Key Derivation Functions) могут использоваться для вывода криптографически сильных секретных ключей (например, AES) на основе материала ключа (например, пароля) и других данных (например, соли).&lt;/p&gt;

&lt;p&gt;Новое KDF API является гораздо более подходящим для задач выведения ключей, чем старое API на основе классов &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/KeyGenerator.html"&gt;KeyGenerator&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/crypto/SecretKeyFactory.html"&gt;SecretKeyFactory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Пока что единственной реализацией KDF API в JDK является HKDF (HMAC-based Extract-and-Expand Key Derivation Function), но в будущем планируется реализовать и другие KDF, например, &lt;a href="https://www.rfc-editor.org/rfc/rfc9106.html"&gt;Argon2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Пример выведения секретного AES-ключа с использованием HKDF:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// Create a KDF object for the specified algorithm&lt;/span&gt;
KDF hkdf = KDF.getInstance(&lt;span style="color: darkred"&gt;"HKDF-SHA256"&lt;/span&gt;);

&lt;span style="color: green"&gt;// Create an ExtractExpand parameter specification&lt;/span&gt;
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

&lt;span style="color: green"&gt;// Derive a 32-byte AES key&lt;/span&gt;
SecretKey key = hkdf.deriveKey(&lt;span style="color: darkred"&gt;"AES"&lt;/span&gt;, params);

&lt;span style="color: green"&gt;// Additional deriveKey calls can be made with the same KDF object&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ранее в Java 21 появилось API для &lt;a href="https://openjdk.org/jeps/452"&gt;механизма инкапсуляции ключей&lt;/a&gt; (KEM). Вместе с KDF эти два API являются важными шагами для поддержки в Java &lt;a href="https://www.rfc-editor.org/rfc/rfc9180.html"&gt;Hybrid Public Key Encryption&lt;/a&gt; (HPKE), криптографической схемы, устойчивой к &lt;a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography"&gt;квантовым атакам&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/470"&gt;PEM Encodings of Cryptographic Objects (Preview) (JEP 470)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview появилось новое API для кодирования криптографических объектов в &lt;a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%87%D1%82%D0%B0_%D1%81_%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C%D1%8E"&gt;формат PEM&lt;/a&gt; и декодирования обратно. Криптографическими объектами могут быть самые разные сущности: открытые ключи, закрытые ключи, сертификаты и т.д.&lt;/p&gt;

&lt;p&gt;Приведём пример открытого ключа, закодированного в формате PEM:&lt;/p&gt;
&lt;pre&gt;-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi/kRGOL7wCPTN4KJ2ppeSt5UYB6u
cPjjuKDtFTXbguOIFDdZ65O/8HTUqS/sVzRF+dg7H3/tkQ/36KdtuADbwQ==
-----END PUBLIC KEY-----&lt;/pre&gt;
&lt;p&gt;Такой ключ можно декодировать с помощью нового класса &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMDecoder.html"&gt;&lt;code&gt;java.security.PEMDecoder&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
PEMDecoder decoder = PEMDecoder.of();
PublicKey key = (PublicKey) decoder.decode(data);
System.out.println(key);&lt;/pre&gt;
&lt;p&gt;Кодирование происходит с помощью класса &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMEncoder.html"&gt;&lt;code&gt;java.security.PEMEncoder&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 25&lt;/span&gt;
PEMEncoder encoder = PEMEncoder.of();
String data = encoder.encodeToString(key);
System.out.println(data);&lt;/pre&gt;

&lt;p&gt;Список всех криптографических объектов, которые можно кодировать/декодировать, лимитирован наследниками нового &lt;code&gt;sealed&lt;/code&gt; интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/DEREncodable.html"&gt;&lt;code&gt;java.security.DEREncodable&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; DEREncodable &lt;span style="color: blue"&gt;permits&lt;/span&gt; AsymmetricKey, KeyPair,
    PKCS8EncodedKeySpec, X509EncodedKeySpec, EncryptedPrivateKeyInfo,
    X509Certificate, X509CRL, PEMRecord {
}&lt;/pre&gt;

&lt;p&gt;Среди наследников выделяется особенный класс &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/PEMRecord.html"&gt;&lt;code&gt;java.security.PEMRecord&lt;/code&gt;&lt;/a&gt;. Этот класс может содержать в себе любые PEM-данные. Он может пригодиться, когда для криптографического объекта в Java нет соответствующего API (например, &lt;a href="https://www.rfc-editor.org/rfc/rfc7468#section-7"&gt;запрос сертификата PKCS #10&lt;/a&gt;):&lt;/p&gt;
&lt;!--java--&gt;&lt;pre&gt;&lt;span style="color: blue"&gt;public record&lt;/span&gt; PEMRecord(String type, String content, &lt;span style="color: blue"&gt;byte&lt;/span&gt;[] leadingData)
    &lt;span style="color: blue"&gt;implements&lt;/span&gt; DEREncodable {
    ...
}&lt;/pre&gt;
&lt;!--java--&gt;&lt;pre&gt;PEMRecord pr = PEMDecoder.of().decode(pem, PEMRecord.&lt;span style="color: blue"&gt;class&lt;/span&gt;);&lt;/pre&gt;

&lt;p&gt;В Java 26 будет &lt;a href="https://openjdk.org/jeps/524"&gt;второе preview&lt;/a&gt; этого API с некоторыми изменениями (например, &lt;code&gt;PEMRecord&lt;/code&gt; будет переименован в &lt;code&gt;PEM&lt;/code&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/508"&gt;Vector API (Tenth Incubator) (JEP 508)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/25/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в десятый раз с некоторыми изменениями.&lt;/p&gt;

&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/519"&gt;Compact Object Headers (JEP 519)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Компактные заголовки объектов, которые появились &lt;a href="https://openjdk.org/jeps/450"&gt;в Java 24&lt;/a&gt; в качестве экспериментального режима, больше не являются экспериментальными. Они всё ещё не включены по умолчанию. Таким образом, чтобы их включить, теперь нужна только одна опция:&lt;/p&gt;
&lt;pre&gt;$ java -XX:+UseCompactObjectHeaders ...&lt;/pre&gt;
&lt;p&gt;При указании данной опции размер заголовков объектов в JVM уменьшается с 96/128 бит до 64 бит на 64-битных платформах. Компактные заголовки не только уменьшают размер кучи, но и могут улучшить производительность благодаря более высокой скорости выделения новых объектов, более низкой нагрузки на GC и лучшей локальности данных.&lt;/p&gt;

&lt;p&gt;Сжатие заголовков достигается за счёт объединения mark-слова (64 бит) и class-слова (64 или 32 бит, если включены сжатые указатели на классы) в одно 64-битное слово. В новой схеме указатели на классы всегда являются сжатыми, и количество бит для них уменьшается с 32 до 22. Identity хеш-код остаётся неизменным: 31 бит. Количество тег-битов становится на один больше (для GC self forwarding). Битов для возраста GC остаётся 4, как и было. Также 4 бита резервируются на будущее для &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Работа по сжатию заголовков в OpenJDK ведётся в проекте &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt;, инициированным &lt;a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html"&gt;в марте 2021 года&lt;/a&gt;. В дальнейшем возможно ещё большое сжатие заголовков до 32 бит, что уменьшит потребление памяти ещё сильнее.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/509"&gt;JFR CPU-Time Profiling (Experimental) (JEP 509)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В JDK Flight Recorder появилось профилирование времени CPU в экспериментальном режиме (только на Linux). Для этого появилось новое событие &lt;code&gt;jdk.CPUTimeSample&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true,filename=profile.jfr ...&lt;/pre&gt;

&lt;p&gt;Профилирование времени CPU похоже на обычное профилирование времени выполнения, но с важной разницей: первое измеряет фактическое время, потраченное CPU, то есть исключая различные ожидания (например, чтения из сокета). Построив такой профиль, можно понять, какие методы больше всего потребляют CPU. Профилирование времени CPU в JFR использует специальный таймер в ядре Linux, который генерирует сигнал через каждый фиксированный промежуток потраченного времени CPU.&lt;/p&gt;

&lt;p&gt;Несмотря на то, что фича является экспериментальной, для её включения не требуется флаг &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/518"&gt;JFR Cooperative Sampling (JEP 518)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK Flight Recorder теперь более стабильно выполняет снятие стек-трейсов потоков во время семплирования.&lt;/p&gt;

&lt;p&gt;Чтобы точно снять стек-трейс, необходимо это делать во время сейфпоинта, иначе профилирование будет страдать от проблемы safepoint bias и давать неточный результат. Поэтому раньше JFR снимал стек-трейсы в произвольных точках, а чтобы корректно построить стек-трейс, использовались эвристики. Однако эти эвристики могли быть неэффективными и даже приводить к крешам JVM.&lt;/p&gt;

&lt;p&gt;Поэтому механизм семплирования был переработан и стал более стабилен. Теперь снятие стек-трейсов происходит только в сейфпоинтах, а проблема safepoint bias решается кооперативно: вместо снятия стек-трейса в произвольном месте (не в сейфпоинте) семплирующий поток записывает запрос на семпл в локальную очередь целевого потока, а тот, доходя до сейфпоинта, достаёт запрос из очереди, реконструирует стек-трейс и выдаёт событие JFR.&lt;/p&gt;

&lt;p&gt;Новый механизм всё ещё имеет некоторые недостатки. Например, когда целевой поток выполняет нативный код, новый подход не используется и применяется старый подход.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/520"&gt;JFR Method Timing &amp; Tracing (JEP 520)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одним новшеством в JDK Flight Recorder стали средства для тайминга и трассировки методов с помощью инструментации байткода.&lt;/p&gt;

&lt;p&gt;В отличие от семплирующих профилировщиков (вроде async-profiler), которые периодически снимают стек-трейсы и записывают статистику для наиболее часто исполняемых методов, новый механизм в JFR позволяет сохранять полную и точную информацию для любых методов, даже если метод был вызван всего один раз и работал очень короткое время.&lt;/p&gt;

&lt;p&gt;Тайминг и трассировка методов сохраняются с помощью двух новых событий &lt;code&gt;jdk.MethodTiming&lt;/code&gt; и &lt;code&gt;jdk.MethodTrace&lt;/code&gt;. Оба эти события принимают фильтр, в котором необходимо прописать метод (или методы).&lt;/p&gt;

&lt;p&gt;В следующем примере происходит трассировка метода &lt;code&gt;HashMap.resize()&lt;/code&gt; и дальнейшая распечатка через &lt;code&gt;jfr&lt;/code&gt; всех его вызовов с подробной информацией (время начала вызова, длительность вызова, поток и стек-трейс):&lt;/p&gt;
&lt;pre&gt;$ java -XX:StartFlightRecording:method-trace=java.util.HashMap::resize,filename=recording.jfr ...
$ jfr print --events jdk.MethodTrace --stack-depth 20 recording.jfr
jdk.MethodTrace {
    startTime = 00:39:26.379 (2025-03-05)
    duration = 0.00113 ms
    method = java.util.HashMap.resize()
    eventThread = "main" (javaThreadId = 3)
    stackTrace = [
      java.util.HashMap.putVal(int, Object, Object, boolean, boolean) line: 636
      java.util.HashMap.put(Object, Object) line: 619
      sun.awt.AppContext.put(Object, Object) line: 598
      sun.awt.AppContext.&amp;lt;init&gt;(ThreadGroup) line: 240
      sun.awt.SunToolkit.createNewAppContext(ThreadGroup) line: 282
      sun.awt.AppContext.initMainAppContext() line: 260
      sun.awt.AppContext.getAppContext() line: 295
      sun.awt.SunToolkit.getSystemEventQueueImplPP() line: 1024
      sun.awt.SunToolkit.getSystemEventQueueImpl() line: 1019
      java.awt.Toolkit.getEventQueue() line: 1375
      java.awt.EventQueue.invokeLater(Runnable) line: 1257
      javax.swing.SwingUtilities.invokeLater(Runnable) line: 1415
      java2d.J2Ddemo.main(String[]) line: 674
    ]
}
...&lt;/pre&gt;
&lt;p&gt;Трассировка происходит путём инструментации метода &lt;code&gt;HashMap.resize()&lt;/code&gt; и внедрения в него эмиссии события &lt;code&gt;jdk.MethodTrace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Рассмотрим другой пример, где замеряется тайминг всех статических инициализаторов:&lt;/p&gt;
&lt;pre&gt;$ java '-XX:StartFlightRecording:method-timing=::&amp;lt;clinit&gt;,filename=clinit.jfr' ...
$ jfr view method-timing clinit.jfr

                                 Method Timing

Timed Method                                           Invocations Average Time
------------------------------------------------------ ----------- ------------
sun.font.HBShaper.&amp;lt;clinit&gt;()                                     1 32.500000 ms
java.awt.GraphicsEnvironment$LocalGE.&amp;lt;clinit&gt;()                  1 32.400000 ms
java2d.DemoFonts.&amp;lt;clinit&gt;()                                      1 21.200000 ms
java.nio.file.TempFileHelper.&amp;lt;clinit&gt;()                          1 17.100000 ms
sun.security.util.SecurityProviderConstants.&amp;lt;clinit&gt;()           1  9.860000 ms
java.awt.Component.&amp;lt;clinit&gt;()                                    1  9.120000 ms
sun.font.SunFontManager.&amp;lt;clinit&gt;()                               1  8.350000 ms
sun.java2d.SurfaceData.&amp;lt;clinit&gt;()                                1  8.300000 ms
java.security.Security.&amp;lt;clinit&gt;()                                1  8.020000 ms
sun.security.util.KnownOIDs.&amp;lt;clinit&gt;()                           1  7.550000 ms
...&lt;/pre&gt;
&lt;p&gt;Здесь в качестве фильтра был указан &lt;code&gt;::&amp;lt;clinit&gt;&lt;/code&gt;, что означает все статические инициализаторы всех классов, а не один статический инициализатор конкретного класса.&lt;/p&gt;

&lt;p&gt;В фильтрах могут быть указаны не только методы, но и классы. В таком случае замеряться тайминг или записываться трассировка будет для всех методов класса. Также можно указывать аннотации. В этом случае будут фильтроваться методы или классы, помеченные указанными аннотациями. Например, если указать фильтр &lt;code&gt;method-timing=@jakarta.ws.rs.GET&lt;/code&gt;, то будет записываться статистика вызова эндпоинтов REST-сервиса. Или можно объявить свою аннотацию, например, &lt;code&gt;@StopWatch&lt;/code&gt; и явно помечать ею методы, которые необходимо замерить:&lt;/p&gt;
&lt;pre&gt;$ java -XX:StartFlightRecording:method-timing=@com.example.StopWatch ...&lt;/pre&gt;

&lt;p&gt;Конфигурацию можно осуществлять не только через командную строку, но и через конфигурационные файлы:&lt;/p&gt;
&lt;!--xml--&gt;&lt;pre&gt;&lt;span style="color: green"&gt;&amp;lt;!-- timing.jfc --&gt;&lt;/span&gt;
&amp;lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &amp;lt;configuration version="2.0"&gt;
  &amp;lt;event name="jdk.MethodTiming"&gt;
    &amp;lt;setting name="enabled"&gt;true&amp;lt;/setting&gt;
    &amp;lt;setting name="filter"&gt;
      com.example.Foo::method1;
      com.example.Bar::method2;
      ...
      com.example.Baz::method17
    &amp;lt;/setting&gt;
  &amp;lt;/event&gt;
&amp;lt;/configuration&gt;&lt;/pre&gt;
&lt;pre&gt;$ java -XX:StartFlightRecording:settings=timing.jfc,settings=default ...&lt;/pre&gt;

&lt;p&gt;Также инициировать процесс записи можно на уже запущенной JVM (через &lt;code&gt;jcmd&lt;/code&gt;). Кроме того, через JMX трассировку и тайминг можно передавать по сети.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/514"&gt;Ahead-of-Time Command-Line Ergonomics (JEP 514)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь стало проще создавать AOT-кэши, поддержка которых появилась &lt;a href="https://openjdk.org/jeps/483"&gt;в Java 24&lt;/a&gt;. Теперь это делается в один этап, а не в два.&lt;/p&gt;

&lt;p&gt;В Java 24 AOT-кэш приходилось создавать двумя запусками, сначала записывая AOT-конфигурацию, а потом используя эту конфигурацию для создания кэша:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf \
       -cp app.jar com.example.App ...
$ java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf \
       -XX:AOTCache=app.aot -cp app.jar&lt;/pre&gt;

&lt;p&gt;Теперь же второй запуск не требуется, и создать кэш можно сразу же. Для этого появился новый ключ &lt;code&gt;AOTCacheOutput&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...&lt;/pre&gt;

&lt;p&gt;Запуск приложения с кэшом проходит точно так же. Здесь ничего не изменилось:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...&lt;/pre&gt;

&lt;p&gt;Напомним, что Ahead-of-Time Class Loading &amp; Linking &amp;ndash; это технология, которая улучшает время стартапа Java-приложений благодаря использованию уже готовых загруженных и слинкованных классов. Создание таких классов происходит во время тренировочного запуске приложения, который создаёт ahead-of-time кэш. Далее все последующие ("боевые") запуски используют этот кэш для более быстрого старта.&lt;/p&gt;

&lt;p&gt;Работа над ускорением запуска JVM ведётся в проекте &lt;a href="https://openjdk.org/projects/leyden/"&gt;Leyden&lt;/a&gt;. Он был инициирован &lt;a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html"&gt;в апреле 2020 года&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/515"&gt;Ahead-of-Time Method Profiling (JEP 515)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно улучшение AOT в Java &amp;ndash; это появление профилей методов в AOT-кэшах. Профили методов собираются во время тренировочного запуска и в последующих запусках используются виртуальной машиной для более быстрого прогрева. Благодаря этому программа стартует быстрее и быстрее достигает пиковой производительности.&lt;/p&gt;

&lt;p&gt;Например, небольшая программа, использующая Stream API и загружающая около 900 классов JDK, выполняется за 73 миллисекунды с использованием профиля, в то время как без профиля она выполняется за 90 миллисекунд. Таким образом, улучшение составляет 19%. При этом размер кэша увеличивается всего на 2.5%.&lt;/p&gt;

&lt;p class="mt-2"&gt;Профилирование методов необходимо для выявления горячих методов. Такие методы потребляют больше всего CPU, и чтобы программа работала быстро, JVM должна такие методы компилировать в нативный код в первую очередь. Однако профилирование &amp;ndash; это довольно трудоёмкий процесс, особенно в фазе прогрева, когда профили ещё отсутствуют полностью. Если собирать профили заранее, то можно сократить некоторый объём работы на старте. Благодаря этому выигрышу фаза прогрева сокращается по времени.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/521"&gt;Generational Shenandoah (JEP 521)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Режим работы с поколениями в сборщике мусора Shenandoah, который появился &lt;a href="https://openjdk.org/jeps/404"&gt;в Java 24&lt;/a&gt;, больше не является экспериментальным. Теперь для его включения не нужен флаг &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational ...&lt;/pre&gt;
&lt;p&gt;Режим работы без поколений пока что остаётся режимом по умолчанию в Shenandoah.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 24</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_24.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_24.html</id>
    <updated>2025-03-17T19:00:00Z</updated>
    <published>2025-03-17T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/24/"&gt;Java 24&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-24.html"&gt;2700 закрытых задач и 24 JEP'а&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/24/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/24/apidiff/23/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 24 не является LTS-релизом, и у неё будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;только полгода&lt;/a&gt; (до сентября 2025 года).&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 24 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/24/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="mt-2"&gt;Рассмотрим все JEP'ы, которые попали в Java 24.&lt;/p&gt;

&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/488"&gt;Primitive Types in Patterns, instanceof, and switch (Second Preview) (JEP 488)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Примитивные типы в паттернах, &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;switch&lt;/code&gt;, которые появились &lt;a href="https://openjdk.org/jeps/455"&gt;в Java 23&lt;/a&gt; в режиме preview, остаются на второе preview без изменений:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;

Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i);
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case double&lt;/span&gt; d -&gt; System.out.println(&lt;span style="color: darkred"&gt;"double: "&lt;/span&gt; + d);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Проверять можно также и то, попадают ли значения в диапазон типа:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"byte: "&lt;/span&gt; + b);
}

&lt;span style="color: blue"&gt;double&lt;/span&gt; d = 3.0;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"float: "&lt;/span&gt; + f);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;В примерах выше &lt;code&gt;42&lt;/code&gt; попадает в диапазон byte (&lt;code&gt;[-128; 127]&lt;/code&gt;), а &lt;code&gt;3.0&lt;/code&gt; без потери точности приводится к &lt;code&gt;int&lt;/code&gt;. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.&lt;/p&gt;
&lt;p&gt;Подобные проверки могут быть полезны и в паттернах записей:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;double&lt;/span&gt; d) {}

&lt;span style="color: blue"&gt;var&lt;/span&gt; json = &lt;span style="color: blue"&gt;new&lt;/span&gt; JsonNumber(3.0);
&lt;span style="color: blue"&gt;if&lt;/span&gt; (json &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;int&lt;/span&gt; i)) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Если до Java 23/24 типы выражений-селекторов в &lt;code&gt;switch&lt;/code&gt; могли быть только &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; и для них поддерживались только константные ветки (&lt;code&gt;case 3&lt;/code&gt; и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = 1.0f;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 0f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"0"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x == 1f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"1"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}

&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = &lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;.isEmpty();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"empty"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"non-empty"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;В Java 25 возможно будет &lt;a href="https://openjdk.org/jeps/8349215"&gt;третье preview&lt;/a&gt; этой фичи.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/494"&gt;Module Import Declarations (Second Preview) (JEP 494)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Module Import Declarations, которые появились &lt;a href="https://openjdk.org/jeps/476"&gt;в Java 23&lt;/a&gt; в режиме preview, перешли во второе превью со следующими двумя изменениями.&lt;/p&gt;

&lt;p&gt;Во-первых, при импорте модуля-агрегатора &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.se/module-summary.html"&gt;&lt;code&gt;java.se&lt;/code&gt;&lt;/a&gt;, теперь импортируются и классы &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/module-summary.html"&gt;&lt;code&gt;java.base&lt;/code&gt;&lt;/a&gt;. В Java 23 при импорте &lt;code&gt;java.se&lt;/code&gt; приходилось отдельно импортировать &lt;code&gt;java.base&lt;/code&gt;, чтобы пользоваться базовыми классами Java, что выглядело странно:&lt;/p&gt;

&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;

&lt;span style="color: blue"&gt;import module&lt;/span&gt; java.se;

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
  &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
    &lt;span style="color: red"&gt;// Нужен import module java.base, иначе будет error: cannot find symbol&lt;/span&gt;
    System.out.println(Set.of());
  }
}&lt;/pre&gt;

&lt;p&gt;В Java 24 теперь же это не нужно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;

&lt;span style="color: blue"&gt;import module&lt;/span&gt; java.se;

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
  &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
    &lt;span style="color: green"&gt;// Работает:&lt;/span&gt;
    System.out.println(Set.of());
  }
}&lt;/pre&gt;

&lt;p&gt;Такое стало возможно благодаря тому, что в Java 24 разрешили модулям делать &lt;code&gt;requires transitive java.base&lt;/code&gt; (раньше было нельзя, поскольку считалось, что любой модуль всегда и так зависит от &lt;code&gt;java.base&lt;/code&gt; неявно):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;

&lt;span style="color: blue"&gt;module&lt;/span&gt; M {
  &lt;span style="color: blue"&gt;requires transitive&lt;/span&gt; java.base; &lt;span style="color: green"&gt;// С Java 24 можно&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;В декларацию &lt;code&gt;java.se&lt;/code&gt; строчка &lt;code&gt;requires transitive java.base&lt;/code&gt; была соответственно и добавлена.&lt;/p&gt;

&lt;p&gt;Во-вторых, импорты со звёздочкой теперь могут перекрывать импорты модулей. До этого перекрывать могли только одиночные импорты:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;

&lt;span style="color: blue"&gt;import module&lt;/span&gt; java.desktop;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.util.List; &lt;span style="color: green"&gt;// Только так можно перекрыть java.awt.List из java.desktop (import java.util.* не сработает)&lt;/span&gt;

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
  &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
    System.out.println(List.of()); &lt;span style="color: green"&gt;// Резолвится java.util.List&lt;/span&gt;
  }
}&lt;/pre&gt;

&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;

&lt;span style="color: blue"&gt;import module&lt;/span&gt; java.desktop;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.util.*; &lt;span style="color: green"&gt;// Теперь можно и так&lt;/span&gt;

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
  &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
    System.out.println(List.of()); &lt;span style="color: green"&gt;// Резолвится java.util.List&lt;/span&gt;
  }
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Напомним, что такое вообще импорт модулей. Декларация &lt;code&gt;import module M&lt;/code&gt; эквивалентна импорту всех экспортированных пакетов из модуля &lt;code&gt;M&lt;/code&gt; и его транзитивных зависимостей в текущий модуль.&lt;/p&gt;
&lt;p&gt;Например, импорт модуля &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/module-summary.html"&gt;&lt;code&gt;java.base&lt;/code&gt;&lt;/a&gt; имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;import&lt;/span&gt; java.io.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.annotation.*;
&lt;span style="color: green"&gt;// ... 49 packages ...&lt;/span&gt;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.auth.x500.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.cert.*;&lt;/pre&gt;

&lt;p&gt;Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt;, &lt;code&gt;Path&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; и др. без необходимости отдельного импорта их соответствующих пакетов.&lt;/p&gt;
&lt;p&gt;Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую &lt;a href="https://openjdk.org/jeps/458"&gt;без предварительной компиляции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;При использовании &lt;i&gt;простых исходных файлов&lt;/i&gt; модуль &lt;code&gt;java.base&lt;/code&gt; импортируется автоматически. Об этом следующий JEP 495.&lt;/p&gt;

&lt;p&gt;Планируется, что фича выйдет из preview &lt;a href="https://openjdk.org/jeps/8344700"&gt;в Java 25&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/495"&gt;Simple Source Files and Instance Main Methods (Fourth Preview) (JEP 495)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Простые исходные файлы и инстанс-методы &lt;code&gt;main()&lt;/code&gt; остаются в режиме preview в четвёртый раз. Эта фича появилась &lt;a href="https://openjdk.org/jeps/445"&gt;в Java 21&lt;/a&gt; и дважды менялась: сначала &lt;a href="https://openjdk.org/jeps/463"&gt;в Java 22&lt;/a&gt;, а потом &lt;a href="https://openjdk.org/jeps/477"&gt;в Java 23&lt;/a&gt;. На этот раз изменений нет кроме новой терминологии и названия JEP'а (в Java 25 фича возможно &lt;a href="https://mail.openjdk.org/pipermail/amber-dev/2025-January/009198.html"&gt;опять поменяется&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Новый протокол запуска Java-программ позволяет запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; (т.е. является instance-методом) и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 24 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, можно запускать файлы и без объявленного класса вовсе. Такие файлы называются простыми исходными файлами:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 24 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один дефолтный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда является final и наследуется от &lt;code&gt;java.lang.Object&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p&gt;В простых исходных файлах также можно обращаться напрямую к следующим 5 методам для работы с консолью:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;public static void println(Object obj);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public static void println();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public static void print(Object obj);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public static String readln(String prompt);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public static String readln();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;То есть пример выше можно написать ещё короче:&lt;/p&gt;
&lt;pre&gt;String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}&lt;/pre&gt;

&lt;p&gt;Эти методы определены в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/IO.html"&gt;&lt;code&gt;java.io.IO&lt;/code&gt;&lt;/a&gt; (каждый простой исходный файл неявно статически импортирует все его методы).&lt;/p&gt;

&lt;p&gt;Также каждый простой исходный файл неявно импортирует модуль &lt;code&gt;java.base&lt;/code&gt; (фича из предыдущего JEP 494). Это значит, что ко всем базовым классам Java можно обращаться без необходимости импортов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(List.of(&lt;span style="color: darkred"&gt;"James"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bill"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Guy"&lt;/span&gt;));
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Простые исходные файлы и instance методы &lt;code&gt;main()&lt;/code&gt; вводятся в Java с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Планируется, что фича выйдет из preview &lt;a href="https://openjdk.org/jeps/8344699"&gt;в Java 25&lt;/a&gt; (и Simple Source Files будут переименованы в Compact Source Files).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/492"&gt;Flexible Constructor Bodies (Third Preview) (JEP 492)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Statements before &lt;code&gt;super()&lt;/code&gt;, которые появились &lt;a href="https://openjdk.org/jeps/447"&gt;в Java 22&lt;/a&gt; в режиме preview и были переименованы во Flexible Constructor Bodies &lt;a href="https://openjdk.org/jeps/482"&gt;в Java 23&lt;/a&gt;, остаются на третье preview без значительных изменений.&lt;/p&gt;

&lt;p&gt;Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;return&lt;/span&gt; value;
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Super(C x, C y) { ... }
}

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(C x) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x); &lt;span style="color: green"&gt;// x is shared here&lt;/span&gt;
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(&lt;span style="color: blue"&gt;new&lt;/span&gt; C(i));
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 24, включив режим preview, то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 24&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = &lt;span style="color: blue"&gt;new&lt;/span&gt; C(i);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x);
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать инстанс-методы). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        var x = i;              &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; B {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
    &lt;span style="color: blue"&gt;void&lt;/span&gt; m() {}
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; B {
    C() {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = i; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        m();       &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Однако если читать поля конструируемого класса до вызова &lt;code&gt;super()&lt;/code&gt; нельзя, то инициализировать их можно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i = i; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: red"&gt;// new Sub(42) will print 0&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова &lt;code&gt;super()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: green"&gt;// new Sub(42) will print 42&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Также инициализация полей до &lt;code&gt;super()&lt;/code&gt; можно пригодиться в проекте Valhalla для &lt;a href="https://youtu.be/IF9l8fYfSnI?t=2006"&gt;definite assignment полей&lt;/a&gt; null-restricted value-классов.&lt;/p&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;p&gt;Планируется, что фича выйдет из preview &lt;a href="https://openjdk.org/jeps/8344702"&gt;в Java 25&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/485"&gt;Stream Gatherers (JEP 485)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Stream gatherers, которые &lt;a href="https://openjdk.org/jeps/461"&gt;в Java 22&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/473"&gt;в Java 23&lt;/a&gt; были в режиме preview, стали постоянным API.&lt;/p&gt;

&lt;p&gt;Gatherers &amp;ndash; это усовершенствование Stream API для поддержки произвольных промежуточных операций.&lt;/p&gt;
&lt;p&gt;Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#limit(long)"&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/a&gt;,
  &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#skip(long)"&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; и т.д). В Java 9 были добавлены &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"&gt;&lt;code&gt;dropWhile&lt;/code&gt;&lt;/a&gt;. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.&lt;/p&gt;
&lt;p&gt;Новая точка расширения &amp;ndash; это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"&gt;&lt;code&gt;Stream::gather(Gatherer)&lt;/code&gt;&lt;/a&gt;, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html"&gt;&lt;code&gt;Gatherer&lt;/code&gt;&lt;/a&gt;, предоставляемого пользователем. Операция &lt;code&gt;gather()&lt;/code&gt; аналогична уже имеющейся операции &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"&gt;&lt;code&gt;Stream::collect(Collector)&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;collect()&lt;/code&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html"&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; определяют точку расширения для терминальных операций, то &lt;code&gt;gather()&lt;/code&gt; и &lt;code&gt;Gatherer&lt;/code&gt; определяют точку расширения для промежуточных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gatherer&lt;/code&gt; представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса &lt;code&gt;Gatherer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gather()&lt;/code&gt; также является промежуточной операцией, поэтому может быть несколько &lt;code&gt;gather()&lt;/code&gt; в одной цепочке:&lt;/p&gt;
&lt;pre&gt;source.gather(a).gather(b).gather(c).collect(...)&lt;/pre&gt;

&lt;p&gt;Вместе с самим &lt;code&gt;Gatherer&lt;/code&gt; было добавлено несколько готовых gatherer'ов, определённых в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html"&gt;&lt;code&gt;Gatherers&lt;/code&gt;&lt;/a&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"&gt;&lt;code&gt;mapConcurrent&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"&gt;&lt;code&gt;windowFixed&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"&gt;&lt;code&gt;windowSliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Давайте рассмотрим несколько примеров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.fold(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .findFirst()
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .get();
&lt;span style="color: grey"&gt;$1 ==&gt;&lt;/span&gt; "123456789"&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.scan(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .toList()
&lt;span style="color: grey"&gt;$2 ==&gt;&lt;/span&gt; [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
&lt;span style="color: grey"&gt;$3 ==&gt;&lt;/span&gt; [[1, 2, 3], [4, 5, 6], [7, 8]]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
&lt;span style="color: grey"&gt;$4 ==&gt;&lt;/span&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]&lt;/pre&gt;

&lt;p&gt;Дизайн интерфейса &lt;code&gt;Gatherer&lt;/code&gt; был создан под влиянием интерфейса &lt;code&gt;Collector&lt;/code&gt;. Вот основная часть его сигнатуры:&lt;/p&gt;
&lt;pre&gt;public interface Gatherer&amp;lt;T, A, R&gt; {
    Supplier&amp;lt;A&gt; initializer();
    Integrator&amp;lt;A, T, R&gt; integrator();
    BinaryOperator&amp;lt;A&gt; combiner();
    BiConsumer&amp;lt;A, Downstream&amp;lt;? super R&gt;&gt; finisher();
}&lt;/pre&gt;
&lt;p&gt;Если взглянуть на &lt;code&gt;Collector&lt;/code&gt;, то он также имеет три параметра &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt; и содержит 4 основных метода: &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#supplier()"&gt;&lt;code&gt;supplier&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#accumulator()"&gt;&lt;code&gt;accumulator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#combiner()"&gt;&lt;code&gt;combiner&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collector.html#finisher()"&gt;&lt;code&gt;finisher&lt;/code&gt;&lt;/a&gt;. Однако &lt;code&gt;Gatherer&lt;/code&gt; использует два вспомогательных интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"&gt;&lt;code&gt;Integrator&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"&gt;&lt;code&gt;Downstream&lt;/code&gt;&lt;/a&gt;, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.&lt;/p&gt;
&lt;p&gt;Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс &lt;code&gt;Gatherer&lt;/code&gt; и можно воспользоваться готовыми методами-фабриками: &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::of(Integrator)&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::ofSequential(Integrator)&lt;/code&gt;&lt;/a&gt; или другими вариациями.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/484"&gt;Class-File API (JEP 484)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Стандартное API для парсинга, генерации и трансформации class-файлов, которое было &lt;a href="https://openjdk.org/jeps/457"&gt;в Java 22&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/466"&gt;в Java 23&lt;/a&gt; в режиме preview, стало постоянным API.&lt;/p&gt;
&lt;p&gt;Новое API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/classfile/package-summary.html"&gt;&lt;code&gt;java.lang.classfile&lt;/code&gt;&lt;/a&gt;. Оно должно заменить копию библиотеки &lt;a href="https://asm.ow2.io/"&gt;ASM&lt;/a&gt; внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.&lt;/p&gt;
&lt;p&gt;Основная проблема ASM (и других библиотек для работы с class-файлами) &amp;ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &amp;ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.&lt;/p&gt;
&lt;p&gt;Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &amp;ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2025 году.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/498"&gt;Warn upon Use of Memory-Access Methods in sun.misc.Unsafe (JEP 498)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;При вызове методов доступа к памяти в классе &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; теперь выдаётся предупреждение в консоль (при первом вызове к соответствующему методу):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: orange"&gt;WARNING: A terminally deprecated method in sun.misc.Unsafe has been called
WARNING: sun.misc.Unsafe::setMemory has been called by com.foo.bar.Server (file:/tmp/foobarserver/thing.jar)
WARNING: Please consider reporting this to the maintainers of com.foo.bar.Server
WARNING: sun.misc.Unsafe::setMemory will be removed in a future release&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;До этого все эти методы стали deprecated for removal. Это произошло &lt;a href="https://openjdk.org/jeps/471"&gt;в Java 23&lt;/a&gt; и в &lt;a href="https://bugs.openjdk.org/browse/JDK-8278223"&gt;Java 18&lt;/a&gt;. Это почти все методы класса: 77 из 87 методов.&lt;/p&gt;
&lt;p&gt;Также &lt;a href="https://bugs.openjdk.org/browse/JDK-8315953"&gt;в Java 22&lt;/a&gt; стали deprecated for removal 6 методов, не относящиеся к памяти, но в Java 24 при их вызове пока не будет предупреждения.&lt;/p&gt;

&lt;p&gt;Вместо методов доступа к памяти необходимо использовать стандартное API в Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/invoke/VarHandle.html"&gt;&lt;code&gt;java.lang.invoke.VarHandle&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для манипуляций с памятью внутри кучи, появилось &lt;a href="https://openjdk.org/jeps/193"&gt;в Java 9&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;java.lang.foreign.MemorySegment&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для доступа к памяти вне кучи (часто в кооперации с &lt;code&gt;VarHandle&lt;/code&gt;), появилось &lt;a href="https://openjdk.org/jeps/454"&gt;в Java 22&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В Java 23 появилась новая опция командной строки &lt;code&gt;--sun-misc-unsafe-memory-access={allow|warn|debug|deny}&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=allow&lt;/code&gt; &amp;ndash; при вызове методов предупреждения нет (дефолтное значение в Java 23).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=warn&lt;/code&gt; &amp;ndash; выдаётся предупреждение при первом вызове (стало дефолтным значением в Java 24).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=debug&lt;/code&gt; &amp;ndash; выдаётся предупреждение при каждом вызове.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=deny&lt;/code&gt; &amp;ndash; выбрасывается &lt;code&gt;UnsupportedOperationException&lt;/code&gt; (станет дефолтным значением в Java 26 или позже; &lt;code&gt;allow&lt;/code&gt; использовать будет нельзя).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В конце концов методы доступа к памяти будут удалены совсем (опция &lt;code&gt;--sun-misc-unsafe-memory-access&lt;/code&gt; будет игнорироваться какое-то время, а потом удалится).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/472"&gt;Prepare to Restrict the Use of JNI (JEP 472)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;С Java 24 началась подготовка к ограничению JNI (Java Native Interface). Первым шагом стало то, что при загрузке нативных библиотек через JNI и линковке теперь будут выдаваться предупреждения в консоль:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: orange"&gt;WARNING: A restricted method in java.lang.System has been called
WARNING: System::load has been called by com.foo.Server in module com.foo (file:/path/to/com.foo.jar)
WARNING: Use --enable-native-access=com.foo to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Разработчик может подавить такие предупреждения с помощью опции командной строки &lt;code&gt;--enable-native-access&lt;/code&gt;, в которой необходимо будет явно перечислить модули, которым даётся разрешение на использование нативных библиотек:&lt;/p&gt;
&lt;pre&gt;java --enable-native-access=M1,M2 ...&lt;/pre&gt;
&lt;p&gt;Если ваш код находится в class path, то в качестве модуля надо указать &lt;code&gt;ALL-UNNAMED&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;java --enable-native-access=ALL-UNNAMED ...&lt;/pre&gt;

&lt;p&gt;Опция &lt;code&gt;--enable-native-access&lt;/code&gt; не нова &amp;ndash; она появилась в Java 22 с появлением &lt;a href="https://openjdk.org/jeps/454"&gt;Foreign Function &amp; Memory API&lt;/a&gt;. Но если до Java 24 она контролировала только ограничение на использование FFM API, то теперь распространяется и на JNI.&lt;/p&gt;

&lt;p&gt;В Java 24 также появилась новая опция &lt;code&gt;--illegal-native-access={allow,warn,deny}&lt;/code&gt;. Она может пригодиться, если не хочется явно перечислять модули через &lt;code&gt;--enable-native-access&lt;/code&gt;. Её значение по умолчанию &amp;ndash; &lt;code&gt;warn&lt;/code&gt;, но если указать &lt;code&gt;allow&lt;/code&gt;, то все предупреждения о нелегальном нативном доступе в консоли будут подавлены. Если же указать &lt;code&gt;deny&lt;/code&gt;, то при каждом нелегальном доступе, наоборот, будет выбрасываться исключение &lt;code&gt;IllegalCallerException&lt;/code&gt;. &lt;code&gt;deny&lt;/code&gt; станет значением по умолчанию в одной из будующих версий Java. Когда это случится, можно будет переключиться только на &lt;code&gt;warn&lt;/code&gt; (&lt;code&gt;allow&lt;/code&gt; будет удалён). Ещё позже будет недоступен уже и &lt;code&gt;warn&lt;/code&gt;, и &lt;code&gt;--enable-native-access&lt;/code&gt; будет единственным способом разрешения JNI.&lt;/p&gt;

&lt;p&gt;Ограничение JNI &amp;ndash; это один из этапов перехода на философию &lt;a href="https://openjdk.org/jeps/8305968"&gt;Integrity by Default&lt;/a&gt; в Java. Смысл её в том, что по умолчанию код, который запускает пользователь, не должен делать ничего кроме использования безопасного API. Если же нужно использовать что-то небезопасное, что потенциально может нарушить целостность, то это возможно только при условии явного разрешения со стороны пользователя.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/486"&gt;Permanently Disable the Security Manager (JEP 486)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Security Manager, который стал &lt;a href="https://openjdk.org/jeps/411"&gt;deprecated for removal&lt;/a&gt; в Java 17, теперь полностью отключён. При попытке его включить через командную строку виртуальная машина откажется стартовать, выдав ошибку:&lt;/p&gt;
&lt;pre&gt;$ java -Djava.security.manager -jar app.jar
&lt;span style="color: red"&gt;Error occurred during initialization of VM
java.lang.Error: A command line option has attempted to allow or enable the Security Manager. Enabling a Security Manager is not supported.
        at java.lang.System.initPhase3(java.base@24/System.java:2067)&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;С любыми другими значениями свойства &lt;code&gt;java.security.manager&lt;/code&gt; (кроме &lt;code&gt;disallow&lt;/code&gt;) будет происходить то же самое:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-Djava.security.manager=""&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-Djava.security.manager=allow&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-Djava.security.manager=default&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-Djava.security.manager=com.foo.CustomM&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Также при попытке установки Security Manager'а в рантайме через &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"&gt;&lt;code&gt;System::setSecurityManager&lt;/code&gt;&lt;/a&gt; будет всегда выбрасываться &lt;code&gt;UnsupportedOperationException&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: red"&gt;Exception in thread "main" java.lang.UnsupportedOperationException: Setting a Security Manager is not supported.
        at java.base/java.lang.System.setSecurityManager(System.java:286)
        ...&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Другие изменения в поведении:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/System.html#getSecurityManager()"&gt;&lt;code&gt;System::getSecurityManager&lt;/code&gt;&lt;/a&gt; всегда возвращает &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Методы &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/AccessController.html#doPrivileged(java.security.PrivilegedAction)"&gt;&lt;code&gt;AccessController::doPrivileged&lt;/code&gt;&lt;/a&gt; просто выполняют действие немедленно.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/AccessController.html#checkPermission(java.security.Permission)"&gt;&lt;code&gt;AccessController::checkPermission&lt;/code&gt;&lt;/a&gt; всегда выбрасывает &lt;code&gt;AccessControlException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/security/Policy.html#setPolicy(java.security.Policy)"&gt;&lt;code&gt;Policy::setPolicy&lt;/code&gt;&lt;/a&gt; всегда выбрасывает &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Методы &lt;code&gt;SecurityManager::check*&lt;/code&gt; всегда выбрасывают &lt;code&gt;SecurityException&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Игнорируются некоторые свойства, связанные с Security Manager (&lt;code&gt;java.security.policy&lt;/code&gt;, &lt;code&gt;jdk.security.filePermCompat&lt;/code&gt; и другие).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Сами классы, связанные с Security Manager API, пока что остаются. Окончательное их удаление планируется в будущем.&lt;/p&gt;

&lt;p class="mt-2"&gt;Отказаться от Security Manager было решено по причине того, что он почти не имел спроса среди разработчиков и при этом слабо отвечал современным требованиям безопасности. Сейчас существуют гораздо более эффективные способы обеспечения безопасности приложений: контейнеры, гипервизоры, песочницы на уровне OS и т.д. Цена же поддержки Security Manager'а оставалось крайне высокой из-за сложной программной модели. Избавившись от необходимости поддерживать Security Manager, разработчики OpenJDK смогут лучше сфокусироваться на других более важных частях JDK, связанных с безопасностью.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/499"&gt;Structured Concurrency (Fourth Preview) (JEP 499)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое было в режиме preview в &lt;a href="https://openjdk.org/jeps/453"&gt;Java 21&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/462"&gt;Java 22&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/480"&gt;Java 23&lt;/a&gt;, остаётся на четвёртый раунд preview без изменений.&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both subtasks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: green"&gt;// Here, both subtasks have succeeded, so compose their results&lt;/span&gt;
    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;
&lt;p&gt;В Java 25 возможно будет &lt;a href="https://openjdk.org/jeps/8340343"&gt;пятое preview&lt;/a&gt; Structured Concurrency с изменениями в API.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/487"&gt;Scoped Values (Fourth Preview) (JEP 487)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые были в preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/464"&gt;Java 22&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/481"&gt;Java 23&lt;/a&gt;, остаётся на четвёртый раунд preview.&lt;/p&gt;
&lt;p&gt;В четвёртом preview в классе &lt;code&gt;ScopedValue&lt;/code&gt; были удалены методы &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#callWhere(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp)"&gt;&lt;code&gt;callWhere()&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#runWhere(java.lang.ScopedValue,java.lang.Object,java.lang.Runnable)"&gt;&lt;code&gt;runWhere()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Класс &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
  &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
  &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/478"&gt;Key Derivation Function API (Preview) (JEP 478)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В пакете &lt;code&gt;javax.crypto&lt;/code&gt; в режиме preview появилось новое API для &lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function"&gt;функций выведения ключа&lt;/a&gt; (KDF - Key Derivation Functions). Такие функции могут использоваться для вывода криптографически сильных секретных ключей (например, AES) на основе материала ключа (например, пароля) и других данных (например, соли).&lt;/p&gt;
&lt;p&gt;Новое KDF API является гораздо более подходящим для задач выведения ключей, чем старое API на основе классов &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/KeyGenerator.html"&gt;KeyGenerator&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/SecretKeyFactory.html"&gt;SecretKeyFactory&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Пока что единственной реализацией KDF API в JDK является HKDF (HMAC-based Extract-and-Expand Key Derivation Function), но в будущем планируется реализовать и другие KDF, например, &lt;a href="https://www.rfc-editor.org/rfc/rfc9106.html"&gt;Argon2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Пример выведения секретного AES-ключа с использованием HKDF:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Create a KDF object for the specified algorithm&lt;/span&gt;
KDF hkdf = KDF.getInstance(&lt;span style="color: darkred"&gt;"HKDF-SHA256"&lt;/span&gt;);

&lt;span style="color: green"&gt;// Create an ExtractExpand parameter specification&lt;/span&gt;
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

&lt;span style="color: green"&gt;// Derive a 32-byte AES key&lt;/span&gt;
SecretKey key = hkdf.deriveKey(&lt;span style="color: darkred"&gt;"AES"&lt;/span&gt;, params);

&lt;span style="color: green"&gt;// Additional deriveKey calls can be made with the same KDF object&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ранее в Java 21 появилось API для &lt;a href="https://openjdk.org/jeps/452"&gt;механизма инкапсуляции ключей&lt;/a&gt; (KEM). Вместе с KDF эти два API являются важными шагами для поддержки в Java &lt;a href="https://www.rfc-editor.org/rfc/rfc9180.html"&gt;Hybrid Public Key Encryption&lt;/a&gt; (HPKE), криптографической схемы, устойчивой к &lt;a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography"&gt;квантовым атакам&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/496"&gt;Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism (JEP 496)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появилась реализация механизма инкапсуляции ключей &lt;a href="https://csrc.nist.gov/pubs/fips/203/final"&gt;ML-KEM&lt;/a&gt;. Это современный криптографический алгоритм обмена ключей, устойчивый к квантовым атакам.&lt;/p&gt;
&lt;p&gt;Реализация ML-KEM использует &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/javax/crypto/KEM.html"&gt;KEM API&lt;/a&gt;, появившееся &lt;a href="https://openjdk.org/jeps/452"&gt;в Java 21&lt;/a&gt;. Поддерживается три набора параметров: ML-KEM-512, ML-KEM-768 и ML-KEM-1024.&lt;/p&gt;
&lt;p&gt;Пример генерации симметричного ключа и его передачи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
KeyPairGenerator g = KeyPairGenerator.getInstance(&lt;span style="color: darkred"&gt;"ML-KEM"&lt;/span&gt;);
KeyPair kp = g.generateKeyPair(); &lt;span style="color: green"&gt;// По умолчанию создаёт пару ML-KEM-768&lt;/span&gt;

&lt;span style="color: green"&gt;// Sender side&lt;/span&gt;
KEM kem1 = KEM.getInstance(&lt;span style="color: darkred"&gt;"ML-KEM"&lt;/span&gt;);
KEM.Encapsulator enc = kem1.newEncapsulator(kp.getPublic());
KEM.Encapsulated encapsulated = enc.encapsulate();
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] msg = encapsulated.encapsulation(); &lt;span style="color: green"&gt;// Send this to receiver&lt;/span&gt;
SecretKey k1 = encapsulated.key(); &lt;span style="color: green"&gt;// Generated symmetric key&lt;/span&gt;

&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
KEM kem2 = KEM.getInstance(&lt;span style="color: darkred"&gt;"ML-KEM"&lt;/span&gt;);
KEM.Decapsulator dec = kem2.newDecapsulator(kp.getPrivate());
SecretKey k2 = dec.decapsulate(msg);

&lt;span style="color: green"&gt;// k1 и k2 должны быть равны&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/497"&gt;Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm (JEP 497)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появилась реализация механизма цифровой подписи &lt;a href="https://csrc.nist.gov/pubs/fips/204/final"&gt;ML-DSA&lt;/a&gt;. Это современный алгоритм цифровой подписи, устойчивый к квантовым атакам.&lt;/p&gt;
&lt;p&gt;Поддерживается три набора параметров: ML-DSA-44, ML-DSA-65 и ML-DSA-87.&lt;/p&gt;
&lt;p&gt;Пример подписи сообщения и её верификации:&lt;/p&gt;
&lt;pre&gt;KeyPairGenerator g = KeyPairGenerator.getInstance(&lt;span style="color: darkred"&gt;"ML-DSA"&lt;/span&gt;);
KeyPair kp = g.generateKeyPair(); &lt;span style="color: green"&gt;// По умолчанию создаёт пару ML-DSA-65&lt;/span&gt;

&lt;span style="color: green"&gt;// Подпись&lt;/span&gt;
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] msg = ...;
Signature ss = Signature.getInstance(&lt;span style="color: darkred"&gt;"ML-DSA"&lt;/span&gt;);
ss.initSign(kp.getPrivate());
ss.update(msg);
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] sig = ss.sign();

&lt;span style="color: green"&gt;// Верификация&lt;/span&gt;
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] msg = ...;
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] sig = ...;
Signature sv = Signature.getInstance(&lt;span style="color: darkred"&gt;"ML-DSA"&lt;/span&gt;);
sv.initVerify(kp.getPublic());
sv.update(msg);
&lt;span style="color: blue"&gt;boolean&lt;/span&gt; verified = sv.verify(sig);&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/489"&gt;Vector API (Ninth Incubator) (JEP 489)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в девятый раз с некоторыми изменениями.&lt;/p&gt;
&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/491"&gt;Synchronize Virtual Threads without Pinning (JEP 491)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки больше не пинятся на свои потоки-носители внутри блоков &lt;code&gt;synchronized&lt;/code&gt;. Такое ограничение существовало с Java 21 по Java 23, где виртуальный поток, захватив монитор, не мог размонтироваться и освободить платформенный поток для другой работы. Особенно плохо это проявлялось в ситуации, в которой код внутри блока &lt;code&gt;synchronized&lt;/code&gt; вызывает долгую блокирующую операцию:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;synchronized byte&lt;/span&gt;[] getData() {
    &lt;span style="color: blue"&gt;byte&lt;/span&gt;[] buf = ...;
    &lt;span style="color: blue"&gt;int&lt;/span&gt; nread = socket.getInputStream().read(buf); &lt;span style="color: red"&gt;// Can block here&lt;/span&gt;
    ...
}&lt;/pre&gt;
&lt;p&gt;Когда платформенный поток пинится на всё время выполнения блока synchronized, он не может быть использован для других виртуальных потоков. Это может сильно навредить масштабируемости приложений, а иногда даже приводить к дедлокам.&lt;/p&gt;
&lt;p&gt;Ещё одним случаем пиннинга было ожидание освобождения монитора при входе в блок synchronized виртуальным потоком. Здесь тоже поток-носитель не мог размонтироваться, до тех пор пока поток не захватит монитор.&lt;/p&gt;
&lt;p&gt;Чтобы предотвратить пиннинг, пользователям и авторам библиотек приходилось переписывать код с &lt;code&gt;synchronized&lt;/code&gt; на классы из пакета &lt;a href="https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/locks/package-summary.html"&gt;&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;&lt;/a&gt;, которые не имеют вышеописанных проблем (но код становится более громоздким). С Java 24 это больше не требуется.&lt;/p&gt;
&lt;p class="mt-2"&gt;Виртуальные потоки появились &lt;a href="https://openjdk.org/jeps/444  "&gt;в Java 21&lt;/a&gt;. Они являются легковесной заменой потоков операционной системы, и их можно создавать в огромном количестве (миллионы экземпляров), что облегчает написание конкурентных программ. Их разработка ведётся в проекте &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;, который был инициирован &lt;a href="https://mail.openjdk.org/pipermail/discuss/2017-September/004390.html"&gt;в сентябре 2017 года&lt;/a&gt;. &lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/450"&gt;Compact Object Headers (Experimental) (JEP 450)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В экспериментальном режиме появилась опция, уменьшающая размер заголовков объектов в JVM с 96/128 бит до 64 бит на 64-битных платформах:&lt;/p&gt;
&lt;pre&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders&lt;/pre&gt;
&lt;p&gt;Заголовки объектов занимают достаточно большой процент памяти, потребляемой JVM. Эксперименты показывают, что в большинстве случаев объекты занимают от 256 до 512 бит. То есть уменьшив заголовки до 64 бит, можно уменьшить потребление памяти на 6-12%. Кроме уменьшения кучи это может улучшить и производительность благодаря более высокой скорости выделения новых объектов, более низкой нагрузки на GC и лучшей локальности данных.&lt;/p&gt;
&lt;p&gt;Сжатие заголовков достигается за счёт объединения mark-слова (64 бит) и class-слова (64 или 32 бит, если включены сжатые указатели на классы) в одно 64-битное слово. В новой схеме указатели на классы всегда являются сжатыми, и количество бит для них уменьшается с 32 до 22. Identity хеш-код остаётся неизменным: 31 бит. Количество тег-битов становится на один больше (для GC self forwarding). Битов для возраста GC остаётся 4, как и было. Также 4 бита резервируются на будущее для &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Работа по сжатию заголовков в OpenJDK ведётся в проекте &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt;, инициированным &lt;a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html"&gt;в марте 2021 года&lt;/a&gt;. JEP 450 является первым результатом работы, попавшим в мейнстрим. В дальнейшем возможно ещё большое сжатие заголовков до 32 бит, что уменьшит потребление памяти ещё сильнее.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/483"&gt;Ahead-of-Time Class Loading &amp; Linking (JEP 483)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появилась возможность запускать приложения с уже загруженными и слинкованными классами, вследствие чего время старта может заметно снизиться. Для этого необходим тренировочный запуск приложения со следующими ключами:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf \
       -cp app.jar com.example.App ...&lt;/pre&gt;
&lt;p&gt;После такого запуска генерируется AOT-конфигурация в файле &lt;code&gt;app.aotconf&lt;/code&gt;, которую нужно преобразовать в AOT-кэш:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf \
       -XX:AOTCache=app.aot -cp app.jar&lt;/pre&gt;
&lt;p&gt;(второй шаг не запускает приложение, а только создаёт кэш)&lt;/p&gt;
&lt;p&gt;Далее все последующие запуски приложения с использованием кэша &lt;code&gt;app.aot&lt;/code&gt; должны быть быстрее:&lt;/p&gt;
&lt;pre&gt;$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...&lt;/pre&gt;
&lt;p&gt;Запуск приложения становится быстрее благодаря тому, что вся работа по чтению, парсингу, загрузке и линковке классов была сделана ahead-of-time, и JVM уже можно её не делать just-in-time.&lt;/p&gt;
&lt;p&gt;Замеры показывают, что простое приложение, использующее Stream API, выполняется на 42% быстрее, если его запустить с использованием AOT-кэша. Другое серверное приложение Spring PetClinic стартует также на 42% быстрее с использованием кэша.&lt;/p&gt;
&lt;p&gt;У технологии есть ряд ограничений:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Все последующие запуски должны выполняться на том же релизе JDK и той же архитектуре.&lt;/li&gt;
  &lt;li&gt;Class path должен быть консистентен тому, что использовался для тренировки.&lt;/li&gt;
  &lt;li&gt;Граф модулей должен быть идентичен. Аргументы &lt;code&gt;-m&lt;/code&gt;, &lt;code&gt;--module&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, &lt;code&gt;--module-path&lt;/code&gt;, &lt;code&gt;--add-modules&lt;/code&gt; и &lt;code&gt;--enable-native-access&lt;/code&gt; должны быть одинаковы. Аргументы &lt;code&gt;--add-exports&lt;/code&gt;, &lt;code&gt;--add-opens&lt;/code&gt;, &lt;code&gt;--add-reads&lt;/code&gt;, &lt;code&gt;--illegal-native-access&lt;/code&gt;, &lt;code&gt;--limit-modules&lt;/code&gt;, &lt;code&gt;--patch-module&lt;/code&gt; и  &lt;code&gt;--upgrade-module-path&lt;/code&gt; не должны использоваться.&lt;/li&gt;
  &lt;li&gt;Сборщик мусора ZGC пока не поддерживается.&lt;/li&gt;
  &lt;li&gt;Могут быть закэшированы только классы, загруженные встроенными загрузчиками классов (пользовательские загрузчики пока не поддерживаются).&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Ahead-of-Time Class Loading &amp; Linking &amp;ndash; это дальнейшее развитие технологии &lt;a href="https://dev.java/learn/jvm/cds-appcds/"&gt;CDS&lt;/a&gt; (Class Data Sharing), которая уже давно есть в Java. До этого CDS могла использоваться только для чтения и парсинга class-файлов. Сейчас же поддерживается их загрузка и линковка.&lt;/p&gt;
&lt;p&gt;Работа над ускорением запуска JVM ведётся в проекте &lt;a href="https://openjdk.org/projects/leyden/"&gt;Leyden&lt;/a&gt;. Он был инициирован &lt;a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html"&gt;в апреле 2020 года&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/490"&gt;ZGC: Remove the Non-Generational Mode (JEP 490)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Режим работы с поколениями в сборщике мусора ZGC (&lt;code&gt;-XX:+UseZGC&lt;/code&gt;), который появился &lt;a href="https://openjdk.org/jeps/439"&gt;в Java 21&lt;/a&gt; и стал включённым по умолчанию &lt;a href="https://openjdk.org/jeps/474"&gt;в Java 23&lt;/a&gt;, теперь стал единственным режимом работы. Режим работы без поколений был удалён, и опция &lt;code&gt;-XX:&amp;pm;ZGenerational&lt;/code&gt; более не имеет эффекта. В будущем при использовании этой опции JVM будет выбрасывать ошибку и будет отказываться стартовать.&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора &lt;a href="https://openjdk.org/jeps/248"&gt;в Java 9&lt;/a&gt; (до него дефолтным был Parallel GC).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/404"&gt;Generational Shenandoah (Experimental) (JEP 404)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Сборщик мусора Shenandoah стал поддерживать поколения в экспериментальном режиме:&lt;/p&gt;
&lt;pre&gt;java -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational&lt;/pre&gt;
&lt;p&gt;Режим работы без поколений остаётся режимом по умолчанию в Shenandoah. Планируется, что режим с поколениями станет дефолтным в будущем.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/479"&gt;Remove the Windows 32-bit x86 Port (JEP 479)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;32-битный порт OpenJDK под Windows был полностью удалён. Это означает, что из кодовой базы OpenJDK были удалены части кода, отвечающие за Windows 32-бит. Собрать JDK под эту платформу больше нельзя.&lt;/p&gt;
&lt;p&gt;32-битный порт под Windows был помечен как &lt;a href="https://openjdk.org/jeps/449"&gt;deprecated for removal&lt;/a&gt; в Java 21. Главной причиной удаления порта стало желание упростить и ускорить разработку платформы. Также в 32-битной версии нет эффективной реализации виртуальных потоков: в ней они мапятся 1:1 на платформенные потоки. Кроме того, 32-битная версия Windows сама доживает свои последние дни: Microsoft прекращает поддержку Windows 10 &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;в октябре&lt;/a&gt; (последняя версия Windows, поддерживающая 32 бит).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/501"&gt;Deprecate the 32-bit x86 Port for Removal (JEP 501)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Вместе с полным удалением 32-битного порта под Windows вся 32-битная x86 архитектура стала deprecated for removal. Практически это означает, что подлежит удалению порт OpenJDK под Linux 32-бит x86, так как это единственная оставшаяся операционная система, для которой есть 32-битный x86 порт.&lt;/p&gt;
&lt;p&gt;Причины такого решения те же самые, что и у удаления 32-битного порта Windows: сложность поддержки, отсутствие эффективной реализации виртуальных потоков и скорое &lt;a href="https://lists.debian.org/debian-devel-announce/2023/12/msg00003.html"&gt;прекращение поддержки 32-бит x86 в Debian&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Полностью удалить 32-битный x86 порт планируется в Java 25. После полного удаления единственным способом запуска Java на 32-бит x86 процессорах будет использование &lt;a href="https://openjdk.org/projects/zero/"&gt;порта Zero&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/493"&gt;Linking Run-Time Images without JMODs (JEP 493)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь может иметь примерно на 25% меньший размер, если в нём будет включена опция, позволяющая собирать кастомные образы с помощью утилиты &lt;code&gt;jlink&lt;/code&gt; без использования JMOD-файлов. Такая опция указывается при сборке JDK, и она выключена по умолчанию, но вендоры JDK могут ей воспользоваться, если захотят предоставлять более лёгкие образы JDK.&lt;/p&gt;
&lt;p&gt;В некоторых случаях размер JDK является критичным параметром, например, в облачных окружениях, где JDK часто передаётся по сети. Уменьшение размера JDK может улучшить эффективность этих операций. JMOD-файлы, находящиеся в директории &lt;code&gt;jmods&lt;/code&gt; &amp;ndash; это одна из причин слишком большой "раздутости" JDK, так как в них содержатся копии всех class-файлов, нативных библиотек и прочих ресурсов, которые уже и так есть внутри образа. Избавиться от JMOD-файлов можно добавив возможность линковать кастомные образы, вытаскивая эти файлы из самого образа, а не из JMOD-файлов. Что и было сделано в JEP 493.&lt;/p&gt;
&lt;p&gt;Проверить, поддерживает ли ваш образ JDK создание кастомных образов без использования JMOD-файлов, можно запустив команду &lt;code&gt;jlink --help&lt;/code&gt; и посмотреть, что написано в Capabilities:&lt;/p&gt;
&lt;pre&gt;$ jlink --help
Usage: jlink &amp;lt;options&gt; --module-path &amp;lt;modulepath&gt; --add-modules &amp;lt;module&gt;[,&amp;lt;module&gt;...]
...
Capabilities:
      &lt;b&gt;Linking from run-time image enabled&lt;/b&gt;&lt;/pre&gt;

&lt;p class="mt-2"&gt;Образы JDK с включённой опцией имеют ряд ограничений:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Сама утилита &lt;code&gt;jlink&lt;/code&gt; не может быть в сгенерированном образе после запуска &lt;code&gt;jlink&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;jlink&lt;/code&gt; выдаст ошибку, если были изменения в конфигурационных файлах.&lt;/li&gt;
  &lt;li&gt;Кросс-линковка (например, запуск &lt;code&gt;jlink&lt;/code&gt; на Linux/x64 для создания образа под Windows/x64) не поддерживается.&lt;/li&gt;
  &lt;li&gt;Линковка не будет работать, если образ использует опцию &lt;code&gt;--patch-module&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Линковка с извлечением модулей из другого образа не поддерживается.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Опция может быть включена по умолчанию в будущем.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/475"&gt;Late Barrier Expansion for G1 (JEP 475)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Реализация барьеров в сборщике мусора G1 была упрощена путём перемещения экспансии барьеров с ранней фазы JIT-компилятора C2 на позднюю.&lt;/p&gt;
&lt;p&gt;Ранняя экспансия барьеров требует от разработчика глубокого знания внутренностей C2, что может замедлить эволюцию и оптимизацию G1. Кроме того, ранняя экспансия увеличивает накладные расходы C2 на 10-20% из-за сложности промежуточного представления (IR) барьеров.&lt;/p&gt;
&lt;p&gt;В Java 24 экспансия барьеров перемещена с самой первой фазы (парсинга байткода в IR) на самую последнюю (эмиссия машинного кода). Такая схема существует в другом сборщике мусора ZGC c Java 14 и доказала свою успешность: экспансия барьеров в самый последний момент не требует никаких специфичных для C2 знаний и не имеет практически никаких накладных расходов на JIT-компиляцию.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 23</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_23.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_23.html</id>
    <updated>2024-09-16T19:00:00Z</updated>
    <published>2024-09-16T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/23/"&gt;Java 23&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-23.html"&gt;2400 закрытых задач и 12 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/23/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/23/apidiff/22/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 23 не является LTS-релизом, и у неё будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;только полгода&lt;/a&gt; (до марта 2025 года).&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 23 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/23/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Рассмотрим все JEP'ы, которые попали в Java 23.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/467"&gt;Markdown Documentation Comments (JEP 467)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь JavaDoc поддерживает формат Markdown. Для его использования документация должна начинаться с &lt;code&gt;///&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// Returns `true` if, and only if, [#length()] is `0`.
///
/// @return `true` if [#length()] is `0`, otherwise `false`&lt;/span&gt;
&lt;span style="color: blue"&gt;public boolean&lt;/span&gt; isEmpty() {
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Markdown компактнее, читабельнее и удобнее для написания, чем существующий формат HTML. Рассмотрим несколько примеров элементов, написанных в формате HTML и Markdown:&lt;/p&gt;
&lt;table class="table"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;HTML&lt;/th&gt;
      &lt;th&gt;Markdown&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;{@link java.util.List}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;[java.util.List]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;{@code true}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;`true`&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;em&gt;warning&amp;lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;_warning_&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;b&gt;error&amp;lt;/b&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;**error**&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
&lt;pre&gt;&amp;lt;ul&gt;
  &amp;lt;li&gt;Item 1&amp;lt;/li&gt;
  &amp;lt;li&gt;Item 2&amp;lt;/li&gt;
  &amp;lt;li&gt;Item 3&amp;lt;/li&gt;
&amp;lt;/ul&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td&gt;
&lt;pre&gt;- Item 1
- Item 2
- Item 3&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;p&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Не нужен (просто необходимо вставить новую строку)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;При этом JavaDoc-теги, такие как &lt;code&gt;{@inheritDoc}&lt;/code&gt;, &lt;code&gt;@param&lt;/code&gt;, &lt;code&gt;@return&lt;/code&gt;, &lt;code&gt;@throws&lt;/code&gt;, остаются прежними:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// {@inheritDoc}
/// In addition, this method calls [#wait()].
///
/// @param i the index&lt;/span&gt;
&lt;span style="color: blue"&gt;public void&lt;/span&gt; m(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Кроме компактности и удобства новый формат также решает проблему сочетания двух символов &lt;code&gt;*/&lt;/code&gt;, которые в формате HTML означают окончание документации:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**
 * &amp;lt;pre&gt;
 * var pattern = Pattern.compile("\\w*/"); // Проблема
 * &amp;lt;/pre&gt;
 */&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;В Markdown-документации же можно не только использовать эту последовательность символов, но и вставлять целые блоки HTML-комментариев:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// Here is an example:
///
/// ```
/// /** Hello World! */
/// public class HelloWorld {
///     public static void main(String... args) {
///         System.out.println("Hello World!"); // the traditional example
///     }
/// }
/// ```&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/455"&gt;Primitive Types in Patterns, instanceof, and switch (Preview) (JEP 455)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь в режиме preview паттерны и операторы &lt;code&gt;instanceof&lt;/code&gt; / &lt;code&gt;switch&lt;/code&gt; поддерживают примитивные типы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;

Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i);
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case double&lt;/span&gt; d -&gt; System.out.println(&lt;span style="color: darkred"&gt;"double: "&lt;/span&gt; + d);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Проверять можно также и то, попадают ли значения в диапазон типа:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"byte: "&lt;/span&gt; + b);
}

&lt;span style="color: blue"&gt;double&lt;/span&gt; d = 3.0;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"float: "&lt;/span&gt; + f);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;В примерах выше &lt;code&gt;42&lt;/code&gt; попадает в диапазон byte (&lt;code&gt;[-128; 127]&lt;/code&gt;), а &lt;code&gt;3.0&lt;/code&gt; без потери точности приводится к &lt;code&gt;int&lt;/code&gt;. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.&lt;/p&gt;
&lt;p&gt;Подобные проверки могут быть полезны и в паттернах записей:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;double&lt;/span&gt; d) {}

&lt;span style="color: blue"&gt;var&lt;/span&gt; json = &lt;span style="color: blue"&gt;new&lt;/span&gt; JsonNumber(3.0);
&lt;span style="color: blue"&gt;if&lt;/span&gt; (json &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;int&lt;/span&gt; i)) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Если раньше типы выражений-селекторов в &lt;code&gt;switch&lt;/code&gt; могли быть только &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; и для них поддерживались только константные ветки (&lt;code&gt;case 3&lt;/code&gt; и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = 1.0f;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 0f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"0"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x == 1f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"1"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}

&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = &lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;.isEmpty();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"empty"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"non-empty"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/476"&gt;Module Import Declarations (Preview) (JEP 476)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview появилась возможность импортировать модули:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;import module&lt;/span&gt; M;&lt;/pre&gt;
&lt;p&gt;Такой импорт эквивалентен импорту всех экспортированных пакетов из модуля &lt;code&gt;M&lt;/code&gt; и его транзитивных зависимостей в текущий модуль.&lt;/p&gt;
&lt;p&gt;Например, импорт модуля &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/module-summary.html"&gt;&lt;code&gt;java.base&lt;/code&gt;&lt;/a&gt; имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;import&lt;/span&gt; java.io.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.annotation.*;
&lt;span style="color: green"&gt;// ... 49 packages ...&lt;/span&gt;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.auth.x500.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.cert.*;&lt;/pre&gt;

&lt;p&gt;Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt;, &lt;code&gt;Path&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; и др. без необходимости отдельного импорта их соответствующих пакетов.&lt;/p&gt;
&lt;p&gt;Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую &lt;a href="https://openjdk.org/jeps/458"&gt;без предварительной компиляции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;При использовании &lt;i&gt;неявно объявленных классов&lt;/i&gt; модуль &lt;code&gt;java.base&lt;/code&gt; импортируется автоматически. Об этом следующий JEP 477.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/477"&gt;Implicitly Declared Classes and Instance Main Methods (Third Preview) (JEP 477)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java 21 в режиме preview появились &lt;a href="https://openjdk.org/jeps/445"&gt;безымянные классы и инстанс-методы &lt;code&gt;main()&lt;/code&gt;&lt;/a&gt;. В Java 22 они были оставлены &lt;a href="https://openjdk.org/jeps/463"&gt;на второе preview&lt;/a&gt; с несколькими изменениями, среди которых самым важным был отказ от безымянных классов в пользу неявно объявленных классов.&lt;/p&gt;
&lt;p&gt;В Java 23 теперь выходит третье preview этой фичи ещё с несколькими изменениями:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html"&gt;&lt;code&gt;java.io.IO&lt;/code&gt;&lt;/a&gt; с тремя публичными статическими методами, которые автоматически импортируются во все неявно объявленные классы:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#print(java.lang.Object)"&gt;&lt;code&gt;void print(Object obj)&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#println(java.lang.Object)"&gt;&lt;code&gt;void println(Object obj)&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#readln(java.lang.String)"&gt;&lt;code&gt;String readln(String prompt)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Неявно объявленные классы автоматически импортируют модуль &lt;code&gt;java.base&lt;/code&gt; (см. JEP 476 выше). То есть автоматически будут видны все публичные верхнеуровневые классы и интерфейсы всех экспортированных пакетов модуля &lt;code&gt;java.base&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новый протокол запуска Java-программ позволяет запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; (т.е. является instance-методом) и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 23 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 23 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// import module java.base; ← неявно
// import static java.io.IO.*; ← неявно

// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Заметьте, что второй пример стал короче не только из-за отсутствия объявления класса, но и из-за использования метода &lt;code&gt;println()&lt;/code&gt; вместо &lt;code&gt;System.out.println()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один неявный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p class="mt-2"&gt;Упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/482"&gt;Flexible Constructor Bodies (Second Preview) (JEP 482)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Statements before &lt;code&gt;super()&lt;/code&gt;, которые появились &lt;a href="https://openjdk.org/jeps/447"&gt;в Java 22&lt;/a&gt; в режиме preview, остаются на второе preview и теперь называются Flexible Constructor Bodies. По сравнению с Java 22 есть одно важное изменение: теперь можно инициализировать поля до вызова конструктора. Про это будет подробнее рассказано дальше.&lt;/p&gt;

&lt;p&gt;Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Super(C x, C y) { ... }
}

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(C x) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x); &lt;span style="color: green"&gt;// x is shared here&lt;/span&gt;
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(&lt;span style="color: blue"&gt;new&lt;/span&gt; C(i));
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 23, включив режим preview, то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = &lt;span style="color: blue"&gt;new&lt;/span&gt; C(i);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x);
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать инстанс-методы). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        var x = i;              &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; B {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
    &lt;span style="color: blue"&gt;void&lt;/span&gt; m() {}
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; B {
    C() {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = i; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        m();       &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Однако если читать поля конструируемого класса до вызова &lt;code&gt;super()&lt;/code&gt; нельзя, то инициализировать их можно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i = i; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: red"&gt;// new Sub(42) will print 0&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова &lt;code&gt;super()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: green"&gt;// new Sub(42) will print 42&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Также инициализация полей до &lt;code&gt;super()&lt;/code&gt; можно пригодиться в проекте Valhalla для &lt;a href="https://youtu.be/IF9l8fYfSnI?t=2006"&gt;definite assignment полей&lt;/a&gt; null-restricted value-классов.&lt;/p&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/473"&gt;Stream Gatherers (Second Preview) (JEP 473)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Stream gatherers, которые &lt;a href="https://openjdk.org/jeps/461"&gt;появились в Java 22&lt;/a&gt; в режиме preview, остаются на второе preview без изменений.&lt;/p&gt;

&lt;p&gt;Gatherers &amp;ndash; это усовершенствование Stream API для поддержки произвольных промежуточных операций.&lt;/p&gt;
&lt;p&gt;Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#limit(long)"&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/a&gt;,
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#skip(long)"&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; и т.д). В Java 9 были добавлены &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"&gt;&lt;code&gt;dropWhile&lt;/code&gt;&lt;/a&gt;. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.&lt;/p&gt;
&lt;p&gt;Новая точка расширения &amp;ndash; это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"&gt;&lt;code&gt;Stream::gather(Gatherer)&lt;/code&gt;&lt;/a&gt;, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html"&gt;&lt;code&gt;Gatherer&lt;/code&gt;&lt;/a&gt;, предоставляемого пользователем. Операция &lt;code&gt;gather()&lt;/code&gt; аналогична уже имеющейся операции &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"&gt;&lt;code&gt;Stream::collect(Collector)&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;collect()&lt;/code&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html"&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; определяют точку расширения для терминальных операций, то &lt;code&gt;gather()&lt;/code&gt; и &lt;code&gt;Gatherer&lt;/code&gt; определяют точку расширения для промежуточных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gatherer&lt;/code&gt; представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса &lt;code&gt;Gatherer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gather()&lt;/code&gt; также является промежуточной операцией, поэтому может быть несколько &lt;code&gt;gather()&lt;/code&gt; в одной цепочке:&lt;/p&gt;
&lt;pre&gt;source.gather(a).gather(b).gather(c).collect(...)&lt;/pre&gt;

&lt;p&gt;Вместе с самим &lt;code&gt;Gatherer&lt;/code&gt; было добавлено несколько готовых gatherer'ов, определённых в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html"&gt;&lt;code&gt;Gatherers&lt;/code&gt;&lt;/a&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"&gt;&lt;code&gt;mapConcurrent&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"&gt;&lt;code&gt;windowFixed&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"&gt;&lt;code&gt;windowSliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Давайте рассмотрим несколько примеров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.fold(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .findFirst()
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .get();
&lt;span style="color: grey"&gt;$1 ==&gt;&lt;/span&gt; "123456789"&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.scan(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .toList()
&lt;span style="color: grey"&gt;$2 ==&gt;&lt;/span&gt; [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
&lt;span style="color: grey"&gt;$3 ==&gt;&lt;/span&gt; [[1, 2, 3], [4, 5, 6], [7, 8]]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
&lt;span style="color: grey"&gt;$4 ==&gt;&lt;/span&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]&lt;/pre&gt;

&lt;p&gt;Дизайн интерфейса &lt;code&gt;Gatherer&lt;/code&gt; был создан под влиянием интерфейса &lt;code&gt;Collector&lt;/code&gt;. Вот основная часть его сигнатуры:&lt;/p&gt;
&lt;pre&gt;public interface Gatherer&amp;lt;T, A, R&gt; {
    Supplier&amp;lt;A&gt; initializer();
    Integrator&amp;lt;A, T, R&gt; integrator();
    BinaryOperator&amp;lt;A&gt; combiner();
    BiConsumer&amp;lt;A, Downstream&amp;lt;? super R&gt;&gt; finisher();
}&lt;/pre&gt;
&lt;p&gt;Если взглянуть на &lt;code&gt;Collector&lt;/code&gt;, то он также имеет три параметра &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt; и содержит 4 основных метода: &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#supplier()"&gt;&lt;code&gt;supplier&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#accumulator()"&gt;&lt;code&gt;accumulator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#combiner()"&gt;&lt;code&gt;combiner&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#finisher()"&gt;&lt;code&gt;finisher&lt;/code&gt;&lt;/a&gt;. Однако &lt;code&gt;Gatherer&lt;/code&gt; использует два вспомогательных интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"&gt;&lt;code&gt;Integrator&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"&gt;&lt;code&gt;Downstream&lt;/code&gt;&lt;/a&gt;, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.&lt;/p&gt;
&lt;p&gt;Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс &lt;code&gt;Gatherer&lt;/code&gt; и можно воспользоваться готовыми методами-фабриками: &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::of(Integrator)&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::ofSequential(Integrator)&lt;/code&gt;&lt;/a&gt; или другими вариациями.&lt;/p&gt;

&lt;p&gt;Stream gatherers станут постоянным API &lt;a href="https://openjdk.org/jeps/485"&gt;в Java 24&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/466"&gt;Class-File API (Second Preview) (JEP 466)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Стандартное API для парсинга, генерации и трансформации class-файлов, которое &lt;a href="https://openjdk.org/jeps/457"&gt;появилось в Java 22&lt;/a&gt;, остаётся на второе preview с несколькими изменениями.&lt;/p&gt;
&lt;p&gt;Новое API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/classfile/package-summary.html"&gt;&lt;code&gt;java.lang.classfile&lt;/code&gt;&lt;/a&gt;. Оно должно заменить копию библиотеки &lt;a href="https://asm.ow2.io/"&gt;ASM&lt;/a&gt; внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.&lt;/p&gt;
&lt;p&gt;Основная проблема ASM (и других библиотек для работы с class-файлами) &amp;ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &amp;ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.&lt;/p&gt;
&lt;p&gt;Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &amp;ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.&lt;/p&gt;

&lt;p&gt;Class-File API станет постоянным API &lt;a href="https://openjdk.org/jeps/484"&gt;в Java 24&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/471"&gt;Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (JEP 471)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В классе &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; все методы доступа к памяти стали deprecated for removal. Это 77 из 87 методов (в JEP написано 79 из 87, но, похоже, автор посчитал неправильно). При этом 3 из них стали deprecated for removal ещё &lt;a href="https://bugs.openjdk.org/browse/JDK-8278223"&gt;в Java 18&lt;/a&gt;: &lt;code&gt;objectFieldOffset()&lt;/code&gt;, &lt;code&gt;staticFieldOffset()&lt;/code&gt; и &lt;code&gt;staticFieldBase()&lt;/code&gt;. Также &lt;a href="https://bugs.openjdk.org/browse/JDK-8315953"&gt;в Java 22&lt;/a&gt; стали deprecated for removal 6 методов, не относящиеся к памяти: &lt;code&gt;park()&lt;/code&gt;, &lt;code&gt;unpark()&lt;/code&gt;, &lt;code&gt;fullFence()&lt;/code&gt;, &lt;code&gt;loadFence()&lt;/code&gt;, &lt;code&gt;storeFence()&lt;/code&gt; и &lt;code&gt;getLoadAverage()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, в &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; остаётся всего 4 метода, которые пока не являются deprecated, причём один из них &amp;ndash; это &lt;code&gt;getUnsafe()&lt;/code&gt;, который получает сам объект &lt;code&gt;Unsafe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;По факту всё это означает, что &lt;code&gt;Unsafe&lt;/code&gt; больше крайне не рекомендуется использовать. Вместо методов доступа к памяти необходимо использовать стандартное API в Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/invoke/VarHandle.html"&gt;&lt;code&gt;java.lang.invoke.VarHandle&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для манипуляций с памятью внутри кучи, появилось &lt;a href="https://openjdk.org/jeps/193"&gt;в Java 9&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;java.lang.foreign.MemorySegment&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для доступа к памяти вне кучи (часто в кооперации с &lt;code&gt;VarHandle&lt;/code&gt;), появилось &lt;a href="https://openjdk.org/jeps/454"&gt;в Java 22&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Использования deprecated методов в &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; будут вызывать предупреждения во время компиляции:&lt;/p&gt;
&lt;pre&gt;HelloWorld.java:4: warning: [removal] getByte(long) in Unsafe has been deprecated and marked for removal
        unsafe.getByte(address);
              ^&lt;/pre&gt;

&lt;p&gt;В дополнение к предупреждениям на этапе компиляции появится возможность включать предупреждения в рантайме при использовании методов доступа к памяти. Для этого появилась новая опция командной строки &lt;code&gt;--sun-misc-unsafe-memory-access={allow|warn|debug|deny}&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=allow&lt;/code&gt; &amp;ndash; при вызове методов предупреждения нет (дефолтное значение в Java 23).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=warn&lt;/code&gt; &amp;ndash; выдаётся предупреждение при первом вызове (станет дефолтным значением в Java 24 или 25).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=debug&lt;/code&gt; &amp;ndash; выдаётся предупреждение при каждом вызове.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=deny&lt;/code&gt; &amp;ndash; выбрасывается &lt;code&gt;UnsupportedOperationException&lt;/code&gt; (станет дефолтным значением в Java 26 или позже; &lt;code&gt;allow&lt;/code&gt; использовать будет нельзя).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В конце концов методы доступа к памяти будут удалены совсем (опция &lt;code&gt;--sun-misc-unsafe-memory-access&lt;/code&gt; будет игнорироваться какое-то время, а потом удалится).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/480"&gt;Structured Concurrency (Third Preview) (JEP 480)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое находится в режиме preview &lt;a href="https://openjdk.org/jeps/453"&gt;с Java 21&lt;/a&gt;, остаётся на третий раунд preview без изменений (&lt;a href="https://openjdk.org/jeps/462"&gt;в Java 22&lt;/a&gt; также не было изменений). До этого оно было в инкубаторе в &lt;a href="https://openjdk.org/jeps/428"&gt;Java 19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;Java 20&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/481"&gt;Scoped Values (Third Preview) (JEP 481)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые стали preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt; и остались на второе preview в &lt;a href="https://openjdk.org/jeps/464"&gt;Java 22&lt;/a&gt;, уходят на третье preview. До этого Scoped Values были в инкубаторе в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В третье preview было внесено пару изменений: метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#callWhere(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp)"&gt;&lt;code&gt;callWhere()&lt;/code&gt;&lt;/a&gt; третьим аргументом теперь принимает новый функциональный интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.CallableOp.html"&gt;&lt;code&gt;CallableOp&lt;/code&gt;&lt;/a&gt; вместо &lt;code&gt;Callable&lt;/code&gt;, а также удалён метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#getWhere(java.lang.ScopedValue,T,java.util.function.Supplier)"&gt;&lt;code&gt;getWhere()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
  &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
  &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/469"&gt;Vector API (Eighth Incubator) (JEP 469)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в восьмой раз без изменений.&lt;/p&gt;
&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/474"&gt;ZGC: Generational Mode by Default (JEP 474)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Режим работы с поколениями, который появился в сборщике мусора ZGC &lt;a href="https://openjdk.org/jeps/439"&gt;в Java 21&lt;/a&gt;, стал включённым по умолчанию. То есть теперь опция &lt;code&gt;-XX:+UseZGC&lt;/code&gt; автоматически включает опцию &lt;code&gt;-XX:+ZGenerational&lt;/code&gt;. Для выключения режима необходимо указать опцию &lt;code&gt;-XX:-ZGenerational&lt;/code&gt;. Однако режим без поколений стал deprecated, и в будущем планируется его окончательное удаление (вместе с опцией &lt;code&gt;-XX:&amp;pm;ZGenerational&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в &lt;a href="https://openjdk.org/jeps/248"&gt;Java 9&lt;/a&gt; (до него дефолтным был Parallel GC)&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 22</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_22.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_22.html</id>
    <updated>2024-03-18T19:00:00Z</updated>
    <published>2024-03-18T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/22/"&gt;Java 22&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-22.html"&gt;2300 закрытых задач и 12 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/22/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/22/apidiff/21/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 22 не является LTS-релизом, и у неё будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;только полгода&lt;/a&gt; (до сентября 2024 года).&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 22 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://jdk.java.net/22/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Рассмотрим все JEP'ы, которые попали в Java 22.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/456"&gt;Unnamed Variables &amp; Patterns (JEP 456)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Безымянные переменные и паттерны, которые появились &lt;a href="https://openjdk.org/jeps/443"&gt;в режиме preview в Java 21&lt;/a&gt;, теперь стали постоянной языковой конструкцией.&lt;/p&gt;

&lt;p&gt;Безымянная переменная &amp;ndash; это переменная, которая обозначена автором как неиспользуемая и обозначаемая символом подчёркивания (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Неиспользуемые переменные довольно часто встречаются на практике:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static int&lt;/span&gt; count(Iterable&amp;lt;Order&gt; orders) {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; total = 0;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Order _ : orders) &lt;span style="color: green"&gt;// order is unused&lt;/span&gt;
        total++;
    &lt;span style="color: blue"&gt;return&lt;/span&gt; total;
}&lt;/pre&gt;
&lt;p&gt;В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому для неё был выбран символ подчёркивания вместо имени. Другой пример:&lt;/p&gt;
&lt;pre&gt;Queue&amp;lt;Integer&gt; q = &lt;span style="color: grey"&gt;...&lt;/span&gt; &lt;span style="color: green"&gt;// x1, y1, z1, x2, y2, z2, ...&lt;/span&gt;
&lt;span style="color: blue"&gt;while&lt;/span&gt; (q.size() &gt;= 3) {
   &lt;span style="color: blue"&gt;var&lt;/span&gt; x = q.remove();
   &lt;span style="color: blue"&gt;var&lt;/span&gt; y = q.remove();
   &lt;span style="color: blue"&gt;var&lt;/span&gt; _ = q.remove();
   &lt;span style="color: grey"&gt;... new Point(x, y) ...&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Здесь были необходимы только координаты &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt;, поэтому для третьей координаты была явно выбрана безымянная переменная, чтобы явно продемонстрировать, что она не используется.&lt;/p&gt;

&lt;p&gt;Частый случай необходимости безымянных переменных &amp;ndash; это неиспользуемые исключения в блоке &lt;code&gt;catch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = ...
&lt;span style="color: blue"&gt;try&lt;/span&gt; {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    &lt;span style="color: grey"&gt;... i ...&lt;/span&gt;
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Здесь важен сам факт наличия исключения, но не само исключение.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try&lt;/code&gt; с ресурсом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; _ = ScopedContext.acquire()) {
    &lt;span style="color: grey"&gt;... no use of acquired resource ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Ну и, конечно же, неиспользуемые параметры лямбда-выражений:&lt;/p&gt;
&lt;pre&gt;...stream.collect(Collectors.toMap(String::toUpperCase, _ -&gt; &lt;span style="color: darkred"&gt;"NODATA"&lt;/span&gt;))&lt;/pre&gt;

&lt;p&gt;Во всех примерах выше использование символа подчёркивания делает код короче и читабельнее, явно обозначает намерения автора и уменьшает пространство для допущения ошибок. Также оно помогает инструментам статического анализа, которые могут жаловаться на неиспользуемые переменные.&lt;/p&gt;

&lt;p&gt;Безымянными могут быть не только переменные, но и &lt;i&gt;паттерны&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), _)) {
    &lt;span style="color: grey"&gt;... x ... y ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Аналогичным образом можно извлечь только цвет, если нужен только он, но не нужны координаты:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(_, Color c)) {
    &lt;span style="color: grey"&gt;... c ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Также есть возможность объявлять &lt;i&gt;безымянные переменные паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (ball) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RedBall _   -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; BlueBall _  -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GreenBall _ -&gt; stopProcessing();
}&lt;/pre&gt;

&lt;p&gt;Код выше можно сократить, объединив две первые ветки &lt;code&gt;case&lt;/code&gt; в одну:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (ball) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RedBall _, BlueBall _  -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GreenBall _            -&gt; stopProcessing();
}&lt;/pre&gt;

&lt;p&gt;Заметим, что такое объединение было бы невозможным без использования безымянных паттернов, так как раньше несколько паттернов в одной ветке разрешались только при отсутствии в них переменных паттернов.&lt;/p&gt;

&lt;p&gt;Более сложный пример со вложенными паттернами, где есть и безымянные паттерны, и безымянные переменные паттернов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(RedBall _), Box(BlueBall _) -&gt; processBox(box);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(GreenBall _)                -&gt; stopProcessing();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(_)                          -&gt; pickAnotherBox();
}&lt;/pre&gt;

&lt;p&gt;В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/458"&gt;Launch Multi-File Source-Code Programs (JEP 458)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь лаунчер &lt;code&gt;java&lt;/code&gt; может запускать программы, состоящие из нескольких исходных файлов Java.&lt;/p&gt;
&lt;p&gt;Напомним, что ранее в Java 11 появилась возможность запускать программы, состоящие из одного файла, без необходимости самостоятельной компиляции (&lt;a href="https://openjdk.org/jeps/330"&gt;JEP 330&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Prog.java&lt;/span&gt;

&lt;span style="color: blue"&gt;class&lt;/span&gt; Prog {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) { Helper.run(); }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Helper {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; run() { System.out.println(&lt;span style="color: darkred"&gt;"Hello!"&lt;/span&gt;); }
}
&lt;/pre&gt;
&lt;p&gt;Такой файл можно было запустить, просто написав:&lt;/p&gt;
&lt;pre&gt;$ java Prog.java
Hello!&lt;/pre&gt;

&lt;p&gt;А сейчас эта возможность была расширена до произвольного количества файлов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Prog.java&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; Prog {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) { Helper.run(); }
}

&lt;span style="color: green"&gt;// Helper.java&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; Helper {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; run() { System.out.println(&lt;span style="color: darkred"&gt;"Hello!"&lt;/span&gt;); }
}&lt;/pre&gt;
&lt;p&gt;Если программу выше запустить через &lt;code&gt;java Prog.java&lt;/code&gt;, то Java скомпилирует в память класс &lt;code&gt;Prog&lt;/code&gt; и запустит его метод &lt;code&gt;main&lt;/code&gt;. Так как класс &lt;code&gt;Prog&lt;/code&gt; ссылается на класс &lt;code&gt;Helper&lt;/code&gt;, то Java найдёт его в файле &lt;code&gt;Helper.java&lt;/code&gt; и тоже скомпилирует его. Таким образом, программа, разбитая на два файла будет работать точно так же, как если бы все классы были помещены в один исходный файл. Этот алгоритм может быть расширен до произвольного количества файлов. Например, если &lt;code&gt;Helper&lt;/code&gt; ссылается ещё на один класс &lt;code&gt;HelperAux&lt;/code&gt;, то будет найден и скомпилирован файл &lt;code&gt;HelperAux.java&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Возможность запускать без отдельного шага компиляции программы, состоящие из нескольких исходных файлов, может быть очень полезной. Главным образом, это может пригодиться для быстрого прототипирования или на ранних стадиях проектов, когда проект ещё не обрёл более-менее стабильную форму. В таких случаях у разработчика есть возможность пропустить стадию настройки сборки проекта и сразу приступить к написанию кода, не ограничиваясь при этом одним исходным файлом (что пришлось бы делать до Java 22). Для некоторых несложных проектов такая конфигурация запуска без инструментов сборки может и вовсе оставаться постоянной.&lt;/p&gt;

&lt;p&gt;Программы, использующие библиотеки в виде уже скомпилированных jar-файлов, также могут быть запущены напрямую. Например, если есть структура:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Prog.java&lt;/li&gt;
    &lt;li&gt;Helper.java&lt;/li&gt;
    &lt;li&gt;libs/library.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;То такую программу можно запустить с помощью опции &lt;code&gt;--class-path&lt;/code&gt; (или &lt;code&gt;-cp&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;$ java --class-path "libs/*" Prog.java&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/459"&gt;String Templates (Second Preview) (JEP 459)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Строковые шаблоны, которые появились в режиме preview &lt;a href="https://openjdk.org/jeps/430"&gt;в Java 21&lt;/a&gt;, уходят на второй раунд preview без изменений.&lt;/p&gt;
&lt;p&gt;Строковые шаблоны &amp;ndash; это новая синтаксическая возможность, позволяющая встраивать в строки выражения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = 10;
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = 20;
&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
String str = STR.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
&lt;span style="color: green"&gt;// В str будет лежать "10 + 20 equals 30"&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;То есть это строковая интерполяция, которая уже давно есть во многих других известных языках программирования.&lt;/p&gt;

&lt;p&gt;Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html"&gt;&lt;code&gt;java.lang.StringTemplate&lt;/code&gt;&lt;/a&gt;, а затем &lt;i&gt;процессор&lt;/i&gt;, реализующий &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html"&gt;&lt;code&gt;java.lang.StringTemplate.Processor&lt;/code&gt;&lt;/a&gt;, конвертирует этот объект в строку или объект другого класса (&lt;i&gt;примечание: сейчас &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html"&gt;идут обсуждения&lt;/a&gt; относительно отказа идеи процессоров и оставления только &lt;code&gt;StringTemplate&lt;/code&gt;&lt;/i&gt;). В примере выше &lt;code&gt;STR."…"&lt;/code&gt; есть ничто иное, как сокращённый вариант следующего кода:&lt;/p&gt;
&lt;pre&gt;StringTemplate template = RAW.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
String str = STR.process(template);&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#STR"&gt;&lt;code&gt;STR&lt;/code&gt;&lt;/a&gt; &amp;ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. &lt;code&gt;STR&lt;/code&gt; неявно импортируется в любой исходный файл, поэтому его можно использовать без &lt;code&gt;import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#RAW"&gt;&lt;code&gt;RAW&lt;/code&gt;&lt;/a&gt; &amp;ndash; это процессор, который ничего не делает со &lt;code&gt;StringTemplate&lt;/code&gt; и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.&lt;/p&gt;

&lt;p&gt;Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/FormatProcessor.html#FMT"&gt;&lt;code&gt;FMT&lt;/code&gt;&lt;/a&gt; поддерживает форматирование с использованием спецификаторов, определённых в &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;java.util.Formatter&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;double&lt;/span&gt; length = 46;
System.out.println(FMT.&lt;span style="color: darkred"&gt;"The length is %.2f&lt;/span&gt;\{length} &lt;span style="color: darkred"&gt;cm"&lt;/span&gt;);
&lt;span style="color: green"&gt;// The length is 46.00 cm&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Процессоры необязательно должны возвращать &lt;code&gt;String&lt;/code&gt;. Вот общая сигнатура метода &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"&gt;&lt;code&gt;process()&lt;/code&gt;&lt;/a&gt; интерфейса &lt;code&gt;Processor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public interface&lt;/span&gt; Processor&amp;lt;R, E &lt;span style="color: blue"&gt;extends&lt;/span&gt; Throwable&gt; {
    R process(StringTemplate stringTemplate) &lt;span style="color: blue"&gt;throws&lt;/span&gt; E;
}&lt;/pre&gt;
&lt;p&gt;Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор &lt;code&gt;JSON&lt;/code&gt; будет создавать напрямую объекты JSON (без промежуточного объекта &lt;code&gt;String&lt;/code&gt;) и при этом поддерживать экранирование кавычек:&lt;/p&gt;
&lt;pre&gt;JSONObject doc = JSON.&lt;span style="color: darkred"&gt;"""&lt;/span&gt;
    &lt;span style="color: darkred"&gt;{&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"name":    "&lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"phone":   "&lt;/span&gt;\{phone}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"address": "&lt;/span&gt;\{address}&lt;span style="color: darkred"&gt;"&lt;/span&gt;
    };
    &lt;span style="color: darkred"&gt;"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt; или &lt;code&gt;address&lt;/code&gt; будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит &lt;code&gt;&amp;quot;&lt;/code&gt; на &lt;code&gt;\&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Или, например, процессор &lt;code&gt;SQL&lt;/code&gt; будет создавать PreparedStatement'ы, защищая от атак SQL Injection:&lt;/p&gt;
&lt;pre&gt;PreparedStatement ps = SQL.&lt;span style="color: darkred"&gt;"SELECT * FROM Person p WHERE p.name = &lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;

&lt;p&gt;Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/447"&gt;Statements before &lt;code&gt;super(...)&lt;/code&gt; (Preview) (JEP 447)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview теперь стало возможным писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i, F f) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(f, f); &lt;span style="color: green"&gt;// f is shared here&lt;/span&gt;
        ...
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(i, &lt;span style="color: blue"&gt;new&lt;/span&gt; F());
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 22, включив режим preview, то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; f = &lt;span style="color: blue"&gt;new&lt;/span&gt; F();
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(f, f); &lt;span style="color: green"&gt;// f is shared here&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект. Это обеспечивает гарантию того, что инициализация всегда происходит сверху-вниз: инициализация полей суперкласса должна всегда выполняться раньше инициализации полей подкласса (&lt;i&gt;возможно такое ограничение смягчат в Java 23 &lt;a href="https://openjdk.org/jeps/8325803"&gt;в следующем preview&lt;/a&gt;&lt;/i&gt;). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i++;               &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на поля суперкласса также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; D {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; A &lt;span style="color: blue"&gt;extends&lt;/span&gt; D {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;.i++; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error - 'this' is enclosing instance&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/463"&gt;Implicitly Declared Classes and Instance Main Methods (Second Preview) (JEP 463)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java 21 в режиме preview появились &lt;a href="https://openjdk.org/jeps/445"&gt;Unnamed Classes and Instance Main Methods&lt;/a&gt;. В Java 22 было принято решение оставить эту фичу на второе preview с некоторыми изменениями. Основное из них &amp;ndash; это отказ от &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isUnnamedClass()"&gt;безымянных классов&lt;/a&gt; в пользу неявно объявленных классов. Также упрощена процедура выбора &lt;code&gt;main&lt;/code&gt;-метода для запуска: если есть метод &lt;code&gt;main&lt;/code&gt; с &lt;code&gt;String[] args&lt;/code&gt;, то запускается он (неважно, &lt;code&gt;static&lt;/code&gt; или нет), иначе запускается метод &lt;code&gt;main&lt;/code&gt; без аргументов.&lt;/p&gt;
&lt;p&gt;Новый протокол запуска позволяет запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 22 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 22 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один неявный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p class="mt-2"&gt;Упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/461"&gt;Stream Gatherers (Preview) (JEP 461)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Stream API был усовершенствован, чтобы поддерживать произвольные промежуточные операции, в режиме preview.&lt;/p&gt;
&lt;p&gt;Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#limit(long)"&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/a&gt;,
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#skip(long)"&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; и т.д). В Java 9 были добавлены &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"&gt;&lt;code&gt;dropWhile&lt;/code&gt;&lt;/a&gt;. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.&lt;/p&gt;
&lt;p&gt;Новая точка расширения &amp;ndash; это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"&gt;&lt;code&gt;Stream::gather(Gatherer)&lt;/code&gt;&lt;/a&gt;, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html"&gt;&lt;code&gt;Gatherer&lt;/code&gt;&lt;/a&gt;, предоставляемого пользователем. Операция &lt;code&gt;gather()&lt;/code&gt; аналогична уже имеющейся операции &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"&gt;&lt;code&gt;Stream::collect(Collector)&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;collect()&lt;/code&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html"&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; определяют точку расширения для терминальных операций, то &lt;code&gt;gather()&lt;/code&gt; и &lt;code&gt;Gatherer&lt;/code&gt; определяют точкой расширения для промежуточных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gatherer&lt;/code&gt; представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса &lt;code&gt;Gatherer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gather()&lt;/code&gt; также является промежуточной операцией, поэтому может быть несколько &lt;code&gt;gather()&lt;/code&gt; в одной цепочке:&lt;/p&gt;
&lt;pre&gt;source.gather(a).gather(b).gather(c).collect(...)&lt;/pre&gt;

&lt;p&gt;Вместе с самим &lt;code&gt;Gatherer&lt;/code&gt; было добавлено несколько готовых gatherer'ов, определённых в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html"&gt;&lt;code&gt;Gatherers&lt;/code&gt;&lt;/a&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"&gt;&lt;code&gt;mapConcurrent&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"&gt;&lt;code&gt;windowFixed&lt;/code&gt;&lt;/a&gt; и
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"&gt;&lt;code&gt;windowSliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Давайте рассмотрим несколько примеров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.fold(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .findFirst()
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .get();
&lt;span style="color: grey"&gt;$1 ==&gt;&lt;/span&gt; "123456789"&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.scan(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .toList()
&lt;span style="color: grey"&gt;$2 ==&gt;&lt;/span&gt; [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
&lt;span style="color: grey"&gt;$3 ==&gt;&lt;/span&gt; [[1, 2, 3], [4, 5, 6], [7, 8]]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
&lt;span style="color: grey"&gt;$4 ==&gt;&lt;/span&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]&lt;/pre&gt;

&lt;p&gt;Дизайн интерфейса &lt;code&gt;Gatherer&lt;/code&gt; был создан под влиянием интерфейса &lt;code&gt;Collector&lt;/code&gt;. Вот основная часть его сигнатуры:&lt;/p&gt;
&lt;pre&gt;public interface Gatherer&amp;lt;T, A, R&gt; {
    Supplier&amp;lt;A&gt; initializer();
    Integrator&amp;lt;A, T, R&gt; integrator();
    BinaryOperator&amp;lt;A&gt; combiner();
    BiConsumer&amp;lt;A, Downstream&amp;lt;? super R&gt;&gt; finisher();
}&lt;/pre&gt;
&lt;p&gt;Если взглянуть на &lt;code&gt;Collector&lt;/code&gt;, то он также имеет три параметра &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt; и содержит 4 основных метода: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#supplier()"&gt;&lt;code&gt;supplier&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#accumulator()"&gt;&lt;code&gt;accumulator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#combiner()"&gt;&lt;code&gt;combiner&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#finisher()"&gt;&lt;code&gt;finisher&lt;/code&gt;&lt;/a&gt;. Однако &lt;code&gt;Gatherer&lt;/code&gt; использует два вспомогательных интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"&gt;&lt;code&gt;Integrator&lt;/code&gt;&lt;/a&gt; и
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"&gt;&lt;code&gt;Downstream&lt;/code&gt;&lt;/a&gt;, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.&lt;/p&gt;
&lt;p&gt;Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс &lt;code&gt;Gatherer&lt;/code&gt; и можно воспользоваться готовыми методами-фабриками: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::of(Integrator)&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::ofSequential(Integrator)&lt;/code&gt;&lt;/a&gt; или другими вариациями.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/457"&gt;Class-File API (Preview) (JEP 457)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview появилось стандартное API для парсинга, генерации и трансформации class-файлов.&lt;/p&gt;
&lt;p&gt;Новое API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/classfile/package-summary.html"&gt;&lt;code&gt;java.lang.classfile&lt;/code&gt;&lt;/a&gt;. Оно должно заменить копию библиотеки &lt;a href="https://asm.ow2.io/"&gt;ASM&lt;/a&gt; внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.&lt;/p&gt;
&lt;p&gt;Основная проблема ASM (и других библиотек для работы с class-файлами) &amp;ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &amp;ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.&lt;/p&gt;
&lt;p&gt;Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &amp;ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/462"&gt;Structured Concurrency (Second Preview) (JEP 462)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое перешло в режим preview &lt;a href="https://openjdk.org/jeps/453"&gt;в Java 21&lt;/a&gt;, уходит на второй раунд preview без изменений. Ранее оно было в инкубаторе в &lt;a href="https://openjdk.org/jeps/428"&gt;Java 19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;Java 20&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
    &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
    &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
    &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/464"&gt;Scoped Values (Second Preview) (JEP 464)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые стали preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt;, как и Structured Concurrency, уходят на второе preview без изменений. До этого Scoped Values были в инкубаторе в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/454"&gt;Foreign Function &amp; Memory API (JEP 454)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, которое было долго в режиме preview (а до этого ещё дольше в инкубаторе), наконец-то стабилизировалось.&lt;/p&gt;
&lt;p&gt;Главной задачей FFM API является замена устаревшего JNI, который является опасным и хрупким средством вызова нативных библиотек и обработки нативных данных. FFM API, напротив, создан как безопасное, удобное, читаемое и эффективное средство интеропа со средой вне Java.&lt;/p&gt;
&lt;p&gt;FFM API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;. Оно состоит из двух частей: API для доступа к внешней памяти (foreign memory) и API для вызова внешних функций (foreign functions).&lt;/p&gt;
&lt;p&gt;API для доступа к внешней памяти предоставляет классы и интерфейсы, которые позволяют выделять, освобождать внешнюю память и манипулировать ею: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SegmentAllocator.html"&gt;&lt;code&gt;SegmentAllocator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;. Также оно использует уже существующий класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/VarHandle.html"&gt;&lt;code&gt;VarHandle&lt;/code&gt;&lt;/a&gt;. API для вызова внешних функций предоставляет классы и интерфейсы
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Linker.html"&gt;&lt;code&gt;Linker&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SymbolLookup.html"&gt;&lt;code&gt;SymbolLookup&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/FunctionDescriptor.html"&gt;&lt;code&gt;FunctionDescriptor&lt;/code&gt;&lt;/a&gt;. Для непосредственно вызовов используется привычный &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandle.html"&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Вот небольшой пример использования FFM API, в котором код на Java получает &lt;code&gt;MethodHandle&lt;/code&gt; для функции &lt;code&gt;radixsort&lt;/code&gt;, написанной на C, и вызывает её для сортировки массива из 4 строк:&lt;/p&gt;

&lt;pre&gt;&lt;span style="color: green"&gt;// 1. Find foreign function on the C library path&lt;/span&gt;
Linker linker          = Linker.nativeLinker();
SymbolLookup stdlib    = linker.defaultLookup();
MethodHandle radixsort = linker.downcallHandle(stdlib.find(&lt;span style="color: darkred"&gt;"radixsort"&lt;/span&gt;), ...);
&lt;span style="color: green"&gt;// 2. Allocate on-heap memory to store four strings&lt;/span&gt;
String[] javaStrings = { &lt;span style="color: darkred"&gt;"mouse"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"cat"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"dog"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"car"&lt;/span&gt; };

&lt;span style="color: green"&gt;// 3. Use try-with-resources to manage the lifetime of off-heap memory&lt;/span&gt;
&lt;span style="color: blue"&gt;try&lt;/span&gt; (Arena offHeap = Arena.ofConfined()) {
    &lt;span style="color: green"&gt;// 4. Allocate a region of off-heap memory to store four pointers&lt;/span&gt;
    MemorySegment pointers
        = offHeap.allocate(ValueLayout.ADDRESS, javaStrings.length);
    &lt;span style="color: green"&gt;// 5. Copy the strings from on-heap to off-heap&lt;/span&gt;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 0; i &lt; javaStrings.length; i++) {
        MemorySegment cString = offHeap.allocateFrom(javaStrings[i]);
        pointers.setAtIndex(ValueLayout.ADDRESS, i, cString);
    }
    &lt;span style="color: green"&gt;// 6. Sort the off-heap data by calling the foreign function&lt;/span&gt;
    radixsort.invoke(pointers, javaStrings.length, MemorySegment.NULL, &lt;span style="color: darkred"&gt;'\0'&lt;/span&gt;);
    &lt;span style="color: green"&gt;// 7. Copy the (reordered) strings from off-heap to on-heap&lt;/span&gt;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 0; i &lt; javaStrings.length; i++) {
        MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);
        javaStrings[i] = cString.reinterpret(...).getString(0);
    }
} &lt;span style="color: green"&gt;// 8. All off-heap memory is deallocated here&lt;/span&gt;

&lt;span style="color: blue"&gt;assert&lt;/span&gt; Arrays.equals(javaStrings,
                     &lt;span style="color: blue"&gt;new&lt;/span&gt; String[] {&lt;span style="color: darkred"&gt;"car"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"cat"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"dog"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"mouse"&lt;/span&gt;});  &lt;span style="color: green"&gt;// true&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Этот код гораздо чище и прозрачнее, чем любое решение с использованием JNI.&lt;/p&gt;

&lt;p&gt;Большая часть FFM API является безопасной по умолчанию. Многие задачи, для которых ранее необходимо было писать нативный код, вызываемый через JNI, теперь решаются написанием только Java-кода. Однако у FFM API есть &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html#restricted"&gt;ограниченные методы&lt;/a&gt; (например, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html#reinterpret(long)"&gt;&lt;code&gt;MemorySegment::reinterpret&lt;/code&gt;&lt;/a&gt;), которые по своей сути являются небезопасными. При их использовании могут возникнуть ужасные последствия вроде краха JVM, которые виртуальная машина не в состоянии предотвратить. Поэтому при выполнении ограниченного метода JVM выдаёт предупреждение, например:&lt;/p&gt;
&lt;pre&gt;WARNING: A restricted method in java.lang.foreign.Linker has been called
WARNING: Linker::downcallHandle has been called by com.foo.Server in an unnamed module
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled&lt;/pre&gt;
&lt;p&gt;Чтобы разрешить модулю использовать ограниченные методы без предупреждений, необходимо использовать опцию командной строки &lt;code&gt;--enable-native-access=M&lt;/code&gt;, где &lt;code&gt;M&lt;/code&gt; &amp;ndash; имя модуля или список модулей через запятую (можно использовать &lt;code&gt;ALL-UNNAMED&lt;/code&gt; для всего кода в classpath). При этом любое использование ограниченных методов вне списка модулей будет выбрасывать &lt;code&gt;IllegalCallerException&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/460"&gt;Vector API (Seventh Incubator) (JEP 460)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в седьмой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.&lt;/p&gt;
&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API тоже сразу же выйдет из инкубатора в статус preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/423"&gt;Region Pinning for G1 (JEP 423)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В сборщике мусора G1 было реализовано &lt;i&gt;закрепление регионов&lt;/i&gt;, которое предотвращает отключение сборки мусора, пока JNI находится в критическом регионе.&lt;/p&gt;
&lt;p&gt;Критический регион &amp;ndash; это код, который выполняется в промежутке между двумя событиями: захват указателя на Java-объект и его освобождение. В этом промежутке сборщик мусора не имеет права двигать Java-объект, чтобы не сломать нативный код, который полагается на то, что он будет находиться по одному и тому же адресу в течение всего времени захвата.&lt;/p&gt;
&lt;p&gt;До Java 22 G1 имел простейшую стратегию: если хотя бы один из потоков находился в критическом регионе, то он просто отключал сборку мусора. Это могло приводить к различным проблемам, начиная с длительных пауз и заканчивая нехваткой памяти при её фактическом избытке.&lt;/p&gt;
&lt;p&gt;Для закрепления критических объектов вовсе необязательно полностью отключать сборщик мусора: достаточно закрепить только тот регион сборщика, в котором находится объект. Это и было реализовано в JEP 423. Это было сделано путём использования счётчика, который увеличивается при захвате критического объекта и уменьшается при освобождении. Если счётчик равен нулю, то регион собирается в нормальном режиме. Если счётчик больше нуля, то регион сборщика закрепляется. Это должно решить вышеописанные проблемы.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 21</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_21.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_21.html</id>
    <updated>2023-09-18T19:00:00Z</updated>
    <published>2023-09-18T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-21.html"&gt;2500 закрытых задач и 15 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/21/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/21/apidiff/20/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Java 21 является LTS-релизом, а значит у него будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;как минимум 5 лет&lt;/a&gt; с момента выхода.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 21 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/21/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 21.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/441"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (JEP 441)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; наконец-то был финализирован и стал стабильной конструкцией языка. Напомним, что он появился в &lt;a href="java_17.html"&gt;Java 17&lt;/a&gt; и был в состоянии &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; четыре релиза: &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/433"&gt;20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый паттерн-матчинг существенно расширяет возможности оператора &lt;code&gt;switch&lt;/code&gt;. Начиная с Java 1.0, &lt;code&gt;switch&lt;/code&gt; поддерживал только сравнение с примитивными константами. Позже список типов был расширен (Java 5 &amp;ndash; перечисления, Java 7 &amp;ndash; строки), но в ветках &lt;code&gt;case&lt;/code&gt; всё ещё могли быть только константы.&lt;/p&gt;
&lt;p&gt;Теперь же &lt;code&gt;switch&lt;/code&gt; поддерживает в ветках &lt;code&gt;case&lt;/code&gt; так называемые &lt;i&gt;паттерны&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Паттерны могут снабжаться условиями с использованием нового ключевого слова &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &lt;span style="color: blue"&gt;when&lt;/span&gt; i &gt; 0 -&gt; String.format(&lt;span style="color: darkred"&gt;"positive int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Также добавлена поддержка матчинга &lt;code&gt;null&lt;/code&gt;. Сделать это можно с помощью явной отдельной ветки &lt;code&gt;case null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Если ветка &lt;code&gt;case null&lt;/code&gt; отсутствует, то &lt;code&gt;switch&lt;/code&gt; с переданным в него &lt;code&gt;null&lt;/code&gt; всегда будет выбрасывать &lt;code&gt;NullPointerException&lt;/code&gt; (даже если есть ветка &lt;code&gt;default&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// NullPointerException&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Ветки &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;default&lt;/code&gt; можно объединять друг с другом:&lt;/p&gt;
&lt;pre&gt;String str = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (str) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Foo or Bar"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null or other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Новый паттерн-матчинг обладает рядом ограничений.&lt;/p&gt;
&lt;p&gt;Во-первых, все &lt;code&gt;switch&lt;/code&gt; (кроме тех, что были корректными до Java 21) должны быть &lt;i&gt;исчерпывающими&lt;/i&gt;. Т.е. в ветках должны покрываться все возможные случаи:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// error: the switch statement does not cover all possible input values&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(s.length());
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; System.out.println(i);
};&lt;/pre&gt;
&lt;p&gt;Пример выше можно исправить, добавив ветку &lt;code&gt;Object o&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Во-вторых, все ветки &lt;code&gt;case&lt;/code&gt; должны располагаться в таком порядке, что ни перед одной веткой нет &lt;i&gt;доминирующей&lt;/i&gt; ветки:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; CharSequence cs -&gt;
        &lt;span style="color: darkred"&gt;"sequence of length "&lt;/span&gt; + cs.length();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// error: this case label is dominated by a preceding case label&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"string of length "&lt;/span&gt; + s.length();
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Так как &lt;code&gt;CharSequence&lt;/code&gt; это более широкий тип, чем &lt;code&gt;String&lt;/code&gt;, то его ветка должна быть расположена ниже.&lt;/p&gt;

&lt;p class="mt-2"&gt;В-третьих, несколько паттернов в одной ветке работать не будут:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s, Integer i -&gt; &lt;span style="color: darkred"&gt;"string or integer"&lt;/span&gt;; &lt;span style="color: red"&gt;// error: illegal fall-through from a pattern&lt;/span&gt;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Т.е. сделать тест по нескольким типам в одной ветке пока что нельзя (хотя грамматика языка это позволяет). Это можно обойти, только включив режим preview и заменив &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;i&lt;/code&gt; на символы подчёркивания (см. JEP про безымянные переменные ниже).&lt;/p&gt;

&lt;p class="mt-2"&gt;В целом новый паттерн-матчинг значительно увеличивает выразительность языка. Особенно хорошо он сочетается с записями. Паттерны записей мы рассмотрим отдельно, поскольку про них есть свой собственный JEP (см. следующий раздел).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/440"&gt;Record Patterns (JEP 440)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Отдельным видом паттернов являются &lt;i&gt;паттерны записей&lt;/i&gt;. Они появились в &lt;a href="https://openjdk.org/jeps/405"&gt;Java 19&lt;/a&gt; в режиме preview и стали стабильными в Java 21.&lt;/p&gt;
&lt;p&gt;Паттерны записей позволяют осуществлять деконструкцию значений записей чрезвычайно компактно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Или через оператор &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) -&gt; System.out.println(x + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Not a point"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Особая мощь паттернов записей состоит в том, что они могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}
&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Используя &lt;code&gt;var&lt;/code&gt;, можно сократить код ещё сильнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(&lt;span style="color: blue"&gt;var&lt;/span&gt; p, &lt;span style="color: blue"&gt;var&lt;/span&gt; c), &lt;span style="color: blue"&gt;var&lt;/span&gt; lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей отлично сочетаются с паттернами по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box(Object obj) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box box) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(String s) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"string: "&lt;/span&gt; + s);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(Object o) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other: "&lt;/span&gt; + o);
    }
}&lt;/pre&gt;

&lt;p&gt;Поддерживается вывод типов записей-дженериков:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;Box&amp;lt;String&gt;&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s))) { &lt;span style="color: green"&gt;// Infers Box&amp;lt;Box&amp;lt;String&gt;&gt;(Box&amp;lt;String&gt;(String s))&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;К сожалению, паттерны записей могут использоваться только в &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;switch&lt;/code&gt;, но не могут использоваться сами по себе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; usePoint(Point p) {
    Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) = p; &lt;span style="color: red"&gt;// Не сработает&lt;/span&gt;
    &lt;span style="color: green"&gt;// Use x and y&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Будем надеяться, что когда-нибудь добавят и такую возможность.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/430"&gt;String Templates (Preview) (JEP 430)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Строковые шаблоны &amp;ndash; новая синтаксическая возможность, позволяющая встраивать в строки выражения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = 10;
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = 20;
String str = STR.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
&lt;span style="color: green"&gt;// В str будет лежать "10 + 20 equals 30"&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, в Java появилась строковая интерполяция, которая уже давно есть во многих других известных языках программирования. Однако в Java она работает только в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt;, т.е. использовать в Java 21 её можно только с включенным флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html"&gt;&lt;code&gt;java.lang.StringTemplate&lt;/code&gt;&lt;/a&gt;, а затем &lt;i&gt;процессор&lt;/i&gt;, реализующий &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html"&gt;&lt;code&gt;java.lang.StringTemplate.Processor&lt;/code&gt;&lt;/a&gt;, конвертирует этот объект в строку (или объект другого класса). В примере выше &lt;code&gt;STR."…"&lt;/code&gt; есть ничто иное, как сокращённый вариант следующего кода:&lt;/p&gt;
&lt;pre&gt;StringTemplate template = RAW.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
String str = STR.process(template);&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#STR"&gt;&lt;code&gt;STR&lt;/code&gt;&lt;/a&gt; &amp;ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. &lt;code&gt;STR&lt;/code&gt; неявно импортируется в любой исходный файл, поэтому его можно использовать без &lt;code&gt;import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#RAW"&gt;&lt;code&gt;RAW&lt;/code&gt;&lt;/a&gt; &amp;ndash; это процессор, который ничего не делает со &lt;code&gt;StringTemplate&lt;/code&gt; и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.&lt;/p&gt;
&lt;p&gt;Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/FormatProcessor.html#FMT"&gt;&lt;code&gt;FMT&lt;/code&gt;&lt;/a&gt; поддерживает форматирование с использованием спецификаторов, определённых в &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;java.util.Formatter&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;double&lt;/span&gt; length = 46;
System.out.println(FMT.&lt;span style="color: darkred"&gt;"The length is %.2f&lt;/span&gt;\{length} &lt;span style="color: darkred"&gt;cm"&lt;/span&gt;);
&lt;span style="color: green"&gt;// The length is 46.00 cm&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Процессоры необязательно должны возвращать &lt;code&gt;String&lt;/code&gt;. Вот общая сигнатура метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"&gt;&lt;code&gt;process()&lt;/code&gt;&lt;/a&gt; интерфейса &lt;code&gt;Processor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public interface&lt;/span&gt; Processor&amp;lt;R, E &lt;span style="color: blue"&gt;extends&lt;/span&gt; Throwable&gt; {
    R process(StringTemplate stringTemplate) &lt;span style="color: blue"&gt;throws&lt;/span&gt; E;
}&lt;/pre&gt;
&lt;p&gt;Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор &lt;code&gt;JSON&lt;/code&gt; будет создавать напрямую объекты JSON (без промежуточного объекта &lt;code&gt;String&lt;/code&gt;) и при этом поддерживать экранирование кавычек:&lt;/p&gt;
&lt;pre&gt;JSONObject doc = JSON.&lt;span style="color: darkred"&gt;"""&lt;/span&gt;
    &lt;span style="color: darkred"&gt;{&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"name":    "&lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"phone":   "&lt;/span&gt;\{phone}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"address": "&lt;/span&gt;\{address}&lt;span style="color: darkred"&gt;"&lt;/span&gt;
    }
    &lt;span style="color: darkred"&gt;"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt; или &lt;code&gt;address&lt;/code&gt; будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит &lt;code&gt;&amp;quot;&lt;/code&gt; на &lt;code&gt;\&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Или, например, процессор &lt;code&gt;SQL&lt;/code&gt; будет создавать PreparedStatement'ы, защищая от атак SQL Injection:&lt;/p&gt;
&lt;pre&gt;PreparedStatement ps = SQL.&lt;span style="color: darkred"&gt;"SELECT * FROM Person p WHERE p.name = &lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/443"&gt;Unnamed Patterns and Variables (Preview) (JEP 443)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новшество в режиме preview: теперь можно объявлять так называемые безымянные переменные и паттерны. Делается это с помощью символа подчеркивания (&lt;code&gt;_&lt;/code&gt;). Это часто необходимо, когда переменная или паттерн не используются:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; acc = 0;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (Order _ : orders) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (acc &lt; LIMIT) {
        … acc++ …
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому, чтобы не придумывать этой переменной название, было использовано подчеркивание вместо имени.&lt;/p&gt;
&lt;p&gt;Довольно частый пример нужности безымянных переменных &amp;ndash; блок &lt;code&gt;catch&lt;/code&gt; с неиспользуемым исключением:&lt;/p&gt;
&lt;pre&gt;String s = …
try {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    …
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Полный список случаев, в которых можно использовать безымянные переменные:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Локальная переменная в блоке,&lt;/li&gt;
  &lt;li&gt;Объявление ресурса в &lt;code&gt;try-with-resources&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Заголовок &lt;code&gt;for&lt;/code&gt; statement,&lt;/li&gt;
  &lt;li&gt;Заголовок улучшенного цикла &lt;code&gt;for&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Исключение в блоке &lt;code&gt;catch&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Параметр лямбда-выражения,&lt;/li&gt;
  &lt;li&gt;Переменная паттерна (см. ниже).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Внимательный читатель заметит, что в списке выше отсутствуют параметры методов. Действительно, они не могут быть безымянными, и для любых методов (как интерфейсов, так и классов) по-прежнему всегда нужно указывать имена параметров.&lt;/p&gt;

&lt;p class="mt-2"&gt;Символы подчёркивания также можно использовать для указания &lt;i&gt;безымянных паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), _)) {
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Здесь разработчику понадобились только координаты точки, но не её цвет. Без безымянного паттерна ему пришлось бы объявлять неиспользуемую переменную типа &lt;code&gt;Color&lt;/code&gt; и придумывать ей имя:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color c)) { &lt;span style="color: orange"&gt;// Warning: unused c&lt;/span&gt;
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Такой код менее читабелен и хуже позволяет сфокусироваться на главном (координатах). Кроме того, некоторые IDE подсветили бы неиспользуемую переменную &lt;code&gt;c&lt;/code&gt;, что ещё одно дополнительное неудобство.&lt;/p&gt;
&lt;p&gt;Есть также возможность объявлять &lt;i&gt;безымянные переменные паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color _)) {
    …
}&lt;/pre&gt;
&lt;p&gt;Безымянные паттерны и переменные паттернов прекрасно сочетаются и со &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(RedBall _), Box(BlueBall _) -&gt; processBox(box);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(GreenBall _)                -&gt; stopProcessing();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(_)                          -&gt; pickAnotherBox();
}&lt;/pre&gt;
&lt;p&gt;В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;Unnamed Classes and Instance Main Methods (Preview) (JEP 445)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь в режиме preview можно запускать программы с методами &lt;code&gt;main()&lt;/code&gt;, которые не являются &lt;code&gt;public static&lt;/code&gt; и у которых нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае JVM сама создаст экземпляр класса (у него должен быть не-&lt;code&gt;private&lt;/code&gt; конструктор без параметров) и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Протокол запуска будет выбирать метод &lt;code&gt;main()&lt;/code&gt; согласно следующему приоритету:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;static void main()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p class="mt-2"&gt;Кроме того, можно писать программы и без объявления класса вовсе:&lt;/p&gt;
&lt;pre&gt;String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;p&gt;В таком случае будет создан неявный безымянный класс (не путать с анонимным классом), которому будут принадлежать метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Безымянный класс является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isSynthetic()"&gt;синтетическим&lt;/a&gt; и &lt;code&gt;final&lt;/code&gt;. Его &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getSimpleName()"&gt;simple name&lt;/a&gt; является пустой строкой:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(getClass().isUnnamed()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().isSynthetic()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().getSimpleName()); &lt;span style="color: green"&gt;// ""&lt;/span&gt;
    System.out.println(getClass().getCanonicalName()); &lt;span style="color: green"&gt;// null&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;При этом &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt; класса совпадает с именем файла, но такое поведение не гарантируется.
&lt;p class="mt-2"&gt;Такое упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
    &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;Virtual Threads (JEP 444)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые много лет разрабатывались в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt; и появились в &lt;a href="https://openjdk.org/jeps/425"&gt;Java 19&lt;/a&gt; в режиме preview, теперь наконец-то стали стабильными.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" (или "одна задача &amp;ndash; один поток") и не прибегать к более сложным асинхронному или реактивному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt; и практически полностью совместимы с классическими потоками: поддерживают стек-трейсы, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#interrupt()"&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; и т.д.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент выполняется виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и дешевизна виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоков и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Несмотря на привлекательность виртуальных потоков, вовсе необязательно предпочитать только их и всегда избегать классических потоков. Например, для задач, интенсивно и долго использующих CPU, лучше подойдут обычные потоки. Или если нужен поток, не являющийся &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)"&gt;демоном&lt;/a&gt;, то также придётся использовать обычный поток, потому что виртуальный поток всегда является демоном.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в инструментарии JDK (дебаггер, JVM TI, Java Flight Recorder).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/431"&gt;Sequenced Collections (JEP 431)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появились три новых интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"&gt;&lt;code&gt;SequencedCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"&gt;&lt;code&gt;SequencedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"&gt;&lt;code&gt;SequencedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; является наследником &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html"&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; и представляет собой коллекцию с установленным порядком элементов. Такими коллекциями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashSet.html"&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; и все реализации &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html"&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedSet.html"&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Deque.html"&gt;&lt;code&gt;Deque&lt;/code&gt;&lt;/a&gt;. У этих коллекций есть общее свойство последовательности элементов, но до Java 21 их общим родителем был &lt;code&gt;Collection&lt;/code&gt;, который является слишком общим интерфейсом и не содержит многих методов, характерных для последовательностей (&lt;code&gt;getFirst()&lt;/code&gt;, &lt;code&gt;getLast()&lt;/code&gt;, &lt;code&gt;addFirst()&lt;/code&gt;, &lt;code&gt;addLast()&lt;/code&gt;, &lt;code&gt;reversed()&lt;/code&gt; и т.д). При этом у самих вышеописанных коллекций такие методы были несогласованны друг с другом (например, &lt;code&gt;list.get(0)&lt;/code&gt; против &lt;code&gt;sortedSet.first()&lt;/code&gt; против &lt;code&gt;deque.getFirst()&lt;/code&gt;), либо вовсе отсутствовали (например, &lt;code&gt;linkedHashSet.getLast()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; закрыла эту дыру в иерархии и привела API к общему знаменателю:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedCollection&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Collection&amp;lt;E&gt; {
    E getFirst();
    E getLast();
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addFirst(E);
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addLast(E);
    E removeFirst();
    E removeLast();
    SequencedCollection&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Теперь больше не надо думать, как для конкретной коллекции получить последний элемент, потому что есть универсальный метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#getLast()"&gt;&lt;code&gt;getLast()&lt;/code&gt;&lt;/a&gt;, который есть и у &lt;code&gt;ArrayList&lt;/code&gt;, и у &lt;code&gt;TreeSet&lt;/code&gt;, и у &lt;code&gt;ArrayDeque&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Особый интерес представляет метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#reversed()"&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;, который возвращает view коллекции с обратным порядком. Это делает обратный обход коллекции гораздо более лаконичным:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; linkedList = new LinkedList&lt;&gt;(…);

&lt;span style="color: green"&gt;// До Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; it = linkedList.descendingIterator(); it.hasNext();) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; e = it.next();
    …
}

&lt;span style="color: green"&gt;// С Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; element : linkedList.reversed()) {
    …
}&lt;/pre&gt;
&lt;p&gt;Для &lt;code&gt;LinkedHashSet&lt;/code&gt; эффективного способа обратного обхода и вовсе не было.&lt;/p&gt;
&lt;p class="mt-2"&gt;Для последовательных множеств ввели интерфейс &lt;code&gt;SequencedSet&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedSet&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Set&amp;lt;E&gt;, SequencedCollection&amp;lt;E&gt; {
    SequencedSet&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;code&gt;LinkedHashSet&lt;/code&gt; и наследники &lt;code&gt;SortedSet&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Также ввели интерфейс &lt;code&gt;SequencedMap&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedMap&amp;lt;K,V&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Map&amp;lt;K,V&gt; {
    Entry&amp;lt;K, V&gt; firstEntry();
    Entry&amp;lt;K, V&gt; lastEntry();
    Entry&amp;lt;K, V&gt; pollFirstEntry();
    Entry&amp;lt;K, V&gt; pollLastEntry();
    V putFirst(K, V);
    V putLast(K, V);
    SequencedSet&amp;lt;K&gt; sequencedKeySet();
    SequencedCollection&amp;lt;V&gt; sequencedValues();
    SequencedSet&amp;lt;Entry&amp;lt;K,V&gt;&gt; sequencedEntrySet();
    SequencedMap&amp;lt;K,V&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashMap.html"&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; и наследники &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedMap.html"&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;Scoped Values (Preview) (JEP 446)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые появились в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt; в &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационном статусе&lt;/a&gt;, теперь стали Preview API.&lt;/p&gt;
&lt;p&gt;Новый класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/453"&gt;Structured Concurrency (Preview) (JEP 453)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно API, которое ранее было в инкубационном статусе (Java &lt;a href="https://openjdk.org/jeps/428"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;20&lt;/a&gt;), а теперь стало Preview API &amp;ndash; это Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
    &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
    &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
    &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/442"&gt;Foreign Function &amp; Memory API (Third Preview) (JEP 442)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напомним, что FFM API много лет разрабатывается в проекте &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; с целью заменить JNI. В &lt;a href="https://openjdk.org/jeps/454"&gt;Java 22&lt;/a&gt; API выйдет из состояния preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;Vector API (Sixth Incubator) (JEP 448)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в шестой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.&lt;/p&gt;
&lt;p&gt;Векторное API останется в инкубаторе, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не станут preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/452"&gt;Key Encapsulation Mechanism API (JEP 452)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В пакете &lt;code&gt;javax.crypto&lt;/code&gt; появилось новое API, реализующее &lt;a href="https://en.wikipedia.org/wiki/Key_encapsulation_mechanism"&gt;механизм инкапсуляции ключей&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Механизм инкапсуляции ключей (KEM) &amp;ndash; это современная криптографическая техника, позволяющая обмениваться симметричными ключами, используя асимметричное шифрование. Если в традиционной технике симметричный ключ генерируется случайным образом и шифруется с помощью открытого ключа (что требует паддинга), то в KEM симметричный ключ выводится из самого открытого ключа.&lt;/p&gt;
&lt;p&gt;В Java KEM API состоит из трёх главных классов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html"&gt;&lt;code&gt;KEM&lt;/code&gt;&lt;/a&gt; &amp;ndash; входная точка API. У него есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html#getInstance(java.lang.String)"&gt;&lt;code&gt;getInstance()&lt;/code&gt;&lt;/a&gt;, возвращающий объект &lt;code&gt;KEM&lt;/code&gt; для указанного алгоритма.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html"&gt;&lt;code&gt;Encapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; представляет собой функцию инкапсуляции, которая вызывается отправителем. У этого класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html#encapsulate()"&gt;&lt;code&gt;encapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает открытый ключ и возвращает секретный ключ, а также key encapsulation message (которое шлётся принимающей стороне).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html"&gt;&lt;code&gt;Decapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; функция декапсуляции, которая вызывается принимающей стороной. У класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html#decapsulate(byte%5B%5D)"&gt;&lt;code&gt;decapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает key encapsulation message и возвращает секретный ключ. Таким образом, у обеих сторон теперь есть одинаковый симметричный ключ, с помощью которого можно дальше обмениваться данными с помощью обычного симметричного шифрования.&lt;/p&gt;
&lt;p&gt;Пример генерации симметричного ключа и его передачи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kpg = KeyPairGenerator.getInstance(&lt;span style="color: darkred"&gt;"X25519"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; kp = kpg.generateKeyPair();

&lt;span style="color: green"&gt;// Sender side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem1 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; sender = kem1.newEncapsulator(kp.getPublic());
&lt;span style="color: blue"&gt;var&lt;/span&gt; encapsulated = sender.encapsulate();
&lt;span style="color: blue"&gt;var&lt;/span&gt; k1 = encapsulated.key();

&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem2 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; receiver = kem2.newDecapsulator(kp.getPrivate());
&lt;span style="color: blue"&gt;var&lt;/span&gt; k2 = receiver.decapsulate(encapsulated.encapsulation());

&lt;span style="color: blue"&gt;assert&lt;/span&gt; Arrays.equals(k1.getEncoded(), k2.getEncoded());&lt;/pre&gt;

&lt;p class="mt-2"&gt;Для KEM также добавлен интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEMSpi.html"&gt;&lt;code&gt;KEMSpi&lt;/code&gt;&lt;/a&gt;, позволяющий предоставлять пользовательские реализации алгоритмов KEM.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/439"&gt;Generational ZGC (JEP 439)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В сборщик мусора ZGC, который появился в &lt;a href="https://openjdk.org/jeps/377"&gt;Java 15&lt;/a&gt;, добавили поддержку поколений. Поколения в ZGC пока что отключены по умолчанию, и для их включения требуется ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;java -XX:+UseZGC -XX:+ZGenerational ...&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/474"&gt;В будущих версиях Java&lt;/a&gt; режим работы с поколениями будет по умолчанию, и ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt; уже требоваться не будет.&lt;/p&gt;
&lt;p&gt;Поколения в ZGC должны улучшить производительность Java-программ, т.к. молодые объекты, которые склонны умирать рано согласно слабой гипотезе о поколениях, будут собираться чаще, а старые объекты &amp;ndash; более редко. При этом характеристики ZGC не должны от этого пострадать: время отклика по-прежнему должно быть сверхнизким (&lt; 1ms) и кучи гигантских размеров (несколько терабайт) должны продолжать поддерживаться.&lt;/p&gt;
&lt;p&gt;Напомним, что также &lt;a href="https://openjdk.org/jeps/404"&gt;ведётся работа&lt;/a&gt; над поддержкой поколений в другом сборщике мусора &lt;a href="https://openjdk.org/jeps/379"&gt;Shenandoah&lt;/a&gt;, похожем по характеристикам на ZGC. Однако в Java 21 Generational Shenandoah попасть не успел.&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в &lt;a href="https://openjdk.org/jeps/248"&gt;Java 9&lt;/a&gt; (до него дефолтным был Parallel GC)&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/451"&gt;Prepare to Disallow the Dynamic Loading of Agents (JEP 451)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;При динамической загрузке агентов теперь выдаётся предупреждение:&lt;/p&gt;
&lt;pre&gt;WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release&lt;/pre&gt;
&lt;p&gt;Агент &amp;ndash; это компонент, который может изменять (инструментировать) код Java-приложения во время работы. Поддержка агентов появилась в Java 5, чтобы была возможность писать продвинутые инструменты вроде профилировщиков, которым необходимо добавлять эмиссию событий в классы, или AOP-библиотек. Для включения агентов требовались опции командной строки &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;, поэтому все агенты тогда могли включаться только явно при старте приложения.&lt;/p&gt;
&lt;p&gt;Однако в Java 6 появился &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html"&gt;Attach API&lt;/a&gt;, который, кроме всего прочего, позволил загружать агенты динамически прямо в работающий JVM. Благодаря этому библиотеки получили возможность подключаться к приложению и по-тихому изменять классы, не имея на то согласия от владельца приложения. Причём изменяться могут не только классы приложения, но и классы JDK. Таким образом, подвергается риску строгая инкапсуляция, которая является одним из краеугольных камней Java.&lt;/p&gt;
&lt;p&gt;Чтобы закрыть такую потенциально опасную дыру, в Java 9 вместе с появлением модулей было предложено запретить динамическую загрузку агентов по умолчанию. Однако тогда было решено отложить на неопределённое время такое радикальное решение, чтобы дать авторам инструментов время подготовиться. В итоге, изменение дожило до наших дней, и было реализовано лишь в Java 21, но в &lt;i&gt;виде предупреждения&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;Чтобы подавить предупреждение, необходимо запускать JVM с опцией &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;, либо загружать агенты при старте JVM, явно перечисляя их с помощью опций &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В будущих версиях Java планируется полностью отключить динамическую загрузку по умолчанию, и она уже не будет работать без &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;Deprecate the Windows 32-bit x86 Port for Removal (JEP 449)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;32-битный порт OpenJDK под Windows стал deprecated for removal. В будущем планируется избавиться от него полностью.&lt;/p&gt;
&lt;p&gt;Удаление порта позволит ускорить разработку платформы. Также причиной стало отсутствие нативной реализации виртуальных потоков на 32-битной версии JDK 21 под Windows: виртуальные потоки в этой версии реализованы через платформенные потоки.&lt;/p&gt;

&lt;p class="mt-4"&gt;Полный список JEP'ов, попавших в JDK 21, начиная с JDK 17: &lt;a href="https://openjdk.org/projects/jdk/21/jeps-since-jdk-17"&gt;ссылка&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #57</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_57.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_57.html</id>
    <updated>2023-04-23T19:00:00Z</updated>
    <published>2023-04-23T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/20-0-1-relnotes.html"&gt;JDK 20.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-7-relnotes.html"&gt;JDK 17.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-19-relnotes.html"&gt;JDK 11.0.19&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;JDK 8u372&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышло несколько новых JEP'ов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;JEP 444: Virtual Threads&lt;/a&gt;. Виртуальные потоки уже интегрированы в &lt;a href="https://jdk.java.net/21/"&gt;ранние сборки JDK 21&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;JEP 445: Flexible Main Methods and Anonymous Main Classes (Preview)&lt;/a&gt;. Про него мы подробно писали в &lt;a href="java_news_54.html"&gt;выпуске #54&lt;/a&gt;, когда он был черновиком и имел другое название (Implicit Classes and Enhanced Main Methods).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;JEP 446: Scoped Values (Preview)&lt;/a&gt;. Scoped Values переходят из инкубационного статуса &lt;a href="https://openjdk.org/jeps/429"&gt;в Java 20&lt;/a&gt; в статус Preview в Java 21.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/447"&gt;JEP 447: Statements before &lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;. Про этот JEP мы писали в &lt;a href="java_news_53.html"&gt;выпуске #53&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;JEP 448: Vector API (Sixth Incubator)&lt;/a&gt;. Таким образом, векторное API остаётся в инкубационном статусе уже в шестой раз.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;JEP 449: Deprecate the Windows 32-bit x86 Port for Removal&lt;/a&gt;. Про причины удаления 32-битного порта JDK на Windows мы писали в &lt;a href="java_news_55.html"&gt;выпуске #55&lt;/a&gt;. 32-битные версии JDK под Linux остаются нетронутыми.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2023/03/intellij-idea-2023-1/"&gt;IntelliJ IDEA 2023.1&lt;/a&gt;. Перечислим некоторые улучшения и нововведения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Изменение масштаба всей IDE (View &gt; Appearance &gt; Zoom IDE).&lt;/li&gt;
  &lt;li&gt;Появился компактный режим (только для нового UI).&lt;/li&gt;
  &lt;li&gt;Вкладки проектов на macOS.&lt;/li&gt;
  &lt;li&gt;Ускоренный доступ к функциональности IDE при открытии проекта (функции IDE становятся доступными гораздо раньше).&lt;/li&gt;
  &lt;li&gt;Ускоренный импорт Maven-проектов.&lt;/li&gt;
  &lt;li&gt;Фоновые проверки коммитов (чтобы ускорить выполнение коммитов).&lt;/li&gt;
  &lt;li&gt;Возможность сохранять варианты расположения окон (Window &gt; Layouts).&lt;/li&gt;
  &lt;li&gt;Отображение знаков пробела только в выделенном коде.&lt;/li&gt;
  &lt;li&gt;Поддержка Java 20.&lt;/li&gt;
  &lt;li&gt;Улучшенный рефакторинг Extract Method, поддерживающий ситуацию, когда фрагмент кода содержит несколько переменных, которые необходимо вернуть.&lt;/li&gt;
  &lt;li&gt;Автодополнение опций VM в Run/Debug Configurations.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #56</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_56.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_56.html</id>
    <updated>2023-03-26T19:00:00Z</updated>
    <published>2023-03-26T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8303683"&gt;JEP: Virtual Threads&lt;/a&gt;. В нём предлагается финализировать виртуальные потоки в Java 21, то есть они больше не будут Preview API. Единственным изменением относительно Java 20 будет поддержка &lt;code&gt;ThreadLocal&lt;/code&gt; переменных в виртуальных потоках. Это гарантирует, что многие существующие библиотеки, использующие &lt;code&gt;ThreadLocal&lt;/code&gt;, продолжат корректно работать при переходе на виртуальные потоки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/443"&gt;JEP 443: Unnamed Patterns and Variables (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_46.html"&gt;выпуске #46&lt;/a&gt;, когда вышел его черновик. С тех пор принципиальных изменений в JEP внесено не было.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/442"&gt;JEP 442: Foreign Function &amp; Memory API (Third Preview)&lt;/a&gt;. Таким образом, в Java 21 API остаётся в статусе Preview в третий раз.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8304400"&gt;JEP: Launch Multi-File Source-Code Programs&lt;/a&gt;. В нём предлагается добавить поддержку запуска программ, состоящих из нескольких исходных файлов &lt;code&gt;.java&lt;/code&gt;. Напомним, что сейчас Java поддерживает запуск только одного исходного файла (возможность, которая появилась &lt;a href="https://openjdk.org/jeps/330"&gt;в Java 11&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Предполагается, что запуск нескольких файлов будет работать следующим образом:&lt;/p&gt;
&lt;ul style="list-style-type: none"&gt;
  &lt;li&gt;&amp;bull; В аргумент командной строки по-прежнему передаётся название одного java-файла, например: &lt;code&gt;java Prog.java&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс ссылается на другие классы, то лаунчер пытается найти эти классы в файловой системе. Предполагается, что каждый класс находится в файле с именем, соответствующем имени класса.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Файлы, на которые никто не ссылается, не компилируются. Это может быть удобно для разработки (например, в них можно оставлять синтаксические ошибки).&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс используется через рефлексию, то файл ищется и компилируется уже во время работы программы.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование пакетов поддерживается. В таком случае файлы должны лежать в соответствующих директориях.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование библиотек также поддерживается. Тогда нужно добавить аргумент &lt;code&gt;-cp&lt;/code&gt;, например: &lt;code&gt;java -cp '*' Prog.java&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://openjdk.org/jeps/401"&gt;JEP 401: Primitive Classes (Preview)&lt;/a&gt; был значительно &lt;a href="https://mail.openjdk.org/pipermail/valhalla-spec-experts/2023-March/002238.html"&gt;переработан и переименован&lt;/a&gt; в Null-Restricted Value Object Storage. В новой версии JEP предлагается ввести так называемые опциональные конструкторы и null-restricted типы.&lt;/p&gt;
&lt;p&gt;Смысл опциональных конструкторов заключается в том, что если в &lt;a href="https://openjdk.org/jeps/8277163"&gt;value-классе&lt;/a&gt; объявлен такой конструктор, то такой класс обязан поддерживать значение по умолчанию, то есть значение, в котором все поля являются нулями. Это значит, что объекты такого класса могут быть проинициализированы в обход конструктора, а значит потенциально нарушать инварианты класса. В результате класс становится менее безопасным, но зато даёт виртуальной машине больше возможностей для более компактного хранения его значений: value-классы с опциональными конструкторами могут иметь лучший flattening, чем просто value-классы.&lt;/p&gt;
&lt;p&gt;JEP также предлагает ввести переменные, которым не может быть присвоен &lt;code&gt;null&lt;/code&gt;. Причём это нововведение будет распространяться на все классы, в том числе и ссылочные. Поскольку null-restricted типы не связаны напрямую с value-классами, то они будут подробно описаны &lt;a href="https://openjdk.java.net/jeps/8303099"&gt;в отдельном JEP'е&lt;/a&gt; (на данный момент ссылка выдаёт 404, т.к. JEP ещё не стал общедоступным). Однако в контексте этого JEP'а они упомянуты, чтобы показать, что они играют важную роль, когда сочетаются с value-классами с опциональными конструкторами: их значения смогут встраиваться в другие объекты и массивы, что и было основной целью проекта Valhalla.&lt;/p&gt;
&lt;p&gt;Также важным изменением в JEP'е стал отказ от нотации &lt;code&gt;X.ref&lt;/code&gt; и &lt;code&gt;X.val&lt;/code&gt;. Вместо них будет восклицательный знак для обозначения null-restricted типов (&lt;code&gt;X!&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=JgMLyGBEQ1c"&gt;Eclipse 2023-03&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/javafx20/"&gt;JavaFX 20&lt;/a&gt;. С этой версии фреймворк требует Java 17 в качестве минимальной версии Java.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/03/java-annotated-monthly-march-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за март.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/surefire/maven-surefire-plugin/history.html"&gt;maven-surefire-plugin 3.0.0&lt;/a&gt;. Это первое обновление плагина Maven для запуска тестов спустя почти 4 года.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 20</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_20.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_20.html</id>
    <updated>2023-03-20T19:00:00Z</updated>
    <published>2023-03-20T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;Java 20&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-20.html"&gt;1500 закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/20/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/20/apidiff/19/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/20/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 20.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;Паттерны записей (Second Preview) (JEP 432)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В паттерны записей, которые появились &lt;a href="https://openjdk.org/jeps/405"&gt;в Java 19&lt;/a&gt; в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; (и остающиеся в этом статусе в Java 20), было внесено три главные изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, добавилась поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей теперь могут присутствовать в заголовке улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; dump(Point[] pointArray) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) : pointArray) {
        System.out.println(&lt;span style="color: darkred"&gt;"("&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + y + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Примечание: эту возможность было решено удалить &lt;a href="https://openjdk.org/jeps/440"&gt;в Java 21&lt;/a&gt;, но она снова может появиться в будущем в другом JEP'е.&lt;/p&gt;

&lt;p class="pt-1"&gt;В-третьих, исчезла поддержка именованных паттернов записей. Это значит, что такой код, который компилировался в Java 19, в Java 20 уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) { &lt;span style="color: red"&gt;// Syntax error&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p&gt;Хотя именованные паттерны и исчезли в этом релизе, это не значит, что они исчезли насовсем. Возможно они появятся в одном из будущих релизов, когда будут более тщательно продуманы.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Fourth Preview) (JEP 433)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Это уже четвёртая итерация preview паттерн-матчинга в Java. Напомним, что предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;. В новой версии три главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, исчерпывающий &lt;code&gt;switch&lt;/code&gt; по перечислениям теперь выбрасывает &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/MatchException.html"&gt;&lt;code&gt;MatchException&lt;/code&gt;&lt;/a&gt;, а не &lt;code&gt;IncompatibleClassChangeError&lt;/code&gt;, если ни одна из меток &lt;code&gt;switch&lt;/code&gt; не сматчилась.&lt;/p&gt;

&lt;p&gt;Во-вторых, упростилась грамматика меток &lt;code&gt;switch&lt;/code&gt; в JLS.&lt;/p&gt;

&lt;p&gt;В-третьих, добавилась поддержка вывода типов в записях-дженериках, если они являются паттернами в &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;S, T&gt;(S first, T second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; recordInference(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; fst, &lt;span style="color: blue"&gt;var&lt;/span&gt; snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Как видите, здесь JEP 433 полностью согласуется с JEP 432.&lt;/p&gt;

&lt;p&gt;Паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; предлагается финализировать в Java 21 (&lt;a href="https://openjdk.org/jeps/440"&gt;JEP 440&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/441"&gt;JEP 441&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;Virtual Threads (Second Preview) (JEP 436)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые появились &lt;a href="https://openjdk.org/jeps/425"&gt;в Java 19&lt;/a&gt;, продолжают оставаться в статусе Preview API (предлагается финализировать их &lt;a href="https://openjdk.org/jeps/8303683"&gt;в Java 21&lt;/a&gt;). Изменений API, связанных с проектом &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;, в этом релизе нет (если не считать scoped values и structured concurrency, которые имеют &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационный статус&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;Scoped Values (Incubator) (JEP 429)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt;, который позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо больше количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;code&gt;where()&lt;/code&gt;. Далее вызывается метод &lt;code&gt;run()&lt;/code&gt;, на протяжении которого это значение можно получить (через метод &lt;code&gt;get()&lt;/code&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потоком не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;/p&gt;&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static final&lt;/span&gt; ScopedValue&amp;lt;Credentials&amp;gt; CREDENTIALS = new ScopedValue&lt;&gt;();

Credentials creds = ...
ScopedValue.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ScopedValue&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;
&lt;p&gt;На период инкубации новое API будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В Java 21 scoped values, скорее всего, &lt;a href="https://openjdk.org/jeps/8304357"&gt;станут preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;Structured Concurrency (Second Incubator) (JEP 437)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured concurrency, которое появилось &lt;a href="https://openjdk.org/jeps/428"&gt;в Java 19&lt;/a&gt;, остаётся в инкубационном статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; (вместе со &lt;code&gt;ScopedValue&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Единственное отличие от предыдущей версии API &amp;ndash; это то, что &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;StructuredTaskScope&lt;/a&gt; теперь поддерживает наследование scoped values потоками, созданными внутри области видимости задачи.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;Foreign Function &amp; Memory API (Second Preview) (JEP 434)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Основные изменения в этом релизе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemoryAddress&lt;/code&gt;. Теперь адреса моделируются через &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt; с нулевой длиной.&lt;/li&gt;
  &lt;li&gt;Улучшена иерархия &lt;code&gt;sealed&lt;/code&gt; интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;, чтобы лучше соответствовать паттерн-матчингу для &lt;code&gt;switch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemorySession&lt;/code&gt;. Он разделён на два интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/SegmentScope.html"&gt;&lt;code&gt;SegmentScope&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В Java 21 Foreign Function &amp; Memory API останется на &lt;a href="https://openjdk.org/jeps/442"&gt;третье preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/438"&gt;Vector API (Fifth Incubator) (JEP 438)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API всё никак не хочет становиться стабильным и остаётся в инкубационном статусе уже в пятый раз (модуль &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;). В этом релизе лишь небольшие исправления багов и улучшения производительности. Скорее всего, инкубационный статус будет оставаться до тех пор, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не появятся в режиме preview (проект &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; сильно зависит от проекта Valhalla).&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 20 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до сентября 2023 года). LTS-релизом станет следующая версия, &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #55</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_55.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_55.html</id>
    <updated>2023-03-05T19:00:00Z</updated>
    <published>2023-03-05T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а были предложены к попаданию в Java 21. Это &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;. Java 21 &amp;ndash; это &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;следующий LTS-релиз&lt;/a&gt; после Java 17, который должен выйти в сентябре 2023 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/438"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;, который сразу же &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-March/007404.html"&gt;был предложен&lt;/a&gt; к попаданию в Java 20. JEP появился с большим опозданием перед самым релизом из-за &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-February/007389.html"&gt;недопонимания&lt;/a&gt; со стороны владельца JEP'а. Сейчас эта ошибка была исправлена. Напомним, что общедоступная версия Java 20 выходит уже &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;через две недели&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло несколько новых черновиков JEP.&lt;/p&gt;
&lt;p&gt;Самые главные &amp;ndash; это &lt;a href="https://openjdk.org/jeps/8300541"&gt;Record Patterns&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8300542"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;. В них предлагается сделать паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; постоянными языковыми конструкциями. Напомним, что в Java 20 они будут всё ещё в статусе preview (&lt;a href="https://openjdk.java.net/jeps/432"&gt;JEP 432&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/433"&gt;JEP 433&lt;/a&gt;). Таким образом, в следующем LTS-релизе Java 21 планируется их &lt;a href="https://mail.openjdk.org/pipermail/amber-dev/2023-February/007841.html"&gt;финализировать&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В финальные версии конструкций предлагается внести следующие небольшие изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Паттерны, заключённые в скобки, поддерживаться не будут.&lt;/li&gt;
  &lt;li&gt;В &lt;code&gt;case&lt;/code&gt;-ветках будут разрешены квалифицированные константы перечислений (при условии, что эти константы совместимы по присваиванию с целевым типом).&lt;/li&gt;
  &lt;li&gt;Паттерны записей в заголовках цикла &lt;code&gt;for&lt;/code&gt; поддерживаться не будут. Однако они снова появятся в отдельном JEP'е.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Следующий черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303167"&gt;Deprecate the Windows x86-32 Port&lt;/a&gt;. Пометить как deprecated 32-битный порт JDK предлагается ради ускорения разработки платформы. Одной из мотиваций также является отсутствие нативной реализации &lt;a href="https://openjdk.org/jeps/436"&gt;виртуальных потоков&lt;/a&gt; на 32-битной Windows JDK. Также Windows 10 (последняя версия Windows, поддерживающая 32 бит) достигнет своей End of Life в &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;октябре 2025 года&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Ещё один черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303358"&gt;Scoped Values (Preview)&lt;/a&gt;. Таким образом, Scoped Values в Java 21 могут выйти из &lt;a href="https://openjdk.org/jeps/429"&gt;инкубационного статуса&lt;/a&gt; и стать preview. Про Scoped Values мы писали в &lt;a href="java_news_44.html"&gt;выпуске #44&lt;/a&gt;, когда они ещё назывались Extent-Local Variables.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Сайт поиска артефактов в Maven Central &lt;a href="https://search.maven.org"&gt;https://search.maven.org&lt;/a&gt; теперь стал перенаправлять на &lt;a href="https://central.sonatype.com"&gt;https://central.sonatype.com&lt;/a&gt;. На сайте Sonatype &lt;a href="https://central.sonatype.org/faq/what-happened-to-search-maven-org/"&gt;это объясняется&lt;/a&gt; тем, что central.sonatype.com уже покрывает главную функциональность search.maven.org, а также предоставляет больше деталей о компонентах, например, рейтинг безопасности. Кроме того, индекс поиска там обновляется гораздо чаще, чем на search.maven.org, а значит там более свежая и надёжная информация.&lt;/p&gt;
&lt;p&gt;Вернуться к старому сайту пока всё ещё можно, если нажать по &lt;a href="https://search.maven.org/?eh"&gt;соответствующей ссылке&lt;/a&gt; во всплывающем сообщении. Полное закрытие старого сайта планируется в конце 2023 - начале 2024 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blogs.apache.org/netbeans/#announce-apache-netbeans-17-released"&gt;Apache NetBeans 17&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jol-dev/2023-February/000509.html"&gt;JOL 0.17&lt;/a&gt;. Из основных изменений: минимальная версия Java теперь 8, добавлена поддержка Lilliput.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #54</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_54.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_54.html</id>
    <updated>2023-02-19T19:00:00Z</updated>
    <published>2023-02-19T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8302326"&gt;Implicit Classes and Enhanced Main Methods (Preview)&lt;/a&gt;. В нём предлагается сделать протокол запуска программ на Java более гибким, дав возможность программисту (в особенности новичку) опускать ненужные конструкции при написании простых программ, что поможет упростить вхождение в язык.&lt;/p&gt;
&lt;p&gt;Во-первых, модификатор &lt;code&gt;public&lt;/code&gt; и параметр &lt;code&gt;String[] args&lt;/code&gt; для метода &lt;code&gt;main()&lt;/code&gt; будут опциональными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, метод &lt;code&gt;main()&lt;/code&gt; не будет обязан быть статическим. Тогда JVM сама инстанцирует класс (для этого у него должен иметься не-private конструктор без аргументов) и вызовет метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, само объявление класса будет опциональным. В таком случае JVM сама создаст экземпляр безымянного неявного класса и вызовет &lt;code&gt;main()&lt;/code&gt; на нём:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Эти три упрощения помогут новичкам сфокусировать своё изучение языка на простых концепциях вроде объявлений переменных и циклов, а затем постепенно переходить к более сложным (классам, модификаторам доступа и статическим методам).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один черновик JEP: &lt;a href="https://openjdk.org/jeps/8299906"&gt;Support Markdown in Documentation Comments&lt;/a&gt;. В этом JEP'е предлагается добавить возможность писать JavaDoc на языке &lt;a href="https://commonmark.org/"&gt;Markdown&lt;/a&gt; вместо HTML. Markdown на сегодняшний день является очень популярным форматом написания документации, отличительной особенностью которого является простота синтаксиса и лёгкость чтения. Markdown трансформируется в HTML, но достаточно легко читаем и в сыром виде.&lt;/p&gt;
&lt;p&gt;Пример возможной документации на Markdown для &lt;code&gt;Object.hashCode()&lt;/code&gt; с использованием Markdown:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**md&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;Returns a hash code value for the object. This method is
&lt;span style="color: green"&gt; * &lt;/span&gt;supported for the benefit of hash tables such as those provided by
&lt;span style="color: green"&gt; * &lt;/span&gt;{&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; java.util.HashMap}.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;The general contract of &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; is:
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;-   Whenever it is invoked on the same object more than once during
&lt;span style="color: green"&gt; * &lt;/span&gt;    an execution of a Java application, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method
&lt;span style="color: green"&gt; * &lt;/span&gt;    must consistently return the same integer, provided no information
&lt;span style="color: green"&gt; * &lt;/span&gt;    used in &lt;span style="color: darkgreen"&gt;`equals`&lt;/span&gt; comparisons on the object is modified.
&lt;span style="color: green"&gt; * &lt;/span&gt;    This integer need not remain consistent from one execution of an
&lt;span style="color: green"&gt; * &lt;/span&gt;    application to another execution of the same application.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   If two objects are equal according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;    #equals(Object) equals} method, then calling the
&lt;span style="color: green"&gt; * &lt;/span&gt;    &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects must produce the
&lt;span style="color: green"&gt; * &lt;/span&gt;    same integer result.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   It is _not_ required that if two objects are unequal
&lt;span style="color: green"&gt; * &lt;/span&gt;    according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; #equals(Object) equals} method, then
&lt;span style="color: green"&gt; * &lt;/span&gt;    calling the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects
&lt;span style="color: green"&gt; * &lt;/span&gt;    must produce distinct integer results.  However, the programmer
&lt;span style="color: green"&gt; * &lt;/span&gt;    should be aware that producing distinct integer results for
&lt;span style="color: green"&gt; * &lt;/span&gt;    unequal objects may improve the performance of hash tables.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@implSpec&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;As far as is reasonably practical, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method defined
&lt;span style="color: green"&gt; * &lt;/span&gt;by class &lt;span style="color: darkgreen"&gt;`Object`&lt;/span&gt; returns distinct integers for distinct objects.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@return&lt;/b&gt;&lt;/span&gt;  a hash code value for this object.
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.Object#equals(java.lang.Object)
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.System#identityHashCode
&lt;span style="color: green"&gt; */&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.9.0/release-notes.html"&gt;Apache Maven 3.9.0&lt;/a&gt;. Самые заметные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Минимальная версия Java теперь 8. Это первое увеличение минимальной версии Java спустя 8 лет. В прошлый раз это был Maven &lt;a href="https://maven.apache.org/docs/3.3.1/release-notes.html"&gt;3.3.1&lt;/a&gt;, где минимальной версией стала Java 7.&lt;/li&gt;
  &lt;li&gt;Обратная совместимость с Maven 2.x окончательно убрана.&lt;/li&gt;
  &lt;li&gt;Теперь выдаются &lt;a href="https://issues.apache.org/jira/browse/MNG-7457"&gt;предупреждения&lt;/a&gt; об использовании deprecated плагинов, целей, параметров и т.д.&lt;/li&gt;
  &lt;li&gt;В консоли теперь пишутся префиксы плагинов вместо их &lt;code&gt;artifactId&lt;/code&gt; (например, &lt;code&gt;compiler:3.10.1:compile&lt;/code&gt; вместо &lt;code&gt;maven-compiler-plugin:3.10.1:compile&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Теперь можно вызывать цели через &lt;a href="https://issues.apache.org/jira/browse/MNG-7353"&gt;&lt;code&gt;mvn pluginPrefix:version:goal&lt;/code&gt;&lt;/a&gt;. Раньше это можно было делать либо через &lt;code&gt;mvn:pluginPrefix:goal&lt;/code&gt;, либо через &lt;code&gt;groupId:artifactId[:version]:goal&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Стала возможной активация профиля по типу &lt;code&gt;packaging&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список изменений и нововведений &lt;a href="https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316922&amp;version=12350913"&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/8.0/release-notes.html"&gt;Gradle 8.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел JetBrains &lt;a href="https://blog.jetbrains.com/idea/2023/02/java-annotated-monthly-february-2023/"&gt;Java Annotated Monthly за февраль&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
</feed>
