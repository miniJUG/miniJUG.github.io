<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2022-10-23T18:00:00Z</updated>
  <entry>
    <title>Новости Java #47</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_47.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_47.html</id>
    <updated>2022-10-23T18:00:00Z</updated>
    <published>2022-10-23T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-1-relnotes.html"&gt;JDK 19.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-5-relnotes.html"&gt;JDK 17.0.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-October/017943.html"&gt;JDK 13.0.13&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-October/017944.html"&gt;JDK 15.0.9&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-17-relnotes.html"&gt;JDK 11.0.17&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-October/015706.html"&gt;JDK 8u352&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышли три новых JEP'а. Это &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/432"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/433"&gt;JEP 433: Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;. Про record patterns и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; мы писали в &lt;a href="java_news_46.html#record_patterns"&gt;прошлом выпуске&lt;/a&gt;, когда они были ещё черновиками, а вот sequenced collections упоминали совсем давно (в &lt;a href="java_news_35.html#sequenced_collections"&gt;выпуске #35&lt;/a&gt;), поэтому давайте рассмотрим его снова и более подробно.&lt;/p&gt;
&lt;p&gt;В JEP 431 предлагается ввести три новых интерфейса в пакет &lt;code&gt;java.util&lt;/code&gt;, которые будет представлять собой коллекции или словари с определённым порядком элементов: &lt;code&gt;SequencedCollection&lt;/code&gt;, &lt;code&gt;SequencedSet&lt;/code&gt; и &lt;code&gt;SequencedMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; будет наследоваться от интерфейса &lt;code&gt;Collection&lt;/code&gt;, и его наследниками будут &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Deque&lt;/code&gt; и &lt;code&gt;SequencedSet&lt;/code&gt;. Примерами такого типа коллекции будут &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;LinkedList&lt;/code&gt;, &lt;code&gt;ArrayDeque&lt;/code&gt;, &lt;code&gt;LinkedHashSet&lt;/code&gt; и &lt;code&gt;TreeSet&lt;/code&gt; (то есть коллекции, в которых есть определённый порядок элементов). Пример коллекции, которая не является &lt;code&gt;SequencedCollection&lt;/code&gt; &amp;ndash; &lt;code&gt;HashSet&lt;/code&gt; (в нём порядок элементов не определён).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedSet&lt;/code&gt; будет наследоваться от &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;SequencedCollection&lt;/code&gt;. Его наследником будет &lt;code&gt;SortedSet&lt;/code&gt;. Примеры конкретных множеств такого типа: &lt;code&gt;TreeSet&lt;/code&gt; и &lt;code&gt;LinkedHashSet&lt;/code&gt;.&lt;/p&gt;
&lt;img src="sequenced_collection.png" class="img-fluid" /&gt;
&lt;p&gt;&lt;code&gt;SequencedMap&lt;/code&gt; будет наследоваться от &lt;code&gt;Map&lt;/code&gt;. Его наследником будет &lt;code&gt;SortedMap&lt;/code&gt;. Примеры конкретных реализаций: &lt;code&gt;TreeMap&lt;/code&gt; и &lt;code&gt;LinkedHashMap&lt;/code&gt;. В &lt;code&gt;HashMap&lt;/code&gt; нет определённого порядка элементов, поэтому она не будет являться &lt;code&gt;SequencedMap&lt;/code&gt;.&lt;/p&gt;
&lt;img src="sequenced_map.png" class="img-fluid" /&gt;
&lt;p&gt;В &lt;code&gt;SequencedCollection&lt;/code&gt; будут новые методы, которых нет в &lt;code&gt;Collection&lt;/code&gt;: &lt;code&gt;getFirst()&lt;/code&gt;, &lt;code&gt;getLast()&lt;/code&gt;, &lt;code&gt;addFirst()&lt;/code&gt;, &lt;code&gt;addLast()&lt;/code&gt;, &lt;code&gt;removeFirst()&lt;/code&gt;, &lt;code&gt;removeLast()&lt;/code&gt;. Также будет новый метод &lt;code&gt;reversed()&lt;/code&gt;, который будет возвращать view с обратным порядком элементов.&lt;/p&gt;
&lt;p&gt;В &lt;code&gt;SequencedMap&lt;/code&gt; будут новые методы &lt;code&gt;firstEntry()&lt;/code&gt;, &lt;code&gt;lastEntry()&lt;/code&gt;, &lt;code&gt;pollFirstEntry()&lt;/code&gt;, &lt;code&gt;pollLastEntry()&lt;/code&gt;, &lt;code&gt;firstKey()&lt;/code&gt;, &lt;code&gt;lastKey()&lt;/code&gt;, &lt;code&gt;putFirst()&lt;/code&gt;, &lt;code&gt;putLast()&lt;/code&gt;, &lt;code&gt;reversed()&lt;/code&gt;, &lt;code&gt;sequencedKeySet()&lt;/code&gt;, &lt;code&gt;sequencedValues()&lt;/code&gt; и &lt;code&gt;sequencedEntrySet()&lt;/code&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; GraalVM CE станет частью OpenJDK. Такое заявление появилось в &lt;a href="https://twitter.com/graalvm/status/1582441450796900354"&gt;Твиттере&lt;/a&gt; проекта GraalVM. На данный момент других деталей нет кроме тех, о которых заявлено в твите. Из того, что известно сейчас:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;В OpenJDK переедут JIT-компилятор и Native Image, входящие в состав GraalVM Community Edition.&lt;/li&gt;
  &lt;li&gt;GraalVM Enterprise Edition остаётся отдельным продуктом с коммерческой лицензией. У GraalVM EE больше оптимизаций, чем у CE, и &lt;a href="https://www.graalvm.org/downloads/"&gt;выше производительность&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;В GraalVM будут использоваться те же процессы разработки и тот же релизный цикл, что и у JDK. Модели лицензирования также будут согласованы.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В ближайшее время ожидается более подробная информация на сайте проекта.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Новая среда разработки Fleet от JetBrains &lt;a href="https://blog.jetbrains.com/fleet/2022/10/introducing-the-fleet-public-preview/"&gt;перешла&lt;/a&gt; в стадию Public Preview и теперь доступна для скачивания неограниченному кругу пользователей.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появились первые &lt;a href="https://jdk.java.net/genzgc/"&gt;EA-сборки&lt;/a&gt; Generational ZGC. Добавление &lt;a href="https://openjdk.org/jeps/8272979"&gt;поколений&lt;/a&gt; в сборщик мусора ZGC должно уменьшить накладные расходы на сборку мусора и увеличить скорость выделения памяти под объекты при длительном режиме аллокации.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Андрей Паньгин выпустил библиотеку &lt;a href="https://github.com/apangin/nalim"&gt;nalim&lt;/a&gt; для быстрых нативных вызовов из Java, которая не использует JNI и не страдает от его накладных расходов. Библиотека может позиционироваться как замена JNI Critical Natives, которые были удалены в JDK 18. Кроме того, JNI Critical Natives были приватным API, а nalim использует стандартный интерфейс JVMCI (который, правда, требует флагов &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Как &lt;a href="https://twitter.com/AndreiPangin/status/1581383155822776320"&gt;утверждает&lt;/a&gt; Андрей, он написал библиотеку за две ночи.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse-ee4j/eclipselink/releases/tag/4.0.0"&gt;EclipseLink 4&lt;/a&gt;. Он полностью поддерживает спецификацию &lt;a href="https://newsroom.eclipse.org/eclipse-newsletter/2022/march/what%E2%80%99s-new-jakarta-persistence-31"&gt;Jakarta Persistence API 3.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #46</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_46.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_46.html</id>
    <updated>2022-10-09T18:00:00Z</updated>
    <published>2022-10-09T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло несколько новых черновиков JEP. Рассмотрим каждый из них.&lt;/p&gt;
&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294349"&gt;Unnamed local variables and patterns&lt;/a&gt;. В этом JEP предлагается добавить в язык безымянные переменные и паттерны, которые будут обозначаться символом &lt;code&gt;_&lt;/code&gt; (подчёркивание).&lt;/p&gt;
&lt;p&gt;Это очень полезное улучшение: оно позволит не давать имя переменной, которая в дальнейшем не будет использоваться. Такая ситуация возникает довольно часто, например, в блоке &lt;code&gt;try-catch&lt;/code&gt;, когда важен только тип исключения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    ...
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Другой частый случай &amp;ndash; лямбда-выражения:&lt;/p&gt;
&lt;pre&gt;map.computeIfAbsent(k, _ -&gt; &lt;span style="color: blue"&gt;new&lt;/span&gt; ArrayList&lt;&gt;());&lt;/pre&gt;
&lt;p&gt;Ещё один пример &amp;ndash; паттерн-матчинг:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; pingDevice(Device d) {
    String ip = &lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Printer(_, _, _, String ipp) -&gt; ipp;
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Server(_, String ips) -&gt; ips;
    };

    ping(ip);
}&lt;/pre&gt;
&lt;p&gt;Полный список случаев, когда можно будет использовать подчёркивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Объявление локальной переменной в блоке.&lt;/li&gt;
  &lt;li&gt;Спецификация ресурса в &lt;code&gt;try-with-resources&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Объявление базового цикла &lt;code&gt;for&lt;/code&gt; или улучшенного цикла &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Переменная паттерна.&lt;/li&gt;
  &lt;li&gt;Параметр &lt;code&gt;catch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Параметр лямбда-выражения.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Заметим, что в данный список не входят параметры методов классов и интерфейсов. В них по прежнему придётся давать имена всем параметрам. Почему такое решение было принято, можно почитать в &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-September/003485.html"&gt;этой ветке&lt;/a&gt; рассылки проекта Amber.&lt;/p&gt;

&lt;p class="pt-1" id="record_patterns"&gt;&lt;a href="https://openjdk.org/jeps/8294078"&gt;Record Patterns (Second Preview)&lt;/a&gt;. Это второе preview паттернов записей (первое попало в &lt;a href="https://openjdk.org/jeps/405"&gt;Java 19&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;В этой итерации три главных изменения.&lt;/p&gt;
&lt;p&gt;Во-первых, добавляется поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей смогут присутствовать в объявлениях улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;T, U&gt;(T first, U second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; loop(List&amp;lt;Pair&amp;lt;String, Integer&gt;&gt; pairs) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; first, &lt;span style="color: blue"&gt;var&lt;/span&gt; second) : pairs) {
        System.out.println(first + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + second);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, исчезает поддержка именованных паттернов записей. Это значит, что такой код уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако по этому пункту возникла &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-October/thread.html#3582"&gt;дискуссия в рассылке&lt;/a&gt;, и пока непонятно, действительно ли примут решение убрать такую полезную возможность языка. Брайн Гетц &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-October/003587.html"&gt;считает&lt;/a&gt;, что с введением такой возможности поспешили и что если её откатить, то это позволит более тщательно её продумать и вернуть обратно в будущем в этой или иной форме.&lt;/p&gt;

&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294285"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;. Это уже четвёртая итерация паттернов записей (предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;). В новой версии два главных изменения: упрощённая грамматика switch labels и поддержка вывода типов для паттернов дженериков.&lt;/p&gt;
&lt;p&gt;Упрощённая грамматика большее значение представляет для разработчиков компиляторов и IDE. А вывод типов в &lt;code&gt;switch&lt;/code&gt; выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;Collection&amp;lt;String&gt; collection = ...;

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (collection) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; List&amp;lt;&gt; l -&gt; ... &lt;span style="color: green"&gt;// Выводится List&amp;lt;String&gt;&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Set&amp;lt;&gt; s  -&gt; ... &lt;span style="color: green"&gt;// Выводится Set&amp;lt;String&gt;&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Queue q  -&gt; ... &lt;span style="color: green"&gt;// Ничего не выводится, сырой тип Queue&lt;/span&gt;
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако для записей diamond-оператор необязателен:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;T, U&gt;(T first, U second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(var fst, var snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;То же самое касается и паттерн-матчинга через &lt;code&gt;instanceof&lt;/code&gt;, пример которого уже был приведён выше (см. пример с &lt;code&gt;Box&amp;lt;T&gt;&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-1"&gt;&lt;a href="https://openjdk.org/jeps/8294992"&gt;64 bit object headers&lt;/a&gt;. Цель этого JEP &amp;ndash; уменьшение размера заголовков с 96/128 до 64 бит. Это позволит уменьшить потребление памяти кучей приблизительно на 6-12%, что, в свою очередь, уменьшит нагрузку на GC и CPU.&lt;/p&gt;
&lt;p&gt;Работа по сжатию заголовков ведётся в проекте &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt;, который был &lt;a href="https://mail.openjdk.org/pipermail/discuss/2021-March/005720.html"&gt;предложен&lt;/a&gt; в марте 2021 года Романом Кеннке, впоследствии и ставшим лидером проекта. Ранее Роман &lt;a href="https://mail.openjdk.org/pipermail/lilliput-dev/2022-May/000457.html"&gt;сообщил&lt;/a&gt;, что в проекте удалось добиться значительных успехов и что уже ведётся работа над следующим этапом: сжатием заголовка до 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Брайан Гетц &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-September/003552.html"&gt;предложил&lt;/a&gt; внести изменения в Java, облегчающие вхождение новичков в язык. Он выложил документ с заголовком &lt;a href="https://openjdk.org/projects/amber/design-notes/on-ramp"&gt;"Paving the on-ramp"&lt;/a&gt; ("прокладывая заезд на автостраду"), где изложил свои мысли относительно возможных упрощений, которые сделают кривую изучения языка более пологой.&lt;/p&gt;
&lt;p&gt;Когда новичок впервые изучает Java, он сразу же сталкивается с большим числом незнакомых концепций, которых нельзя избежать при написании даже самой простой программы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Для полного понимания этого кода придётся разобраться чуть ли не со всеми основными аспектами языка:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Уровни видимости (&lt;code&gt;public&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Классы.&lt;/li&gt;
  &lt;li&gt;Методы.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;static&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;main&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Строки.&lt;/li&gt;
  &lt;li&gt;Массивы (&lt;code&gt;String[]&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Поля (&lt;code&gt;out&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Константы (&lt;code&gt;out&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Брайан Гетц предлагает три упрощения, которые помогут изучающим язык начать с минимально короткой программы и постепенно переходить к более сложным концепциям.&lt;/p&gt;
&lt;p&gt;Во-первых, можно сделать &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; и параметр &lt;code&gt;args&lt;/code&gt; опциональными. Тогда код упростится до следующего:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, можно ввести концепцию безымянных классов, что позволит объявлять поля и методы без объявления класса. Это позволит упростить код ещё сильнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Наконец, можно сделать некоторые наиболее часто используемые методы статическими (&lt;code&gt;println&lt;/code&gt;, &lt;code&gt;readln&lt;/code&gt;) и импортировать их автоматически (как автоматически импортируются все классы в &lt;code&gt;java.lang&lt;/code&gt;). В итоге код сократится до самого минимума:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p class="pt-1"&gt;Сейчас всё это существует исключительно на уровне концепции, которая активно обсуждается в рассылке, но возможно что-то из предложенных идей будет в будущем реализовано в языке.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/10/java-annotated-monthly-october-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за октябрь.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #45</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_45.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_45.html</id>
    <updated>2022-09-25T18:00:00Z</updated>
    <published>2022-09-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt;. Про шаблонные строки мы писали в &lt;a href="java_news_28.html"&gt;выпуске #28&lt;/a&gt;, когда они были предложены в рассылке проекта Amber. С тех пор концепция шаблонных строк дозрела до JEP-кандидата, и возможно, они попадут в следующий релиз &lt;a href="https://jdk.java.net/20/"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://jakarta.ee/release/10/"&gt;Jakarta EE 10&lt;/a&gt;. В этом релизе теперь требуется Java 11 в качестве минимальной версии, а также есть поддержка Java 17. В Jakarta EE 10 более 20 спецификаций получили обновления, а также появилась новая спецификация CDI Lite 4.0. Из принципиальных нововведений также стало появление &lt;a href="https://jakarta.ee/specifications/coreprofile/10/"&gt;Core Profile&lt;/a&gt;, минимального набора спецификаций, созданного специально для микросервисов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Lightbend &lt;a href="https://www.lightbend.com/blog/why-we-are-changing-the-license-for-akka"&gt;объявила&lt;/a&gt; об изменении лицензии у Akka, инструментария, реализующего программную модель на основе акторов.&lt;/p&gt;
&lt;p&gt;Начиная с версии 2.7, которая выйдет в октябре, Akka будет иметь коммерческую лицензию BSL 1.1. Это значит, что Akka будет иметь не open-source, а так называемую source-available модель, при которой исходные коды будут всё ещё доступны, но Akka можно будет использовать бесплатно только для разработки и других непроизводственных целей. Для производственных целей придётся приобретать коммерческую лицензию, которая, однако, будет бесплатной для компаний с годовым оборотом меньше 25 миллионов долларов. Кроме того, через 3 года после выхода код Akka становится полностью свободным под лицензией Apache 2.0. Также исключением является Play Framework, который внутри себя использует Akka: его также можно использовать бесплатно. Akka 2.6 &lt;a href="https://www.lightbend.com/akka/license-faq"&gt;будет оставаться&lt;/a&gt; под лицензией Apache 2.0 и будет получать критические обновления до сентября 2023 года.&lt;/p&gt;
&lt;p&gt;Йонас Бонер, создатель Akka, объяснил такое решение тем, что большое количество крупных компаний, таких как Apple, Disney и GM, используют Akka совершенно бесплатно, но все усилия и затраты несёт на себе небольшая компания Lightbend. Новая лицензия позволит сдвинуть баланс в сторону других участников, которые будут обязаны платить и тем самым вносить вклад в будущее Akka.&lt;/p&gt;
&lt;p&gt;Цены на Akka уже &lt;a href="https://www.lightbend.com/akka#pricing"&gt;опубликованы&lt;/a&gt; и составляют от 1995 до 2995 долларов в год за одно ядро в зависимости от лицензии.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=eEXvOjtauxI"&gt;Eclipse 2022-09&lt;/a&gt;. Вот некоторые улучшения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Более быстрый поиск по подстроке в workspace.&lt;/li&gt;
  &lt;li&gt;Поддержка цветного вывода в консоли.&lt;/li&gt;
  &lt;li&gt;Новая галочка "Enable word wrap when opening an editor".&lt;/li&gt;
  &lt;li&gt;Улучшения в Clean Up Actions "Convert to switch expression" и "Convert to enhanced 'for' loops".&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 19</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_19.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_19.html</id>
    <updated>2022-09-19T18:00:00Z</updated>
    <published>2022-09-19T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;Java 19&lt;/a&gt;. В этот релиз попало более &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-19.html"&gt;двух тысяч закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/19/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/19/apidiff/18/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/19/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вот список JEP'ов, которые попали в Java 19.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/427"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Third Preview) (JEP 427)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt;, который &lt;a href="https://openjdk.org/jeps/406"&gt;появился в Java 17&lt;/a&gt; в режиме preview и остался на &lt;a href="https://openjdk.org/jeps/420"&gt;второе preview в Java 18&lt;/a&gt;, всё ещё остаётся в этом статусе. Это первый случай в Java, когда языковой конструкции не хватило двух релизов, чтобы стать стабильной: ранее все конструкции укладывались в два preview.&lt;/p&gt;
&lt;p&gt;В этом релизе в паттерн-матчинг было внесено два главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, охранные паттерны &lt;code&gt;&amp;&amp;&lt;/code&gt; были заменены на условия &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &amp;&amp; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;

&lt;p&gt;О мотивации такого изменения можно прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003195.html"&gt;в рассылке проекта Amber&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Во-вторых, было изменено поведение матчинга &lt;code&gt;null&lt;/code&gt;. Теперь &lt;code&gt;null&lt;/code&gt; матчится только в ветке &lt;code&gt;case null&lt;/code&gt; и большие ни в каких других, включая тотальных:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: green"&gt;// matches because total pattern&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;// NPE&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; ...; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Про причины такого изменения можно также прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003194.html"&gt;в рассылке&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/405"&gt;Паттерны записей (Preview) (JEP 405)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг дополнился новым видом паттерна: паттерн записей.&lt;/p&gt;
&lt;p&gt;Раньше для паттерн-матчинга записей был доступен только паттерн по типу с дальнейшим ручным извлечением компонентов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point p) {
        &lt;span style="color: blue"&gt;int&lt;/span&gt; x = p.x();
        &lt;span style="color: blue"&gt;int&lt;/span&gt; y = p.y();
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;С паттернами записей код становится существенно компактнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printCoordinatesAndColor(ColoredPoint cp) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (cp &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y), &lt;span style="color: blue"&gt;var&lt;/span&gt; c)) {
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
        System.out.println(&lt;span style="color: darkred"&gt;"color = "&lt;/span&gt; + c);
    }
}&lt;/pre&gt;

&lt;p&gt;Также паттерны записей могут быть именованными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) {
        System.out.println(&lt;span style="color: darkred"&gt;"point = "&lt;/span&gt; + p);
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Кроме того, паттерны записей хорошо сочетаются со &lt;code&gt;switch&lt;/code&gt; из предыдущего JEP'а:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 &amp;&amp; y &gt; 0 -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Positive point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/425"&gt;Virtual Threads (Preview) (JEP 425)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появились виртуальные потоки в режиме preview.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" и не прибегать к более сложному асинхронному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt;, а значит, большую часть существующего кода не придётся переписывать.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент работает виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и малый размер виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоки и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в дебаггере, JVM TI и Java Flight Recorder.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки разрабатываются &lt;a href="https://mail.openjdk.org/pipermail/announce/2017-October/000238.html"&gt;с 2017 года&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/428"&gt;Structured Concurrency (Incubator) (JEP 428)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одним результатом работы над проектом Loom стало добавление в Java нового API для Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;. Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Future&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Future&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join();           &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
    scope.throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.resultNow(), order.resultNow());
}&lt;/pre&gt;

&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием &lt;code&gt;ExecutorService&lt;/code&gt; и &lt;code&gt;submit()&lt;/code&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;code&gt;close()&lt;/code&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новое API должно облегчить написание многопоточных программ благодаря знакомому структурному подходу. Пока API имеет инкубационный статус, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; и одноимённом пакете.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/424"&gt;Foreign Function &amp; Memory API (Preview) (JEP 424)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, которое было в инкубационном статусе &lt;a href="https://openjdk.org/jeps/412"&gt;в Java 17&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/419"&gt;Java 18&lt;/a&gt;, теперь стало Preview API. Оно находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;


&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/426"&gt;Vector API (Fourth Incubator) (JEP 426)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API, которое уже было в инкубационном статусе три релиза (&lt;a href="https://openjdk.org/jeps/338"&gt;Java 16&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/414"&gt;Java 17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/417"&gt;Java 18&lt;/a&gt;), продолжает в нём находиться. Пока API не выйдет из инкубационного статуса, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/422"&gt;Linux/RISC-V Port (JEP 422)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь официально портирован под архитектуру Linux/RISC-V.&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 19 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до марта 2023 года). Однако Azul обещает выпускать обновления Zulu как минимум &lt;a href="https://www.azul.com/products/azul-support-roadmap/"&gt;до марта 2025 года&lt;/a&gt; (2.5 года).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #44</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_44.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_44.html</id>
    <updated>2022-08-28T18:00:00Z</updated>
    <published>2022-08-28T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/18-0-2-relnotes.html#R18_0_2_1"&gt;JDK 18.0.2.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-4-relnotes.html#R17_0_4_1"&gt;JDK 17.0.4.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-August/016645.html"&gt;JDK 11.0.16.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-August/015329.html"&gt;JDK 8u345&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;18.0.2.1, 17.0.4.1, 11.0.6.1 &amp;ndash; вынужденные обновления, которые пришлось выпустить из-за &lt;a href="https://bugs.openjdk.org/browse/JDK-8292260"&gt;критической регрессии&lt;/a&gt; в JIT-компиляторе C2, вызывающей креш JVM.&lt;/p&gt;
&lt;p&gt;8u345 пришлось выпустить из-за другого &lt;a href="https://bugs.openjdk.org/browse/JDK-8290832"&gt;критического бага&lt;/a&gt; в 8u342.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел первый &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-August/006861.html"&gt;релиз-кандидат Java 19&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/429"&gt;JEP 429: Extent-Local Variables (Incubator)&lt;/a&gt;. В нём предлагается ввести новый класс &lt;a href="https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ExtentLocal.html"&gt;&lt;code&gt;ExtentLocal&lt;/code&gt;&lt;/a&gt; в качестве альтернативы существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ExtentLocal&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одной нити (или дерева нитей) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данной нити, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд проблем, например, неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно), неограниченное время жизни (переменная очистится, только когда исполнение всей нити завершится или когда будет вызван remove(), но про него часто забывают), высокая цена наследования (дочерние нити всегда вынуждены делать полную копию переменной, даже если родительская нить никогда не будет её изменять).&lt;/p&gt;
&lt;p&gt;В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ExtentLocal&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Однажды ассоциированное с объектом &lt;code&gt;ExtentLocal&lt;/code&gt; значение остаётся иммутабельным. Для этого используется метод &lt;code&gt;where()&lt;/code&gt;. Кроме того, значение ассоциируется на ограниченный срок, который определяется длительностью метода &lt;code&gt;run()&lt;/code&gt;. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ExtentLocal&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним нитям не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;p&gt;Пример использования &lt;code&gt;ExtentLocal&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ExtentLocal&amp;lt;Credentials&amp;gt; CREDENTIALS =
    ExtentLocal.newInstance();

Credentials creds = ...
ExtentLocal.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ExtentLocal&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.slf4j.org/news.html"&gt;SLF4J 2.0&lt;/a&gt;. Это первое мажорное обновление фасада логирования спустя 17 лет после выхода первой версии. Новая версия теперь требует Java 8 и содержит новый &lt;a href="https://www.slf4j.org/manual.html#fluent"&gt;Fluent Logging API&lt;/a&gt;. Кроме того, SLF4J API теперь использует механизм &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; для нахождения соответствующего логирующего провайдера. SLF4J 2.0 полностью обратно совместим с SLF4J 1.x, т.е. весь существующий код, использующий SLF4J API, не требует перекомпиляции. Однако при обновлении до второй версии потребуется соответствующее обновление бэкенда, иначе SLF4J API не сможет найти бэкенд и выдаст предупреждение.&lt;/p&gt;
&lt;p&gt;Вместе с выходом второй версии SLF4J вышли &lt;a href="https://logback.qos.ch/news.html"&gt;Logback 1.3.0 и 1.4.0&lt;/a&gt;, которые поддерживают SLF4J 2.0. Различие между 1.3.0 и 1.4.0 состоит в том, Logback 1.4.0 требует Java 11 и использует пространство имён Jakarta EE (&lt;code&gt;jakarta.*&lt;/code&gt;), в то время как Logback 1.3.0 работает на Java 8 и использует Java EE (&lt;code&gt;javax.*&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://www.jetbrains.com/idea/whatsnew/"&gt;IntelliJ IDEA 2022.2&lt;/a&gt;. Теперь среда разработки использует JetBrains Runtime 17 вместо 11.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/08/java-annotated-monthly-august-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за август.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://medium.com/helidon/helidon-3-0-is-released-1bd2df1f999b"&gt;Helidon 3.0&lt;/a&gt;. Теперь фреймворк требует Java 17 и поддерживает спецификации MicroProfile 5.0 и Jakarta EE 9.1.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #43</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_43.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_43.html</id>
    <updated>2022-07-24T18:00:00Z</updated>
    <published>2022-07-24T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/18-0-2-relnotes.html"&gt;JDK 18.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-4-relnotes.html"&gt;JDK 17.0.4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-July/015833.html"&gt;JDK 15.0.8 и 13.0.12&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-16-relnotes.html"&gt;JDK 11.0.16&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-July/015254.html"&gt;JDK 8u342&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; JDK 19 перешёл &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-July/006803.html"&gt;во вторую фазу Rampdown&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Visual Studio Code появилась &lt;a href="https://devblogs.microsoft.com/java/java-on-visual-studio-code-update-july-2022/"&gt;поддержка Lombok&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/07/java-annotated-monthly-july-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за июль.&lt;/p&gt;

&lt;p class="pt-3"&gt;Возвращаем рубрику &amp;laquo;Полезняшки&amp;raquo;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://maven.apache.org/wrapper/"&gt;Maven Wrapper&lt;/a&gt;. Надоело держать зоопарк Maven'ов для своих проектов? Хорошая новость: скачивать Maven теперь вообще не нужно. Просто запускаете один раз &lt;code&gt;mvn wrapper:wrapper&lt;/code&gt; на проекте и дальше вместо &lt;code&gt;mvn command&lt;/code&gt; просто вызываете &lt;code&gt;mvnw command&lt;/code&gt;. Maven Wrapper сам скачает и запустит нужную версию Maven.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sho7a/Decompiler"&gt;Decompiler&lt;/a&gt; &amp;ndash; простой декомпилятор байткода Java с графическим интерфейсом. В качестве движка декомпиляции использует недавно анонсированный &lt;a href="https://github.com/QuiltMC/quiltflower"&gt;Quiltflower&lt;/a&gt;, который хорошо поддерживает современные синтаксические конструкции Java.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/weisJ/jsvg"&gt;JSVG&lt;/a&gt; &amp;ndash; очень лёгкая и быстрая Java-библиотека для рисования SVG. Потребляет на ~98% меньше памяти, чем Apache Batik. Находится в стадии ранней разработки.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #42</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_42.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_42.html</id>
    <updated>2022-07-03T18:00:00Z</updated>
    <published>2022-07-03T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8280389"&gt;JEP: Classfile API&lt;/a&gt;. Цель этого JEP &amp;ndash; создать API для парсинга, генерации и трансформации class-файлов.&lt;/p&gt;
&lt;p&gt;В данный момент наиболее распространена библиотека для работы с байткодом ASM, форк которой используется, в том числе, в самой JDK. Основная проблема с ASM заключается в том, что она всегда отстаёт на один релиз от JDK. Когда выходит новая версия JDK, последняя версия ASM поддерживает только предпоследнюю версию байткода. Из-за этого инструменты и библиотеки, которые корректно работали на предпоследней версии байткода, могут неожиданно ломаться, когда сталкиваются с новыми class-файлами. Раньше это не было большой проблемой, так как релизы Java выходили раз в 3-5 лет. С переходом на &lt;a href="java_18_3.html"&gt;новую частоту&lt;/a&gt; релизов это стало создавать неприятности как для пользователей, так и для разработчиков библиотек.&lt;/p&gt;
&lt;p&gt;Решение этой проблемы очевидное: библиотека для работы с class-файлами должна быть частью JDK. Тогда пользователи такого classfile API не будут иметь проблем с только что вышедшей новой версией Java, поскольку поддержка новой версии байткода будет идти сразу "из коробки".&lt;/p&gt;
&lt;p&gt;Новое API будет учитывать и ряд других проблем ASM. Например, ASM имеет старую кодовую базу с большим количеством багажа, доставшегося по наследству от первых версий. Также в ASM используется подход, основанный на Visitor. Было бы глупо в 2022-м году использовать этот же шаблон при наличии современных языковых конструкций: лямбд, записей и паттерн-матчинга.&lt;/p&gt;
&lt;p&gt;Планируется, что API сначала заменит ASM внутри самой JDK, а позже станет частью публичного API.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=zDJtVYAJwyY"&gt;Eclipse 2022-06&lt;/a&gt;. Перечислим самые заметные нововведения и улучшения в среде разработки:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка Java 18.&lt;/li&gt;
  &lt;li&gt;Улучшена производительность автодополнения в редакторе.&lt;/li&gt;
  &lt;li&gt;Несколько новых &lt;i&gt;Quick Fix&lt;/i&gt; и &lt;i&gt;Cleanup Action&lt;/i&gt; для Java.&lt;/li&gt;
  &lt;li&gt;Улучшена производительность печати в консоль.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Find Actions&lt;/i&gt; (&lt;code&gt;Ctrl+3&lt;/code&gt;) теперь может искать файлы.&lt;/li&gt;
  &lt;li&gt;Несколько новых команд, связанных с режимом multi-selection.&lt;/li&gt;
  &lt;li&gt;Кодировка по умолчанию для workspace теперь UTF-8.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/netbeans/releases/tag/14"&gt;Apache NetBeans 14&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/"&gt;Kotlin 1.7.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.gwtproject.org/release-notes.html#Release_Notes_2_10_0"&gt;GWT 2.10.0&lt;/a&gt;. Это первое обновление библиотеки спустя два года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2022/06/14/orm-61-final/"&gt;Hibernate 6.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #41</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_41.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_41.html</id>
    <updated>2022-06-12T18:00:00Z</updated>
    <published>2022-06-12T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 19 перешёл в &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-June/006735.html"&gt;первую фазу Rampdown&lt;/a&gt;. Список JEP'ов &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;заморожен&lt;/a&gt;, а исходный код ответвлён в &lt;a href="https://github.com/openjdk/jdk19"&gt;стабилизационный репозиторий&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Примечательно, что из всех семи JEP'ов Java 19 только один будет иметь стабильный характер (&lt;a href="https://openjdk.java.net/jeps/422"&gt;Linux/RISC-V Port&lt;/a&gt;). Все остальные будут иметь статус Preview, либо Incubator.&lt;/p&gt;
&lt;p&gt;Тем временем, уже &lt;a href="https://github.com/openjdk/jdk/pull/8236"&gt;началась&lt;/a&gt; разработка Java 20. У нового релиза появилась &lt;a href="https://jdk.java.net/20/"&gt;своя страница&lt;/a&gt;, где можно скачать первую сборку JDK 20-ea+1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java 19 попал интересный &lt;a href="https://github.com/openjdk/jdk/pull/3402"&gt;патч&lt;/a&gt;, который исправляет &lt;a href="https://bugs.openjdk.org/browse/JDK-4511638"&gt;баг 20-летней давности&lt;/a&gt;. Баг этот заключается в том, что метод &lt;code&gt;Double.toString()&lt;/code&gt; иногда возвращает некорректный результат, например:&lt;/p&gt;
&lt;pre&gt;&amp;gt; jshell
&lt;span style="color: grey"&gt;|  Welcome to JShell -- Version 18.0.1.1
|  For an introduction type: /help intro&lt;/span&gt;

jshell&amp;gt; Double.toString(1e23)
$1 ==&gt; "9.999999999999999E22"&lt;/pre&gt;
&lt;p&gt;В Java 19 это исправлено:&lt;/p&gt;
&lt;pre&gt;&amp;gt; jshell
&lt;span style="color: grey"&gt;|  Welcome to JShell -- Version 19-ea
|  For an introduction type: /help intro&lt;/span&gt;

jshell&amp;gt; Double.toString(1e23)
$1 ==&gt; "1.0E23"&lt;/pre&gt;
&lt;p&gt;Помимо возвращения корректного результата новая реализация также значительно быстрее (в 17.7 раз по &lt;a href="https://mail.openjdk.org/pipermail/core-libs-dev/2020-April/065921.html"&gt;замерам автора&lt;/a&gt;), поскольку не выделяет промежуточных объектов, не содержит циклов и использует только целочисленную арифметику.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В блоге IntelliJ IDEA вышел новый выпуск &lt;a href="https://blog.jetbrains.com/idea/2022/06/java-annotated-monthly-june-2022/"&gt;Java Annotated Monthly&lt;/a&gt; за июнь.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #40</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_40.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_40.html</id>
    <updated>2022-05-29T18:00:00Z</updated>
    <published>2022-05-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java18"&gt;JDK 18.0.1.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java17"&gt;JDK 17.0.3.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java11"&gt;JDK 11.0.15.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java8"&gt;JDK 8u333&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Такое внеплановое обновление пришлось выпустить из-за &lt;a href="https://bugs.openjdk.org/browse/JDK-8285468?jql=project%20%3D%20JDK%20AND%20fixVersion%20%3D%2018.0.1.1"&gt;нескольких критических багов&lt;/a&gt; в OpenJDK.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Ещё один JEP предложен к JDK 19. Это &lt;a href="https://openjdk.org/jeps/428"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;. Это седьмой и, вероятно, последний JEP, который попадёт в этот релиз, поскольку до первой фазы Rampdown остаётся &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;меньше двух недель&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Марк Рейнолд &lt;a href="https://mail.openjdk.org/pipermail/discuss/2022-May/006110.html"&gt;заявил&lt;/a&gt; о начале работы над проектом Leyden. У проекта появилась &lt;a href="https://openjdk.org/projects/leyden/"&gt;своя страница&lt;/a&gt; на сайте OpenJDK и &lt;a href="https://mail.openjdk.org/mailman/listinfo/leyden-dev"&gt;почтовая рассылка&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напомним, что целью проекта Leyden является решение проблемы медленного старта JVM и большого размера образа. Призыв к обсуждению проекта был ещё &lt;a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html"&gt;в апреле 2020 года&lt;/a&gt;, а голосование по нему завершилось &lt;a href="https://mail.openjdk.org/pipermail/announce/2020-June/000290.html"&gt;в июне того же года&lt;/a&gt;. Тогда предлагалось, что упомянутые проблемы будут решаться через концепцию статического образа &amp;ndash; автономной программы, которая выполняет целевое приложение и ничего больше.&lt;/p&gt;
&lt;p&gt;В текущем предложении подход будет &lt;a href="https://openjdk.org/projects/leyden/notes/01-beginnings"&gt;несколько иным&lt;/a&gt;: движение к "закрытому миру" будет постепенным и инкрементальным. Полностью статические образы будут самой конечной целью, а в промежутке в JDK будут внедряться улучшения, которые разработчики смогут начать использовать раньше.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains планирует полностью поменять интерфейс IntelliJ IDEA и других своих IDE. Как &lt;a href="https://blog.jetbrains.com/idea/2022/05/take-part-in-the-new-ui-preview-for-your-jetbrains-ide/"&gt;утверждается&lt;/a&gt; в блоге JetBrains, "тренды графического интерфейса эволюционировали, и многие из наших пользователей говорят нам, что текущий интерфейс кажется тяжеловесным и устаревшим". Поэтому в компании было принято решение разработать абсолютно новый look-and-feel, который будет чистым, современным и мощным.&lt;/p&gt;
&lt;p&gt;Новый графический интерфейс будет внедряться постепенно. Сначала ограниченный круг пользователей сможет принять участие в &lt;a href="https://www.jetbrains.com/lp/intellij-new-ui-preview/"&gt;программе раннего доступа&lt;/a&gt;, где сможет попробовать новый интерфейс и поделиться обратной связью с командой JetBrains. Позже в этом году новый интерфейс станет общедоступным, а в следующем году он станет интерфейсом по умолчанию, сначала для новых пользователей, а потом для всех остальных. После этого старый интерфейс будет всё ещё доступен как минимум в течение года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/05/19/spring-boot-2-7-0-available-now"&gt;Spring Boot 2.7.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #39</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_39.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_39.html</id>
    <updated>2022-05-15T18:00:00Z</updated>
    <published>2022-05-15T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стало известно ещё о трёх новых JEP, которые попадут в JDK 19.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="https://openjdk.org/jeps/425"&gt;JEP 425: Virtual Threads (Preview)&lt;/a&gt; (этот JEP уже интегрирован в сборку &lt;a href="https://jdk.java.net/19/"&gt;JDK 19-ea+22&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Второй &amp;ndash; &lt;a href="https://openjdk.org/jeps/427"&gt;JEP 427: Pattern Matching for switch (Third Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_37.html"&gt;выпуске #37&lt;/a&gt;, когда он был ещё в статусе черновика.&lt;/p&gt;
&lt;p&gt;Третий &amp;ndash; &lt;a href="https://openjdk.org/jeps/424"&gt;JEP 424: Foreign Function &amp; Memory API (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_35.html"&gt;выпуске #35&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-1"&gt;Также предложен ко включению в Java 19 &lt;a href="https://openjdk.org/jeps/405"&gt;JEP 405: Record Patterns (Preview)&lt;/a&gt;. Про этот JEP мы писали давно в &lt;a href="java_news_8.html"&gt;выпуске #8&lt;/a&gt;, когда он ещё был озаглавлен как "Record and Array Patterns (Preview)". В текущий JEP было решено не включать паттерны массивов и оставить только паттерны записей. Паттерны массивов отложены на один из будущих JEP'ов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Марк Рейнолд предложил переименовать домен &lt;a href="https://openjdk.org/"&gt;openjdk.java.net&lt;/a&gt; в &lt;a href="https://openjdk.org"&gt;openjdk.org&lt;/a&gt;. С момента появления OpenJDK в 2007 году вся его инфраструктура (исходный код, веб, e-mail, wiki, задачи) хостится в домене третьего уровня openjdk.java.net, хотя веб-сайт &lt;a href="https://en.wikipedia.org/wiki/Java.net"&gt;java.net&lt;/a&gt; был сайтом для Java-сообщества и имел слабое отношение к разработке самого OpenJDK. В 2017 году этот сайт был закрыт.&lt;/p&gt;
&lt;p&gt;С тех пор много открытого ПО стало хоститься в домене .org, и перемещение туда OpenJDK будет логичным шагом. Также это послужит напоминанием о том, что OpenJDK разрабатывается сообществом, а не одной главенствующей корпорацией.&lt;/p&gt;
&lt;p&gt;Вместе с самим доменом openjdk.java.net также будут переименованы все его активные поддомены (bugs, cr, db, git, hg, mail, wiki). При этом старые ссылки, ведущие на openjdk.java.net, будут перенаправлены на соответствующие адреса в домене openjdk.org.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел в свет новый декомпилятор Java-байткода &lt;a href="https://github.com/QuiltMC/quiltflower"&gt;Quiltflower&lt;/a&gt;. Quiltflower является форком декомпилятора Fernflower, который является стандартным декомпилятором в IntelliJ IDEA. Как &lt;a href="https://www.reddit.com/r/java/comments/ue8u59/new_open_source_java_decompiler/"&gt;утверждает автор&lt;/a&gt;, Quiltflower более точно воспроизводит исходный Java-код и поддерживает различные синтаксические конструкции (try-with-resources, выражения &lt;code&gt;switch&lt;/code&gt;, паттерн-матчинг, sealed-классы и т.д). В доказательство приводятся &lt;a href="https://gist.github.com/SuperCoder7979/c7171b0e34b6eccf0b9f1c37030867dc"&gt;примеры&lt;/a&gt;, сравнивающие результаты декомпиляции Fernflower и Quiltflower.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Роман Кеннке &lt;a href="https://mail.openjdk.org/pipermail/lilliput-dev/2022-May/000457.html"&gt;сообщил&lt;/a&gt;, что проекту &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt; удалось сократить размер заголовков объектов с 96/128 бит до 64 бит. При этом 64-битные заголовки являются лишь промежуточным шагом, и он заявил, что следующим шагом будет сокращение заголовков ещё сильнее: до 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="http://weld.cdi-spec.org/news/2022/04/29/weld-500Final/"&gt;Weld 5.0.0.Final&lt;/a&gt;, который поддерживает спецификацию &lt;a href="https://jakarta.ee/specifications/cdi/4.0/"&gt;CDI 4&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
</feed>
