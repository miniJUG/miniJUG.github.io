<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-04-04T17:00:00Z</updated>
  <entry>
    <title>Новости Java #13</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_13.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_13.html</id>
    <updated>2021-04-04T17:00:00Z</updated>
    <published>2021-04-04T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Появилось &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-March/005266.html"&gt;расписание процесса выхода JDK 17&lt;/a&gt;. Общедоступная версия Java 17 по плану должна выйти 14 сентября 2021 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появился новый &lt;a href="https://openjdk.java.net/jeps/408"&gt;JEP 408: Simple Web Server&lt;/a&gt;. В нём предлагает добавить в JDK стандартную утилиту, которая будет запускать простой веб-сервер для хостинга статических файлов в указанной директории. При этом реализация веб-сервера в Java существует ещё с JDK 1.6 в публичном пакете &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html"&gt;&lt;code&gt;com.sun.net.httpserver&lt;/code&gt;&lt;/a&gt;, а задачей JEP будет лишь предоставить для него простое API и возможность запускать его из командной строки одной простой командой.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-April/000299.html"&gt;Завершено голосование&lt;/a&gt; по созданию проекта Lilliput, и теперь он будет официально запущен. Напомним, в этом проекте будут исследоваться возможности по &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;сжатию заголовков&lt;/a&gt; Java-объектов до 64/32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На YouTube &lt;a href="https://www.youtube.com/playlist?list=PLutlXcN4EAwD4L_vwgYXtoHoNembpw_t0"&gt;появились видео докладов&lt;/a&gt; с конференции JakartaOne Livestream.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.8.1/release-notes.html"&gt;Apache Maven 3.8.1&lt;/a&gt;. В этой версии внешние репозитории, использующие протокол HTTP, теперь блокируются по умолчанию. Это первый релиз Maven спустя полтора года после выхода версии 3.6.3.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://projectlombok.org/changelog"&gt;Lombok 1.18.20&lt;/a&gt; с поддержкой Java 16 и записей.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/03/intellij-idea-2021-1-rc/"&gt;IntelliJ IDEA 2021.1 RC&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jol-dev/2021-March/000335.html"&gt;JOL 0.15&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+16&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+6&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://dotty.epfl.ch/blog/2021/03/31/scala3-rc2.html"&gt;Scala 3.0.0-RC2&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #12</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_12.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_12.html</id>
    <updated>2021-03-28T17:00:00Z</updated>
    <published>2021-03-28T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло 3 новых JEP. Это &lt;a href="http://openjdk.java.net/jeps/405"&gt;JEP 405: Record Patterns &amp; Array Patterns (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/406"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/407"&gt;JEP 407: Remove RMI Activation&lt;/a&gt;. Про первые два мы уже писали в &lt;a href="java_news_8.html"&gt;предыдущих выпусках&lt;/a&gt;. В JEP 407 предлагается окончательно удалить устаревшую часть RMI, которая называется RMI Activation. В Java 15 она стала &lt;a href="http://openjdk.java.net/jeps/385"&gt;deprecated for removal&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Появилось 3 новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8263381"&gt;Dynamic Deserialization Filters&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/8264130"&gt;PAC-RET protection for Linux/AArch64&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8264131"&gt;Arm64e support for MacOS/AArch64&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Официально объявлено, что проект jdk11u &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-March/005470.html"&gt;переедет на Git и GitHub&lt;/a&gt;. Это случится летом, когда начнётся разработка JDK 11.0.13.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://newsroom.eclipse.org/news/announcements/eclipse-foundation%E2%80%99s-eclipse-jetty-project-prepares-future-jetty-11-release"&gt;Eclipse Jetty 11&lt;/a&gt; (а точнее 11.0.2).&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-March/003218.html"&gt;JMH 1.29&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pr-2"&gt;&amp;bull; Вышла статья &lt;a href="https://malloc.se/blog/zgc-jdk16"&gt;ZGC | What's new in JDK 16&lt;/a&gt;. В ней утверждается, что в JDK 16 удалось снизить максимальные паузы с 10мс до 1мс.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #11</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_11.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_11.html</id>
    <updated>2021-03-20T17:00:00Z</updated>
    <published>2021-03-20T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Главная новость этой недели &amp;ndash; это, конечно же, выход Java 16. Про неё мы подробно написали в &lt;a href="java_16.html"&gt;этой статье&lt;/a&gt;. В течение небольшого промежутка времени после выхода большинство поставщиков выкатили свои сборки OpenJDK 16: &lt;a href="https://sap.github.io/SapMachine/"&gt;SapMachine&lt;/a&gt;, &lt;a href="https://aws.amazon.com/ru/about-aws/whats-new/2021/03/announcing-general-availability-amazon-corretto-16/"&gt;Amazon Corretto&lt;/a&gt;, &lt;a href="https://www.azul.com/downloads/zulu-community/?version=java-16&amp;package=jdk"&gt;Azul Zulu&lt;/a&gt;, &lt;a href="https://blog.adoptopenjdk.net/2021/03/adoptopenjdk-16-available/"&gt;AdoptOpenJDK&lt;/a&gt; (в т.ч. OpenJ9), &lt;a href="https://bell-sw.com/announcements/2021/03/19/JDK-16-Release/"&gt;Liberica JDK&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Сразу позле выхода Java 16 вышло 4 новых JEP. Это &lt;a href="http://openjdk.java.net/jeps/401"&gt;JEP 401: Primitive Objects (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/402"&gt;JEP 402: Unify the Basic Primitives with Objects (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/403"&gt;JEP 403: Strongly Encapsulate JDK Internals&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/404"&gt;JEP 404: Generational Shenandoah&lt;/a&gt;. Про все JEP кроме третьего мы уже писали в предыдущих выпусках, когда они ещё были черновиками.&lt;/p&gt;
&lt;p&gt;В JEP 403 предлагается сделать опцию &lt;code&gt;--illegal-access&lt;/code&gt; недействующей. В Java 9-16 эта опция позволяет глобально открыть все внутренности JDK без перечисления конкретных пакетов (в Java 16 её значение &lt;a href="http://openjdk.java.net/jeps/396"&gt;стало&lt;/a&gt; по умолчанию &lt;code&gt;deny&lt;/code&gt;). Если JEP будет реализован, то &lt;code&gt;--illegal-access=permit/warn/debug&lt;/code&gt; не будет иметь эффекта, и для открытия пакетов придётся использовать опцию &lt;code&gt;--add-opens&lt;/code&gt;. Также в будущем планируется удалить &lt;code&gt;--illegal-access&lt;/code&gt; окончательно.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ещё два JEP были предложены к попаданию в Java 17. Это &lt;a href="https://openjdk.java.net/jeps/391"&gt;JEP 391: macOS/AArch64 Port&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/398"&gt;JEP 398: Deprecate the Applet API for Removal&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Роман Кеннке, который на прошлой неделе предложил &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;проект Lilliput&lt;/a&gt;, запустил &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-March/000296.html"&gt;официальное голосование&lt;/a&gt; по созданию проекта. На текущий момент проголосовало 26 членов OpenJDK, и все они проголосовали за создание проекта.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=OGGALLHnH-c"&gt;Eclipse 2021-03&lt;/a&gt;. В нём появилось параллельное построение индекса поиска, неблокирующее автодополнение, 16 новых Clean Up действий, quick fix для инициализации переменной в &lt;code&gt;try-with-resources&lt;/code&gt;, улучшенная поддержка &lt;code&gt;sealed&lt;/code&gt; классов и многое другое.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел баг-фикс релиз &lt;a href="https://blog.jetbrains.com/idea/2021/03/intellij-idea-2020-3-3/"&gt;IntelliJ IDEA 2020.3.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v2.0"&gt;Async Profiler 2.0&lt;/a&gt;. Также &lt;a href="https://www.youtube.com/watch?v=TDpbt4thECc"&gt;вышло видео&lt;/a&gt;, где Андрей Паньгин демонстрирует работу Async Profiler в IntelliJ IDEA.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://inside.java/2021/03/16/jmc-8-released/"&gt;JDK Misson Control 8.0.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2021/03/16/spring-framework-5-3-5-available-now"&gt;Spring Framefork 5.3.5&lt;/a&gt; с поддержкой Java 16.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла статья &lt;a href="https://seanjmullan.org/blog/2021/03/18/jdk16"&gt;JDK 16 Security Enhancements&lt;/a&gt;, где рассказано какие изменения в криптографии, PKI, TLS, Signed JARs были сделаны в Java 16.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://github.com/google/guava/releases/tag/v30.1.1"&gt;Guava 30.1.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+13&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+5&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 16</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_16.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_16.html</id>
    <updated>2021-03-15T17:00:00Z</updated>
    <published>2021-03-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;16-я версия&lt;/a&gt; платформы Java SE. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-16.txt"&gt;двух с половиной тысяч&lt;/a&gt; закрытых задач и 17 JEP'ов. Изменения API можно посмотреть &lt;a href="https://javaalmanac.io/jdk/16/apidiff/15/"&gt;здесь&lt;/a&gt;. Release notes &lt;a href="https://www.oracle.com/java/technologies/javase/16-all-relnotes.html"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Уже сейчас доступны для скачивания дистрибутивы &lt;a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html"&gt;Oracle JDK&lt;/a&gt; и &lt;a href="http://jdk.java.net/16/"&gt;OpenJDK&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;JEP'ы, которые попали в Java 16, мы разобьём на четыре категории: язык, API, JVM и инфраструктура.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/375"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (JEP 375)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Оператор &lt;code&gt;instanceof&lt;/code&gt; с паттерн-матчингом, который &lt;a href="https://openjdk.java.net/jeps/305"&gt;появился&lt;/a&gt; в Java 14 и перешёл во &lt;a href="https://openjdk.java.net/jeps/375"&gt;второе preview&lt;/a&gt; в Java 15, теперь стал стабильной синтаксической конструкцией и больше не требует флага &lt;code&gt;--enable-preview&lt;/code&gt;. Паттерн-матчинг мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;, и с того момента в него было внесено два изменения:&lt;/p&gt;
&lt;p&gt;Во-первых, переменные паттернов теперь не являются неявно финальными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) {
    s = &lt;span style="color: darkred"&gt;"Hello"&lt;/span&gt;; &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Во-вторых, если тип выражения, известный на этапе компиляции, является подтипом проверяемого типа, то теперь это ошибка компиляции:&lt;/p&gt;
&lt;pre&gt;String str = ...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (str &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) { &lt;span style="color: green"&gt;// Oшибка в Java 16, OK в Java 15&lt;/span&gt;
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/395"&gt;Записи (JEP 395)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одна синтаксическая конструкция, которая стала стабильной &amp;ndash; это записи. Она также была в режиме preview в &lt;a href="https://openjdk.java.net/jeps/359"&gt;Java 14&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/384"&gt;Java 15&lt;/a&gt;. Записи мы также подробно &lt;a href="trying_records_in_java14.html"&gt;рассматривали ранее&lt;/a&gt;. В Java 16 было внесено следующее изменение: теперь во внутренних классах разрешено объявлять статические члены:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;static void&lt;/span&gt; main(String[] args) {
        }

        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {
        }
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/397"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (второе preview) (JEP 397)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;&amp;laquo;Запечатанные&amp;raquo; классы, которые появились в Java 15 в режиме preview, остаются в этом статусе. Их мы рассматривали в &lt;a href="trying_sealed_classes_in_java_15.html"&gt;этой статье&lt;/a&gt;. Изменения по сравнению с прошлой версией следующие:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Теперь в спецификации языка Java появилось понятие contextual keyword взамен старым понятиям restricted keyword и restricted identifier, и одними из таких contextual keywords стали &lt;code&gt;sealed&lt;/code&gt;, &lt;code&gt;non-sealed&lt;/code&gt; и &lt;code&gt;permits&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Компилятор теперь производит более строгие проверки при конверсии типов, в иерархиях которых есть &lt;code&gt;sealed&lt;/code&gt; классы:&lt;pre&gt;
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Sealed {
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Impl &lt;span style="color: blue"&gt;implements&lt;/span&gt; Sealed {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; f(Runnable r) {
        Sealed s = (Sealed) r; &lt;span style="color: red"&gt;// error: incompatible types&lt;/span&gt;
    }
}&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Метод &lt;code&gt;Class.permittedSubclasses()&lt;/code&gt; переименован в &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#getPermittedSubclasses()"&gt;&lt;code&gt;Class.getPermittedSubclasses()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/396"&gt;Строгая инкапсуляция внутренностей JDK по умолчанию (JEP 396)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инкапсуляция внутренних API JDK, которая была &lt;a href="https://openjdk.java.net/jeps/260"&gt;введена в Java 9&lt;/a&gt;, теперь стала строгой: если в Java 9-15 значение опции &lt;code&gt;--illegal-access&lt;/code&gt; было по умолчанию &lt;code&gt;permit&lt;/code&gt;, то с Java 16 она становится &lt;code&gt;deny&lt;/code&gt;. Это значит, что рефлективный доступ к защищённым членам классов и статический доступ к неэкспортированным API (&lt;code&gt;sun.*&lt;/code&gt;, &lt;code&gt;com.sun.*&lt;/code&gt;, &lt;code&gt;jdk.internal.*&lt;/code&gt; и т.д.) теперь будет выбрасывать ошибку.&lt;/p&gt;
&lt;p&gt;Если код требует доступа к внутренностям JDK во время выполнения, то чтобы он продолжал работать на Java 16, теперь придётся явно указывать одну из трёх опций JVM:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--illegal-access=permit/warn/debug&lt;/code&gt;: открытие всех пакетов JDK&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-opens=module/package=target-module&lt;/code&gt;: открытие одного пакета&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-exports=module/package=target-module&lt;/code&gt;: экспортирование одного пакета (только для статического доступа)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В будущем опция &lt;code&gt;--illegal-access&lt;/code&gt; может быть удалена окончательно. Начиная с Java 16, при её использовании выдаётся предупреждение: &lt;code&gt;Option --illegal-access is deprecated and will be removed in a future release&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Изменения не касаются критического API в модуле &lt;code&gt;jdk.unsupported&lt;/code&gt;: классы в пакетах &lt;code&gt;sun.misc&lt;/code&gt; и &lt;code&gt;sun.reflect&lt;/code&gt; остаются доступными без флагов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/390"&gt;Warnings for Value-Based Classes (JEP 390)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Классы-обёртки примитивных типов (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt; и т.д.) теперь относятся к категории value-based классов, и их конструкторы, которые ранее &lt;a href="new_integer_is_deprecated.html"&gt;стали deprecated&lt;/a&gt; в Java 9, теперь помечены как &lt;a href="https://openjdk.java.net/jeps/277"&gt;deprecated for removal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Понятие value-based классов появилось в спецификации API &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html"&gt;Java 8&lt;/a&gt;. Такие классы являются неизменяемыми, создаются только через фабрики, и в их использовании не должны использоваться операции, чувствительные к identity: сравнение на &lt;code&gt;==&lt;/code&gt;, синхронизация, &lt;code&gt;identityHashCode()&lt;/code&gt; и т.д. Value-based классы являются кандидатами для миграции на &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;примитивные классы&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;, который сейчас находится в стадии активной разработки.&lt;/p&gt;
&lt;p&gt;При синхронизации на объектах value-based классов теперь будет выдаваться предупреждение во время компиляции:&lt;/p&gt;
&lt;pre&gt;Double d = 0.0;
&lt;span style="color: blue"&gt;synchronized&lt;/span&gt; (d) { &lt;span style="color: orange"&gt;// warning: [synchronization] attempt to synchronize on an instance of a value-based class&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Также можно включить проверки синхронизации на value-based объектах во время выполнения с помощью флагов JVM:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=1&lt;/code&gt;: при попытке синхронизации будет фатальная ошибка.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=2&lt;/code&gt;: при попытке синхронизации будет предупреждение.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/376"&gt;ZGC: Concurrent Thread-Stack Processing (JEP 376)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Обработка стеков потоков в сборщике мусора &lt;a href="https://openjdk.java.net/jeps/377"&gt;ZGC&lt;/a&gt; теперь перенесена из safepoints в конкурентную фазу. Это позволило ещё сильнее уменьшить паузы сборщика мусора.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/380"&gt;Unix-Domain Socket Channels (JEP 380)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Добавлена поддержка &lt;a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0_Unix"&gt;сокетов доменов Unix&lt;/a&gt; в socket channel и server-socket channel API. Такие сокеты используются для межпроцессного взаимодействия внутри одного хоста, и в них не используются сетевые соединения, что делает такое взаимодействие более безопасным и эффективным. Сокеты доменов Unix с &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/"&gt;недавних пор&lt;/a&gt; поддерживаются в Windows 10 и Windows Server 2019.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/387"&gt;Elastic Metaspace (JEP 387)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Metaspace (пространство JVM, в котором хранятся метаданные классов) переработан для более эффективной отдачи неиспользуемой памяти обратно операционной системе и меньшего потребления памяти вне кучи в целом. Такое улучшение может быть полезно для приложений, которые интенсивно загружают и выгружают классы посредством большого количества загрузчиков классов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/386"&gt;Alpine Linux Port (JEP 386)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь портирован на &lt;a href="https://ru.wikipedia.org/wiki/Alpine_Linux"&gt;Alpine Linux&lt;/a&gt; и другие дистрибутивы Linux, которые используют &lt;a href="https://ru.wikipedia.org/wiki/Musl"&gt;musl&lt;/a&gt; в качестве реализации стандартной библиотеки C. Alpine Linux популярен в облаках, микросервисах и контейнерах благодаря своему маленькому размеру образа. Новый порт позволит нативно запускать JDK в этих окружениях.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/388"&gt;Windows/AArch64 Port (JEP 388)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK также портирован на архитектуру &lt;a href="https://docs.microsoft.com/ru-ru/windows/uwp/porting/apps-on-arm"&gt;Windows/AArch64&lt;/a&gt;. Это позволит запускать Java на компьютерах с Windows on ARM, которые в последнее время набирают популярность.&lt;/p&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;Новые методы в &lt;code&gt;Stream&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;Хотя для этих двух новых методов в интерфейсе &lt;code&gt;java.util.stream.Stream&lt;/code&gt; нет отдельного JEP, хочется упомянуть их здесь, так как это довольно заметное изменение.&lt;/p&gt;
&lt;p&gt;Первый метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"&gt;&lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/a&gt;. Этот метод собирает содержимое &lt;code&gt;Stream&lt;/code&gt; в неизменяемый список и возвращает его. При этом, в отличие от &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableList()"&gt;&lt;code&gt;Collectors.toUnmodifiableList()&lt;/code&gt;&lt;/a&gt;, список, который возвращается из &lt;code&gt;Stream.toList()&lt;/code&gt;, толерантен к &lt;code&gt;null&lt;/code&gt;-элементам.&lt;/p&gt;
&lt;p&gt;Второй метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)"&gt;&lt;code&gt;Stream.mapMulti()&lt;/code&gt;&lt;/a&gt; (и примитивные специализации). Это метод является императивным аналогом метода &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;Stream.flatMap()&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;flatMap()&lt;/code&gt; принимает функцию, которая для каждого элемента должна вернуть &lt;code&gt;Stream&lt;/code&gt;, то &lt;code&gt;mapMulti()&lt;/code&gt; принимает процедуру с двумя параметрами, где первый параметр &amp;ndash; это текущий элемент, а второй &amp;ndash; Consumer, в который кладутся значения. Пример:&lt;/p&gt;
&lt;pre&gt;IntStream.rangeClosed(1, 10).mapMulti((i, consumer) -&gt; {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; j = 1; j &lt;= i; j++) {
        consumer.accept(j);
    }
}); &lt;span style="color: green"&gt;// Возвращает 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/392"&gt;Инструмент упаковки (JEP 392)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инструмент создания самодостаточных приложений &lt;code&gt;jpackage&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/343"&gt;появился в Java 14&lt;/a&gt; в инкубационном статусе, теперь стал постоянным модулем.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/338"&gt;Vector API (Incubator) (JEP 338)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый инструментарий для преобразования векторных вычислений в SIMD-инструкции процессора (x64 и AArch64). Векторное API позволит разработчику контролировать процесс компиляции и не полагаться на автовекторизацию, которая в JVM является ограниченным и хрупким механизмом. Явная векторизация может применяться в таких областях как машинное обучение, линейная алгебра, криптография и др.&lt;/p&gt;
&lt;p&gt;API находится в инкубационном модуле &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/389"&gt;Foreign Linker API (Incubator) (JEP 389)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новое API, которое появилось в результате работы над проектом &lt;a href="http://openjdk.java.net/projects/panama/"&gt;Panama&lt;/a&gt; &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/module-summary.html"&gt;Foreign Linker API&lt;/a&gt;. Это инструментарий для статического доступа к нативному коду из Java, созданный для замены JNI: он должен быть более простым в использовании, более безопасным и желательно более быстрым.&lt;/p&gt;
&lt;p&gt;Про Foreign API &lt;a href="https://www.youtube.com/watch?v=4vHMmLqF09Y"&gt;делал доклад&lt;/a&gt; Владимир Иванов из Oracle.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/393"&gt;Foreign-Memory Access API (Third Incubator) (JEP 393)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API для доступа вне кучи Java, которое появилось &lt;a href="https://openjdk.java.net/jeps/370"&gt;в Java 14&lt;/a&gt;, остаётся в инкубационном статусе с некоторыми изменениями.&lt;/p&gt;

&lt;h4&gt;Инфраструктура&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/347"&gt;Enable C++14 Language Features (JEP 347)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Кодовая база JDK до Java 16 использовала стандарты C++98/03. При этом с Java 11 код стал собираться версией с более новым стандартом, однако в нём всё ещё нельзя было использовать возможности стандарта C++11/14. Теперь же часть из этих возможностей использовать можно: в гиде по стилю HotSpot определён список возможностей C++11/14, которые можно использовать и которые нельзя.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/357"&gt;Migrate from Mercurial to Git (JEP 357)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/369"&gt;Migrate to GitHub (JEP 369)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Совершён переход репозиториев JDK на Git и GitHub. Миграция была полностью завершена в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2020-September/004694.html"&gt;сентябре 2020 года&lt;/a&gt;, и разработка Java 16 уже полностью велась в &lt;a href="https://git.openjdk.java.net/jdk"&gt;новом репозитории&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Переход на GitHub облегчил процесс принятия изменений контрибьюторами. Теперь изменения предлагаются через привычные большинству пользователей пулл-реквесты, и большая часть процесса автоматизирована с помощью команд и ботов. Подробнее про процесс можно прочитать на &lt;a href="https://wiki.openjdk.java.net/display/SKARA/Skara"&gt;странице проекта Skara&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также сейчас &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;обсуждается&lt;/a&gt; переход на Git более старых версий JDK: &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; и, возможно, &lt;a href="https://wiki.openjdk.java.net/display/jdk8u/Main"&gt;jdk8u&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;Java 16 является STS-релизом, у которого выйдет только два обновления.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #10</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_10.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_10.html</id>
    <updated>2021-03-13T17:00:00Z</updated>
    <published>2021-03-13T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002895.html"&gt;продолжается обсуждение&lt;/a&gt; того, как должны выглядеть условия в &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;паттернах&lt;/a&gt;, и, похоже, группа экспертов уже близка к единому мнению. Условия, скорее всего, будут отделяться от паттернов оператором &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s &amp;&amp; (s.length() == 1) -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Брайан Гетц предвидит, что в Java когда-нибудь могут появиться паттерны в присваивании, поэтому уже сейчас начинает &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002916.html"&gt;обсуждать&lt;/a&gt; эту тему в рассылке.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышло два новых JEP:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.java.net/jeps/399"&gt;JEP 399: Intermediate-Representation Graph Serialization&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.java.net/jeps/400"&gt;JEP 400: UTF-8 by Default&lt;/a&gt;. В этом JEP'е предлагается сделать UTF-8 кодировкой по умолчанию для таких API как &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileReader.html"&gt;FileReader&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileWriter.html"&gt;FileWriter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStreamReader.html"&gt;InputStreamReader&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStreamWriter.html"&gt;OutputStreamWriter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html"&gt;Formatter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Scanner.html"&gt;Scanner&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLEncoder.html"&gt;URLEncoder&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLDecoder.html"&gt;URLDeconder&lt;/a&gt; и т.д. Сейчас кодировка по умолчанию определяется во время старта JVM и может зависеть от различных факторов, таких как операционная система, пользовательская локаль и значения некоторых свойств виртуальной машины. Когда этот JEP будет реализован, UTF-8 станет кодировкой по умолчанию для всех JDK, что сделает приложения на Java более портируемыми.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Роман Кеннке, лидер проекта Shenandoah в RedHat, предложил в рассылке &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;новый проект Lilliput&lt;/a&gt;, целью которого будет уменьшение размера заголовка объекта в Hotspot до 64/32 бит и более гибкая схема размещения битов в нём. Сейчас заголовок каждого объекта в 64-разрядном Hotspot имеет размер от 96 до 128 бит, и такое сжатие могло бы существенно снизить нагрузку на память и/или CPU в Java-приложениях.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains выпустила первую версию своего &lt;a href="https://blog.jetbrains.com/blog/2021/03/11/projector-is-out/"&gt;нового инструмента Projector&lt;/a&gt;, который позволяет запускать IDE от JetBrains или Swing-приложения на сервере и управлять ими откуда угодно с помощью браузера или нативного приложения.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://netbeans.apache.org/download/nb123/nb123.html"&gt;Apache NetBeans 12.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла версия 1.0 библиотеки &lt;a href="https://in.relation.to/2021/03/08/hibernate-reactive-1/"&gt;Hibernate Reactive&lt;/a&gt;, которая предоставляет реактивное API к Hibernate ORM.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://openjfx.io/highlights/16/"&gt;JavaFX 16&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+13-1000&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+4-174&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #9</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_9.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_9.html</id>
    <updated>2021-03-07T17:00:00Z</updated>
    <published>2021-03-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Брайан Гетц запустил в рассылке Amber &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002862.html"&gt;дискуссию&lt;/a&gt; по поводу того, как в &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/a&gt; должны выглядеть паттерны с условиями. Пока что в этом вопросе консенсуса нет, и была предложена масса вариантов. Вот примеры возможных решений:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;when&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &lt;span style="color: blue"&gt;if&lt;/span&gt; (x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp;&amp; x &gt; 0:&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &amp;&amp; x &gt; 0):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ещё одно письмо от Брайана Гетца было опубликовано про &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002836.html"&gt;паттерны примитивных типов и конверсии&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.java.net/jeps/398"&gt;JEP 398: Deprecate the Applet API for Removal&lt;/a&gt;. API аплетов, которое &lt;a href="https://openjdk.java.net/jeps/289"&gt;стало deprecated&lt;/a&gt; в Java 9, теперь предлагается пометить как подлежащее окончательному удалению.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый мартовский выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/03/java-annotated-monthly-march-2021/"&gt;Java Annotated Monthly&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге AdoptOpenJDK &lt;a href="https://blog.adoptopenjdk.net/2021/03/transition-to-eclipse-an-update/"&gt;появился пост&lt;/a&gt; с обновлением статуса переезда проекта в Eclipse Foundation. Напомним, что 9 месяцев назад &lt;a href="https://blog.adoptopenjdk.net/2020/06/adoptopenjdk-to-join-the-eclipse-foundation/"&gt;было объявлено&lt;/a&gt;, что проект AdoptOpenJDK собирается присоединиться к Eclipse Foundation, а его имя будет изменено на Eclipse Adoptium.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+12&lt;/a&gt;, &lt;a href="https://jdk.java.net/lanai/"&gt;JDK 17-lanai+3-133&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-March/003171.html"&gt;JMH 1.28&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #8</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_8.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_8.html</id>
    <updated>2021-02-28T17:00:00Z</updated>
    <published>2021-02-28T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло два новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8260244"&gt;Record and Array Patterns (Preview)&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В первом JEP'е предлагается ввести в язык паттерны записей и паттерны массивов. Паттерны записей будут выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
    System.out.println(x + y);
}&lt;/pre&gt;
&lt;p&gt;Паттерны могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint r)) {
    System.out.println(c);
}&lt;/pre&gt;
&lt;p&gt;Паттерны массивов выглядят так:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2, ... }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Паттерн на примере выше срабатывает для массивов длины 2 или более. Если нужен паттерн строгой длины 2, то многоточие не нужно указывать:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2 }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Есть возможность осуществлять паттерн-матчинг по многомерным массивам. Также можно вкладывать паттерны массивов в паттерны записей и наоборот.&lt;/p&gt;
&lt;p class="pt-1"&gt;Во втором JEP'е предлагается ввести паттерн-матчинг по типу для оператора &lt;code&gt;switch&lt;/code&gt;, и это будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;Если пользователю нужен матчинг &lt;code&gt;null&lt;/code&gt;, то придётся указывать отдельную ветку:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Если не указывать явную ветку &lt;code&gt;case null&lt;/code&gt; и в &lt;code&gt;switch&lt;/code&gt; передастся нулевой объект, то будет выбрасываться &lt;code&gt;NullPointerException&lt;/code&gt;, даже если будет присутствовать ветка &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) { &lt;span style="color: red"&gt;// will throw NPE&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Чтобы ветка &lt;code&gt;default&lt;/code&gt; покрывала &lt;code&gt;null&lt;/code&gt;, нужно будет использовать паттерн &lt;code&gt;null, default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Паттерн &lt;code&gt;null&lt;/code&gt; можно будет также объединять и с паттерном по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case null&lt;/span&gt;, String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;В первой итерации поддержки смешанных паттернов (паттернов по типу и константных паттернов в одном &lt;code&gt;switch&lt;/code&gt;) не будет:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Hello world"&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Hello back"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Nothing?"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; также будет поддерживать условные паттерны. Для этого предлагается ввести охранные паттерны вида &lt;code&gt;true(boolean expr)&lt;/code&gt; и &lt;code&gt;false(boolean expr)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Shape s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Triangle t &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(t.calculateArea() &gt; 100) -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Large Triangle"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"A shape (including small triangles"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p class="pt-1"&gt;Если оба JEP'а будет реализованы вместе, то первый будет дополнять возможности второго. Так, все паттерны по записям и массивам можно будет использовать и в ветках &lt;code&gt;switch&lt;/code&gt; (в том числе вложенные).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел первый релиз-кандидат языка Scala 3: &lt;a href="https://dotty.epfl.ch/blog/2021/02/17/scala3-rc1.html"&gt;Scala 3.0.0-RC1&lt;/a&gt;. В эту версию попало более 400 пулл-реквестов от контрибьюторов с прошлого релиза 3.0.0-M3.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.scala-lang.org/scala3/new-in-scala3.html"&gt;Scala 3&lt;/a&gt;, разработка которой более 5 лет ведётся в проекте &lt;a href="https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"&gt;Dotty&lt;/a&gt; &amp;ndash; это полная переработка Scala 2, но в значительной части с ней совместимая: большая часть кода на Scala 2 остаётся валидным кодом для компилятора Scala 3, а для остального кода есть &lt;a href="https://scalacenter.github.io/scala-3-migration-guide/"&gt;гид по миграции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также вышло обновление &lt;a href="https://github.com/scala/scala/releases/tag/v2.13.5"&gt;Scala 2.13.5&lt;/a&gt;. В него попала поддержка последних версий Java вплоть до ещё не вышедшей Java 17, поддержка Scala 3.0.0-RC1, более безопасный паттерн-матчинг и другие изменения.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Опубликованы результаты &lt;a href="https://arjan-tijms.omnifaces.org/2021/02/jakarta-ee-survey-20202021-results.html"&gt;опроса Jakarta EE&lt;/a&gt;, который проводился с сентября 2020 по февраль 2021 года. В нём 684 респондента ответили на вопросы относительно использования технологий Java EE / JakartaEE. Из интересных результатов опроса следующие факты:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;Самый используемый сервер приложений &amp;ndash; это RedHat WildFly, а самый ненавистный &amp;ndash; IBM WebSphere.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые API: JPA, CDI и JAX-RS.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые библиотеки: Hibernate, Weld и Hibernate Validator.&lt;/li&gt;
   &lt;li&gt;&lt;a href="https://microprofile.io/"&gt;MicroProfile&lt;/a&gt; попробовало 32% опрошенных. Это на 16% больше, чем 2 года назад.&lt;/li&gt;
   &lt;li&gt;Самые популярные продукты MicroProfile: Quarkus, WildFly и Payara Micro.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-3"&gt;&amp;bull; Была объявлена виртуальная конференция &lt;a href="https://jakartaone.org/2021/russian/"&gt;JakartaOne Livestream на русском&lt;/a&gt;, которая пройдёт 31 марта 2021 года.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+11&lt;/a&gt;, &lt;a href="https://jdk.java.net/panama/"&gt;JDK 17-panama+2-51&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышлая &lt;a href="https://www.reddit.com/r/java/comments/lsbcwe/flatlaf_10_swing_look_and_feel/"&gt;версия 1.0&lt;/a&gt; библиотеки &lt;a href="https://github.com/JFormDesigner/FlatLaf"&gt;FlatLaf&lt;/a&gt; для кроссплатформенного Look and Feel в приложениях на Swing.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В официальной документации Android &lt;a href="https://stackoverflow.com/questions/66346971/android-deprecated-annotation-is-deprecated-whats-the-replacement"&gt;обнаружили&lt;/a&gt;, что аннотация &lt;code&gt;@Deprecated&lt;/code&gt; помечена как Deprecated. Эта ошибка возникла из-за того, что в JavaDoc аннотации присутствовал код &lt;code&gt;{@code @deprecated}&lt;/code&gt;, который сигнализировал парсеру документации добавить "пропущенную" аннотацию &lt;code&gt;@Deprecated&lt;/code&gt;. Баг уже был &lt;a href="https://android-review.googlesource.com/c/platform/libcore/+/1601554"&gt;устранён&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #7</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_7.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_7.html</id>
    <updated>2021-02-14T17:00:00Z</updated>
    <published>2021-02-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел ещё один JEP по проекту Valhalla: &lt;a href="http://openjdk.java.net/jeps/8259731"&gt;Unify the Basic Primitives with Objects (Preview)&lt;/a&gt;. В нём предлагается мигрировать 8 примитивных типов Java (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;) таким образом, чтобы они стали экземплярами соответствующих классов-обёрток (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;), которые сами станут примитивными классами. В такой схеме, например, тип &lt;code&gt;int&lt;/code&gt; станет алиасом для &lt;code&gt;Integer.val,&lt;/code&gt; а &lt;code&gt;Integer&lt;/code&gt; &amp;ndash; к &lt;code&gt;int.ref&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Благодаря такой унификации у примитивных типов появятся свойства, которых у них не было с самого появления языка: наследование, наличие методов (&lt;code&gt;17.toString()&lt;/code&gt;, &lt;code&gt;23.compareTo(42))&lt;/code&gt; и возможность быть параметрами дженериков (будет отдельный JEP).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;предложили&lt;/a&gt; перевести проект &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; на Git. Так как переход 16u и 13u на Git уже &lt;a href="https://openjdk.java.net/projects/skara/"&gt;совершён&lt;/a&gt;, то это поможет унифицировать процесс разработки обновлений разных мажорных версий JDK. Переход на Git предлагается сделать к июню 2021 года, когда начнётся работа над JDK 11.0.13.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains начала программу раннего доступа (EAP) к своему &lt;a href="https://blog.jetbrains.com/idea/2021/02/early-access-program-for-qodana-a-new-product-that-brings-the-smarts-of-jetbrains-ides-into-your-ci-pipeline/"&gt;новому продукту Qodana&lt;/a&gt; &amp;ndash; платформы для статического анализа и измерения качества кода. Qodana состоит из двух частей: движок для запуска анализа в CI и веб-панель с отчётами. Статический анализатор кода представляет собой движок IntelliJ IDEA без графического интерфейса, и его можно запустить на любом CI-сервере. Для TeamCity есть готовый плагин.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Николай Парлог (aka &lt;a href="https://twitter.com/nipafx"&gt;nipafx&lt;/a&gt;) выложил на YouTube &lt;a href="https://youtu.be/ZyTH8uCziI4"&gt;интервью с Брайаном Гетцом&lt;/a&gt; про то, почему сериализация, nullability, мутабельность и другие аспекты сделаны умолчательными в Java, и можно ли это было сделать по-другому.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #6</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_6.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_6.html</id>
    <updated>2021-02-07T17:00:00Z</updated>
    <published>2021-02-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-February/005062.html"&gt;Вышел&lt;/a&gt; первый релиз-кандидат 16-й версии Java: &lt;a href="https://jdk.java.net/16/"&gt;JDK 16+35&lt;/a&gt;. Также вышла новая ранняя сборка JDK 17: &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+8&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Стал известен второй JEP, который предложен к выходу в Java 17. Это &lt;a href="http://openjdk.java.net/jeps/382"&gt;JEP 382: New macOS Rendering Pipeline&lt;/a&gt;. Цель этого JEP'а &amp;ndash; реализовать новый конвейер Java 2D-рендеринга на основе Apple Metal API в качестве альтернативы старому deprecated OpenGL API. Разработка нового конвейера ведётся в рамках &lt;a href="http://openjdk.java.net/projects/lanai/"&gt;проекта Lanai&lt;/a&gt;, у которого недавно вышла &lt;a href="https://jdk.java.net/lanai/"&gt;ранняя сборка&lt;/a&gt; JDK 17-lanai+2-49.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Компания JFrog &lt;a href="https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/"&gt;закрывает&lt;/a&gt; свои облачные платформы Bintray, GoCenter и ChartCenter. Эти сервисы много лет предоставляли возможность бесплатно публиковать и распространять бинарные артефакты любому разработчику открытого программного обеспечения, однако 1 мая 2021 года сервисы будут остановлены, и все опубликованные артефакты перестанут быть доступными.&lt;/p&gt;
&lt;p&gt;Частью Bintray, также подпадающей под закрытие, является репозиторий JCenter, который стал популярной альтернативой &lt;a href="https://search.maven.org/"&gt;Maven Central&lt;/a&gt; благодаря более простому процессу публикации туда Maven-артефактов. Особенно популярен JCenter среди пользователей Gradle, поскольку документация и примеры Gradle &lt;a href="https://docs.gradle.org/current/samples/sample_gradle_plugin.html"&gt;рекомендуют&lt;/a&gt; использовать JCenter в качестве репозитория по умолчанию:&lt;/p&gt;
&lt;pre&gt;repositories {
    &lt;span style="color: darkgreen"&gt;// Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.&lt;/span&gt;
    jcenter()
}&lt;/pre&gt;
&lt;p&gt;Также JCenter &lt;a href="https://developer.android.com/studio/build/dependencies#remote-repositories"&gt;указывается&lt;/a&gt; по умолчанию в новых проектах Android Studio.&lt;/p&gt;
&lt;p&gt;Брайан Фокс, CTO компании Sonatype, которая обслуживает Maven Central, после выхода новости о закрытии Bintray &lt;a href="https://blog.sonatype.com/dear-bintray-and-jcenter-users-heres-what-you-need-to-know-about-the-central-repository"&gt;опубликовал пост&lt;/a&gt;, в котором призвал пользователей JCenter не беспокоиться и ответил на несколько частозадаваемых вопросов относительно перехода на Central.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышло сразу три новых черновика JEP:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261007"&gt;Frozen Arrays (Preview)&lt;/a&gt;. Здесь предлагается ввести в Java замороженные массивы, то есть массивы, которые нельзя изменять. Такие массивы могут сделать код более безопасным, а саму программу более эффективной благодаря лучшей оптимизации неизменяемых массивов виртуальной машиной. Сами массивы можно будет создавать либо с помощью методов-фабрик, либо путём замораживания существующего мутабельного массива (при этом возвращается новый массив).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261099"&gt;Internal Frozen Arrays&lt;/a&gt;. Этот JEP связан с предыдущим, и в нём описаны внутренние низкоуровневые методы JDK, которые смогут замораживать мутабельные массивы на месте (без копирования). Эти методы предоставят основу для реализации более высокоуровневых методов-фабрик.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8260865"&gt;Generational Shenandoah&lt;/a&gt;. В этом JEP'е предлагается добавить в сборщик мусора Shenandoah поколения. Это сможет &lt;a href="https://youtu.be/cJyzt9b6KrU?t=2345"&gt;повысить эффективность&lt;/a&gt; сборки мусора.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; JUG.ru &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b_bCEiqcpNwoB0xT6wlIofb"&gt;выложил видео&lt;/a&gt; с конференции Joker 2020.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/02/kotlin-1-4-30-released/"&gt;Kotlin 1.4.30&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains опубликовала &lt;a href="https://www.jetbrains.com/lp/annualreport-2020/"&gt;JetBrains 2020/21 Annual Highlights&lt;/a&gt;. На этой странице собраны все самые значительные события, которые произошли с компанией за предыдущий год, и опубликованы статистики роста популярности продуктов, количества пользователей и прочих показателей.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #5</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_5.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_5.html</id>
    <updated>2021-01-31T17:00:00Z</updated>
    <published>2021-01-31T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; На сайте OpenJDK опубликован черновик JEP &lt;a href="http://openjdk.java.net/jeps/8201533"&gt;&amp;laquo;Enhanced javadoc support for code samples (snippets)&amp;raquo;&lt;/a&gt;. В нём предлагается ввести в javadoc новый тег &lt;code&gt;@snippet&lt;/code&gt;, с помощью которого можно будет вставлять в документацию примеры кода и делать это лучше, чем это делается сейчас с использованием блоков &lt;code&gt;&amp;lt;pre&amp;gt;{@code ...}&amp;lt;/pre&amp;gt;&lt;/code&gt;. Новые сниппеты будут предоставлять механизм для лучшей проверки корректности кода, подсветки синтаксиса, улучшенной поддержки редактирования в IDE.&lt;/p&gt;
&lt;p&gt;Пример сниппета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**
 * The following code shows how to use Optional.isPresent:
 * {@snippet :
 *     &lt;/span&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (v.isPresent()) {
 &lt;span style="color: green"&gt;*&lt;/span&gt;         System.out.println(&lt;span style="color: darkred"&gt;"v: "&lt;/span&gt; + v.get());
 &lt;span style="color: green"&gt;*&lt;/span&gt;     }
 &lt;span style="color: green"&gt;* }
 */&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Сниппеты в javadoc будут поддерживать вложенные комментарии &lt;code&gt;&lt;span style="color: green"&gt;/* ... */&lt;/span&gt;&lt;/code&gt; (с помощью &amp;lt;pre&amp;gt; это сделать нельзя), ссылки на код из внешнего файла (&lt;code&gt;@snippet file="SomeFile.java"&lt;/code&gt;), обрезание ненужных пробельных символов в началах строк (как в &lt;a href="text_blocks.html"&gt;блоках текста&lt;/a&gt;), подсветку определённых участков сниппета и многие другие возможности.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел ещё один черновик JEP &lt;a href="http://openjdk.java.net/jeps/8260688"&gt;&amp;laquo;Improve regex performance&amp;raquo;&lt;/a&gt;. В этом JEP'е предлагается заменить движок регулярных выражений, который в Java работает довольно быстро, но не даёт гарантированной максимальной сложности алгоритма поиска. Это делает сервисы, написанные на Java, потенциально уязвимыми к DoS-атакам на основе регулярных выражений (&lt;a href="https://en.wikipedia.org/wiki/ReDoS"&gt;ReDoS&lt;/a&gt;). Особенно легко такие атаки могут быть организованы, если пользователь знает, какое именно регулярное выражение используется на сервере для валидации полей, и уж тем более, если сам может загружать своё регулярное выражение.&lt;/p&gt;
&lt;p&gt;Чтобы избежать этого, можно использовать движок регулярных выражений, основанный на детерминированных конечных автоматах (DFA), который даёт гарантированную сложность &lt;code&gt;O(N)&lt;/code&gt;, однако он поддерживает не все возможности регулярных выражений. В JEP'е предлагаются варианты решений такой проблемы, например, использовать разные алгоритмы в зависимости от указанного выражения или позволять пользователю указывать с помощью флага, какой именно алгоритм использовать. Пока что в JEP'е нет окончательного ответа относительно выбора подхода, и, видимо, он ещё будет сильно дорабатываться.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/01/intellij-idea-2021-1-eap-1/"&gt;IntelliJ IDEA 2021.1 EAP&lt;/a&gt; (Early Access Program). В этой версии среды появилась базовая поддержка Java 16, WSL 2 (Windows Subsytem for Linux 2), новая возможность Run Targets (выполнение программы в среде: Docker, SSH, WSL), улучшения в UI и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/jmc/8/"&gt;JDK Misson Control 8.0.0 EA&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ну и напоследок немного юмора. Известный программист, Java-чемпион Heinz Kabutz &lt;a href="https://twitter.com/heinzkabutz/status/1355137101545799682"&gt;выложил в Твиттере задачку&lt;/a&gt; со следующим вопросом:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Как, не меняя ни одного символа, сделать так, чтобы программа скомпилировалась:&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; InnerStaticMember {
  &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String... args) {
      System.out.println(&lt;span style="color: darkred"&gt;"Look Ma, no hands!"&lt;/span&gt;);
    }
  }
}&lt;/pre&gt;
&lt;p&gt;Среди ответов отметилось несколько правильных: нужно просто перейти на Java 16, потому что Java 16 &lt;a href="https://openjdk.java.net/jeps/395"&gt;разрешает статические члены во внутренних классах&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Однако самым смешным (но в то же время абсолютно корректным) оказался ответ, где написан конвейер Linux-команд, который берёт исходное изображение, обрезает её так, что из неё остаётся только кусок с классом &lt;code&gt;Inner&lt;/code&gt;, распознаёт из неё текст и компилирует.&lt;/p&gt;</content>
  </entry>
</feed>
