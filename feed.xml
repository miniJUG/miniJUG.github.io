<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2023-09-18T18:00:00Z</updated>
  <entry>
    <title>Вышла Java 21</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_21.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_21.html</id>
    <updated>2023-09-18T18:00:00Z</updated>
    <published>2023-09-18T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-21.html"&gt;2500 закрытых задач и 15 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/21/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/21/apidiff/20/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Java 21 является LTS-релизом, а значит у него будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;как минимум 5 лет&lt;/a&gt; с момента выхода.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 21 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/21/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 21.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/441"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (JEP 441)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; наконец-то был финализирован и стал стабильной конструкцией языка. Напомним, что он появился в &lt;a href="https://habr.com/ru/articles/577924/"&gt;Java 17&lt;/a&gt; и был в состоянии &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; четыре релиза: &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/433"&gt;20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый паттерн-матчинг существенно расширяет возможности оператора &lt;code&gt;switch&lt;/code&gt;. Начиная с Java 1.0, &lt;code&gt;switch&lt;/code&gt; поддерживал только сравнение с примитивными константами. Позже список типов был расширен (Java 5 &amp;ndash; перечисления, Java 7 &amp;ndash; строки), но в ветках &lt;code&gt;case&lt;/code&gt; всё ещё могли быть только константы.&lt;/p&gt;
&lt;p&gt;Теперь же &lt;code&gt;switch&lt;/code&gt; поддерживает в ветках &lt;code&gt;case&lt;/code&gt; так называемые &lt;i&gt;паттерны&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Паттерны могут снабжаться условиями с использованием нового ключевого слова &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &lt;span style="color: blue"&gt;when&lt;/span&gt; i &gt; 0 -&gt; String.format(&lt;span style="color: darkred"&gt;"positive int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Также добавлена поддержка матчинга &lt;code&gt;null&lt;/code&gt;. Сделать это можно с помощью явной отдельной ветки &lt;code&gt;case null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Если ветка &lt;code&gt;case null&lt;/code&gt; отсутствует, то &lt;code&gt;switch&lt;/code&gt; с переданным в него &lt;code&gt;null&lt;/code&gt; всегда будет выбрасывать &lt;code&gt;NullPointerException&lt;/code&gt; (даже если есть ветка &lt;code&gt;default&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// NullPointerException&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Ветки &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;default&lt;/code&gt; можно объединять друг с другом:&lt;/p&gt;
&lt;pre&gt;String str = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (str) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Foo or Bar"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null or other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Новый паттерн-матчинг обладает рядом ограничений.&lt;/p&gt;
&lt;p&gt;Во-первых, все &lt;code&gt;switch&lt;/code&gt; (кроме тех, что были корректными до Java 21) должны быть &lt;i&gt;исчерпывающими&lt;/i&gt;. Т.е. в ветках должны покрываться все возможные случаи:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// error: the switch statement does not cover all possible input values&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(s.length());
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; System.out.println(i);
};&lt;/pre&gt;
&lt;p&gt;Пример выше можно исправить, добавив ветку &lt;code&gt;Object o&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Во-вторых, все ветки &lt;code&gt;case&lt;/code&gt; должны располагаться в таком порядке, что ни перед одной веткой нет &lt;i&gt;доминирующей&lt;/i&gt; ветки:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; CharSequence cs -&gt;
        &lt;span style="color: darkred"&gt;"sequence of length "&lt;/span&gt; + cs.length();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// error: this case label is dominated by a preceding case label&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"string of length "&lt;/span&gt; + s.length();
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Так как &lt;code&gt;CharSequence&lt;/code&gt; это более широкий тип, чем &lt;code&gt;String&lt;/code&gt;, то его ветка должна быть расположена ниже.&lt;/p&gt;

&lt;p class="mt-2"&gt;В-третьих, несколько паттернов в одной ветке работать не будут:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s, Integer i -&gt; &lt;span style="color: darkred"&gt;"string or integer"&lt;/span&gt;; &lt;span style="color: red"&gt;// error: illegal fall-through from a pattern&lt;/span&gt;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Т.е. сделать тест по нескольким типам в одной ветке пока что нельзя (хотя грамматика языка это позволяет). Это можно обойти, только включив режим preview и заменив &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;i&lt;/code&gt; на символы подчёркивания (см. JEP про безымянные переменные ниже).&lt;/p&gt;

&lt;p class="mt-2"&gt;В целом новый паттерн-матчинг значительно увеличивает выразительность языка. Особенно хорошо он сочетается с записями. Паттерны записей мы рассмотрим отдельно, поскольку про них есть свой собственный JEP (см. следующий раздел).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/440"&gt;Record Patterns (JEP 440)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Отдельным видом паттернов являются &lt;i&gt;паттерны записей&lt;/i&gt;. Они появились в &lt;a href="https://openjdk.org/jeps/405"&gt;Java 19&lt;/a&gt; в режиме preview и стали стабильными в Java 21.&lt;/p&gt;
&lt;p&gt;Паттерны записей позволяют осуществлять деконструкцию значений записей чрезвычайно компактно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Или через оператор &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) -&gt; System.out.println(x + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Not a point"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Особая мощь паттернов записей состоит в том, что они могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}
&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Используя &lt;code&gt;var&lt;/code&gt;, можно сократить код ещё сильнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(&lt;span style="color: blue"&gt;var&lt;/span&gt; p, &lt;span style="color: blue"&gt;var&lt;/span&gt; c), &lt;span style="color: blue"&gt;var&lt;/span&gt; lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей отлично сочетаются с паттернами по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box(Object obj) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box box) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(String s) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"string: "&lt;/span&gt; + s);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(Object o) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other: "&lt;/span&gt; + o);
    }
}&lt;/pre&gt;

&lt;p&gt;Поддерживается вывод типов записей-дженериков:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;Box&amp;lt;String&gt;&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s))) { &lt;span style="color: green"&gt;// Infers Box&amp;lt;Box&amp;lt;String&gt;&gt;(Box&amp;lt;String&gt;(String s))&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;К сожалению, паттерны записей могут использоваться только в &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;switch&lt;/code&gt;, но не могут использоваться сами по себе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; usePoint(Point p) {
    Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) = p; &lt;span style="color: red"&gt;// Не сработает&lt;/span&gt;
    &lt;span style="color: green"&gt;// Use x and y&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Будем надеяться, что когда-нибудь добавят и такую возможность.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/430"&gt;String Templates (Preview) (JEP 430)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Строковые шаблоны &amp;ndash; новая синтаксическая возможность, позволяющая встраивать в строки выражения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = 10;
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = 20;
String str = STR.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
&lt;span style="color: green"&gt;// В str будет лежать "10 + 20 equals 30"&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, в Java появилась строковая интерполяция, которая уже давно есть во многих других известных языках программирования. Однако в Java она работает только в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt;, т.е. использовать в Java 21 её можно только с включенным флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html"&gt;&lt;code&gt;java.lang.StringTemplate&lt;/code&gt;&lt;/a&gt;, а затем &lt;i&gt;процессор&lt;/i&gt;, реализующий &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html"&gt;&lt;code&gt;java.lang.StringTemplate.Processor&lt;/code&gt;&lt;/a&gt;, конвертирует этот объект в строку (или объект другого класса). В примере выше &lt;code&gt;STR."…"&lt;/code&gt; есть ничто иное, как сокращённый вариант следующего кода:&lt;/p&gt;
&lt;pre&gt;StringTemplate template = RAW.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
String str = STR.process(template);&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#STR"&gt;&lt;code&gt;STR&lt;/code&gt;&lt;/a&gt; &amp;ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. &lt;code&gt;STR&lt;/code&gt; неявно импортируется в любой исходный файл, поэтому его можно использовать без &lt;code&gt;import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#RAW"&gt;&lt;code&gt;RAW&lt;/code&gt;&lt;/a&gt; &amp;ndash; это процессор, который ничего не делает со &lt;code&gt;StringTemplate&lt;/code&gt; и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.&lt;/p&gt;
&lt;p&gt;Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/FormatProcessor.html#FMT"&gt;&lt;code&gt;FMT&lt;/code&gt;&lt;/a&gt; поддерживает форматирование с использованием спецификаторов, определённых в &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;java.util.Formatter&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;double&lt;/span&gt; length = 46;
System.out.println(FMT.&lt;span style="color: darkred"&gt;"The length is %.2f&lt;/span&gt;\{length} &lt;span style="color: darkred"&gt;cm"&lt;/span&gt;);
&lt;span style="color: green"&gt;// The length is 46.00 cm&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Процессоры необязательно должны возвращать &lt;code&gt;String&lt;/code&gt;. Вот общая сигнатура метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"&gt;&lt;code&gt;process()&lt;/code&gt;&lt;/a&gt; интерфейса &lt;code&gt;Processor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public interface&lt;/span&gt; Processor&amp;lt;R, E &lt;span style="color: blue"&gt;extends&lt;/span&gt; Throwable&gt; {
    R process(StringTemplate stringTemplate) &lt;span style="color: blue"&gt;throws&lt;/span&gt; E;
}&lt;/pre&gt;
&lt;p&gt;Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор &lt;code&gt;JSON&lt;/code&gt; будет создавать напрямую объекты JSON (без промежуточного объекта &lt;code&gt;String&lt;/code&gt;) и при этом поддерживать экранирование кавычек:&lt;/p&gt;
&lt;pre&gt;JSONObject doc = JSON.&lt;span style="color: darkred"&gt;"""&lt;/span&gt;
    &lt;span style="color: darkred"&gt;{&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"name":    "&lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"phone":   "&lt;/span&gt;\{phone}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"address": "&lt;/span&gt;\{address}&lt;span style="color: darkred"&gt;"&lt;/span&gt;
    };
    &lt;span style="color: darkred"&gt;"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt; или &lt;code&gt;address&lt;/code&gt; будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит &lt;code&gt;&amp;quot;&lt;/code&gt; на &lt;code&gt;\&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Или, например, процессор &lt;code&gt;SQL&lt;/code&gt; будет создавать PreparedStatement'ы, защищая от атак SQL Injection:&lt;/p&gt;
&lt;pre&gt;PreparedStatement ps = SQL.&lt;span style="color: darkred"&gt;"SELECT * FROM Person p WHERE p.name = &lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/443"&gt;Unnamed Patterns and Variables (Preview) (JEP 443)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новшество в режиме preview: теперь можно объявлять так называемые безымянные переменные и паттерны. Делается это с помощью символа подчеркивания (&lt;code&gt;_&lt;/code&gt;). Это часто необходимо, когда переменная или паттерн не используются:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; acc = 0;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (Order _ : orders) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (acc &lt; LIMIT) {
        … acc++ …
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому, чтобы не придумывать этой переменной название, было использовано подчеркивание вместо имени.&lt;/p&gt;
&lt;p&gt;Довольно частый пример нужности безымянных переменных &amp;ndash; блок &lt;code&gt;catch&lt;/code&gt; с неиспользуемым исключением:&lt;/p&gt;
&lt;pre&gt;String s = …
try {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    …
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Полный список случаев, в которых можно использовать безымянные переменные:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Локальная переменная в блоке,&lt;/li&gt;
  &lt;li&gt;Объявление ресурса в &lt;code&gt;try-with-resources&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Заголовок &lt;code&gt;for&lt;/code&gt; statement,&lt;/li&gt;
  &lt;li&gt;Заголовок улучшенного цикла &lt;code&gt;for&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Исключение в блоке &lt;code&gt;catch&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Параметр лямбда-выражения,&lt;/li&gt;
  &lt;li&gt;Переменная паттерна (см. ниже).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Внимательный читатель заметит, что в списке выше отсутствуют параметры методов. Действительно, они не могут быть безымянными, и для любых методов (как интерфейсов, так и классов) по-прежнему всегда нужно указывать имена параметров.&lt;/p&gt;

&lt;p class="mt-2"&gt;Символы подчёркивания также можно использовать для указания &lt;i&gt;безымянных паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), _)) {
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Здесь разработчику понадобились только координаты точки, но не её цвет. Без безымянного паттерна ему пришлось бы объявлять неиспользуемую переменную типа &lt;code&gt;Color&lt;/code&gt; и придумывать ей имя:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color c)) { &lt;span style="color: orange"&gt;// Warning: unused c&lt;/span&gt;
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Такой код менее читабелен и хуже позволяет сфокусироваться на главном (координатах). Кроме того, некоторые IDE подсветили бы неиспользуемую переменную &lt;code&gt;c&lt;/code&gt;, что ещё одно дополнительное неудобство.&lt;/p&gt;
&lt;p&gt;Есть также возможность объявлять &lt;i&gt;безымянные переменные паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color _)) {
    …
}&lt;/pre&gt;
&lt;p&gt;Безымянные паттерны и переменные паттернов прекрасно сочетаются и со &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(RedBall _), Box(BlueBall _) -&gt; processBox(box);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(GreenBall _)                -&gt; stopProcessing();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(_)                          -&gt; pickAnotherBox();
}&lt;/pre&gt;
&lt;p&gt;В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;Unnamed Classes and Instance Main Methods (Preview) (JEP 445)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь в режиме preview можно запускать программы с методами &lt;code&gt;main()&lt;/code&gt;, которые не являются &lt;code&gt;public static&lt;/code&gt; и у которых нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае JVM сама создаст экземпляр класса (у него должен быть не-&lt;code&gt;private&lt;/code&gt; конструктор без параметров) и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Протокол запуска будет выбирать метод &lt;code&gt;main()&lt;/code&gt; согласно следующему приоритету:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;static void main()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p class="mt-2"&gt;Кроме того, можно писать программы и без объявления класса вовсе:&lt;/p&gt;
&lt;pre&gt;String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;p&gt;В таком случае будет создан неявный безымянный класс (не путать с анонимным классом), которому будут принадлежать метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Безымянный класс является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isSynthetic()"&gt;синтетическим&lt;/a&gt; и &lt;code&gt;final&lt;/code&gt;. Его &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getSimpleName()"&gt;simple name&lt;/a&gt; является пустой строкой:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(getClass().isUnnamed()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().isSynthetic()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().getSimpleName()); &lt;span style="color: green"&gt;// ""&lt;/span&gt;
    System.out.println(getClass().getCanonicalName()); &lt;span style="color: green"&gt;// null&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;При этом &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt; класса совпадает с именем файла, но такое поведение не гарантируется.
&lt;p class="mt-2"&gt;Такое упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
    &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;Virtual Threads (JEP 444)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые много лет разрабатывались в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt; и появились в &lt;a href="https://openjdk.org/jeps/425"&gt;Java 19&lt;/a&gt; в режиме preview, теперь наконец-то стали стабильными.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" (или "одна задача &amp;ndash; один поток") и не прибегать к более сложным асинхронному или реактивному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt; и практически полностью совместимы с классическими потоками: поддерживают стек-трейсы, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#interrupt()"&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; и т.д.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент выполняется виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и дешевизна виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоков и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Несмотря на привлекательность виртуальных потоков, вовсе необязательно предпочитать только их и всегда избегать классических потоков. Например, для задач, интенсивно и долго использующих CPU, лучше подойдут обычные потоки. Или если нужен поток, не являющийся &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)"&gt;демоном&lt;/a&gt;, то также придётся использовать обычный поток, потому что виртуальный поток всегда является демоном.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в инструментарии JDK (дебаггер, JVM TI, Java Flight Recorder).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/431"&gt;Sequenced Collections (JEP 431)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появились три новых интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"&gt;&lt;code&gt;SequencedCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"&gt;&lt;code&gt;SequencedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"&gt;&lt;code&gt;SequencedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; является наследником &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html"&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; и представляет собой коллекцию с установленным порядком элементов. Такими коллекциями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashSet.html"&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; и все реализации &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html"&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedSet.html"&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Deque.html"&gt;&lt;code&gt;Deque&lt;/code&gt;&lt;/a&gt;. У этих коллекций есть общее свойство последовательности элементов, но до Java 21 их общим родителем был &lt;code&gt;Collection&lt;/code&gt;, который является слишком общим интерфейсом и не содержит многих методов, характерных для последовательностей (&lt;code&gt;getFirst()&lt;/code&gt;, &lt;code&gt;getLast()&lt;/code&gt;, &lt;code&gt;addFirst()&lt;/code&gt;, &lt;code&gt;addLast()&lt;/code&gt;, &lt;code&gt;reversed()&lt;/code&gt; и т.д). При этом у самих вышеописанных коллекций такие методы были несогласованны друг с другом (например, &lt;code&gt;list.get(0)&lt;/code&gt; против &lt;code&gt;sortedSet.first()&lt;/code&gt; против &lt;code&gt;deque.getFirst()&lt;/code&gt;), либо вовсе отсутствовали (например, &lt;code&gt;linkedHashSet.getLast()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; закрыла эту дыру в иерархии и привела API к общему знаменателю:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedCollection&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Collection&amp;lt;E&gt; {
    E getFirst();
    E getLast();
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addFirst(E);
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addLast(E);
    E removeFirst();
    E removeLast();
    SequencedCollection&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Теперь больше не надо думать, как для конкретной коллекции получить последний элемент, потому что есть универсальный метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#getLast()"&gt;&lt;code&gt;getLast()&lt;/code&gt;&lt;/a&gt;, который есть и у &lt;code&gt;ArrayList&lt;/code&gt;, и у &lt;code&gt;TreeSet&lt;/code&gt;, и у &lt;code&gt;ArrayDeque&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Особый интерес представляет метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#reversed()"&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;, который возвращает view коллекции с обратным порядком. Это делает обратный обход коллекции гораздо более лаконичным:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; linkedList = new LinkedList&lt;&gt;(…);

&lt;span style="color: green"&gt;// До Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; it = linkedList.descendingIterator(); it.hasNext();) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; e = it.next();
    …
}

&lt;span style="color: green"&gt;// С Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; element : linkedList.reversed()) {
    …
}&lt;/pre&gt;
&lt;p&gt;Для &lt;code&gt;LinkedHashSet&lt;/code&gt; эффективного способа обратного обхода и вовсе не было.&lt;/p&gt;
&lt;p class="mt-2"&gt;Для последовательных множеств ввели интерфейс &lt;code&gt;SequencedSet&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedSet&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Set&amp;lt;E&gt;, SequencedCollection&amp;lt;E&gt; {
    SequencedSet&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;code&gt;LinkedHashSet&lt;/code&gt; и наследники &lt;code&gt;SortedSet&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Также ввели интерфейс &lt;code&gt;SequencedMap&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedMap&amp;lt;K,V&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Map&amp;lt;K,V&gt; {
    Entry&amp;lt;K, V&gt; firstEntry();
    Entry&amp;lt;K, V&gt; lastEntry();
    Entry&amp;lt;K, V&gt; pollFirstEntry();
    Entry&amp;lt;K, V&gt; pollLastEntry();
    V putFirst(K, V);
    V putLast(K, V);
    SequencedSet&amp;lt;K&gt; sequencedKeySet();
    SequencedCollection&amp;lt;V&gt; sequencedValues();
    SequencedSet&amp;lt;Entry&amp;lt;K,V&gt;&gt; sequencedEntrySet();
    SequencedMap&amp;lt;K,V&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashMap.html"&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; и наследники &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedMap.html"&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;Scoped Values (Preview) (JEP 446)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые появились в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt; в &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационном статусе&lt;/a&gt;, теперь стали Preview API.&lt;/p&gt;
&lt;p&gt;Новый класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда неприменим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/453"&gt;Structured Concurrency (Preview) (JEP 453)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно API, которое ранее было в инкубационном статусе (Java &lt;a href="https://openjdk.org/jeps/428"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;20&lt;/a&gt;), а теперь стало Preview API &amp;ndash; это Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
    &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
    &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
    &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/442"&gt;Foreign Function &amp; Memory API (Third Preview) (JEP 442)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напомним, что FFM API много лет разрабатывается в проекте &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; с целью заменить JNI. В &lt;a href="https://openjdk.org/jeps/454"&gt;Java 22&lt;/a&gt; API выйдет из состояния preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;Vector API (Sixth Incubator) (JEP 448)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в шестой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.&lt;/p&gt;
&lt;p&gt;Векторное API останется в инкубаторе, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не станут preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/452"&gt;Key Encapsulation Mechanism API (JEP 452)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В пакете &lt;code&gt;javax.crypto&lt;/code&gt; появилось новое API, реализующее &lt;a href="https://en.wikipedia.org/wiki/Key_encapsulation_mechanism"&gt;механизм инкапсуляции ключей&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Механизм инкапсуляции ключей (KEM) &amp;ndash; это современная криптографическая техника, позволяющая обмениваться симметричными ключами, используя асимметричное шифрование. Если в традиционной технике симметричный ключ генерируется случайным образом и шифруется с помощью открытого ключа (что требует паддинга), то в KEM симметричный ключ выводится из самого открытого ключа.&lt;/p&gt;
&lt;p&gt;В Java KEM API состоит из трёх главных классов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html"&gt;&lt;code&gt;KEM&lt;/code&gt;&lt;/a&gt; &amp;ndash; входная точка API. У него есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html#getInstance(java.lang.String)"&gt;&lt;code&gt;getInstance()&lt;/code&gt;&lt;/a&gt;, возвращающий объект &lt;code&gt;KEM&lt;/code&gt; для указанного алгоритма.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html"&gt;&lt;code&gt;Encapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; представляет собой функцию инкапсуляции, которая вызывается отправителем. У этого класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html#encapsulate()"&gt;&lt;code&gt;encapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает открытый ключ и возвращает секретный ключ, а также key encapsulation message (которое шлётся принимающей стороне).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html"&gt;&lt;code&gt;Decapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; функция декапсуляции, которая вызывается принимающей стороной. У класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html#decapsulate(byte%5B%5D)"&gt;&lt;code&gt;decapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает key encapsulation message и возвращает секретный ключ. Таким образом, у обеих сторон теперь есть одинаковый симметричный ключ, с помощью которого можно дальше обмениваться данными с помощью обычного симметричного шифрования.&lt;/p&gt;
&lt;p&gt;Пример генерации симметричного ключа и его передачи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kpg = KeyPairGenerator.getInstance(&lt;span style="color: darkred"&gt;"X25519"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; kp = kpg.generateKeyPair();

&lt;span style="color: green"&gt;// Sender side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem1 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; sender = kem1.newEncapsulator(kp.getPublic());
&lt;span style="color: blue"&gt;var&lt;/span&gt; encapsulated = sender.encapsulate();
&lt;span style="color: blue"&gt;var&lt;/span&gt; k1 = encapsulated.key();

&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem2 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; receiver = kem2.newDecapsulator(kp.getPrivate());
&lt;span style="color: blue"&gt;var&lt;/span&gt; k2 = receiver.decapsulate(encapsulated.encapsulation());

&lt;span style="color: blue"&gt;assert&lt;/span&gt; Arrays.equals(k1.getEncoded(), k2.getEncoded());&lt;/pre&gt;

&lt;p class="mt-2"&gt;Для KEM также добавлен интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEMSpi.html"&gt;&lt;code&gt;KEMSpi&lt;/code&gt;&lt;/a&gt;, позволяющий предоставлять пользовательские реализации алгоритмов KEM.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/439"&gt;Generational ZGC (JEP 439)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В сборщик мусора ZGC, который появился в &lt;a href="https://openjdk.org/jeps/377"&gt;Java 15&lt;/a&gt;, добавили поддержку поколений. Поколения в ZGC пока что отключены по умолчанию, и для их включения требуется ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;java -XX:+UseZGC -XX:+ZGenerational ...&lt;/pre&gt;
&lt;p&gt;В будущих версиях Java режим работы с поколениями будет по умолчанию, и ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt; уже требоваться не будет.&lt;/p&gt;
&lt;p&gt;Поколения в ZGC должны улучшить производительность Java-программ, т.к. молодые объекты, которые склонны умирать рано согласно слабой гипотезе о поколениях, будут собираться чаще, а старые объекты &amp;ndash; более редко. При этом характеристики ZGC не должны от этого пострадать: время отклика по-прежнему должно быть сверхнизким (&lt; 1ms) и кучи гигантских размеров (несколько терабайт) должны продолжать поддерживаться.&lt;/p&gt;
&lt;p&gt;Напомним, что также &lt;a href="https://openjdk.org/jeps/404"&gt;ведётся работа&lt;/a&gt; над поддержкой поколений в другом сборщике мусора &lt;a href="https://openjdk.org/jeps/379"&gt;Shenandoah&lt;/a&gt;, похожем по характеристикам на ZGC. Однако в Java 21 Generational Shenandoah попасть не успел.&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в &lt;a href="https://openjdk.org/jeps/248"&gt;Java 9&lt;/a&gt; (до него дефолтным был Parallel GC)&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/451"&gt;Prepare to Disallow the Dynamic Loading of Agents (JEP 451)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;При динамической загрузке агентов теперь выдаётся предупреждение:&lt;/p&gt;
&lt;pre&gt;WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release&lt;/pre&gt;
&lt;p&gt;Агент &amp;ndash; это компонент, который может изменять (инструментировать) код Java-приложения во время работы. Поддержка агентов появилась в Java 5, чтобы была возможность писать продвинутые инструменты вроде профилировщиков, которым необходимо добавлять эмиссию событий в классы, или AOP-библиотек. Для включения агентов требовались опции командной строки &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;, поэтому все агенты тогда могли включаться только явно при старте приложения.&lt;/p&gt;
&lt;p&gt;Однако в Java 6 появился &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html"&gt;Attach API&lt;/a&gt;, который, кроме всего прочего, позволил загружать агенты динамически прямо в работающий JVM. Благодаря этому библиотеки получили возможность подключаться к приложению и по-тихому изменять классы, не имея на то согласия от владельца приложения. Причём изменяться могут не только классы приложения, но и классы JDK. Таким образом, подвергается риску строгая инкапсуляция, которая является одним из краеугольных камней Java.&lt;/p&gt;
&lt;p&gt;Чтобы закрыть такую потенциально опасную дыру, в Java 9 вместе с появлением модулей было предложено запретить динамическую загрузку агентов по умолчанию. Однако тогда было решено отложить на неопределённое время такое радикальное решение, чтобы дать авторам инструментов время подготовиться. В итоге, изменение дожило до наших дней, и было реализовано лишь в Java 21, но в &lt;i&gt;виде предупреждения&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;Чтобы подавить предупреждение, необходимо запускать JVM с опцией &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;, либо загружать агенты при старте JVM, явно перечисляя их с помощью опций &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В будущих версиях Java планируется полностью отключить динамическую загрузку по умолчанию, и она уже не будет работать без &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;Deprecate the Windows 32-bit x86 Port for Removal (JEP 449)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;32-битный порт OpenJDK под Windows стал deprecated for removal. В будущем планируется избавиться от него полностью.&lt;/p&gt;
&lt;p&gt;Удаление порта позволит ускорить разработку платформы. Также причиной стало отсутствие нативной реализации виртуальных потоков на 32-битной версии JDK 21 под Windows: виртуальные потоки в этой версии реализованы через платформенные потоки.&lt;/p&gt;

&lt;p class="mt-4"&gt;Полный список JEP'ов, попавших в JDK 21, начиная с JDK 17: &lt;a href="https://openjdk.org/projects/jdk/21/jeps-since-jdk-17"&gt;ссылка&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #57</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_57.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_57.html</id>
    <updated>2023-04-23T18:00:00Z</updated>
    <published>2023-04-23T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/20-0-1-relnotes.html"&gt;JDK 20.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-7-relnotes.html"&gt;JDK 17.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-19-relnotes.html"&gt;JDK 11.0.19&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;JDK 8u372&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышло несколько новых JEP'ов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;JEP 444: Virtual Threads&lt;/a&gt;. Виртуальные потоки уже интегрированы в &lt;a href="https://jdk.java.net/21/"&gt;ранние сборки JDK 21&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;JEP 445: Flexible Main Methods and Anonymous Main Classes (Preview)&lt;/a&gt;. Про него мы подробно писали в &lt;a href="java_news_54.html"&gt;выпуске #54&lt;/a&gt;, когда он был черновиком и имел другое название (Implicit Classes and Enhanced Main Methods).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;JEP 446: Scoped Values (Preview)&lt;/a&gt;. Scoped Values переходят из инкубационного статуса &lt;a href="https://openjdk.org/jeps/429"&gt;в Java 20&lt;/a&gt; в статус Preview в Java 21.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/447"&gt;JEP 447: Statements before &lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;. Про этот JEP мы писали в &lt;a href="java_news_53.html"&gt;выпуске #53&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;JEP 448: Vector API (Sixth Incubator)&lt;/a&gt;. Таким образом, векторное API остаётся в инкубационном статусе уже в шестой раз.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;JEP 449: Deprecate the Windows 32-bit x86 Port for Removal&lt;/a&gt;. Про причины удаления 32-битного порта JDK на Windows мы писали в &lt;a href="java_news_55.html"&gt;выпуске #55&lt;/a&gt;. 32-битные версии JDK под Linux остаются нетронутыми.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2023/03/intellij-idea-2023-1/"&gt;IntelliJ IDEA 2023.1&lt;/a&gt;. Перечислим некоторые улучшения и нововведения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Изменение масштаба всей IDE (View &gt; Appearance &gt; Zoom IDE).&lt;/li&gt;
  &lt;li&gt;Появился компактный режим (только для нового UI).&lt;/li&gt;
  &lt;li&gt;Вкладки проектов на macOS.&lt;/li&gt;
  &lt;li&gt;Ускоренный доступ к функциональности IDE при открытии проекта (функции IDE становятся доступными гораздо раньше).&lt;/li&gt;
  &lt;li&gt;Ускоренный импорт Maven-проектов.&lt;/li&gt;
  &lt;li&gt;Фоновые проверки коммитов (чтобы ускорить выполнение коммитов).&lt;/li&gt;
  &lt;li&gt;Возможность сохранять варианты расположения окон (Window &gt; Layouts).&lt;/li&gt;
  &lt;li&gt;Отображение знаков пробела только в выделенном коде.&lt;/li&gt;
  &lt;li&gt;Поддержка Java 20.&lt;/li&gt;
  &lt;li&gt;Улучшенный рефакторинг Extract Method, поддерживающий ситуацию, когда фрагмент кода содержит несколько переменных, которые необходимо вернуть.&lt;/li&gt;
  &lt;li&gt;Автодополнение опций VM в Run/Debug Configurations.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #56</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_56.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_56.html</id>
    <updated>2023-03-26T18:00:00Z</updated>
    <published>2023-03-26T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8303683"&gt;JEP: Virtual Threads&lt;/a&gt;. В нём предлагается финализировать виртуальные потоки в Java 21, то есть они больше не будут Preview API. Единственным изменением относительно Java 20 будет поддержка &lt;code&gt;ThreadLocal&lt;/code&gt; переменных в виртуальных потоках. Это гарантирует, что многие существующие библиотеки, использующие &lt;code&gt;ThreadLocal&lt;/code&gt;, продолжат корректно работать при переходе на виртуальные потоки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/443"&gt;JEP 443: Unnamed Patterns and Variables (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_46.html"&gt;выпуске #46&lt;/a&gt;, когда вышел его черновик. С тех пор принципиальных изменений в JEP внесено не было.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/442"&gt;JEP 442: Foreign Function &amp; Memory API (Third Preview)&lt;/a&gt;. Таким образом, в Java 21 API остаётся в статусе Preview в третий раз.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8304400"&gt;JEP: Launch Multi-File Source-Code Programs&lt;/a&gt;. В нём предлагается добавить поддержку запуска программ, состоящих из нескольких исходных файлов &lt;code&gt;.java&lt;/code&gt;. Напомним, что сейчас Java поддерживает запуск только одного исходного файла (возможность, которая появилась &lt;a href="https://openjdk.org/jeps/330"&gt;в Java 11&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Предполагается, что запуск нескольких файлов будет работать следующим образом:&lt;/p&gt;
&lt;ul style="list-style-type: none"&gt;
  &lt;li&gt;&amp;bull; В аргумент командной строки по-прежнему передаётся название одного java-файла, например: &lt;code&gt;java Prog.java&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс ссылается на другие классы, то лаунчер пытается найти эти классы в файловой системе. Предполагается, что каждый класс находится в файле с именем, соответствующем имени класса.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Файлы, на которые никто не ссылается, не компилируются. Это может быть удобно для разработки (например, в них можно оставлять синтаксические ошибки).&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс используется через рефлексию, то файл ищется и компилируется уже во время работы программы.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование пакетов поддерживается. В таком случае файлы должны лежать в соответствующих директориях.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование библиотек также поддерживается. Тогда нужно добавить аргумент &lt;code&gt;-cp&lt;/code&gt;, например: &lt;code&gt;java -cp '*' Prog.java&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://openjdk.org/jeps/401"&gt;JEP 401: Primitive Classes (Preview)&lt;/a&gt; был значительно &lt;a href="https://mail.openjdk.org/pipermail/valhalla-spec-experts/2023-March/002238.html"&gt;переработан и переименован&lt;/a&gt; в Null-Restricted Value Object Storage. В новой версии JEP предлагается ввести так называемые опциональные конструкторы и null-restricted типы.&lt;/p&gt;
&lt;p&gt;Смысл опциональных конструкторов заключается в том, что если в &lt;a href="https://openjdk.org/jeps/8277163"&gt;value-классе&lt;/a&gt; объявлен такой конструктор, то такой класс обязан поддерживать значение по умолчанию, то есть значение, в котором все поля являются нулями. Это значит, что объекты такого класса могут быть проинициализированы в обход конструктора, а значит потенциально нарушать инварианты класса. В результате класс становится менее безопасным, но зато даёт виртуальной машине больше возможностей для более компактного хранения его значений: value-классы с опциональными конструкторами могут иметь лучший flattening, чем просто value-классы.&lt;/p&gt;
&lt;p&gt;JEP также предлагает ввести переменные, которым не может быть присвоен &lt;code&gt;null&lt;/code&gt;. Причём это нововведение будет распространяться на все классы, в том числе и ссылочные. Поскольку null-restricted типы не связаны напрямую с value-классами, то они будут подробно описаны &lt;a href="https://openjdk.java.net/jeps/8303099"&gt;в отдельном JEP'е&lt;/a&gt; (на данный момент ссылка выдаёт 404, т.к. JEP ещё не стал общедоступным). Однако в контексте этого JEP'а они упомянуты, чтобы показать, что они играют важную роль, когда сочетаются с value-классами с опциональными конструкторами: их значения смогут встраиваться в другие объекты и массивы, что и было основной целью проекта Valhalla.&lt;/p&gt;
&lt;p&gt;Также важным изменением в JEP'е стал отказ от нотации &lt;code&gt;X.ref&lt;/code&gt; и &lt;code&gt;X.val&lt;/code&gt;. Вместо них будет восклицательный знак для обозначения null-restricted типов (&lt;code&gt;X!&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=JgMLyGBEQ1c"&gt;Eclipse 2023-03&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/javafx20/"&gt;JavaFX 20&lt;/a&gt;. С этой версии фреймворк требует Java 17 в качестве минимальной версии Java.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/03/java-annotated-monthly-march-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за март.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/surefire/maven-surefire-plugin/history.html"&gt;maven-surefire-plugin 3.0.0&lt;/a&gt;. Это первое обновление плагина Maven для запуска тестов спустя почти 4 года.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 20</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_20.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_20.html</id>
    <updated>2023-03-20T18:00:00Z</updated>
    <published>2023-03-20T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;Java 20&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-20.html"&gt;1500 закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/20/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/20/apidiff/19/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/20/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 20.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;Паттерны записей (Second Preview) (JEP 432)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В паттерны записей, которые появились &lt;a href="https://openjdk.org/jeps/405"&gt;в Java 19&lt;/a&gt; в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; (и остающиеся в этом статусе в Java 20), было внесено три главные изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, добавилась поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей теперь могут присутствовать в заголовке улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; dump(Point[] pointArray) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) : pointArray) {
        System.out.println(&lt;span style="color: darkred"&gt;"("&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + y + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Примечание: эту возможность было решено удалить &lt;a href="https://openjdk.org/jeps/440"&gt;в Java 21&lt;/a&gt;, но она снова может появиться в будущем в другом JEP'е.&lt;/p&gt;

&lt;p class="pt-1"&gt;В-третьих, исчезла поддержка именованных паттернов записей. Это значит, что такой код, который компилировался в Java 19, в Java 20 уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) { &lt;span style="color: red"&gt;// Syntax error&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p&gt;Хотя именованные паттерны и исчезли в этом релизе, это не значит, что они исчезли насовсем. Возможно они появятся в одном из будущих релизов, когда будут более тщательно продуманы.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Fourth Preview) (JEP 433)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Это уже четвёртая итерация preview паттерн-матчинга в Java. Напомним, что предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;. В новой версии три главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, исчерпывающий &lt;code&gt;switch&lt;/code&gt; по перечислениям теперь выбрасывает &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/MatchException.html"&gt;&lt;code&gt;MatchException&lt;/code&gt;&lt;/a&gt;, а не &lt;code&gt;IncompatibleClassChangeError&lt;/code&gt;, если ни одна из меток &lt;code&gt;switch&lt;/code&gt; не сматчилась.&lt;/p&gt;

&lt;p&gt;Во-вторых, упростилась грамматика меток &lt;code&gt;switch&lt;/code&gt; в JLS.&lt;/p&gt;

&lt;p&gt;В-третьих, добавилась поддержка вывода типов в записях-дженериках, если они являются паттернами в &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;S, T&gt;(S first, T second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; recordInference(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; fst, &lt;span style="color: blue"&gt;var&lt;/span&gt; snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Как видите, здесь JEP 433 полностью согласуется с JEP 432.&lt;/p&gt;

&lt;p&gt;Паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; предлагается финализировать в Java 21 (&lt;a href="https://openjdk.org/jeps/440"&gt;JEP 440&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/441"&gt;JEP 441&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;Virtual Threads (Second Preview) (JEP 436)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые появились &lt;a href="https://openjdk.org/jeps/425"&gt;в Java 19&lt;/a&gt;, продолжают оставаться в статусе Preview API (предлагается финализировать их &lt;a href="https://openjdk.org/jeps/8303683"&gt;в Java 21&lt;/a&gt;). Изменений API, связанных с проектом &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;, в этом релизе нет (если не считать scoped values и structured concurrency, которые имеют &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационный статус&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;Scoped Values (Incubator) (JEP 429)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt;, который позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо больше количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;code&gt;where()&lt;/code&gt;. Далее вызывается метод &lt;code&gt;run()&lt;/code&gt;, на протяжении которого это значение можно получить (через метод &lt;code&gt;get()&lt;/code&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потоком не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;/p&gt;&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static final&lt;/span&gt; ScopedValue&amp;lt;Credentials&amp;gt; CREDENTIALS = new ScopedValue&lt;&gt;();

Credentials creds = ...
ScopedValue.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ScopedValue&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;
&lt;p&gt;На период инкубации новое API будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В Java 21 scoped values, скорее всего, &lt;a href="https://openjdk.org/jeps/8304357"&gt;станут preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;Structured Concurrency (Second Incubator) (JEP 437)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured concurrency, которое появилось &lt;a href="https://openjdk.org/jeps/428"&gt;в Java 19&lt;/a&gt;, остаётся в инкубационном статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; (вместе со &lt;code&gt;ScopedValue&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Единственное отличие от предыдущей версии API &amp;ndash; это то, что &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;StructuredTaskScope&lt;/a&gt; теперь поддерживает наследование scoped values потоками, созданными внутри области видимости задачи.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;Foreign Function &amp; Memory API (Second Preview) (JEP 434)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Основные изменения в этом релизе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemoryAddress&lt;/code&gt;. Теперь адреса моделируются через &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt; с нулевой длиной.&lt;/li&gt;
  &lt;li&gt;Улучшена иерархия &lt;code&gt;sealed&lt;/code&gt; интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;, чтобы лучше соответствовать паттерн-матчингу для &lt;code&gt;switch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemorySession&lt;/code&gt;. Он разделён на два интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/SegmentScope.html"&gt;&lt;code&gt;SegmentScope&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В Java 21 Foreign Function &amp; Memory API останется на &lt;a href="https://openjdk.org/jeps/442"&gt;третье preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/438"&gt;Vector API (Fifth Incubator) (JEP 438)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API всё никак не хочет становиться стабильным и остаётся в инкубационном статусе уже в пятый раз (модуль &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;). В этом релизе лишь небольшие исправления багов и улучшения производительности. Скорее всего, инкубационный статус будет оставаться до тех пор, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не появятся в режиме preview (проект &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; сильно зависит от проекта Valhalla).&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 20 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до сентября 2023 года). LTS-релизом станет следующая версия, &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #55</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_55.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_55.html</id>
    <updated>2023-03-05T18:00:00Z</updated>
    <published>2023-03-05T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а были предложены к попаданию в Java 21. Это &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;. Java 21 &amp;ndash; это &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;следующий LTS-релиз&lt;/a&gt; после Java 17, который должен выйти в сентябре 2023 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/438"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;, который сразу же &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-March/007404.html"&gt;был предложен&lt;/a&gt; к попаданию в Java 20. JEP появился с большим опозданием перед самым релизом из-за &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-February/007389.html"&gt;недопонимания&lt;/a&gt; со стороны владельца JEP'а. Сейчас эта ошибка была исправлена. Напомним, что общедоступная версия Java 20 выходит уже &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;через две недели&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло несколько новых черновиков JEP.&lt;/p&gt;
&lt;p&gt;Самые главные &amp;ndash; это &lt;a href="https://openjdk.org/jeps/8300541"&gt;Record Patterns&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8300542"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;. В них предлагается сделать паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; постоянными языковыми конструкциями. Напомним, что в Java 20 они будут всё ещё в статусе preview (&lt;a href="https://openjdk.java.net/jeps/432"&gt;JEP 432&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/433"&gt;JEP 433&lt;/a&gt;). Таким образом, в следующем LTS-релизе Java 21 планируется их &lt;a href="https://mail.openjdk.org/pipermail/amber-dev/2023-February/007841.html"&gt;финализировать&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В финальные версии конструкций предлагается внести следующие небольшие изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Паттерны, заключённые в скобки, поддерживаться не будут.&lt;/li&gt;
  &lt;li&gt;В &lt;code&gt;case&lt;/code&gt;-ветках будут разрешены квалифицированные константы перечислений (при условии, что эти константы совместимы по присваиванию с целевым типом).&lt;/li&gt;
  &lt;li&gt;Паттерны записей в заголовках цикла &lt;code&gt;for&lt;/code&gt; поддерживаться не будут. Однако они снова появятся в отдельном JEP'е.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Следующий черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303167"&gt;Deprecate the Windows x86-32 Port&lt;/a&gt;. Пометить как deprecated 32-битный порт JDK предлагается ради ускорения разработки платформы. Одной из мотиваций также является отсутствие нативной реализации &lt;a href="https://openjdk.org/jeps/436"&gt;виртуальных потоков&lt;/a&gt; на 32-битной Windows JDK. Также Windows 10 (последняя версия Windows, поддерживающая 32 бит) достигнет своей End of Life в &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;октябре 2025 года&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Ещё один черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303358"&gt;Scoped Values (Preview)&lt;/a&gt;. Таким образом, Scoped Values в Java 21 могут выйти из &lt;a href="https://openjdk.org/jeps/429"&gt;инкубационного статуса&lt;/a&gt; и стать preview. Про Scoped Values мы писали в &lt;a href="java_news_44.html"&gt;выпуске #44&lt;/a&gt;, когда они ещё назывались Extent-Local Variables.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Сайт поиска артефактов в Maven Central &lt;a href="https://search.maven.org"&gt;https://search.maven.org&lt;/a&gt; теперь стал перенаправлять на &lt;a href="https://central.sonatype.com"&gt;https://central.sonatype.com&lt;/a&gt;. На сайте Sonatype &lt;a href="https://central.sonatype.org/faq/what-happened-to-search-maven-org/"&gt;это объясняется&lt;/a&gt; тем, что central.sonatype.com уже покрывает главную функциональность search.maven.org, а также предоставляет больше деталей о компонентах, например, рейтинг безопасности. Кроме того, индекс поиска там обновляется гораздо чаще, чем на search.maven.org, а значит там более свежая и надёжная информация.&lt;/p&gt;
&lt;p&gt;Вернуться к старому сайту пока всё ещё можно, если нажать по &lt;a href="https://search.maven.org/?eh"&gt;соответствующей ссылке&lt;/a&gt; во всплывающем сообщении. Полное закрытие старого сайта планируется в конце 2023 - начале 2024 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blogs.apache.org/netbeans/#announce-apache-netbeans-17-released"&gt;Apache NetBeans 17&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jol-dev/2023-February/000509.html"&gt;JOL 0.17&lt;/a&gt;. Из основных изменений: минимальная версия Java теперь 8, добавлена поддержка Lilliput.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #54</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_54.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_54.html</id>
    <updated>2023-02-19T18:00:00Z</updated>
    <published>2023-02-19T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8302326"&gt;Implicit Classes and Enhanced Main Methods (Preview)&lt;/a&gt;. В нём предлагается сделать протокол запуска программ на Java более гибким, дав возможность программисту (в особенности новичку) опускать ненужные конструкции при написании простых программ, что поможет упростить вхождение в язык.&lt;/p&gt;
&lt;p&gt;Во-первых, модификатор &lt;code&gt;public&lt;/code&gt; и параметр &lt;code&gt;String[] args&lt;/code&gt; для метода &lt;code&gt;main()&lt;/code&gt; будут опциональными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, метод &lt;code&gt;main()&lt;/code&gt; не будет обязан быть статическим. Тогда JVM сама инстанцирует класс (для этого у него должен иметься не-private конструктор без аргументов) и вызовет метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, само объявление класса будет опциональным. В таком случае JVM сама создаст экземпляр безымянного неявного класса и вызовет &lt;code&gt;main()&lt;/code&gt; на нём:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Эти три упрощения помогут новичкам сфокусировать своё изучение языка на простых концепциях вроде объявлений переменных и циклов, а затем постепенно переходить к более сложным (классам, модификаторам доступа и статическим методам).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один черновик JEP: &lt;a href="https://openjdk.org/jeps/8299906"&gt;Support Markdown in Documentation Comments&lt;/a&gt;. В этом JEP'е предлагается добавить возможность писать JavaDoc на языке &lt;a href="https://commonmark.org/"&gt;Markdown&lt;/a&gt; вместо HTML. Markdown на сегодняшний день является очень популярным форматом написания документации, отличительной особенностью которого является простота синтаксиса и лёгкость чтения. Markdown трансформируется в HTML, но достаточно легко читаем и в сыром виде.&lt;/p&gt;
&lt;p&gt;Пример возможной документации на Markdown для &lt;code&gt;Object.hashCode()&lt;/code&gt; с использованием Markdown:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**md&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;Returns a hash code value for the object. This method is
&lt;span style="color: green"&gt; * &lt;/span&gt;supported for the benefit of hash tables such as those provided by
&lt;span style="color: green"&gt; * &lt;/span&gt;{&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; java.util.HashMap}.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;The general contract of &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; is:
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;-   Whenever it is invoked on the same object more than once during
&lt;span style="color: green"&gt; * &lt;/span&gt;    an execution of a Java application, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method
&lt;span style="color: green"&gt; * &lt;/span&gt;    must consistently return the same integer, provided no information
&lt;span style="color: green"&gt; * &lt;/span&gt;    used in &lt;span style="color: darkgreen"&gt;`equals`&lt;/span&gt; comparisons on the object is modified.
&lt;span style="color: green"&gt; * &lt;/span&gt;    This integer need not remain consistent from one execution of an
&lt;span style="color: green"&gt; * &lt;/span&gt;    application to another execution of the same application.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   If two objects are equal according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;    #equals(Object) equals} method, then calling the
&lt;span style="color: green"&gt; * &lt;/span&gt;    &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects must produce the
&lt;span style="color: green"&gt; * &lt;/span&gt;    same integer result.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   It is _not_ required that if two objects are unequal
&lt;span style="color: green"&gt; * &lt;/span&gt;    according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; #equals(Object) equals} method, then
&lt;span style="color: green"&gt; * &lt;/span&gt;    calling the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects
&lt;span style="color: green"&gt; * &lt;/span&gt;    must produce distinct integer results.  However, the programmer
&lt;span style="color: green"&gt; * &lt;/span&gt;    should be aware that producing distinct integer results for
&lt;span style="color: green"&gt; * &lt;/span&gt;    unequal objects may improve the performance of hash tables.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@implSpec&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;As far as is reasonably practical, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method defined
&lt;span style="color: green"&gt; * &lt;/span&gt;by class &lt;span style="color: darkgreen"&gt;`Object`&lt;/span&gt; returns distinct integers for distinct objects.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@return&lt;/b&gt;&lt;/span&gt;  a hash code value for this object.
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.Object#equals(java.lang.Object)
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.System#identityHashCode
&lt;span style="color: green"&gt; */&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.9.0/release-notes.html"&gt;Apache Maven 3.9.0&lt;/a&gt;. Самые заметные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Минимальная версия Java теперь 8. Это первое увеличение минимальной версии Java спустя 8 лет. В прошлый раз это был Maven &lt;a href="https://maven.apache.org/docs/3.3.1/release-notes.html"&gt;3.3.1&lt;/a&gt;, где минимальной версией стала Java 7.&lt;/li&gt;
  &lt;li&gt;Обратная совместимость с Maven 2.x окончательно убрана.&lt;/li&gt;
  &lt;li&gt;Теперь выдаются &lt;a href="https://issues.apache.org/jira/browse/MNG-7457"&gt;предупреждения&lt;/a&gt; об использовании deprecated плагинов, целей, параметров и т.д.&lt;/li&gt;
  &lt;li&gt;В консоли теперь пишутся префиксы плагинов вместо их &lt;code&gt;artifactId&lt;/code&gt; (например, &lt;code&gt;compiler:3.10.1:compile&lt;/code&gt; вместо &lt;code&gt;maven-compiler-plugin:3.10.1:compile&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Теперь можно вызывать цели через &lt;a href="https://issues.apache.org/jira/browse/MNG-7353"&gt;&lt;code&gt;mvn pluginPrefix:version:goal&lt;/code&gt;&lt;/a&gt;. Раньше это можно было делать либо через &lt;code&gt;mvn:pluginPrefix:goal&lt;/code&gt;, либо через &lt;code&gt;groupId:artifactId[:version]:goal&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Стала возможной активация профиля по типу &lt;code&gt;packaging&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список изменений и нововведений &lt;a href="https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316922&amp;version=12350913"&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/8.0/release-notes.html"&gt;Gradle 8.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел JetBrains &lt;a href="https://blog.jetbrains.com/idea/2023/02/java-annotated-monthly-february-2023/"&gt;Java Annotated Monthly за февраль&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #53</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_53.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_53.html</id>
    <updated>2023-01-29T18:00:00Z</updated>
    <published>2023-01-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-2-relnotes.html"&gt;JDK 19.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-6-relnotes.html"&gt;JDK 17.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020011.html"&gt;JDK 13.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020012.html"&gt;JDK 15.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-18-relnotes.html"&gt;JDK 11.0.18&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2023-January/016479.html"&gt;JDK 8u362&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8300786"&gt;No longer require &lt;code&gt;super()&lt;/code&gt; and &lt;code&gt;this()&lt;/code&gt; to appear first in a constructor&lt;/a&gt;. В нём предлагается разрешить писать инструкции кода до вызова &lt;code&gt;super()&lt;/code&gt; и &lt;code&gt;this()&lt;/code&gt; в конструкторах.&lt;/p&gt;
&lt;p&gt;Напомним, что сейчас эти вызовы всегда должны быть первыми вызовами в конструкторах, иначе код не скомпилируется:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (value &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value); &lt;span style="color: red"&gt;// error: call to super must be first statement in constructor&lt;/span&gt;
    }
}&lt;/pre&gt;
&lt;p&gt;Такое ограничение иногда создаёт неудобства, например, при необходимости проверять входные аргументы до вызова суперконструктора (как в примере выше), при передаче одного и того же вычисляемого параметра в суперконструктор несколько раз или при нетривиальной подготовке параметра перед передачей его в суперконструктор.&lt;/p&gt;
&lt;p&gt;JEP предлагает это ограничение снять и позволить писать инструкции до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;. Однако для кода до вызова остаётся ограничение, что он должен быть в статическом контексте, то есть не должен ссылаться на текущий объект явно или неявно (использовать &lt;code&gt;this&lt;/code&gt;, вызывать нестатические методы и так далее).&lt;/p&gt;
&lt;p&gt;Любопытно, что в спецификации JVM подобного ограничения нет, и она разрешает произвольный код до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;, если он не ссылается на конструируемый объект. Таким образом, предлагаемое изменение будет чисто языковым изменением, без необходимости менять что-то в виртуальной машине.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Черновик JEP "Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns", о котором мы писали в &lt;a href="java_news_49.html"&gt;выпуске #49&lt;/a&gt;, был переименован в &lt;a href="https://openjdk.org/jeps/8288476"&gt;"Primitive types in patterns, &lt;code&gt;instanceof&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;"&lt;/a&gt;. Добавилось важное дополнение, что примитивные типы смогут появляться в ветках &lt;code&gt;switch&lt;/code&gt;. Например:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (i) {
    &lt;span style="color: blue"&gt;case byte&lt;/span&gt; b -&gt; ... ;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; ... ;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;p&gt;Кроме того, список типов константных выражений в ветках будет расширен до всех примитивных типов, включая &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;boolean&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.0f -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.5f -&gt; ...
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; g -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; x = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (x) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 10_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 20_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; ...
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Oracle &lt;a href="https://houseofbrick.com/blog/oracle-java-pricing/"&gt;изменила правила&lt;/a&gt; платной подписки на Java SE. Теперь единицей, по которой рассчитывается стоимость, становится сотрудник компании, а не процессор. Таким образом, теперь на цену подписки влияет только количество сотрудников, а не количество серверов и настольных компьютеров, на которых запущена Java (если только у вас не больше 50000 процессоров на серверах). Это приведёт к подорожанию подписки для большинства случаев. В некоторых случаях такой рост будет на порядок.&lt;/p&gt;
&lt;p&gt;Напомним, что Java была и остаётся свободным ПО, и вышеупомянутое изменение ценовой политики Oracle никак не повлияет на пользователей &lt;a href="https://openjdk.org/"&gt;OpenJDK&lt;/a&gt;, которая продолжает оставаться бесплатной. Останется бесплатной и &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;Oracle JDK 17&lt;/a&gt;, в том числе и для коммерческого использования. Повышение тарифных планов коснётся только компаний, имеющих &lt;a href="https://www.oracle.com/java/java-se-subscription/#rc30p3"&gt;Oracle Java SE Universal Subscription&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #52</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_52.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_52.html</id>
    <updated>2023-01-17T18:00:00Z</updated>
    <published>2023-01-17T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://kotlinlang.org/docs/whatsnew18.html"&gt;Kotlin 1.8.0&lt;/a&gt;. Некоторые заметные нововведения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новые экспериментальные функции &lt;code&gt;copyToRecursively()&lt;/code&gt; and &lt;code&gt;deleteRecursively()&lt;/code&gt; для директорий.&lt;/li&gt;
  &lt;li&gt;Улучшенная производительность kotlin-reflect.&lt;/li&gt;
  &lt;li&gt;Новая опция &lt;code&gt;-Xdebug&lt;/code&gt;, подавляющая оптимизации, для более удобной отладки.&lt;/li&gt;
  &lt;li&gt;Больше не поддерживается таргетирование в байткод 1.6 и 1.7. Вследствие этого, стандартные библиотеки скомпилированы только в 1.8, и более нет разделения на &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, а есть единый &lt;code&gt;kotlin-stdlib&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Улучшена интероперабельность с Objective-C/Swift.&lt;/li&gt;
  &lt;li&gt;Совместимость с Gradle 7.3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/01/java-annotated-monthly-january-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за январь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/maven/releases/tag/maven-3.8.7"&gt;Apache Maven 3.8.7&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/mockito/mockito/releases/tag/v5.0.0"&gt;Mockito 5.0.0&lt;/a&gt;. Новая версия библиотеки требует Java 11 в качестве минимальной версии.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #51</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_51.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_51.html</id>
    <updated>2022-12-25T18:00:00Z</updated>
    <published>2022-12-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 перешёл в &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-December/007233.html"&gt;первую фазу Rampdown&lt;/a&gt;. Окончательный список JEP'ов, которые попадут в релиз, следующий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;JEP 433: Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK предложен &lt;a href="https://mail.openjdk.org/pipermail/discuss/2022-December/006164.html"&gt;новый проект Galahad&lt;/a&gt;, целью которого будет внедрение в OpenJDK технологий GraalVM, связанных с Java, а именно JIT-компилятора GraalVM (полностью написанного на Java) в качестве альтернативы существующему JIT-компилятору HotSpot. Затем, следующим шагом будет использование AOT-компилятора GraalVM для компиляции JIT-компилятора, а позднее &amp;ndash; портирование Native Image в качестве общего решения для любых Java-приложений.&lt;/p&gt;
&lt;p&gt;Напомним, что GraalVM уже однажды был частью OpenJDK (с &lt;a href="https://openjdk.org/jeps/317"&gt;Java 10&lt;/a&gt; по &lt;a href="https://openjdk.org/jeps/410"&gt;Java 16&lt;/a&gt;) в качестве экспериментальной технологии, но был убран из-за сложности поддержки и малой используемости. Новой целью будет превращение GraalVM в downstream-репозиторий (GraalVM EE и CE будут полностью основаны на исходном коде OpenJDK), а значит, не будет проблемы дублирования усилий.&lt;/p&gt;
&lt;p class="pt-1"&gt;Также стали известны &lt;a href="https://medium.com/graalvm/graalvm-galahad-and-a-new-release-schedule-d081d1031bba"&gt;подробности&lt;/a&gt; относительно согласования релизных циклов GraalVM и OpenJDK: начиная с JDK 20, GraalVM будет выходить 2 раза в год (а не 4, как раньше). Следующая версия GraalVM выйдет одновременно с JDK 20 в марте и будет называться &lt;i&gt;GraalVM for JDK 20&lt;/i&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=jJau4kUoLrA"&gt;Eclipse 2022-12&lt;/a&gt;. Что нового появилось в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка Java 19, включая экспериментальные возможности (паттерны записей и паттер-матчинг для &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Более умный &lt;i&gt;Extract Local Variable&lt;/i&gt;, учитывающий проверки на &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Три новых quick fixes для классов: &lt;i&gt;Create getters and setters&lt;/i&gt;, &lt;i&gt;Create &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;&lt;/i&gt; и &lt;i&gt;Create &lt;code&gt;toString()&lt;/code&gt;&lt;/i&gt;.&lt;/li&gt;
  &lt;li&gt;Галочка &lt;i&gt;Automatically update Maven projects configuration&lt;/i&gt; больше не является экспериментальной и включена по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшение редактора XML: автоматическая вставка закрывающего XML-элемента и удаление закрывающего XML-элемента, если вставляется символ &lt;code&gt;/&lt;/code&gt; в конец открывающего элемента.&lt;/li&gt;
  &lt;li&gt;Поддержка RelaxNG в качестве языка схемы XML (в дополнение к существующим DTD и XSD).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse/microprofile/releases/tag/6.0"&gt;MicroProfile 6.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.0"&gt;GlassFish 7&lt;/a&gt;, поддерживающий спецификацию Jakarta EE 10.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.infoq.com/news/2022/12/resilience4j-2-0-0"&gt;Resilience4j 2.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #50</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_50.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_50.html</id>
    <updated>2022-12-04T18:00:00Z</updated>
    <published>2022-12-04T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 пополнился ещё четырьмя JEP'ами:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007215.html"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007223.html"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007225.html"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007224.html"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, на текущий момент у Java 20 шесть JEP'ов, и только один из них &amp;ndash; это полностью новая фича (Scoped Values), а не следующая итерация уже существующей. До первый фазы Rampdown &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-October/007108.html"&gt;остаётся 3 дня&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/11/intellij-idea-2022-3/"&gt;IntelliJ IDEA 2022.3&lt;/a&gt;. Перечислим некоторые нововведения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый полностью переработанный Look &amp; Feel, который можно включить в настройках (галочка &lt;i&gt;Enable new UI&lt;/i&gt; во вкладке &lt;i&gt;New UI Preview&lt;/i&gt;).&lt;/li&gt;
  &lt;li&gt;Возможность синхронизации настроек между устройствами (Settings Sync).&lt;/li&gt;
  &lt;li&gt;Новый способ автоподстановки бинов Spring, Micronaut и Jakarta EE CDI (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Автогенерация схемы OpenAPI из контроллера Spring или ресурса JAX-RS (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Поддержка Redis (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Возможность пристыковывать окна инструментов к плавающим вкладкам редакторов.&lt;/li&gt;
  &lt;li&gt;Предпросмотр результата Intention action теперь включён по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшенный UX в Search Everywhere.&lt;/li&gt;
  &lt;li&gt;Категоризация результатов в Find Usages по сходству использований.&lt;/li&gt;
  &lt;li&gt;Улучшенные Tips of the Day.&lt;/li&gt;
  &lt;li&gt;Улучшенные Bookmarks&lt;/li&gt;
  &lt;li&gt;Возможность просмотра кода библиотек в предпочитаемом стиле с переформатированием.&lt;/li&gt;
  &lt;li&gt;Улучшения производительности (старт и отзывчивость UI).&lt;/li&gt;
  &lt;li&gt;Новые инспекции Java (похожие инструкции в &lt;code&gt;switch&lt;/code&gt;, лишние проверки на длины массивов, ненужный &lt;code&gt;stream.parallel()&lt;/code&gt; и т.д.).&lt;/li&gt;
  &lt;li&gt;Поддержка синтаксических возможностей Java 19 (паттерны записей и изменения в паттерн-матчинге &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;В режиме отладки: если анализатор может предсказать, что ветка не будет исполнена, то она окрашивается в серый цвет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/12/java-annotated-monthly-december-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за декабрь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/11/24/spring-boot-3-0-goes-ga"&gt;Spring Boot 3.0&lt;/a&gt;. Главные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется Spring 6.0.&lt;/li&gt;
  &lt;li&gt;Java 17 &amp;ndash; минимальная версия.&lt;/li&gt;
  &lt;li&gt;Генерация нативных образов GraalVM.&lt;/li&gt;
  &lt;li&gt;Улучшения в observability через Micrometer и Micrometer Tracing.&lt;/li&gt;
  &lt;li&gt;Полный переход от Java EE к Jakarta EE. Jakarta EE 9 &amp;ndash; минимальная версия. Есть поддержка Jakarta EE 10.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v2.9"&gt;Async Profiler 2.9&lt;/a&gt; с новым профайлером утечек в куче.&lt;/p&gt;</content>
  </entry>
</feed>
