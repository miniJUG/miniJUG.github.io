<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-03-07T17:00:00Z</updated>
  <entry>
    <title>Новости Java #9</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_9.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_9.html</id>
    <updated>2021-03-07T17:00:00Z</updated>
    <published>2021-03-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Брайан Гетц запустил в рассылке Amber &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002862.html"&gt;дискуссию&lt;/a&gt; по поводу того, как в &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/a&gt; должны выглядеть паттерны с условиями. Пока что в этом вопросе консесуса нет, и была предложена масса вариантов. Вот примеры возможных решений:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;when&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &lt;span style="color: blue"&gt;if&lt;/span&gt; (x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp;&amp; x &gt; 0:&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &amp;&amp; x &gt; 0):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ещё одно письмо от Брайана Гетца было опубликовано про &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002836.html"&gt;паттерны примитивных типов и конверсии&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.java.net/jeps/398"&gt;JEP 398: Deprecate the Applet API for Removal&lt;/a&gt;. API аплетов, которое &lt;a href="https://openjdk.java.net/jeps/289"&gt;стало deprecated&lt;/a&gt; в Java 9, теперь предлагается пометить как подлежащее окончательному удалению.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый мартовский выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/03/java-annotated-monthly-march-2021/"&gt;Java Annotated Monthly&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге AdoptOpenJDK &lt;a href="https://blog.adoptopenjdk.net/2021/03/transition-to-eclipse-an-update/"&gt;появился пост&lt;/a&gt; с обновлением статуса переезда проекта в Eclipse Foundation. Напомним, что 9 месяцев назад &lt;a href="https://blog.adoptopenjdk.net/2020/06/adoptopenjdk-to-join-the-eclipse-foundation/"&gt;было объявлено&lt;/a&gt;, что проект AdoptOpenJDK собирается присоединиться к Eclipse Foundation, а его имя будет изменено на Eclipse Adoptium.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+12&lt;/a&gt;, &lt;a href="https://jdk.java.net/lanai/"&gt;JDK 17-lanai+3-133&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-March/003171.html"&gt;JMH 1.28&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #8</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_8.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_8.html</id>
    <updated>2021-02-28T17:00:00Z</updated>
    <published>2021-02-28T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло два новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8260244"&gt;Record and Array Patterns (Preview)&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В первом JEP'е предлагается ввести в язык паттерны записей и паттерны массивов. Паттерны записей будут выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
    System.out.println(x + y);
}&lt;/pre&gt;
&lt;p&gt;Паттерны могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint r)) {
    System.out.println(c);
}&lt;/pre&gt;
&lt;p&gt;Паттерны массивов выглядят так:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2, ... }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Паттерн на примере выше срабатывает для массивов длины 2 или более. Если нужен паттерн строгой длины 2, то многоточие не нужно указывать:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2 }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Есть возможность осуществлять паттерн-матчинг по многомерным массивам. Также можно вкладывать паттерны массивов в паттерны записей и наоборот.&lt;/p&gt;
&lt;p class="pt-1"&gt;Во втором JEP'е предлагается ввести паттерн-матчинг по типу для оператора &lt;code&gt;switch&lt;/code&gt;, и это будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;Если пользователю нужен матчинг &lt;code&gt;null&lt;/code&gt;, то придётся указывать отдельную ветку:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Если не указывать явную ветку &lt;code&gt;case null&lt;/code&gt; и в &lt;code&gt;switch&lt;/code&gt; передастся нулевой объект, то будет выбрасываться &lt;code&gt;NullPointerException&lt;/code&gt;, даже если будет присутствовать ветка &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) { &lt;span style="color: red"&gt;// will throw NPE&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Чтобы ветка &lt;code&gt;default&lt;/code&gt; покрывала &lt;code&gt;null&lt;/code&gt;, нужно будет использовать паттерн &lt;code&gt;null, default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Паттерн &lt;code&gt;null&lt;/code&gt; можно будет также объединять и с паттерном по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case null&lt;/span&gt;, String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;В первой итерации поддержки смешанных паттернов (паттернов по типу и константных паттернов в одном &lt;code&gt;switch&lt;/code&gt;) не будет:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Hello world"&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Hello back"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Nothing?"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; также будет поддерживать условные паттерны. Для этого предлагается ввести охранные паттерны вида &lt;code&gt;true(boolean expr)&lt;/code&gt; и &lt;code&gt;false(boolean expr)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Shape s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Triangle t &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(t.calculateArea() &gt; 100) -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Large Triangle"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"A shape (including small triangles"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p class="pt-1"&gt;Если оба JEP'а будет реализованы вместе, то первый будет дополнять возможности второго. Так, все паттерны по записям и массивам можно будет использовать и в ветках &lt;code&gt;switch&lt;/code&gt; (в том числе вложенные).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел первый релиз-кандидат языка Scala 3: &lt;a href="https://dotty.epfl.ch/blog/2021/02/17/scala3-rc1.html"&gt;Scala 3.0.0-RC1&lt;/a&gt;. В эту версию попало более 400 пулл-реквестов от контрибьюторов с прошлого релиза 3.0.0-M3.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.scala-lang.org/scala3/new-in-scala3.html"&gt;Scala 3&lt;/a&gt;, разработка которой более 5 лет ведётся в проекте &lt;a href="https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"&gt;Dotty&lt;/a&gt; &amp;ndash; это полная переработка Scala 2, но в значительной части с ней совместимая: большая часть кода на Scala 2 остаётся валидным кодом для компилятора Scala 3, а для остального кода есть &lt;a href="https://scalacenter.github.io/scala-3-migration-guide/"&gt;гид по миграции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также вышло обновление &lt;a href="https://github.com/scala/scala/releases/tag/v2.13.5"&gt;Scala 2.13.5&lt;/a&gt;. В него попала поддержка последних версий Java вплоть до ещё не вышедшей Java 17, поддержка Scala 3.0.0-RC1, более безопасный паттерн-матчинг и другие изменения.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Опубликованы результаты &lt;a href="https://arjan-tijms.omnifaces.org/2021/02/jakarta-ee-survey-20202021-results.html"&gt;опроса Jakarta EE&lt;/a&gt;, который проводился с сентября 2020 по февраль 2021 года. В нём 684 респондента ответили на вопросы относительно использования технологий Java EE / JakartaEE. Из интересных результатов опроса следующие факты:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;Самый используемый сервер приложений &amp;ndash; это RedHat WildFly, а самый ненавистный &amp;ndash; IBM WebSphere.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые API: JPA, CDI и JAX-RS.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые библиотеки: Hibernate, Weld и Hibernate Validator.&lt;/li&gt;
   &lt;li&gt;&lt;a href="https://microprofile.io/"&gt;MicroProfile&lt;/a&gt; попробовало 32% опрошенных. Это на 16% больше, чем 2 года назад.&lt;/li&gt;
   &lt;li&gt;Самые популярные продукты MicroProfile: Quarkus, WildFly и Payara Micro.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-3"&gt;&amp;bull; Была объявлена виртуальная конференция &lt;a href="https://jakartaone.org/2021/russian/"&gt;JakartaOne Livestream на русском&lt;/a&gt;, которая пройдёт 31 марта 2021 года.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+11&lt;/a&gt;, &lt;a href="https://jdk.java.net/panama/"&gt;JDK 17-panama+2-51&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышлая &lt;a href="https://www.reddit.com/r/java/comments/lsbcwe/flatlaf_10_swing_look_and_feel/"&gt;версия 1.0&lt;/a&gt; библиотеки &lt;a href="https://github.com/JFormDesigner/FlatLaf"&gt;FlatLaf&lt;/a&gt; для кроссплатформенного Look and Feel в приложениях на Swing.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В официальной документации Android &lt;a href="https://stackoverflow.com/questions/66346971/android-deprecated-annotation-is-deprecated-whats-the-replacement"&gt;обнаружили&lt;/a&gt;, что аннотация &lt;code&gt;@Deprecated&lt;/code&gt; помечена как Deprecated. Эта ошибка возникла из-за того, что в JavaDoc аннотации присутствовал код &lt;code&gt;{@code @deprecated}&lt;/code&gt;, который сигнализировал парсеру документации добавить "пропущенную" аннотацию &lt;code&gt;@Deprecated&lt;/code&gt;. Баг уже был &lt;a href="https://android-review.googlesource.com/c/platform/libcore/+/1601554"&gt;устранён&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #7</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_7.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_7.html</id>
    <updated>2021-02-14T17:00:00Z</updated>
    <published>2021-02-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел ещё один JEP по проекту Valhalla: &lt;a href="http://openjdk.java.net/jeps/8259731"&gt;Unify the Basic Primitives with Objects (Preview)&lt;/a&gt;. В нём предлагается мигрировать 8 примитивных типов Java (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;) таким образом, чтобы они стали экземплярами соответствующих классов-обёрток (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;), которые сами станут примитивными классами. В такой схеме, например, тип &lt;code&gt;int&lt;/code&gt; станет алиасом для &lt;code&gt;Integer.val,&lt;/code&gt; а &lt;code&gt;Integer&lt;/code&gt; &amp;ndash; к &lt;code&gt;int.ref&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Благодаря такой унификации у примитивных типов появятся свойства, которых у них не было с самого появления языка: наследование, наличие методов (&lt;code&gt;17.toString()&lt;/code&gt;, &lt;code&gt;23.compareTo(42))&lt;/code&gt; и возможность быть параметрами дженериков (будет отдельный JEP).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;предложили&lt;/a&gt; перевести проект &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; на Git. Так как переход 16u и 13u на Git уже &lt;a href="https://openjdk.java.net/projects/skara/"&gt;совершён&lt;/a&gt;, то это поможет унифицировать процесс разработки обновлений разных мажорных версий JDK. Переход на Git предлагается сделать к июню 2021 года, когда начнётся работа над JDK 11.0.13.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains начала программу раннего доступа (EAP) к своему &lt;a href="https://blog.jetbrains.com/idea/2021/02/early-access-program-for-qodana-a-new-product-that-brings-the-smarts-of-jetbrains-ides-into-your-ci-pipeline/"&gt;новому продукту Qodana&lt;/a&gt; &amp;ndash; платформы для статического анализа и измерения качества кода. Qodana состоит из двух частей: движок для запуска анализа в CI и веб-панель с отчётами. Статический анализатор кода представляет собой движок IntelliJ IDEA без графического интерфейса, и его можно запустить на любом CI-сервере. Для TeamCity есть готовый плагин.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Николай Парлог (aka &lt;a href="https://twitter.com/nipafx"&gt;nipafx&lt;/a&gt;) выложил на YouTube &lt;a href="https://youtu.be/ZyTH8uCziI4"&gt;интервью с Брайаном Гетцом&lt;/a&gt; про то, почему сериализация, nullability, мутабельность и другие аспекты сделаны умолчательными в Java, и можно ли это было сделать по-другому.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #6</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_6.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_6.html</id>
    <updated>2021-02-07T17:00:00Z</updated>
    <published>2021-02-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-February/005062.html"&gt;Вышел&lt;/a&gt; первый релиз-кандидат 16-й версии Java: &lt;a href="https://jdk.java.net/16/"&gt;JDK 16+35&lt;/a&gt;. Также вышла новая ранняя сборка JDK 17: &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+8&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Стал известен второй JEP, который предложен к выходу в Java 17. Это &lt;a href="http://openjdk.java.net/jeps/382"&gt;JEP 382: New macOS Rendering Pipeline&lt;/a&gt;. Цель этого JEP'а &amp;ndash; реализовать новый конвейер Java 2D-рендеринга на основе Apple Metal API в качестве альтернативы старому deprecated OpenGL API. Разработка нового конвейера ведётся в рамках &lt;a href="http://openjdk.java.net/projects/lanai/"&gt;проекта Lanai&lt;/a&gt;, у которого недавно вышла &lt;a href="https://jdk.java.net/lanai/"&gt;ранняя сборка&lt;/a&gt; JDK 17-lanai+2-49.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Компания JFrog &lt;a href="https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/"&gt;закрывает&lt;/a&gt; свои облачные платформы Bintray, GoCenter и ChartCenter. Эти сервисы много лет предоставляли возможность бесплатно публиковать и распространять бинарные артефакты любому разработчику открытого программного обеспечения, однако 1 мая 2021 года сервисы будут остановлены, и все опубликованные артефакты перестанут быть доступными.&lt;/p&gt;
&lt;p&gt;Частью Bintray, также подпадающей под закрытие, является репозиторий JCenter, который стал популярной альтернативой &lt;a href="https://search.maven.org/"&gt;Maven Central&lt;/a&gt; благодаря более простому процессу публикации туда Maven-артефактов. Особенно популярен JCenter среди пользователей Gradle, поскольку документация и примеры Gradle &lt;a href="https://docs.gradle.org/current/samples/sample_gradle_plugin.html"&gt;рекомендуют&lt;/a&gt; использовать JCenter в качестве репозитория по умолчанию:&lt;/p&gt;
&lt;pre&gt;repositories {
    &lt;span style="color: darkgreen"&gt;// Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.&lt;/span&gt;
    jcenter()
}&lt;/pre&gt;
&lt;p&gt;Также JCenter &lt;a href="https://developer.android.com/studio/build/dependencies#remote-repositories"&gt;указывается&lt;/a&gt; по умолчанию в новых проектах Android Studio.&lt;/p&gt;
&lt;p&gt;Брайан Фокс, CTO компании Sonatype, которая обслуживает Maven Central, после выхода новости о закрытии Bintray &lt;a href="https://blog.sonatype.com/dear-bintray-and-jcenter-users-heres-what-you-need-to-know-about-the-central-repository"&gt;опубликовал пост&lt;/a&gt;, в котором призвал пользователей JCenter не беспокоиться и ответил на несколько частозадаваемых вопросов относительно перехода на Central.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышло сразу три новых черновика JEP:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261007"&gt;Frozen Arrays (Preview)&lt;/a&gt;. Здесь предлагается ввести в Java замороженные массивы, то есть массивы, которые нельзя изменять. Такие массивы могут сделать код более безопасным, а саму программу более эффективной благодаря лучшей оптимизации неизменяемых массивов виртуальной машиной. Сами массивы можно будет создавать либо с помощью методов-фабрик, либо путём замораживания существующего мутабельного массива (при этом возвращается новый массив).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261099"&gt;Internal Frozen Arrays&lt;/a&gt;. Этот JEP связан с предыдущим, и в нём описаны внутренние низкоуровневые методы JDK, которые смогут замораживать мутабельные массивы на месте (без копирования). Эти методы предоставят основу для реализации более высокоуровневых методов-фабрик.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8260865"&gt;Generational Shenandoah&lt;/a&gt;. В этом JEP'е предлагается добавить в сборщик мусора Shenandoah поколения. Это сможет &lt;a href="https://youtu.be/cJyzt9b6KrU?t=2345"&gt;повысить эффективность&lt;/a&gt; сборки мусора.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; JUG.ru &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b_bCEiqcpNwoB0xT6wlIofb"&gt;выложил видео&lt;/a&gt; с конференции Joker 2020.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/02/kotlin-1-4-30-released/"&gt;Kotlin 1.4.30&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains опубликовала &lt;a href="https://www.jetbrains.com/lp/annualreport-2020/"&gt;JetBrains 2020/21 Annual Highlights&lt;/a&gt;. На этой странице собраны все самые значительные события, которые произошли с компанией за предыдущий год, и опубликованы статистики роста популярности продуктов, количества пользователей и прочих показателей.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #5</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_5.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_5.html</id>
    <updated>2021-01-31T17:00:00Z</updated>
    <published>2021-01-31T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; На сайте OpenJDK опубликован черновик JEP &lt;a href="http://openjdk.java.net/jeps/8201533"&gt;&amp;laquo;Enhanced javadoc support for code samples (snippets)&amp;raquo;&lt;/a&gt;. В нём предлагается ввести в javadoc новый тег &lt;code&gt;@snippet&lt;/code&gt;, с помощью которого можно будет вставлять в документацию примеры кода и делать это лучше, чем это делается сейчас с использованием блоков &lt;code&gt;&amp;lt;pre&amp;gt;{@code ...}&amp;lt;/pre&amp;gt;&lt;/code&gt;. Новые сниппеты будут предоставлять механизм для лучшей проверки корректности кода, подсветки синтаксиса, улучшенной поддержки редактирования в IDE.&lt;/p&gt;
&lt;p&gt;Пример сниппета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**
 * The following code shows how to use Optional.isPresent:
 * {@snippet :
 *     &lt;/span&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (v.isPresent()) {
 &lt;span style="color: green"&gt;*&lt;/span&gt;         System.out.println(&lt;span style="color: darkred"&gt;"v: "&lt;/span&gt; + v.get());
 &lt;span style="color: green"&gt;*&lt;/span&gt;     }
 &lt;span style="color: green"&gt;* }
 */&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Сниппеты в javadoc будут поддерживать вложенные комментарии &lt;code&gt;&lt;span style="color: green"&gt;/* ... */&lt;/span&gt;&lt;/code&gt; (с помощью &amp;lt;pre&amp;gt; это сделать нельзя), ссылки на код из внешнего файла (&lt;code&gt;@snippet file="SomeFile.java"&lt;/code&gt;), обрезание ненужных пробельных символов в началах строк (как в &lt;a href="text_blocks.html"&gt;блоках текста&lt;/a&gt;), подсветку определённых участков сниппета и многие другие возможности.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел ещё один черновик JEP &lt;a href="http://openjdk.java.net/jeps/8260688"&gt;&amp;laquo;Improve regex performance&amp;raquo;&lt;/a&gt;. В этом JEP'е предлагается заменить движок регулярных выражений, который в Java работает довольно быстро, но не даёт гарантированной максимальной сложности алгоритма поиска. Это делает сервисы, написанные на Java, потенциально уязвимыми к DoS-атакам на основе регулярных выражений (&lt;a href="https://en.wikipedia.org/wiki/ReDoS"&gt;ReDoS&lt;/a&gt;). Особенно легко такие атаки могут быть организованы, если пользователь знает, какое именно регулярное выражение используется на сервере для валидации полей, и уж тем более, если сам может загружать своё регулярное выражение.&lt;/p&gt;
&lt;p&gt;Чтобы избежать этого, можно использовать движок регулярных выражений, основанный на детерминированных конечных автоматах (DFA), который даёт гарантированную сложность &lt;code&gt;O(N)&lt;/code&gt;, однако он поддерживает не все возможности регулярных выражений. В JEP'е предлагаются варианты решений такой проблемы, например, использовать разные алгоритмы в зависимости от указанного выражения или позволять пользователю указывать с помощью флага, какой именно алгоритм использовать. Пока что в JEP'е нет окончательного ответа относительно выбора подхода, и, видимо, он ещё будет сильно дорабатываться.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/01/intellij-idea-2021-1-eap-1/"&gt;IntelliJ IDEA 2021.1 EAP&lt;/a&gt; (Early Access Program). В этой версии среды появилась базовая поддержка Java 16, WSL 2 (Windows Subsytem for Linux 2), новая возможность Run Targets (выполнение программы в среде: Docker, SSH, WSL), улучшения в UI и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/jmc/8/"&gt;JDK Misson Control 8.0.0 EA&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ну и напоследок немного юмора. Известный программист, Java-чемпион Heinz Kabutz &lt;a href="https://twitter.com/heinzkabutz/status/1355137101545799682"&gt;выложил в Твиттере задачку&lt;/a&gt; со следующим вопросом:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Как, не меняя ни одного символа, сделать так, чтобы программа скомпилировалась:&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; InnerStaticMember {
  &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String... args) {
      System.out.println(&lt;span style="color: darkred"&gt;"Look Ma, no hands!"&lt;/span&gt;);
    }
  }
}&lt;/pre&gt;
&lt;p&gt;Среди ответов отметилось несколько правильных: нужно просто перейти на Java 16, потому что Java 16 &lt;a href="https://openjdk.java.net/jeps/395"&gt;разрешает статические члены во внутренних классах&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Однако самым смешным (но в то же время абсолютно корректным) оказался ответ, где написан конвейер Linux-команд, который берёт исходное изображение, обрезает её так, что из неё остаётся только кусок с классом &lt;code&gt;Inner&lt;/code&gt;, распознаёт из неё текст и компилирует.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #4</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_4.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_4.html</id>
    <updated>2021-01-24T17:00:00Z</updated>
    <published>2021-01-24T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Java отпраздновала знаменательную дату: 23 января 1996 года, ровно 25 лет назад, вышла первая стабильная версия JDK, которая имела версию &lt;a href="https://javaalmanac.io/jdk/1.0/"&gt;1.0.2&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://blog.adoptopenjdk.net/2021/01/adoptopenjdk-8u282-11010-and-1502-available/"&gt;Вышли&lt;/a&gt; обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-January/013337.html"&gt;JDK 8u282&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004689.html"&gt;JDK 11.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004690.html"&gt;JDK 13.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://jdk.java.net/15/"&gt;JDK 15.0.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также вышли обновления ранних сборок JDK: &lt;a href="http://jdk.java.net/16/"&gt;JDK 16-ea+33&lt;/a&gt; и &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+6&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайн Гетц опубликовал несколько писем в &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/thread.html"&gt;рассылке Amber&lt;/a&gt; с рассуждениями относительно паттерн-матчинга и подробностями его развития в ближайшем будущем:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002758.html"&gt;Pattern features for next iteration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002763.html"&gt;Patterns: Nullity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002778.html"&gt;Patterns: Declaration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002782.html"&gt;Relaxed assignment conversions for sealed types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также Брайн Гетц опубликовал статью на InfoQ: &lt;a href="https://www.infoq.com/articles/java-pattern-matching/"&gt;Java Feature Spotlight: Pattern Matching&lt;/a&gt;. В ней он рассказывает, как выглядит паттерн-матчинг в Java сейчас и в каком направлении он будет развиваться.&lt;/p&gt;
&lt;p&gt;Кроме того, выложено &lt;a href="https://freecontent.manning.com/interview-with-brian-goetz/"&gt;большое интервью&lt;/a&gt; с Брайном про его работу над развитием языка.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Ещё один день рождения празднует IntelliJ IDEA. Её первая версия вышла в свет в 2001 году. В связи с этим JetBrains организует бесплатную виртуальную конференцию &lt;a href="https://www.jetbrains.com/ru-ru/lp/intellijidea-20-anniversary/"&gt;IntelliJ IDEA Conf&lt;/a&gt;, которая состоится 25-26 февраля.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В новосибирском сообществе Java-программистов JUGNsk объявили об очередном &lt;a href="https://www.meetup.com/JUGNsk/events/275807033/"&gt;онлайн-митапе&lt;/a&gt;, который состоится 28 января в 15:00 по московскому времени.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Тагир Валеев опубликовал статью на Хабре: &lt;a href="https://habr.com/ru/post/538280/"&gt;Анбоксинг в современной Java&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла GraalVM 21.0. В дополнение к &lt;a href="https://medium.com/graalvm/graalvm-21-0-introducing-a-new-way-to-run-java-df894256de28"&gt;основной новости&lt;/a&gt; о выходе новой версии была опубликована &lt;a href="https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840"&gt;дополнительная статья&lt;/a&gt; с подробностями того, как JVM реализована полностью на Java с использованием фреймворка Truffle.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/lists/tycho-dev/msg01837.html"&gt;Eclipse Tycho 2.2.0.&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #3</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_3.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_3.html</id>
    <updated>2021-01-17T17:00:00Z</updated>
    <published>2021-01-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; По просьбам читателей на сайт &lt;a href="https://minijug.ru"&gt;minijug.ru&lt;/a&gt; был добавлен feed в формате Atom. Это сделано для тех, кто предпочитает узнавать о новых публикациях через агрегатор новостных лент, а не через &lt;a href="https://t.me/miniJUG"&gt;Telegram-канал&lt;/a&gt;. Адрес feed &lt;a href="https://minijug.ru/feed.xml"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Java 16 теперь во &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-January/005001.html"&gt;второй фазе Rampdown&lt;/a&gt;, а значит на одну ступень ближе к релизу, который &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;по плану&lt;/a&gt; должен произойти 16 марта.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В компилятор Java было внесено &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8250769"&gt;несколько изменений&lt;/a&gt; в отношении preview API. Preview API &amp;ndash; это один из трёх типов &lt;a href="https://openjdk.java.net/jeps/12"&gt;preview feature&lt;/a&gt; в Java, наряду с preview language feature и preview VM feature. Preview API разделены на две большие группы: &lt;em&gt;нормальные&lt;/em&gt; (normal) и &lt;em&gt;рефлективные&lt;/em&gt; (reflective). Нормальные также подразделяются на &lt;em&gt;неотъемлемые&lt;/em&gt; (essential), &lt;em&gt;удобные&lt;/em&gt; (convenient) и &lt;em&gt;автономные&lt;/em&gt; (standalone). Однако для &lt;code&gt;javac&lt;/code&gt; важно только разделение на нормальные и рефлективные. Главные изменения &lt;code&gt;javac&lt;/code&gt; следующие:&lt;/p&gt;
&lt;p&gt;1. Аннотация &lt;code&gt;@PreviewFeature&lt;/code&gt; перенесена из пакета &lt;code&gt;jdk.internal&lt;/code&gt; в пакет &lt;code&gt;jdk.internal.javac&lt;/code&gt;, и в неё добавлен флаг &lt;code&gt;reflective&lt;/code&gt;, который заменил старый флаг &lt;code&gt;essentialAPI&lt;/code&gt;. Этот новый флаг как раз и поможет компилятору отличать рефлективные preview API от нормальных.&lt;/p&gt;
&lt;p&gt;2. Рефлективные preview API можно использовать без флага компилятора &lt;code&gt;--enable-preview&lt;/code&gt;, а нормальные &amp;ndash; только с флагом.&lt;/p&gt;
&lt;p&gt;3. При использовании класса, который использует preview feature, теперь выдаётся предупреждение (например, если использован &lt;code&gt;sealed&lt;/code&gt;-класс из какой-нибудь библиотеки). Но это предупреждение можно подавить через &lt;code&gt;@SuppressWarnings(&lt;span style="color: darkred"&gt;"preview"&lt;/span&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;4. Классы помечаются как зависящие от preview feature, только если это действительно необходимо (такие class-файлы имеют специальную минорную версию 65535, например 61.65535 для Java 17). Если класс не использует ни одной preview language feature (ни прямо, ни косвенно), ни одной preview VM feature и ни одного нормального preview API, то он компилируется в обычный (не-preview) class-файл. Другими словами, если из preview features использовать только рефлективные preview API, то такие программы можно будет запускать без флага &lt;code&gt;--enable-preview&lt;/code&gt;, даже если они скомпилированы с флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Эти изменения в &lt;code&gt;javac&lt;/code&gt; будут работать только начиная с Java 17.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Опубликован новый черновик &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;JEP: Primitive Objects (Preview)&lt;/a&gt;, в котором описывается, как в Java планируется внедрить примитивные объекты. Примитивные объекты &amp;ndash; это объекты, которые не имеют идентичности, то есть при их копировании получается объект, неотличимый от оригинального. Такие объекты могут передаваться напрямую и легко встраиваться (в другие объекты/массивы/стек), что снижает накладные расходы на их использование и делает их более эффективными, чем объекты с идентичностью.&lt;/p&gt;
&lt;p class="pt-3"&gt;Новый черновик JEP &amp;ndash; это возможно первая детальная публичная спецификация, которая стала результатом многолетних исследований, множества встреч экспертов и обсуждений, проведённых по value-типам в рамках проекта &lt;a href="http://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;. В ходе проекта было сделано несколько прототипов, несколько раз значительно менялась концепция, а сами value-типы дважды переименовывались: сначала в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2019-April/000916.html"&gt;inline-классы&lt;/a&gt;, а потом в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2020-October/001415.html"&gt;примитивные классы&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/01/java-annotated-monthly-january-2021/"&gt;&amp;laquo;Java Annotated Monthly&amp;raquo;&lt;/a&gt;, где собрано огромное количество ссылок на новости, статьи, тьюториалы и прочие материалы о Java и связанных темах.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://mail.openjdk.java.net/pipermail/loom-dev/2021-January/002046.html"&gt;новая сборка Loom&lt;/a&gt;, основанная на JDK 17+5.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://github.com/scala/scala/releases/tag/v2.12.13"&gt;Scala 2.12.13&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #2</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_2.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_2.html</id>
    <updated>2021-01-10T17:00:00Z</updated>
    <published>2021-01-10T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стал известен первый JEP, который попадёт в Java 17. Это &lt;a href="https://openjdk.java.net/jeps/356"&gt;JEP 356: Enhanced Pseudo-Random Number Generators&lt;/a&gt;. В рамках этого JEP'а будет добавлен интерфейс &lt;code&gt;RandomGenerator&lt;/code&gt; с четырьмя его специализациями: &lt;code&gt;SplittableRandomGenerator&lt;/code&gt;, &lt;code&gt;JumpableRandomGenerator&lt;/code&gt;, &lt;code&gt;LeapableRandomGenerator&lt;/code&gt; и &lt;code&gt;ArbitrarilyJumpableRandomGenerator&lt;/code&gt;. Кроме того, будет добавлен класс &lt;code&gt;RandomGeneratorFactory&lt;/code&gt;, который будет возвращать конкретные реализации &lt;code&gt;RandomGenerator&lt;/code&gt;. Старые классы &lt;code&gt;Random&lt;/code&gt;, &lt;code&gt;ThreadLocalRandom&lt;/code&gt; и &lt;code&gt;SplittableRandom&lt;/code&gt; будут отрефакторены и станут одними из реализаций &lt;code&gt;RandomGenerator&lt;/code&gt;. Также будут реализованы новые алгоритмы генерации псевдослучайных чисел.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайан Гетц опубликовал &lt;a href="https://github.com/openjdk/amber-docs/blob/master/site/design-notes/pattern-match-object-model.md"&gt;новый документ&lt;/a&gt; &amp;laquo;Паттерн-матчинг в объектной модели Java&amp;raquo;. В нём описывается возможный подход внедрения паттерн-матчинга в язык. Документ довольно большой, поэтому попробуем выделить основные моменты:&lt;/p&gt;
&lt;p&gt;&amp;ndash; Если язык предоставляет возможноть агрегации посредством конструкторов/фабричных методов, то он должен предоставлять и обратный механизм деконструкции:&lt;/p&gt;
&lt;pre&gt;Object x = &lt;span style="color: blue"&gt;new&lt;/span&gt; Foo(a, b); &lt;span style="color: green"&gt;// конструкция&lt;/span&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b): ... &lt;span style="color: green"&gt;// деконструкция&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Если конструирование объекта поддерживает композицию, то и деконструирование тоже должно её поддерживать:&lt;/p&gt;
&lt;pre&gt;Optional.of(Shape.redBall(1));&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Optional.of(Shape.redBall(&lt;span style="color: blue"&gt;var&lt;/span&gt; size)): ...&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Паттерны деконструкции являются точно такими же членами класса, как и конструкторы/методы. Паттерны имеют тело, в котором описывается всё необходимое поведение.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Раз паттерны являются членами класса, то они поддерживают все их атрибуты: модификаторы доступа, перегрузка, переопределение, static/instance, параметрический полиморфизм, делегирование к другим паттернам, varargs и т.д.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Паттерны также имеют дополнительные уникальные атрибуты: наличие целевого операнда, тип которого должен быть совместим с целевым типом, полнота/частичность, исчерпываемость, разделение аргументов на входные и выходные.&lt;/p&gt;
&lt;p&gt;&amp;ndash; В конце документа описываются также другие идеи вроде комбинирования паттернов с помощью булевых операторов (AND/OR), структурные паттерны и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Также Брайн Гетц предложил в рассылке Amber несколько идей относительно паттерн-матчинга:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002688.html"&gt;Оператор алмаза в паттернах&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Было&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;K, ? extends V&amp;gt; em) { ... }

&lt;span style="color: green"&gt;// Стало&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;&amp;gt; em) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002695.html"&gt;Паттерны массивов&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (arr &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { &lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b }) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002710.html"&gt;Охранные паттерны&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; P(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) __AND &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0) __AND Q(&lt;span style="color: blue"&gt;var&lt;/span&gt; y):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Джонатан Гиббонс (Oracle) &lt;a href="https://mail.openjdk.java.net/pipermail/code-tools-dev/2021-January/000625.html"&gt;предложил&lt;/a&gt; добавить в JDK утилиту &lt;code&gt;apidiff&lt;/code&gt; для сравнения нескольких версий API. Утилита сможет анализировать class-файлы, исходные файлы Java и файлы документации и генерировать HTML-отчёт о различиях в API. Внутри она будет использовать фронтенд &lt;code&gt;javac&lt;/code&gt; и модули &lt;code&gt;java.compiler&lt;/code&gt;/&lt;code&gt;jdk.compiler&lt;/code&gt; для чтения исходных и класс-файлов, а значит не будет проблем с поддержкой в утилите последних языковых изменений. Джонатан пишет, что у него уже есть продвинутый прототип утилиты и он надеется в скором времени опубликовать его на GitHub.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Американские новостные агентства &lt;a href="https://www.wsj.com/articles/solarwinds-hack-breached-justice-department-systems-11609958761"&gt;написали&lt;/a&gt; о взломе нескольких министерств США через программное обеспечение компании SolarWinds и о возможной организации этих кибератак хакерами, связанными с Россией. В статьях написано, что хакеры могли это сделать, получив доступ к билд-серверу TeamCity, развёрнутому в компании для сборки ПО. Далее сообщается, что американские спецслужбы и специалисты по кибербезопасности начали исследование возможной роли JetBrains в атаке.&lt;/p&gt;
&lt;p&gt;При этом авторы не объясняют, почему такой негативный акцент в статьях сделан именно на JetBrains, ведь кроме TeamCity в SolarWinds должно использоваться множество других программ и инструментов для разработки. New York Times вообще &lt;a href="https://web.archive.org/web/20210106195835/https://www.nytimes.com/2021/01/06/us/politics/russia-cyber-hack.html"&gt;назвал&lt;/a&gt; JetBrains &amp;laquo;obscure software company&amp;raquo; (&amp;laquo;тёмная&amp;raquo;, &amp;laquo;неясная&amp;raquo;), но позже изменил эту фразу в статье на &amp;laquo;widely used software company&amp;raquo;, и вообще в течение последующих дней множество раз изменял статью, постоянно внося туда правки и уточнения. Многие программисты в Твиттере довольно резко отреагировали на &lt;a href="https://twitter.com/nicoleperlroth/status/1346909580219936769"&gt;твит&lt;/a&gt; редактора New York Times и одной из авторов статьи, делая &lt;a href="https://twitter.com/nikitonsky/status/1347004468966141954"&gt;ретвиты&lt;/a&gt; с саркастическими шутками.&lt;/p&gt;
&lt;p&gt;Максим Шафиров, CEO JetBrains, после выхода новостей, сразу написал &lt;a href="https://blog.jetbrains.com/blog/2021/01/06/statement-on-the-story-from-the-new-york-times-regarding-jetbrains-and-solarwinds/"&gt;официальный ответ&lt;/a&gt;, что JetBrains никак не может быть причастен к атаке и компания не была извещена о расследовании, но полностью готова к сотрудничеству. На следующий день он выложил &lt;a href="https://blog.jetbrains.com/blog/2021/01/07/an-update-on-solarwinds/"&gt;более подробный пост&lt;/a&gt;, в котором более подробно описал ситуацию. Он написал, что компании неизвестно об уязвимостях в TeamCity, которые могли бы быть эксплуатированы для организации подобных атак, и компания проводит регулярный аудит своих инструментов и систем.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Брюс Эккель, автор &amp;laquo;Философия Java&amp;raquo; и многих других книг о Java, C++ и JVM языках, &lt;a href="https://www.bruceeckel.com/2021/01/02/the-problem-with-gradle/"&gt;написал пост&lt;/a&gt; &amp;laquo;The Problem with Gradle&amp;raquo;, где рассказал свою историю использования Gradle и перечислил его проблемы.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://docs.gradle.org/6.8/release-notes.html"&gt;Вышел Gradle 6.8&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #1</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_1.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_1.html</id>
    <updated>2021-01-03T17:00:00Z</updated>
    <published>2021-01-03T17:00:00Z</published>
    <content type="html">&lt;p&gt;Всех с Новым 2021 Годом!&lt;/p&gt;
&lt;p&gt;&amp;bull; В компиляторе javac &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8259025"&gt;нашли баг&lt;/a&gt;, который не позволяет использовать лямбды в компактных конструкторах записей при определённых обстоятельствах. Баг был обнаружен пользователем @skohlman &lt;a href="https://twitter.com/skohlmann/status/1344684426836500480"&gt;в Твиттере&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; &lt;a href="https://youtrack.jetbrains.com/issue/JBR-2526#focus=Comments-27-4620322.0-0"&gt;Вышла&lt;/a&gt; стабильная версия JetBrains Runtime под Apple M1. Теперь она включена почти во все IDE компании, начиная с версии 2020.3.1. Пользователи уже доложили о нескольких ошибках, которые проявляются в различных IDE.&lt;/p&gt;
&lt;p&gt;&amp;bull; Разработчики обнаружили новый класс &lt;a href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/util/HexFormat.html"&gt;HexFormat&lt;/a&gt;, который появится в Java 17. С помощью этого класса можно будет конвертировать строки с шестнадцатеричными символами в массивы байтов и обратно.&lt;/p&gt;
&lt;p&gt;&amp;bull; Huawei реализовал &lt;a href="https://gitee.com/openeuler/bishengjdk-11/tree/risc-v/"&gt;свой порт&lt;/a&gt; OpenJDK 11 под архитектуру Linux/RISC-V и &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2020-December/005657.html"&gt;спрашивает&lt;/a&gt;, заинтересовано ли сообщество во включении этого порта в jdk-master. Alibaba изъявили желание помочь и сделать вклад в разработку.&lt;/p&gt;
&lt;p&gt;&amp;bull; Команда Jetty &lt;a href="https://mail.openjdk.java.net/pipermail/loom-dev/2020-December/001974.html"&gt;рассказала&lt;/a&gt; об опыте перехода веб-сервера на виртуальные нити из проекта Loom. Они сделали вывод, что количество нитей &amp;ndash; это не всегда главный лимитирующий фактор, и правило &amp;laquo;просто всегда создавай виртуальную нить&amp;raquo; может не сработать, если каждая нить имеет глубокий стек или держит какие-то большие ресурсы.&lt;/p&gt;
&lt;p&gt;&amp;bull; Разработчик из Oracle &lt;a href="https://cl4es.github.io/2021/01/04/Investigating-MD5-Overheads.html"&gt;рассказал&lt;/a&gt; о том, как ускорил MD5 в OpenJDK.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 15</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_15_is_out.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_15_is_out.html</id>
    <updated>2020-09-14T17:00:00Z</updated>
    <published>2020-09-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;Сегодня в свет вышла новая, &lt;a href="http://openjdk.java.net/projects/jdk/15/"&gt;15-я версия платформы Java&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Скачать JDK 15 можно по следующим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html"&gt;Oracle JDK&lt;/a&gt; (проприетарная версия, обратите внимание на ограничения в использовании).&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/15/"&gt;OpenJDK&lt;/a&gt; (бесплатная версия)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В новый релиз попало 14 JEP'ов и &lt;a href="http://jdk.java.net/15/release-notes"&gt;сотни более мелких улучшений&lt;/a&gt;. Если хочется ознакомиться с полным списком изменений с точностью до всех JIRA-тикетов, то их можно посмотреть на &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-15.txt"&gt;сайте Алексея Шипилёва&lt;/a&gt;. Также если интересны все изменения API, то их можно посмотреть &lt;a href="https://javaalmanac.io/jdk/15/apidiff/14/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Перечислим JEP'ы, которые попали в Java 15:&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/378"&gt;Блоки текста (JEP 378)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Блоки текста, которые &lt;a href="text_blocks.html"&gt;появились&lt;/a&gt; в Java 13 и прошли два preview, теперь стали стабильной синтаксической конструкцией. Это значит, что в Java теперь две постоянные конструкции, которые появились с выхода Java 11: &lt;a href="https://openjdk.java.net/jeps/361"&gt;выражения &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt; и блоки текста.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/375"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (второе preview) (JEP 375)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Улучшенный оператор &lt;code&gt;instanceof&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/305"&gt;появился&lt;/a&gt; в Java 14, перешёл во второе preview без изменений. Напомним, что &lt;a href="https://openjdk.java.net/jeps/12"&gt;режим preview&lt;/a&gt; существует в Java для нововведений, которые находятся в предварительном статусе, т.е. могут измениться несовместимым образом или даже совсем исчезнуть, и для их включения необходим специальный флаг &lt;code&gt;--enable-preview&lt;/code&gt;. Паттерн-матчинг для &lt;code&gt;instanceof&lt;/code&gt; мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/384"&gt;Записи (второе preview) (JEP 384)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Записи, которые также &lt;a href="https://openjdk.java.net/jeps/359"&gt;появились&lt;/a&gt; в Java 14, тоже остались в режиме preview. Изменений по сравнению с прошлой версией немного: убрано ограничение, что канонический конструктор должен быть &lt;code&gt;public&lt;/code&gt;, а также разрешены &lt;a href="local_interfaces_and_enums.html"&gt;локальные перечисления и интерфейсы&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/360"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (preview) (JEP 360)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появилось языковое нововведение: &amp;laquo;запечатанные&amp;raquo; классы. Помечаются такие классы модификатором &lt;code&gt;sealed&lt;/code&gt;, после чего круг классов, которые могут наследоваться от данного класса, становится ограниченным. &lt;code&gt;sealed&lt;/code&gt; классы мы подробно рассматривали в &lt;a href="trying_sealed_classes_in_java_15.html"&gt;этой статье&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/377"&gt;ZGC (JEP 377)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;ZGC, который &lt;a href="https://openjdk.java.net/jeps/333"&gt;появился&lt;/a&gt; в Java 11 в экспериментальном статусе, теперь официально готов к продуктовой разработке. Напомним, что ZGC &amp;ndash; это сборщик мусора, который нацелен на маленькие паузы (&lt; 10мс) и готовность работать в условиях огромных куч (&gt; 1TB).&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/379"&gt;Shenandoah (JEP 379)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Shenandoah, ещё один низкопаузный сборщик мусора и &lt;a href="zgc.html"&gt;конкурент&lt;/a&gt; ZGC, теперь также имеет статус готового к продуктовой разработке. Shenandoah впервые &lt;a href="https://openjdk.java.net/jeps/189"&gt;появился&lt;/a&gt; в Java 12. Также недавно стало известно, что Shenandoah был &lt;a href="https://twitter.com/rkennke/status/1288530745179463680"&gt;бэкпортирован в JDK 11&lt;/a&gt;, который является текущим LTS-релизом Java. Это значит, что чтобы его использовать, необязательно обновляться до JDK 15, а достаточно обновиться до JDK 11.0.9, которая &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;выйдет&lt;/a&gt; 20 октября 2020 года.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/374"&gt;Disable and Deprecate Biased Locking (JEP 374)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Biased Locking, который много лет существовал в JDK, было решено убрать из-за сложности поддержки и "неочевидных преимуществ" этой оптимизации. Начиная с этого релиза, опция &lt;code&gt;-XX:+UseBiasedLocking&lt;/code&gt; отключена по умолчанию, а при её использовании и всех её связанных опций будет выдаваться предупреждение. Про мотивы отключения Biased Locking рассказал Сергей Куксенко в &lt;a href="https://www.youtube.com/watch?v=v3oK5_docYE"&gt;подкасте Hydra&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/381"&gt;Удаление портов Solaris и SPARC (JEP 381)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Порты JDK на Solaris/SPARC, Solaris/x64 и Linux/SPARC, которые &lt;a href="https://openjdk.java.net/jeps/362"&gt;стали&lt;/a&gt; deprecated for removal в Java 14, теперь удалены окончательно. Удаление этих портов упростит и ускорит разработку JDK.&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/371"&gt;Скрытые классы (JEP 371)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый тип классов, называемых &lt;a href="hidden_classes.html"&gt;скрытыми&lt;/a&gt;. На скрытые классы не могут прямо ссылаться другие классы, и всё их использование может осуществляться только через рефлексию. Также их нельзя обнаружить по имени, и их методы не появляются в стек-трейсах. Создаются такие классы с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)"&gt;&lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/372"&gt;Удаление движка JavaScript Nashorn (JEP 372)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Движок Nashorn, который &lt;a href="https://openjdk.java.net/jeps/335"&gt;стал&lt;/a&gt; deprecated for removal в Java 11, теперь удалён &lt;a href="remove_nashorn.html"&gt;окончательно&lt;/a&gt;. В качестве замены Nashorn теперь придётся искать другой движок JavaScript, например, &lt;a href="https://github.com/graalvm/graaljs"&gt;GraalVM JavaScript&lt;/a&gt; или &lt;a href="https://github.com/mozilla/rhino"&gt;Rhino&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/373"&gt;Reimplement the Legacy DatagramSocket API (JEP 373)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Реализации старых сокетов из JDK 1.0 &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/DatagramSocket.html"&gt;&lt;code&gt;java.net.DatagramSocket&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/MulticastSocket.html"&gt;&lt;code&gt;java.net.MulticastSocket&lt;/code&gt;&lt;/a&gt; были полностью заменены на более простые, современные и легкоадаптируемые к виртуальным нитям, которые планируется ввести в язык в рамках &lt;a href="https://openjdk.java.net/projects/loom/"&gt;проекта Loom&lt;/a&gt;. Ранее в Java 13 &lt;a href="https://openjdk.java.net/jeps/353"&gt;были переписаны&lt;/a&gt; &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/Socket.html"&gt;&lt;code&gt;java.net.Socket&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/ServerSocket.html"&gt;&lt;code&gt;java.net.ServerSocket&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/383"&gt;Foreign-Memory Access API (Second Incubator) (JEP 383)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API для доступа вне кучи Java, которое &lt;a href="https://openjdk.java.net/jeps/370"&gt;появилось&lt;/a&gt; в Java 14 в статусе модуля-&lt;a href="https://openjdk.java.net/jeps/11"&gt;инкубатора&lt;/a&gt;, остаётся в этом статусе.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/385"&gt;Deprecate RMI Activation for Removal (JEP 385)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Устаревшая и малоиспользуемая часть RMI, которая называется RMI Activation, стала deprecated for removal.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/339"&gt;Edwards-Curve Digital Signature Algorithm (EdDSA) (JEP 339)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Современный алгоритм с открытым ключом для создания цифровой подписи EdDSA реализован в Java.&lt;/p&gt;
&lt;p class="pt-3"&gt;Java 15, как и 12, 13, 14, является STS-релизом, и у неё выйдет только два обновления.&lt;/p&gt;</content>
  </entry>
</feed>
