<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2023-03-26T18:00:00Z</updated>
  <entry>
    <title>Новости Java #56</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_56.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_56.html</id>
    <updated>2023-03-26T18:00:00Z</updated>
    <published>2023-03-26T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8303683"&gt;JEP: Virtual Threads&lt;/a&gt;. В нём предлагается финализировать виртуальные потоки в Java 21, то есть они больше не будут Preview API. Единственным изменением относительно Java 20 будет поддержка &lt;code&gt;ThreadLocal&lt;/code&gt; переменных в виртуальных потоках. Это гарантирует, что многие существующие библиотеки, использующие &lt;code&gt;ThreadLocal&lt;/code&gt;, продолжат корректно работать при переходе на виртуальные потоки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/443"&gt;JEP 443: Unnamed Patterns and Variables (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_46.html"&gt;выпуске #46&lt;/a&gt;, когда вышел его черновик. С тех пор принципиальных изменений в JEP внесено не было.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/442"&gt;JEP 442: Foreign Function &amp; Memory API (Third Preview)&lt;/a&gt;. Таким образом, в Java 21 API остаётся в статусе Preview в третий раз.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8304400"&gt;JEP: Launch Multi-File Source-Code Programs&lt;/a&gt;. В нём предлагается добавить поддержку запуска программ, состоящих из нескольких исходных файлов &lt;code&gt;.java&lt;/code&gt;. Напомним, что сейчас Java поддерживает запуск только одного исходного файла (возможность, которая появилась &lt;a href="https://openjdk.org/jeps/330"&gt;в Java 11&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Предполагается, что запуск нескольких файлов будет работать следующим образом:&lt;/p&gt;
&lt;ul style="list-style-type: none"&gt;
  &lt;li&gt;&amp;bull; В аргумент командной строки по-прежнему передаётся название одного java-файла, например: &lt;code&gt;java Prog.java&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс ссылается на другие классы, то лаунчер пытается найти эти классы в файловой системе. Предполагается, что каждый класс находится в файле с именем, соответствующем имени класса.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Файлы, на которые никто не ссылается, не компилируются. Это может быть удобно для разработки (например, в них можно оставлять синтаксические ошибки).&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс используется через рефлексию, то файл ищется и компилируется уже во время работы программы.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование пакетов поддерживается. В таком случае файлы должны лежать в соответствующих директориях.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование библиотек также поддерживается. Тогда нужно добавить аргумент &lt;code&gt;-cp&lt;/code&gt;, например: &lt;code&gt;java -cp '*' Prog.java&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://openjdk.org/jeps/401"&gt;JEP 401: Primitive Classes (Preview)&lt;/a&gt; был значительно &lt;a href="https://mail.openjdk.org/pipermail/valhalla-spec-experts/2023-March/002238.html"&gt;переработан и переименован&lt;/a&gt; в Null-Restricted Value Object Storage. В новой версии JEP предлагается ввести так называемые опциональные конструкторы и null-restricted типы.&lt;/p&gt;
&lt;p&gt;Смысл опциональных конструкторов заключается в том, что если в &lt;a href="https://openjdk.org/jeps/8277163"&gt;value-классе&lt;/a&gt; объявлен такой конструктор, то такой класс обязан поддерживать значение по умолчанию, то есть значение, в котором все поля являются нулями. Это значит, что объекты такого класса могут быть проинициализированы в обход конструктора, а значит потенциально нарушать инварианты класса. В результате класс становится менее безопасным, но зато даёт виртуальной машине больше возможностей для более компактного хранения его значений: value-классы с опциональными конструкторами могут иметь лучший flattening, чем просто value-классы.&lt;/p&gt;
&lt;p&gt;JEP также предлагает ввести переменные, которым не может быть присвоен &lt;code&gt;null&lt;/code&gt;. Причём это нововведение будет распространяться на все классы, в том числе и ссылочные. Поскольку null-restricted типы не связаны напрямую с value-классами, то они будут подробно описаны &lt;a href="https://openjdk.java.net/jeps/8303099"&gt;в отдельном JEP'е&lt;/a&gt; (на данный момент ссылка выдаёт 404, т.к. JEP ещё не стал общедоступным). Однако в контексте этого JEP'а они упомянуты, чтобы показать, что они играют важную роль, когда сочетаются с value-классами с опциональными конструкторами: их значения смогут встраиваться в другие объекты и массивы, что и было основной целью проекта Valhalla.&lt;/p&gt;
&lt;p&gt;Также важным изменением в JEP'е стал отказ от нотации &lt;code&gt;X.ref&lt;/code&gt; и &lt;code&gt;X.val&lt;/code&gt;. Вместо них будет восклицательный знак для обозначения null-restricted типов (&lt;code&gt;X!&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=JgMLyGBEQ1c"&gt;Eclipse 2023-03&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/javafx20/"&gt;JavaFX 20&lt;/a&gt;. С этой версии фреймворк требует Java 17 в качестве минимальной версии Java.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/03/java-annotated-monthly-march-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за март.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/surefire/maven-surefire-plugin/history.html"&gt;maven-surefire-plugin 3.0.0&lt;/a&gt;. Это первое обновление плагина Maven для запуска тестов спустя почти 4 года.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 20</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_20.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_20.html</id>
    <updated>2023-03-20T18:00:00Z</updated>
    <published>2023-03-20T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;Java 20&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-20.html"&gt;1500 закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/20/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/20/apidiff/19/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/20/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 20.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;Паттерны записей (Second Preview) (JEP 432)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В паттерны записей, которые появились &lt;a href="https://openjdk.org/jeps/405"&gt;в Java 19&lt;/a&gt; в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; (и остающиеся в этом статусе в Java 20), было внесено три главные изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, добавилась поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей теперь могут присутствовать в заголовке улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; dump(Point[] pointArray) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) : pointArray) {
        System.out.println(&lt;span style="color: darkred"&gt;"("&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + y + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Примечание: эту возможность было решено удалить &lt;a href="https://openjdk.org/jeps/440"&gt;в Java 21&lt;/a&gt;, но она снова может появиться в будущем в другом JEP'е.&lt;/p&gt;

&lt;p class="pt-1"&gt;В-третьих, исчезла поддержка именованных паттернов записей. Это значит, что такой код, который компилировался в Java 19, в Java 20 уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) { &lt;span style="color: red"&gt;// Syntax error&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p&gt;Хотя именованные паттерны и исчезли в этом релизе, это не значит, что они исчезли насовсем. Возможно они появятся в одном из будущих релизов, когда будут более тщательно продуманы.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Fourth Preview) (JEP 433)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Это уже четвёртая итерация preview паттерн-матчинга в Java. Напомним, что предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;. В новой версии три главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, исчерпывающий &lt;code&gt;switch&lt;/code&gt; по перечислениям теперь выбрасывает &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/MatchException.html"&gt;&lt;code&gt;MatchException&lt;/code&gt;&lt;/a&gt;, а не &lt;code&gt;IncompatibleClassChangeError&lt;/code&gt;, если ни одна из меток &lt;code&gt;switch&lt;/code&gt; не сматчилась.&lt;/p&gt;

&lt;p&gt;Во-вторых, упростилась грамматика меток &lt;code&gt;switch&lt;/code&gt; в JLS.&lt;/p&gt;

&lt;p&gt;В-третьих, добавилась поддержка вывода типов в записях-дженериках, если они являются паттернами в &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;S, T&gt;(S first, T second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; recordInference(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; fst, &lt;span style="color: blue"&gt;var&lt;/span&gt; snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Как видите, здесь JEP 433 полностью согласуется с JEP 432.&lt;/p&gt;

&lt;p&gt;Паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; предлагается финализировать в Java 21 (&lt;a href="https://openjdk.org/jeps/440"&gt;JEP 440&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/441"&gt;JEP 441&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;Virtual Threads (Second Preview) (JEP 436)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые появились &lt;a href="https://openjdk.org/jeps/425"&gt;в Java 19&lt;/a&gt;, продолжают оставаться в статусе Preview API (предлагается финализировать их &lt;a href="https://openjdk.org/jeps/8303683"&gt;в Java 21&lt;/a&gt;). Изменений API, связанных с проектом &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;, в этом релизе нет (если не считать scoped values и structured concurrency, которые имеют &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационный статус&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;Scoped Values (Incubator) (JEP 429)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt;, который позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо больше количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;code&gt;where()&lt;/code&gt;. Далее вызывается метод &lt;code&gt;run()&lt;/code&gt;, на протяжении которого это значение можно получить (через метод &lt;code&gt;get()&lt;/code&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потоком не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;/p&gt;&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static final&lt;/span&gt; ScopedValue&amp;lt;Credentials&amp;gt; CREDENTIALS = new ScopedValue&lt;&gt;();

Credentials creds = ...
ScopedValue.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ScopedValue&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;
&lt;p&gt;На период инкубации новое API будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В Java 21 scoped values, скорее всего, &lt;a href="https://openjdk.org/jeps/8304357"&gt;станут preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;Structured Concurrency (Second Incubator) (JEP 437)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured concurrency, которое появилось &lt;a href="https://openjdk.org/jeps/428"&gt;в Java 19&lt;/a&gt;, остаётся в инкубационном статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; (вместе со &lt;code&gt;ScopedValue&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Единственное отличие от предыдущей версии API &amp;ndash; это то, что &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;StructuredTaskScope&lt;/a&gt; теперь поддерживает наследование scoped values потоками, созданными внутри области видимости задачи.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;Foreign Function &amp; Memory API (Second Preview) (JEP 434)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Основные изменения в этом релизе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemoryAddress&lt;/code&gt;. Теперь адреса моделируются через &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt; с нулевой длиной.&lt;/li&gt;
  &lt;li&gt;Улучшена иерархия &lt;code&gt;sealed&lt;/code&gt; интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;, чтобы лучше соответствовать паттерн-матчингу для &lt;code&gt;switch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemorySession&lt;/code&gt;. Он разделён на два интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/SegmentScope.html"&gt;&lt;code&gt;SegmentScope&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В Java 21 Foreign Function &amp; Memory API останется на &lt;a href="https://openjdk.org/jeps/442"&gt;третье preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/438"&gt;Vector API (Fifth Incubator) (JEP 438)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API всё никак не хочет становиться стабильным и остаётся в инкубационном статусе уже в пятый раз (модуль &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;). В этом релизе лишь небольшие исправления багов и улучшения производительности. Скорее всего, инкубационный статус будет оставаться до тех пор, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не появятся в режиме preview (проект &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; сильно зависит от проекта Valhalla).&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 20 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до сентября 2023 года). LTS-релизом станет следующая версия, &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #55</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_55.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_55.html</id>
    <updated>2023-03-05T18:00:00Z</updated>
    <published>2023-03-05T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а были предложены к попаданию в Java 21. Это &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;. Java 21 &amp;ndash; это &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;следующий LTS-релиз&lt;/a&gt; после Java 17, который должен выйти в сентябре 2023 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/438"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;, который сразу же &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-March/007404.html"&gt;был предложен&lt;/a&gt; к попаданию в Java 20. JEP появился с большим опозданием перед самым релизом из-за &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-February/007389.html"&gt;недопонимания&lt;/a&gt; со стороны владельца JEP'а. Сейчас эта ошибка была исправлена. Напомним, что общедоступная версия Java 20 выходит уже &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;через две недели&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло несколько новых черновиков JEP.&lt;/p&gt;
&lt;p&gt;Самые главные &amp;ndash; это &lt;a href="https://openjdk.org/jeps/8300541"&gt;Record Patterns&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8300542"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;. В них предлагается сделать паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; постоянными языковыми конструкциями. Напомним, что в Java 20 они будут всё ещё в статусе preview (&lt;a href="https://openjdk.java.net/jeps/432"&gt;JEP 432&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/433"&gt;JEP 433&lt;/a&gt;). Таким образом, в следующем LTS-релизе Java 21 планируется их &lt;a href="https://mail.openjdk.org/pipermail/amber-dev/2023-February/007841.html"&gt;финализировать&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В финальные версии конструкций предлагается внести следующие небольшие изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Паттерны, заключённые в скобки, поддерживаться не будут.&lt;/li&gt;
  &lt;li&gt;В &lt;code&gt;case&lt;/code&gt;-ветках будут разрешены квалифицированные константы перечислений (при условии, что эти константы совместимы по присваиванию с целевым типом).&lt;/li&gt;
  &lt;li&gt;Паттерны записей в заголовках цикла &lt;code&gt;for&lt;/code&gt; поддерживаться не будут. Однако они снова появятся в отдельном JEP'е.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Следующий черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303167"&gt;Deprecate the Windows x86-32 Port&lt;/a&gt;. Пометить как deprecated 32-битный порт JDK предлагается ради ускорения разработки платформы. Одной из мотиваций также является отсутствие нативной реализации &lt;a href="https://openjdk.org/jeps/436"&gt;виртуальных потоков&lt;/a&gt; на 32-битной Windows JDK. Также Windows 10 (последняя версия Windows, поддерживающая 32 бит) достигнет своей End of Life в &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;октябре 2025 года&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Ещё один черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303358"&gt;Scoped Values (Preview)&lt;/a&gt;. Таким образом, Scoped Values в Java 21 могут выйти из &lt;a href="https://openjdk.org/jeps/429"&gt;инкубационного статуса&lt;/a&gt; и стать preview. Про Scoped Values мы писали в &lt;a href="java_news_44.html"&gt;выпуске #44&lt;/a&gt;, когда они ещё назывались Extent-Local Variables.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Сайт поиска артефактов в Maven Central &lt;a href="https://search.maven.org"&gt;https://search.maven.org&lt;/a&gt; теперь стал перенаправлять на &lt;a href="https://central.sonatype.com"&gt;https://central.sonatype.com&lt;/a&gt;. На сайте Sonatype &lt;a href="https://central.sonatype.org/faq/what-happened-to-search-maven-org/"&gt;это объясняется&lt;/a&gt; тем, что central.sonatype.com уже покрывает главную функциональность search.maven.org, а также предоставляет больше деталей о компонентах, например, рейтинг безопасности. Кроме того, индекс поиска там обновляется гораздо чаще, чем на search.maven.org, а значит там более свежая и надёжная информация.&lt;/p&gt;
&lt;p&gt;Вернуться к старому сайту пока всё ещё можно, если нажать по &lt;a href="https://search.maven.org/?eh"&gt;соответствующей ссылке&lt;/a&gt; во всплывающем сообщении. Полное закрытие старого сайта планируется в конце 2023 - начале 2024 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blogs.apache.org/netbeans/#announce-apache-netbeans-17-released"&gt;Apache NetBeans 17&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jol-dev/2023-February/000509.html"&gt;JOL 0.17&lt;/a&gt;. Из основных изменений: минимальная версия Java теперь 8, добавлена поддержка Lilliput.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #54</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_54.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_54.html</id>
    <updated>2023-02-19T18:00:00Z</updated>
    <published>2023-02-19T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8302326"&gt;Implicit Classes and Enhanced Main Methods (Preview)&lt;/a&gt;. В нём предлагается сделать протокол запуска программ на Java более гибким, дав возможность программисту (в особенности новичку) опускать ненужные конструкции при написании простых программ, что поможет упростить вхождение в язык.&lt;/p&gt;
&lt;p&gt;Во-первых, модификатор &lt;code&gt;public&lt;/code&gt; и параметр &lt;code&gt;String[] args&lt;/code&gt; для метода &lt;code&gt;main()&lt;/code&gt; будут опциональными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, метод &lt;code&gt;main()&lt;/code&gt; не будет обязан быть статическим. Тогда JVM сама инстанцирует класс (для этого у него должен иметься не-private конструктор без аргументов) и вызовет метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, само объявление класса будет опциональным. В таком случае JVM сама создаст экземпляр безымянного неявного класса и вызовет &lt;code&gt;main()&lt;/code&gt; на нём:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Эти три упрощения помогут новичкам сфокусировать своё изучение языка на простых концепциях вроде объявлений переменных и циклов, а затем постепенно переходить к более сложным (классам, модификаторам доступа и статическим методам).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один черновик JEP: &lt;a href="https://openjdk.org/jeps/8299906"&gt;Support Markdown in Documentation Comments&lt;/a&gt;. В этом JEP'е предлагается добавить возможность писать JavaDoc на языке &lt;a href="https://commonmark.org/"&gt;Markdown&lt;/a&gt; вместо HTML. Markdown на сегодняшний день является очень популярным форматом написания документации, отличительной особенностью которого является простота синтаксиса и лёгкость чтения. Markdown трансформируется в HTML, но достаточно легко читаем и в сыром виде.&lt;/p&gt;
&lt;p&gt;Пример возможной документации на Markdown для &lt;code&gt;Object.hashCode()&lt;/code&gt; с использованием Markdown:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**md&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;Returns a hash code value for the object. This method is
&lt;span style="color: green"&gt; * &lt;/span&gt;supported for the benefit of hash tables such as those provided by
&lt;span style="color: green"&gt; * &lt;/span&gt;{&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; java.util.HashMap}.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;The general contract of &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; is:
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;-   Whenever it is invoked on the same object more than once during
&lt;span style="color: green"&gt; * &lt;/span&gt;    an execution of a Java application, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method
&lt;span style="color: green"&gt; * &lt;/span&gt;    must consistently return the same integer, provided no information
&lt;span style="color: green"&gt; * &lt;/span&gt;    used in &lt;span style="color: darkgreen"&gt;`equals`&lt;/span&gt; comparisons on the object is modified.
&lt;span style="color: green"&gt; * &lt;/span&gt;    This integer need not remain consistent from one execution of an
&lt;span style="color: green"&gt; * &lt;/span&gt;    application to another execution of the same application.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   If two objects are equal according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;    #equals(Object) equals} method, then calling the
&lt;span style="color: green"&gt; * &lt;/span&gt;    &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects must produce the
&lt;span style="color: green"&gt; * &lt;/span&gt;    same integer result.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   It is _not_ required that if two objects are unequal
&lt;span style="color: green"&gt; * &lt;/span&gt;    according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; #equals(Object) equals} method, then
&lt;span style="color: green"&gt; * &lt;/span&gt;    calling the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects
&lt;span style="color: green"&gt; * &lt;/span&gt;    must produce distinct integer results.  However, the programmer
&lt;span style="color: green"&gt; * &lt;/span&gt;    should be aware that producing distinct integer results for
&lt;span style="color: green"&gt; * &lt;/span&gt;    unequal objects may improve the performance of hash tables.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@implSpec&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;As far as is reasonably practical, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method defined
&lt;span style="color: green"&gt; * &lt;/span&gt;by class &lt;span style="color: darkgreen"&gt;`Object`&lt;/span&gt; returns distinct integers for distinct objects.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@return&lt;/b&gt;&lt;/span&gt;  a hash code value for this object.
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.Object#equals(java.lang.Object)
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.System#identityHashCode
&lt;span style="color: green"&gt; */&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.9.0/release-notes.html"&gt;Apache Maven 3.9.0&lt;/a&gt;. Самые заметные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Минимальная версия Java теперь 8. Это первое увеличение минимальной версии Java спустя 8 лет. В прошлый раз это был Maven &lt;a href="https://maven.apache.org/docs/3.3.1/release-notes.html"&gt;3.3.1&lt;/a&gt;, где минимальной версией стала Java 7.&lt;/li&gt;
  &lt;li&gt;Обратная совместимость с Maven 2.x окончательно убрана.&lt;/li&gt;
  &lt;li&gt;Теперь выдаются &lt;a href="https://issues.apache.org/jira/browse/MNG-7457"&gt;предупреждения&lt;/a&gt; об использовании deprecated плагинов, целей, параметров и т.д.&lt;/li&gt;
  &lt;li&gt;В консоли теперь пишутся префиксы плагинов вместо их &lt;code&gt;artifactId&lt;/code&gt; (например, &lt;code&gt;compiler:3.10.1:compile&lt;/code&gt; вместо &lt;code&gt;maven-compiler-plugin:3.10.1:compile&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Теперь можно вызывать цели через &lt;a href="https://issues.apache.org/jira/browse/MNG-7353"&gt;&lt;code&gt;mvn pluginPrefix:version:goal&lt;/code&gt;&lt;/a&gt;. Раньше это можно было делать либо через &lt;code&gt;mvn:pluginPrefix:goal&lt;/code&gt;, либо через &lt;code&gt;groupId:artifactId[:version]:goal&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Стала возможной активация профиля по типу &lt;code&gt;packaging&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список изменений и нововведений &lt;a href="https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316922&amp;version=12350913"&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/8.0/release-notes.html"&gt;Gradle 8.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел JetBrains &lt;a href="https://blog.jetbrains.com/idea/2023/02/java-annotated-monthly-february-2023/"&gt;Java Annotated Monthly за февраль&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #53</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_53.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_53.html</id>
    <updated>2023-01-29T18:00:00Z</updated>
    <published>2023-01-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-2-relnotes.html"&gt;JDK 19.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-6-relnotes.html"&gt;JDK 17.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020011.html"&gt;JDK 13.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020012.html"&gt;JDK 15.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-18-relnotes.html"&gt;JDK 11.0.18&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2023-January/016479.html"&gt;JDK 8u362&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8300786"&gt;No longer require &lt;code&gt;super()&lt;/code&gt; and &lt;code&gt;this()&lt;/code&gt; to appear first in a constructor&lt;/a&gt;. В нём предлагается разрешить писать инструкции кода до вызова &lt;code&gt;super()&lt;/code&gt; и &lt;code&gt;this()&lt;/code&gt; в конструкторах.&lt;/p&gt;
&lt;p&gt;Напомним, что сейчас эти вызовы всегда должны быть первыми вызовами в конструкторах, иначе код не скомпилируется:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (value &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value); &lt;span style="color: red"&gt;// error: call to super must be first statement in constructor&lt;/span&gt;
    }
}&lt;/pre&gt;
&lt;p&gt;Такое ограничение иногда создаёт неудобства, например, при необходимости проверять входные аргументы до вызова суперконструктора (как в примере выше), при передаче одного и того же вычисляемого параметра в суперконструктор несколько раз или при нетривиальной подготовке параметра перед передачей его в суперконструктор.&lt;/p&gt;
&lt;p&gt;JEP предлагает это ограничение снять и позволить писать инструкции до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;. Однако для кода до вызова остаётся ограничение, что он должен быть в статическом контексте, то есть не должен ссылаться на текущий объект явно или неявно (использовать &lt;code&gt;this&lt;/code&gt;, вызывать нестатические методы и так далее).&lt;/p&gt;
&lt;p&gt;Любопытно, что в спецификации JVM подобного ограничения нет, и она разрешает произвольный код до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;, если он не ссылается на конструируемый объект. Таким образом, предлагаемое изменение будет чисто языковым изменением, без необходимости менять что-то в виртуальной машине.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Черновик JEP "Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns", о котором мы писали в &lt;a href="java_news_49.html"&gt;выпуске #49&lt;/a&gt;, был переименован в &lt;a href="https://openjdk.org/jeps/8288476"&gt;"Primitive types in patterns, &lt;code&gt;instanceof&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;"&lt;/a&gt;. Добавилось важное дополнение, что примитивные типы смогут появляться в ветках &lt;code&gt;switch&lt;/code&gt;. Например:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (i) {
    &lt;span style="color: blue"&gt;case byte&lt;/span&gt; b -&gt; ... ;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; ... ;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;p&gt;Кроме того, список типов константных выражений в ветках будет расширен до всех примитивных типов, включая &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;boolean&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.0f -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.5f -&gt; ...
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; g -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; x = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (x) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 10_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 20_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; ...
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Oracle &lt;a href="https://houseofbrick.com/blog/oracle-java-pricing/"&gt;изменила правила&lt;/a&gt; платной подписки на Java SE. Теперь единицей, по которой рассчитывается стоимость, становится сотрудник компании, а не процессор. Таким образом, теперь на цену подписки влияет только количество сотрудников, а не количество серверов и настольных компьютеров, на которых запущена Java (если только у вас не больше 50000 процессоров на серверах). Это приведёт к подорожанию подписки для большинства случаев. В некоторых случаях такой рост будет на порядок.&lt;/p&gt;
&lt;p&gt;Напомним, что Java была и остаётся свободным ПО, и вышеупомянутое изменение ценовой политики Oracle никак не повлияет на пользователей &lt;a href="https://openjdk.org/"&gt;OpenJDK&lt;/a&gt;, которая продолжает оставаться бесплатной. Останется бесплатной и &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;Oracle JDK 17&lt;/a&gt;, в том числе и для коммерческого использования. Повышение тарифных планов коснётся только компаний, имеющих &lt;a href="https://www.oracle.com/java/java-se-subscription/#rc30p3"&gt;Oracle Java SE Universal Subscription&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #52</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_52.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_52.html</id>
    <updated>2023-01-17T18:00:00Z</updated>
    <published>2023-01-17T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://kotlinlang.org/docs/whatsnew18.html"&gt;Kotlin 1.8.0&lt;/a&gt;. Некоторые заметные нововведения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новые экспериментальные функции &lt;code&gt;copyToRecursively()&lt;/code&gt; and &lt;code&gt;deleteRecursively()&lt;/code&gt; для директорий.&lt;/li&gt;
  &lt;li&gt;Улучшенная производительность kotlin-reflect.&lt;/li&gt;
  &lt;li&gt;Новая опция &lt;code&gt;-Xdebug&lt;/code&gt;, подавляющая оптимизации, для более удобной отладки.&lt;/li&gt;
  &lt;li&gt;Больше не поддерживается таргетирование в байткод 1.6 и 1.7. Вследствие этого, стандартные библиотеки скомпилированы только в 1.8, и более нет разделения на &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, а есть единый &lt;code&gt;kotlin-stdlib&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Улучшена интероперабельность с Objective-C/Swift.&lt;/li&gt;
  &lt;li&gt;Совместимость с Gradle 7.3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/01/java-annotated-monthly-january-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за январь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/maven/releases/tag/maven-3.8.7"&gt;Apache Maven 3.8.7&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/mockito/mockito/releases/tag/v5.0.0"&gt;Mockito 5.0.0&lt;/a&gt;. Новая версия библиотеки требует Java 11 в качестве минимальной версии.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #51</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_51.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_51.html</id>
    <updated>2022-12-25T18:00:00Z</updated>
    <published>2022-12-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 перешёл в &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-December/007233.html"&gt;первую фазу Rampdown&lt;/a&gt;. Окончательный список JEP'ов, которые попадут в релиз, следующий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;JEP 433: Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Fourth Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK предложен &lt;a href="https://mail.openjdk.org/pipermail/discuss/2022-December/006164.html"&gt;новый проект Galahad&lt;/a&gt;, целью которого будет внедрение в OpenJDK технологий GraalVM, связанных с Java, а именно JIT-компилятора GraalVM (полностью написанного на Java) в качестве альтернативы существующему JIT-компилятору HotSpot. Затем, следующим шагом будет использование AOT-компилятора GraalVM для компиляции JIT-компилятора, а позднее &amp;ndash; портирование Native Image в качестве общего решения для любых Java-приложений.&lt;/p&gt;
&lt;p&gt;Напомним, что GraalVM уже однажды был частью OpenJDK (с &lt;a href="https://openjdk.org/jeps/317"&gt;Java 10&lt;/a&gt; по &lt;a href="https://openjdk.org/jeps/410"&gt;Java 16&lt;/a&gt;) в качестве экспериментальной технологии, но был убран из-за сложности поддержки и малой используемости. Новой целью будет превращение GraalVM в downstream-репозиторий (GraalVM EE и CE будут полностью основаны на исходном коде OpenJDK), а значит, не будет проблемы дублирования усилий.&lt;/p&gt;
&lt;p class="pt-1"&gt;Также стали известны &lt;a href="https://medium.com/graalvm/graalvm-galahad-and-a-new-release-schedule-d081d1031bba"&gt;подробности&lt;/a&gt; относительно согласования релизных циклов GraalVM и OpenJDK: начиная с JDK 20, GraalVM будет выходить 2 раза в год (а не 4, как раньше). Следующая версия GraalVM выйдет одновременно с JDK 20 в марте и будет называться &lt;i&gt;GraalVM for JDK 20&lt;/i&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=jJau4kUoLrA"&gt;Eclipse 2022-12&lt;/a&gt;. Что нового появилось в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка Java 19, включая экспериментальные возможности (паттерны записей и паттер-матчинг для &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Более умный &lt;i&gt;Extract Local Variable&lt;/i&gt;, учитывающий проверки на &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Три новых quick fixes для классов: &lt;i&gt;Create getters and setters&lt;/i&gt;, &lt;i&gt;Create &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;&lt;/i&gt; и &lt;i&gt;Create &lt;code&gt;toString()&lt;/code&gt;&lt;/i&gt;.&lt;/li&gt;
  &lt;li&gt;Галочка &lt;i&gt;Automatically update Maven projects configuration&lt;/i&gt; больше не является экспериментальной и включена по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшение редактора XML: автоматическая вставка закрывающего XML-элемента и удаление закрывающего XML-элемента, если вставляется символ &lt;code&gt;/&lt;/code&gt; в конец открывающего элемента.&lt;/li&gt;
  &lt;li&gt;Поддержка RelaxNG в качестве языка схемы XML (в дополнение к существующим DTD и XSD).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse/microprofile/releases/tag/6.0"&gt;MicroProfile 6.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.0"&gt;GlassFish 7&lt;/a&gt;, поддерживающий спецификацию Jakarta EE 10.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.infoq.com/news/2022/12/resilience4j-2-0-0"&gt;Resilience4j 2.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #50</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_50.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_50.html</id>
    <updated>2022-12-04T18:00:00Z</updated>
    <published>2022-12-04T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 20 пополнился ещё четырьмя JEP'ами:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007215.html"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007223.html"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007225.html"&gt;JEP 429: Scoped Values (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007224.html"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, на текущий момент у Java 20 шесть JEP'ов, и только один из них &amp;ndash; это полностью новая фича (Scoped Values), а не следующая итерация уже существующей. До первый фазы Rampdown &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-October/007108.html"&gt;остаётся 3 дня&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/11/intellij-idea-2022-3/"&gt;IntelliJ IDEA 2022.3&lt;/a&gt;. Перечислим некоторые нововведения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый полностью переработанный Look &amp; Feel, который можно включить в настройках (галочка &lt;i&gt;Enable new UI&lt;/i&gt; во вкладке &lt;i&gt;New UI Preview&lt;/i&gt;).&lt;/li&gt;
  &lt;li&gt;Возможность синхронизации настроек между устройствами (Settings Sync).&lt;/li&gt;
  &lt;li&gt;Новый способ автоподстановки бинов Spring, Micronaut и Jakarta EE CDI (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Автогенерация схемы OpenAPI из контроллера Spring или ресурса JAX-RS (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Поддержка Redis (только Ultimate).&lt;/li&gt;
  &lt;li&gt;Возможность пристыковывать окна инструментов к плавающим вкладкам редакторов.&lt;/li&gt;
  &lt;li&gt;Предпросмотр результата Intention action теперь включён по умолчанию.&lt;/li&gt;
  &lt;li&gt;Улучшенный UX в Search Everywhere.&lt;/li&gt;
  &lt;li&gt;Категоризация результатов в Find Usages по сходству использований.&lt;/li&gt;
  &lt;li&gt;Улучшенные Tips of the Day.&lt;/li&gt;
  &lt;li&gt;Улучшенные Bookmarks&lt;/li&gt;
  &lt;li&gt;Возможность просмотра кода библиотек в предпочитаемом стиле с переформатированием.&lt;/li&gt;
  &lt;li&gt;Улучшения производительности (старт и отзывчивость UI).&lt;/li&gt;
  &lt;li&gt;Новые инспекции Java (похожие инструкции в &lt;code&gt;switch&lt;/code&gt;, лишние проверки на длины массивов, ненужный &lt;code&gt;stream.parallel()&lt;/code&gt; и т.д.).&lt;/li&gt;
  &lt;li&gt;Поддержка синтаксических возможностей Java 19 (паттерны записей и изменения в паттерн-матчинге &lt;code&gt;switch&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;В режиме отладки: если анализатор может предсказать, что ветка не будет исполнена, то она окрашивается в серый цвет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/12/java-annotated-monthly-december-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за декабрь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/11/24/spring-boot-3-0-goes-ga"&gt;Spring Boot 3.0&lt;/a&gt;. Главные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется Spring 6.0.&lt;/li&gt;
  &lt;li&gt;Java 17 &amp;ndash; минимальная версия.&lt;/li&gt;
  &lt;li&gt;Генерация нативных образов GraalVM.&lt;/li&gt;
  &lt;li&gt;Улучшения в observability через Micrometer и Micrometer Tracing.&lt;/li&gt;
  &lt;li&gt;Полный переход от Java EE к Jakarta EE. Jakarta EE 9 &amp;ndash; минимальная версия. Есть поддержка Jakarta EE 10.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v2.9"&gt;Async Profiler 2.9&lt;/a&gt; с новым профайлером утечек в куче.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #49</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_49.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_49.html</id>
    <updated>2022-11-20T18:00:00Z</updated>
    <published>2022-11-20T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а предложены к выходу в &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;JDK 20&lt;/a&gt;. Это &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007198.html"&gt;432: Record Patterns (Second Preview)&lt;/a&gt; и &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-November/007199.html"&gt;433: Pattern Matching for switch (Fourth Preview)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли два новых JEP'а. Это &lt;a href="https://openjdk.org/jeps/436"&gt;JEP 436: Virtual Threads (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел черновик JEP: &lt;a href="https://openjdk.org/jeps/8288476"&gt;Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns&lt;/a&gt;. В нём предлагается расширить возможности оператора &lt;code&gt;instanceof&lt;/code&gt; и паттернов типов, позволив делать проверки не только для ссылочных, но и для примитивных типов:&lt;/p&gt;
&lt;pre&gt;Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) {
    ...
}&lt;/pre&gt;
&lt;p&gt;В случае сужающей конверсии такие тесты будут дополнительно проверять, проходит ли конверсия без потери точности. Например, в данном случае условие не выполнится, потому что &lt;code&gt;500&lt;/code&gt; не попадает в диапазон &lt;code&gt;byte&lt;/code&gt; (от &lt;code&gt;-128&lt;/code&gt; до &lt;code&gt;127&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 500;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) {
    &lt;span style="color: green"&gt;// Не будет выполнено&lt;/span&gt;
    ...
}&lt;/pre&gt;
&lt;p&gt;А в данном примере условие выполнится, потому что &lt;code&gt;500&lt;/code&gt; попадает в диапазон &lt;code&gt;short&lt;/code&gt; (от &lt;code&gt;-32678&lt;/code&gt; до &lt;code&gt;32677&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 500;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof short&lt;/span&gt; s) {
    &lt;span style="color: green"&gt;// Выполнится&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/11/16/spring-framework-6-0-goes-ga"&gt;Spring 6.0&lt;/a&gt;. Новая версия фреймворка требует Java 17 и использует пространство имён Jakarta EE 9+ (&lt;code&gt;jakarta.*&lt;/code&gt;). При этом есть поддержка API Jakarta EE 10, например, &lt;a href="https://jakarta.ee/specifications/servlet/6.0/"&gt;Jakarta Servlet 6.0&lt;/a&gt; и &lt;a href="https://jakarta.ee/specifications/persistence/3.1/"&gt;Jakarta Persistence 3.1&lt;/a&gt;. Это позволяет использовать последние веб-контейнеры, такие как Tomcat 10.1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.wildfly.org/news/2022/11/09/WildFly27-Final-Released/"&gt;WildFly 27&lt;/a&gt; с поддержкой Jakarta EE 10.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jmh-dev/2022-November/003553.html"&gt;JMH 1.36&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #48</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_48.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_48.html</id>
    <updated>2022-11-06T18:00:00Z</updated>
    <published>2022-11-06T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли два новых JEP.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="https://openjdk.org/jeps/434"&gt;JEP 434: Foreign Function &amp; Memory API (Second Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Второй &amp;ndash; &lt;a href="https://openjdk.org/jeps/435"&gt;JEP 435: Asynchronous Stack Trace VM API&lt;/a&gt;. В нём предлагается добавить в JDK публичное и хорошо протестированное нативное API для получения стек-трейсов с возможностью асинхронного использования. В OpenJDK уже существует API &lt;code&gt;AsyncGetCallTrace&lt;/code&gt;, которое широко используется во многих профилировщиках (например, &lt;a href="https://github.com/jvm-profiling-tools/async-profiler"&gt;async-profiler&lt;/a&gt;), но это API является внутренним и не поддерживает нативные фреймы. JEP 435 предлагает ввести новый метод &lt;code&gt;AsyncGetStackTrace&lt;/code&gt;, который будет экспортирован в заголовке &lt;code&gt;include/profile.h&lt;/code&gt; и будет иметь возможность включать фреймы C/C++ в результат.&lt;/p&gt;
&lt;p class="pt-1"&gt;Кроме того, ещё вышло два новых черновика JEP: &lt;a href="https://openjdk.org/jeps/8295817"&gt;Virtual Threads (Second Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8296037"&gt;Structured Concurrency (Second Incubator)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На сайте Oracle стали публиковаться &lt;a href="https://jdk.java.net/javafx20/"&gt;ранние сборки JavaFX 20&lt;/a&gt;. Скачать можно как JavaFX SDK, так и файлы JMOD.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JUG.ru &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b8OCdXV_tqP8YrMIlgB_BER"&gt;выложил&lt;/a&gt; доклады с конференции JPoint 2022.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.14"&gt;Jackson 2.14&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
</feed>
