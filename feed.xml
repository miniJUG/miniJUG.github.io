<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-07-17T17:00:00Z</updated>
  <entry>
    <title>Новости Java #23</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_23.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_23.html</id>
    <updated>2021-07-17T17:00:00Z</updated>
    <published>2021-07-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 17 перешла во &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-July/005758.html"&gt;вторую фазу Rampdown&lt;/a&gt;. Теперь в релиз могут приниматься только критические баги с приоритетом P1 или P2.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK начата &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-July/005846.html"&gt;предварительная дискуссия&lt;/a&gt; по созданию проекта, целью которого будет поддержка в Java сервера дисплея Wayland в Linux. &lt;a href="https://ru.wikipedia.org/wiki/Wayland"&gt;Wayland&lt;/a&gt; является современной заменой сервера X11 и уже включён по умолчанию в некоторых дистрибутивах, например &lt;a href="https://www.opennet.ru/opennews/art.shtml?num=54481"&gt;Ubuntu 21.04&lt;/a&gt; и &lt;a href="https://www.opennet.ru/opennews/art.shtml?num=50644"&gt;RHEL 8&lt;/a&gt;. Так как Linux с графическим интерфейсом является популярным выбором многих разработчиков Java, поддержка Wayland будет иметь большую важность для них.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Компания JetBrains выпустила свой ежегодный отчёт &lt;a href="https://blog.jetbrains.com/blog/2021/07/16/the-state-of-developer-ecosystem-2021/"&gt;&amp;laquo;Состояние экосистемы разработки&amp;raquo;&lt;/a&gt;. В этом году в опросе участвовало более 30 тысяч разработчиков из 183 стран. Перечислим некоторые интересные результаты:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Самый популярный язык &amp;ndash; JavaScript. Его использовали 69% опрошенных в течение последних 12 месяцев (Java использовали 49%). Также он является и самым популярным в качестве основного языка разработки (39% против 32% у Java).&lt;/li&gt;
  &lt;li&gt;Kotlin пока что не попадает в первую десятку, однако имеет неплохой результат: с точки зрения общей распространённости он на 13-м месте (14%), а в как основной язык &amp;ndash; на 11-м (7%). Также Kotlin является самым желаемым языком для перехода с Java: в ближайшие 12 месяцев на него хотят перейти 13% разработчиков Java. Кроме того, Kotlin в пятёрке желаемых для перехода со всех языков (вместе с Go, TypeScript, Python и Rust).&lt;/li&gt;
  &lt;li&gt;Популярность Scala падает уже третий год подряд: в 2019 её использовали 6%, в 2020 &amp;ndash; 5%, в 2021 &amp;ndash; 3%.&lt;/li&gt;
  &lt;li&gt;Количество сотрудников, работающих удалённо, возрасло с 20% (в начале 2020) до 70%.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://quarkus.io/blog/quarkus-2-0-0-final-released/"&gt;Quarkus 2.0&lt;/a&gt;. В новой версии был осуществлён переход на JDK 11, Vert.x 4, Eclipse MicroProfile 4, GraalVM 21.1, а также внесено множество других изменений. Также пока готовился этот недельный выпуск, вышли багфикс-релизы &lt;a href="https://quarkus.io/blog/quarkus-2-0-1-final-released/"&gt;2.0.1&lt;/a&gt; и &lt;a href="https://quarkus.io/blog/quarkus-2-0-2-final-released/"&gt;2.0.2&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.sonarqube.org/sonarqube-9-0/"&gt;SonarQube 9.0&lt;/a&gt; с поддержкой Bitbucket Cloud, GitHub Actions, C++ 20, Java 16, более точно анализа и многого другого.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/blog/2021/07/15/new-tool-pages-improved-performance-refreshed-ui-and-more-in-toolbox-app-1-21/"&gt;JetBrains ToolBox 1.21&lt;/a&gt;. Это первый релиз ToolBox, который написан полностью на чистом Kotlin, с использованием фреймворка &lt;a href="https://www.jetbrains.com/lp/compose/"&gt;Compose for Desktop&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/07/14/spring-framework-5-3-9-and-5-2-16-available-now"&gt;Spring Framework 5.3.9 и 5.2.16&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Spring Boot &lt;a href="https://spring.io/blog/2021/06/24/spring-boot-2-5-2-is-now-available"&gt;2.5.2&lt;/a&gt; и &lt;a href="https://spring.io/blog/2021/06/24/spring-boot-2-4-8-is-now-available"&gt;2.4.8&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/06/22/spring-security-5-5-1-5-4-7-5-3-10-and-5-2-11-released"&gt;Spring Security 5.5.1, 5.4.7, 5.3.10 и 5.2.11&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/06/14/spring-native-0-10-0-available-now"&gt;Spring Native 0.10.0&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/06/22/spring-data-2021-0-2-and-2020-0-10-released"&gt;Spring Data 2021.0.2 и 2020.0.10&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/06/25/spring-integration-zip-2-0-0-available"&gt;Spring Integration Zip 2.0.0&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/07/09/spring-authorization-server-0-1-2-available-now"&gt;Spring Authorization Server 0.1.2&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/nashorn-dev/2021-July/007639.html"&gt;Nashorn 15.3&lt;/a&gt; с поддержкой Java 17.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #22</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_22.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_22.html</id>
    <updated>2021-06-27T17:00:00Z</updated>
    <published>2021-06-27T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/eclipse/news/4.20/"&gt;Eclipse 2021-06&lt;/a&gt;. Что нового появилось в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Языковая поддержка Java 16: &lt;a href="https://openjdk.java.net/jeps/394"&gt;паттерн-матчинг для &lt;code&gt;instanceof&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/395"&gt;записи&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/397"&gt;&lt;code&gt;sealed&lt;/code&gt;-классы (preview)&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Новый quick fix для объявления переменной в цикле &lt;code&gt;foreach&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;12 новых действий clean up.&lt;/li&gt;
  &lt;li&gt;Отображение значения полей в цепочке при отладке, то есть при наведении на &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; в &lt;code&gt;a.b.c&lt;/code&gt; показывается значение &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;А также общие улучшения в IDE, плагине для Git и в других подсистемах.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; В 2021 году разработчики впервые стали больше использовать Java 11, чем Java 8. Такими данными поделилась компания Snyk в своём ежегодном отчёте &lt;a href="https://foojay.io/today/new-jvm-ecosystem-report-2021-has-arrived/"&gt;"JVM Ecosystem Survey" за 2021 год&lt;/a&gt;. Snyk проводила опрос совместно с Azul с февраля по март 2021 года среди более чем 2 тысяч разработчиков Java.&lt;/p&gt;
&lt;p&gt;Как показывают результаты опроса, в продуктовых окружениях Java 11 использует 61.5% респондентов, что на 1.6% больше, чем Java 8. При этом последние версии Java (14 и 15 на момент опроса) имеют цифры 4.9% и 11.7% соответственно. Это существенно больше, чем постепенно уходящие в небытие Java 6 и 7, которые имеют всего 1.9% и 3.8%.&lt;/p&gt;
&lt;p&gt;В разработке же новые версии имеют ещё большую популярность: Java 11 использует 64.3% респондентов против 50.1% у Java 8. Java 15 использует 25.6% опрошенных.&lt;/p&gt;
&lt;p&gt;В отчёте также присутствует множество других интересных данных, например:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Наиболее популярный дистрибутив JDK &amp;ndash; AdoptOpenJDK (44.1%). Второе место у Oracle OpenJDK (28%).&lt;/li&gt;
  &lt;li&gt;Kotlin &amp;ndash; второй популярный язык после Java (17.7% и 91% соответственно). Groovy использует 13% опрошенных.&lt;/li&gt;
  &lt;li&gt;IntelliJ IDEA &amp;ndash; с большим отрывом самая популярная IDE (71.6%). Следующий идёт Eclipse, у которого всего 24.6%.&lt;/li&gt;
  &lt;li&gt;Среди билд-систем больше всего используется Maven (76.2%). У Gradle цифра более скромная &amp;ndash; 38.1%.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Из Java окончательно &lt;a href="https://github.com/openjdk/jdk/pull/4522"&gt;удалили код&lt;/a&gt;, отвечающий за biased locking. Ранее в Java 15 biased locking был &lt;a href="https://openjdk.java.net/jeps/374"&gt;отключен по умолчанию&lt;/a&gt; и стал deprecated. Сейчас же он удалён окончательно, и с Java 18 опция -XX:+UseBiasedLocking станет несуществующей.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+28&lt;/a&gt; и &lt;a href="http://jdk.java.net/18/"&gt;JDK 18-ea+3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/core-libs-dev/2021-June/079414.html"&gt;ASM 9.2&lt;/a&gt; с поддержкой Java 18.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.wildfly.org/news/2021/06/17/WildFly24-Final-Released/"&gt;WildFly 24&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #21</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_21.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_21.html</id>
    <updated>2021-06-14T17:00:00Z</updated>
    <published>2021-06-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 17 перешёл в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-June/005690.html"&gt;первую фазу Rampdown&lt;/a&gt;. Это значит, что JDK 17 форкнут в отдельный &lt;a href="https://github.com/openjdk/jdk17"&gt;стабилизационный репозиторий&lt;/a&gt;, и в релиз больше не будут приниматься никакие новые JEP'ы.&lt;/p&gt;
&lt;p&gt;Кроме того, стало известно, что &lt;a href="https://openjdk.java.net/jeps/406"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt; был интегрирован в Java 17 и попал в последнюю сборку &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+26&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также вышла первая сборка &lt;a href="http://jdk.java.net/18/"&gt;JDK 18-ea+1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="http://openjdk.java.net/jeps/8261529"&gt;JEP: Universal Generics (Preview)&lt;/a&gt;. Это очередной JEP по проекту &lt;a href="http://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;, и в нём предлагается расширить пространство всех переменных типов в дженериках до всех типов, то есть не только ссылочных типов, но и примитивных типов значений. Это означает, что для компилятора Java больше не будет ошибкой, если указать примитивы в качестве типов-параметров (например, List&amp;lt;int&amp;gt;). При этом, если в generic коде переменной типа будет присвоен &lt;code&gt;null&lt;/code&gt;, то компилятор будет выдавать предупреждение:&lt;/p&gt;
&lt;pre&gt;class C&amp;lt;T&amp;gt; {
    T x = null; &lt;span style="color: orange"&gt;// warning: null assignment&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Таким образом, компилятор предупреждает разработчика о том, что может произойти &lt;code&gt;null&lt;/code&gt;-загрязнение, то есть если переменная &lt;code&gt;T&lt;/code&gt; окажется value-типом, то в ней будет находиться несовместимое значение, что в дальнейшем может привеcти к NullPointerException:&lt;/p&gt;
&lt;pre&gt;C&amp;lt;Point&amp;gt; c = new C&amp;lt;Point&amp;gt;();
Point p = c.x; &lt;span style="color: red"&gt;// NPE&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Такая стратегия означает, что весь существующий код дженериков будет продолжать компилироваться, и лишь в некоторых местах будут предупреждения, которые сопроводитель кода сможет исправить постепенно.&lt;/p&gt;
&lt;p&gt;Важно отметить, что в данном JEP речи о специализации дженериков времени выполнения пока не идёт, и дженерики будут продолжать компилироваться в байткод через стирание типов (erasure), то есть во время выполнения дженерики с value-типами будут работать как ссылочные типы. JEP про специализацию будет опубликован в будущем.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; У инструмента &lt;code&gt;jar&lt;/code&gt;, который входит в состав JDK, появилась новая опция &lt;a href="https://github.com/openjdk/jdk/pull/3971"&gt;&lt;code&gt;--validate&lt;/code&gt;&lt;/a&gt;. Она служит для валидации &lt;a href="https://openjdk.java.net/jeps/238"&gt;multi-release JAR-файлов&lt;/a&gt;: делает анализ экспортированных API для каждой из декларированных версий Java и проверяет, что они согласованны. Такой анализ проводился и ранее при создании или обновлении JAR-файлов, но теперь его можно выполнить отдельным действием.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В блоге JetBrains вышел &lt;a href="https://blog.jetbrains.com/idea/2021/06/java-annotated-monthly-june-2021/"&gt;Java Annotated Monthly за июнь 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2021/06/09/spring-framework-5-3-8-available-now"&gt;Spring Framework 5.3.8&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.1/release-notes.html"&gt;Gradle 7.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #20</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_20.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_20.html</id>
    <updated>2021-06-05T17:00:00Z</updated>
    <published>2021-06-05T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Началась разработка Java 18. В репозитории GitHub &lt;a href="https://github.com/openjdk/jdk/pull/4175/commits"&gt;появился пулл-реквест&lt;/a&gt; со стандартными процедурами, которые проводятся при старте нового релиза: добавление новых констант с версиями, таблиц символов, заголовков в файлах и т.д. Новая версия формата class-файлов будет равна 62.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик JEP, связанный с проектом &lt;a href="https://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/401"&gt;примитивными объектами&lt;/a&gt;: &lt;a href="http://openjdk.java.net/jeps/8267650"&gt;Better-defined JVM class file validation&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В &lt;a href="https://openjdk.java.net/jeps/411"&gt;JEP 411: Deprecate the Security Manager for Removal&lt;/a&gt; были внесены &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-May/005616.html"&gt;важные изменения&lt;/a&gt;. Значение свойства &lt;code&gt;java.security.manager&lt;/code&gt; всё-таки предлагается по умолчанию оставить равным &lt;code&gt;allow&lt;/code&gt;, а не &lt;code&gt;disallow&lt;/code&gt;, что означает, что при вызове &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"&gt;&lt;code&gt;System.setSecurityManager()&lt;/code&gt;&lt;/a&gt; будет выводиться предупреждение в консоль, а не выбрасываться &lt;code&gt;UnsupportedOperationException&lt;/code&gt;. Таким образом, приложения, которые используют &lt;code&gt;setSecurityManager()&lt;/code&gt;, будут продолжать работать на Java 17 без изменений, что &lt;a href="https://blogs.apache.org/netbeans/entry/jep-411-deprecate-the-security1"&gt;облегчит&lt;/a&gt; их миграцию.&lt;/p&gt;
&lt;p&gt;Однако значение свойства &lt;code&gt;java.security.manager&lt;/code&gt; всё-таки станет равным &lt;code&gt;disallow&lt;/code&gt;, но это произойдёт в Java 18.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK продолжается обсуждение темы &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2021-June/001533.html"&gt;абстрактности класса Object&lt;/a&gt;. На данный момент предлагается следующее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Будет введён новый метод &lt;code&gt;IdentityObject::newIdentity&lt;/code&gt; (Б.Гетц предлагает &lt;code&gt;Objects::newIdentity&lt;/code&gt;), который будет возвращать объект некоторого внутреннего класса, реализующего интерфейс &lt;code&gt;IdentityObject&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;JVM будет заменять вызовы &lt;code&gt;new Object()&lt;/code&gt; на создание объекта, реализующего &lt;code&gt;IdentityObject&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;javac будет заменять вызовы &lt;code&gt;new Object()&lt;/code&gt; на &lt;code&gt;IdentityObject.newIdentity()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Такая стратегия позволит постепенно перейти от возможности вызова &lt;code&gt;new Object()&lt;/code&gt; до его полного запрета в будущем.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Программисты из Amazon предлагают порассуждать о возможности &lt;a href="https://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2021-May/047486.html"&gt;реализации Partial Escape Analysis&lt;/a&gt; в Hotspot.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://jakarta.ee/news/jakarta-ee-9-1-released/"&gt;Jakarta EE 9.1&lt;/a&gt; с поддержкой Java 11. Также вышел &lt;a href="https://github.com/eclipse-ee4j/glassfish/releases/tag/6.1.0"&gt;Eclipse GlassFish 6.1.0&lt;/a&gt;, который соответствует спецификации Jakarta EE 9.1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2021/06/02/hibernate-orm-550-final-release/"&gt;Hibernate 5.5.0.Final&lt;/a&gt;. Вместе с обычными артефактами в пространстве имён &lt;code&gt;javax&lt;/code&gt; теперь появились аналогичные артефакты в пространстве имён &lt;code&gt;jakarta&lt;/code&gt;. Например, у Hibernate Core есть две версии: &lt;a href="https://search.maven.org/artifact/org.hibernate/hibernate-core/5.5.0.Final/jar"&gt;hibernate-core&lt;/a&gt; и &lt;a href="https://search.maven.org/artifact/org.hibernate/hibernate-core-jakarta/5.5.0.Final/jar"&gt;hibernate-core-jakarta&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+25&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+7&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://netbeans.apache.org/download/nb124/nb124.html"&gt;NetBeans 12.4&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/06/intellij-idea-2021-1-2/"&gt;IntelliJ IDEA 2021.1.2&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-May/003307.html"&gt;JMH 1.32&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #19</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_19.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_19.html</id>
    <updated>2021-05-22T17:00:00Z</updated>
    <published>2021-05-22T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Языку Java исполнилось 26 лет. 23 мая 1995 года компания Sun Microsystems впервые официально представила платформу Java, имевшую версию 1.0a2.&lt;/p&gt;
&lt;p&gt;В честь дня рождения будет проведён онлайн-марафон &lt;a href="https://nipafx.dev/26h-java/"&gt;"26 Hours of Java"&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Разработка &lt;a href="http://openjdk.java.net/projects/jdk/17/"&gt;Java 17&lt;/a&gt; идёт полным ходом, и количество JEP'ов в этом релизе прибавилось сразу на семь штук.&lt;/p&gt;
&lt;p&gt;Запланированы:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/412"&gt;JEP 412: Foreign Function &amp; Memory API (Incubator)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/414"&gt;JEP 414: Vector API (Second Incubator)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Предложены:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/306"&gt;JEP 306: Restore Always-Strict Floating-Point Semantics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/403"&gt;JEP 403: Strongly Encapsulate JDK Internals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/406"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/407"&gt;JEP 407: Remove RMI Activation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/411"&gt;JEP 411: Deprecate the Security Manager for Removal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Брайан Гетц написал &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-May/002996.html"&gt;письмо в рассылку OpenJDK&lt;/a&gt;, где он описал прогресс, которого в итоге удалось достигнуть в расширении возможностей оператора &lt;code&gt;switch&lt;/code&gt;. Он рассказал, каким образом удалось решить проблемы с тотальностью, проваливанием (fallthrough), областями видимости и &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+23&lt;/a&gt;, &lt;a href="https://jdk.java.net/panama/"&gt;JDK 17-panama+3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Ещё один день рождения празднует &lt;a href="https://en.wikipedia.org/wiki/Hibernate_(framework)"&gt;Hibernate&lt;/a&gt;. Его первая версия вышла ровно 20 лет назад, 23 мая 2001 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/20/spring-boot-2-5-is-now-ga"&gt;Spring Boot 2.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/18/spring-security-5-5-goes-ga"&gt;Spring Security 5.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/19/spring-integration-5-5-goes-ga"&gt;Spring Integration 5.5 и 5.4.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/19/spring-batch-4-2-7-and-4-3-3-are-out"&gt;Spring Batch 4.2.7 и 4.3.3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/17/spring-amqp-2-2-17-releae-2-3-7-available"&gt;Spring AMQP 2.2.17 и 2.3.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/14/spring-ldap-2-3-4-released"&gt;Spring LDAP 2.3.4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/05/14/spring-data-2021-0-1-and-2020-0-9-released"&gt;Spring Data 2021.0.1 and 2020.0.9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spockframework.org/spock/docs/2.0/release_notes.html"&gt;Spock 2.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jol-dev/2021-May/000369.html"&gt;JOL 0.16&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #18</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_18.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_18.html</id>
    <updated>2021-05-16T17:00:00Z</updated>
    <published>2021-05-16T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышла &lt;a href="https://scala-lang.org/blog/2021/05/14/scala3-is-here.html"&gt;Scala 3&lt;/a&gt;. Это следующая версия языка, работа над которой велась более 8 лет более чем 100 разработчиками. В этот релиз попало 28 тысяч коммитов, 7400 пулл-реквестов и 4100 закрытых задач. Новый язык содержит в себе &amp;laquo;последние исследования в теории типов, так же как и индустриальный опыт Scala 2&amp;raquo;. Перечислим лишь некоторые изменения в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый синтаксис &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/control-syntax.html"&gt;без фигурных скобок&lt;/a&gt;. Индентация теперь имеет &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/indentation.html"&gt;строгие правила&lt;/a&gt; и влияет на компиляцию.&lt;/li&gt;
  &lt;li&gt;Ключевое слово &lt;code&gt;new&lt;/code&gt; теперь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/creator-applications.html"&gt;опционально&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Implicit'ов больше нет, и теперь концепция разделена на несколько независимых частей, каждая из которых заточена под свои конкретные вещи: &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/using-clauses.html"&gt;условия using&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/givens.html"&gt;given-инстансы&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/extension-methods.html"&gt;extension-методы&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/conversions.html"&gt;неявные конверсии&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/context-functions.html"&gt;контекстные функции&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/enums/enums.html"&gt;Перечисления&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/new-types/intersection-types.html"&gt;Пересечения&lt;/a&gt; и &lt;a href="https://dotty.epfl.ch/docs/reference/new-types/union-types.html"&gt;объеденения&lt;/a&gt; типов.&lt;/li&gt;
  &lt;li&gt;Типы функций, &lt;a href="https://dotty.epfl.ch/docs/reference/new-types/dependent-function-types.html"&gt;зависящие от параметров&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/new-types/match-types.html"&gt;match-типы&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;trait'ы теперь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/trait-parameters.html"&gt;могут иметь параметры&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Классы, от которых можно наследоваться, теперь должны иметь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/open-classes.html"&gt;модификатор &lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Подробный список новых возможностей и улучшений в Scala 3 можно найти &lt;a href="https://docs.scala-lang.org/scala3/new-in-scala3.html"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="http://openjdk.java.net/jeps/8266010"&gt;JEP: Reimplement Core Reflection on Method Handles&lt;/a&gt;. В нём предлагается реализовать рефлексию в Java поверх method handles, тем самым избавившись от одной лишней реализации рефлективного механизма, которые дублируют друг друга. Это уменьшит затраты на поддержку и разработку API в пакетах &lt;code&gt;java.lang.reflect&lt;/code&gt; и &lt;code&gt;java.lang.invoke&lt;/code&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На сайте OpenJDK впервые появились &lt;a href="https://jdk.java.net/17/"&gt;сборки JDK под Apple M1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains объявил &lt;a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-online-event/"&gt;Kotlin Online Event&lt;/a&gt; в честь выхода Kotlin 1.5. Он состоится 25 мая.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/scala/scala/releases/tag/v2.13.6"&gt;Scala 2.13.6&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли &lt;a href="https://spring.io/blog/2021/05/11/spring-framework-5-3-7-and-5-2-15-available-now"&gt;Spring Framework 5.3.7 и 5.2.15&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-May/003286.html"&gt;JMH 1.31&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #17</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_17.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_17.html</id>
    <updated>2021-05-09T17:00:00Z</updated>
    <published>2021-05-09T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Самая главная новость этой недели &amp;ndash; выход &lt;a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/"&gt;Kotlin 1.5.0&lt;/a&gt;. Перечислим некоторые изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Появилась поддержка &lt;a href="https://openjdk.java.net/jeps/395"&gt;JVM-записей&lt;/a&gt; с помощью аннотации &lt;code&gt;@JvmRecord&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Модификатор &lt;code&gt;sealed&lt;/code&gt; теперь можно применять не только классам, но и к интерфейсам.&lt;/li&gt;
  &lt;li&gt;Подклассы &lt;code&gt;sealed&lt;/code&gt; классов теперь не обязаны объявляться в том же файле, а могут объявляться в любых файлах того же пакета.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md"&gt;&lt;code&gt;inline value&lt;/code&gt; классы&lt;/a&gt;, которые появились в экспериментальном режиме в Kotlin 1.2.30, теперь стали стабильными.&lt;/li&gt;
  &lt;li&gt;Новый &lt;a href="https://blog.jetbrains.com/kotlin/2021/02/the-jvm-backend-is-in-beta-let-s-make-it-stable-together/"&gt;IR (Intermediate Representation) компилятор&lt;/a&gt; Kotlin в JVM стал стабильным и включенным по умолчанию.&lt;/li&gt;
  &lt;li&gt;SAM (Single Abstract Method) адаптеры теперь компилируются в &lt;code&gt;invokedynamic&lt;/code&gt;. Для простых лямбд такая возможность тоже появилась, но только в экспериментальном режиме с включенной опцией &lt;code&gt;-Xlambdas=indy&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Версия JVM target теперь 1.8 вместо 1.6.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="JEP 415: Context-Specific Deserialization Filters"&gt;JEP 415: Context-Specific Deserialization Filters&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/05/java-annotated-monthly-may-2021/"&gt;Java Annotated Monthly за май 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8266431"&gt;предложено&lt;/a&gt; улучшить алгоритм сортировки чисел. Тесты показывают, что прирост производительности составляет 50% в среднем и до 6 раз на больших случайных массивах. Огромный прирост в последнем случае достигается засчёт использования поразрядной сортировки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK было предложено сделать &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2021-May/001518.html"&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; абстрактным классом&lt;/a&gt;. Это бы сделало согласованной модель, в которой примитивные классы могут наследоваться только от абстрактных классов без полей, но сломало бы обратную совместимость на уровне исходного кода. Но запретить вызывать &lt;code&gt;new Object()&lt;/code&gt; можно поэтапно, сначала показывая предупреждение, а спустя несколько лет переквалифицировать в ошибку компиляции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел бэкпорт-релиз &lt;a href="https://docs.gradle.org/6.9/release-notes.html"&gt;Gradle 6.9&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-May/003237.html"&gt;JMH 1.30&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #16</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_16.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_16.html</id>
    <updated>2021-05-02T17:00:00Z</updated>
    <published>2021-05-02T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.java.net/jeps/413"&gt;JEP 413: Code Snippets in Java API Documentation&lt;/a&gt;. Про него мы подробно писали в &lt;a href="java_news_5.html"&gt;выпуске новостей #5&lt;/a&gt;, когда появился его черновик.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://openjdk.java.net/jeps/414"&gt;JEP 414: Vector API (Second Incubator)&lt;/a&gt;. API для векторных вычислений появилось &lt;a href="java_16.html"&gt;в Java 16&lt;/a&gt; в статусе инкубатора, и в следующем релизе продолжит находиться в этом статусе.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Брайан Гётц &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-April/002959.html"&gt;предложил&lt;/a&gt; в рассылке OpenJDK идею сделать все &lt;code&gt;switch&lt;/code&gt; исчерпывающими (exhaustive). Это значит, что подобное использование оператора &lt;code&gt;switch&lt;/code&gt; когда-нибудь перестанет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;enum&lt;/span&gt; COLOR {
    RED, GREEN, BLUE;
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (color) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RED: System.out.println(&lt;span style="color: darkred"&gt;"red"&lt;/span&gt;); &lt;span style="color: blue"&gt;break&lt;/span&gt;;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GREEN: System.out.println(&lt;span style="color: darkred"&gt;"green"&lt;/span&gt;); &lt;span style="color: blue"&gt;break&lt;/span&gt;;
}&lt;/pre&gt;
&lt;p&gt;Чтобы такой statement стал компилироваться, нужно будет добавить либо недостающую константу, либо ветку &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Так как предлагаемое изменение сломает обратную совместимость, то сначала для неисчерпывающих &lt;code&gt;switch&lt;/code&gt; предлагается выдавать предупреждение, а лишь потом переквалифицировать их в ошибки компиляции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли IntelliJ IDEA &lt;a href="https://blog.jetbrains.com/idea/2021/04/intellij-idea-2020-3-4/"&gt;2020.3.4&lt;/a&gt; и &lt;a href="https://blog.jetbrains.com/idea/2021/04/intellij-idea-2021-1-1/"&gt;2021.1.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://medium.com/graalvm/graalvm-21-1-96e18f6806bf"&gt;GraalVM 21.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.micronaut.io/latest/guide/#whatsNew"&gt;Micronaut 2.5&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло обновление JDK: &lt;a href="http://jdk.java.net/17/"&gt;17-ea+20&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jcstress-dev/2021-April/000561.html"&gt;JCStress 0.10&lt;/a&gt; (библиотека для проверки корректности concurrency).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #15</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_15.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_15.html</id>
    <updated>2021-04-25T17:00:00Z</updated>
    <published>2021-04-25T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/16-0-1-relnotes.html"&gt;JDK 16.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005848.html"&gt;JDK 15.0.3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005850.html"&gt;JDK 13.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005860.html"&gt;JDK 11.0.11&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-April/013680.html"&gt;JDK 8u292&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+19&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;bull; Вышел &lt;a href="https://openjdk.java.net/jeps/411"&gt;JEP 411: Deprecate the Security Manager for Removal&lt;/a&gt;. Как следует из названия, в нём предлагается пометить класс &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html"&gt;&lt;code&gt;java.lang.SecurityManager&lt;/code&gt;&lt;/a&gt; как deprecated for removal, а в будущих релизах удалить его окончательно. Также этой же участи будут постигнуты ещё 10 классов и 7 методов, связанных с &lt;code&gt;SecurityManager&lt;/code&gt;. Кроме того, значение свойста &lt;code&gt;java.security.manager&lt;/code&gt; станет по умолчанию &lt;code&gt;disallow&lt;/code&gt; (что означает, что &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"&gt;&lt;code&gt;System.setSecurityManager()&lt;/code&gt;&lt;/a&gt; будет выбрасывать &lt;code&gt;UnsupportedOperationException&lt;/code&gt;), а при его указании через аргументы командной строки будет выдаваться предупреждение на старте.&lt;/p&gt;
&lt;p&gt;Отказаться от Security Manager предлагается по причине того, что он слабо отвечает современным требованиям безопасности и не имеет высокого спроса со стороны современных Java-разработчиков, а цена его поддержки очень высока. У него хрупкая модель разрешений, сложная программная модель, и он приносит большие накладные расходы в плане производительности.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один &lt;a href="https://openjdk.java.net/jeps/412"&gt;JEP 412: Foreign Function &amp; Memory API (Incubator)&lt;/a&gt;. Этот JEP &amp;ndash; не что иное, как объединение и дальнейшая эволюция других двух JEP'ов: &lt;a href="https://openjdk.java.net/jeps/370"&gt;JEP 370: Foreign-Memory Access API (Incubator)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/389"&gt;JEP 389: Foreign Linker API (Incubator)&lt;/a&gt;. Эти два API тесно связаны друг с другом и находятся в одном модуле &lt;code&gt;jdk.incubator.foreign&lt;/code&gt;, поэтому было логично их объединить.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2021/04/java-annotated-monthly-april-2021/"&gt;Java Annotated Monthly за апрель 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains &lt;a href="https://blog.jetbrains.com/idea/2021/04/end-of-support-for-32-bit-operating-systems-in-intellij-based-ides/"&gt;откажется от поддержки 32-битных версий&lt;/a&gt; своих IDE. 2021.1 станут последними версиями сред, которые поддерживают 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/blog/2021/04/13/jetbrains-toolbox-2021-1-summary/"&gt;JetBrains ToolBox 2021.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-rc-released/"&gt;Kotlin 1.5.0-RC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/13/spring-framework-5-3-6-and-5-2-14-available-now"&gt;Spring Framework 5.3.6 и 5.2.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/14/spring-integration-5-5-rc1-5-4-6-5-3-7-available"&gt;Spring Integration 5.5-RC1, 5.4.6 и 5.3.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-5-0-rc1-available-now"&gt;Spring Boot 2.5.0-RC1&lt;/a&gt;, &lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-4-5-available-now"&gt;2.4.5&lt;/a&gt; и &lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-3-10-is-now-available"&gt;2.3.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/12/spring-security-5-5-0-rc1-released"&gt;Spring Security 5.5.0-RC1&lt;/a&gt;, &lt;a href="https://spring.io/blog/2021/04/12/spring-security-5-2-10-5-3-9-and-5-4-6-released"&gt;5.4.6, 5.3.9 и 5.2.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/20/what-s-new-in-spring-data-2021-0"&gt;Spring Data 2021.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/raphw/byte-buddy/blob/master/release-notes.md"&gt;ByteBuddy 1.11.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/api_to_upgrade_from_java_8_part_3.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/api_to_upgrade_from_java_8_part_3.html</id>
    <updated>2021-04-23T17:00:00Z</updated>
    <published>2021-04-23T17:00:00Z</published>
    <content type="html">&lt;p&gt;Какие есть причины переходить на новые версии Java? Кто-то это сделает из-за новых языковых возможностей вроде &lt;a href="https://openjdk.java.net/jeps/361"&gt;выражений &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/378"&gt;блоков текста&lt;/a&gt; или &lt;a href="https://openjdk.java.net/jeps/395"&gt;записей&lt;/a&gt;. Кому-то понадобятся новые интересные возможности вроде &lt;a href="https://openjdk.java.net/jeps/261"&gt;модулей&lt;/a&gt; или &lt;a href="https://openjdk.java.net/jeps/379"&gt;низкопаузных сборщиков мусора&lt;/a&gt;. Кто-то это сделает просто из-за того, что обновив версию Java, их программа &lt;a href="https://openjdk.java.net/jeps/341"&gt;станет быстрее&lt;/a&gt; и будет &lt;a href="https://openjdk.java.net/jeps/254"&gt;есть меньше памяти&lt;/a&gt;. Но есть ещё одна, не менее важная причина. Это новые API, которые позволят писать меньше кода и избежать траты времени на поиск нужной функциональности во внешних библиотеках. А в некоторых случаях сделают ваш код быстрее.&lt;/p&gt;
&lt;p&gt;В предыдущих двух частях мы уже рассмотрели по 10 новых API, которые появились в Java 9 и более поздних версиях (&lt;a href="api_to_upgrade_from_java_8.html"&gt;часть 1&lt;/a&gt;, &lt;a href="api_to_upgrade_from_java_8_part_2.html"&gt;часть 2&lt;/a&gt;). Сегодня мы рассмотрим ещё 10.&lt;/p&gt;
&lt;!-- cut --&gt;

&lt;h4&gt;1. &lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: &lt;a href="java_16.html"&gt;Java 16&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Для какой задачи чаще всего используется &lt;code&gt;Stream&lt;/code&gt; в Java? Конечно же, для трансформации списков: у нас есть список, над которым нужно совершить какое-то преобразование и вернуть новый. Такой паттерн вы наверняка видели в своём проекте множество раз:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;T&amp;gt; targetList = sourceList
        .stream()
        &lt;span style="color: green"&gt;// промежуточные операции&lt;/span&gt;
        .collect(Collectors.toList());&lt;/pre&gt;
&lt;p&gt;Нельзя сказать, что &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; является очень уж громоздкой конструкцией, но всё же хочется для такой частой операции писать поменьше кода. И в Java 16 это стало возможно с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"&gt;&lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;T&amp;gt; targetList = sourceList
        .stream()
        &lt;span style="color: green"&gt;// промежуточные операции&lt;/span&gt;
        .toList();&lt;/pre&gt;
&lt;p&gt;Есть ли какая-то разница между &lt;code&gt;toList()&lt;/code&gt; и &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;? Оба ли способа ведут себя одинаково? С практической точки зрения можно сказать, что нет: если &lt;code&gt;toList()&lt;/code&gt; возвращает неизменяемый список, то &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; возвращает некий список, о котором неизвестно, неизменяемый он или нет. То есть если вы нигде в коде не используете негарантированную вам спецификацией изменяемость списка (надеюсь, вы из такой категории людей), то смело можете заменять &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; на &lt;code&gt;toList()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Однако &lt;code&gt;Stream.toList()&lt;/code&gt; делает код не только короче, но и эффективнее! Дело в том, что &lt;code&gt;Stream.toList()&lt;/code&gt; использует внутри себя &lt;code&gt;Stream.toArray()&lt;/code&gt;, который выделяет массив точной длины, если &lt;code&gt;Spliterator&lt;/code&gt; имеет характеристику &lt;code&gt;SIZED&lt;/code&gt;. В то время как &lt;code&gt;Collectors.toList()&lt;/code&gt; никак эту характеристику не использует и всегда начинает с пустого &lt;code&gt;ArrayList&lt;/code&gt;, накапливая в нём элементы с постоянными переаллокациями.&lt;/p&gt;
&lt;p&gt;Давайте напишем несколько бенчмарков. Для начала рассмотрим самый простейший случай: замерим, как быстро создаётся копия исходного списка, т.е. проверим цепочку вообще без промежуточных операций. Так как для такого сценария &lt;code&gt;Stream&lt;/code&gt; по идее вообще не нужен, и того же самого можно добиться просто вызвав &lt;code&gt;new ArrayList&lt;&gt;(sourceList)&lt;/code&gt; или &lt;code&gt;List.copyOf(sourceList)&lt;/code&gt;, то замерим и эти два случая тоже:&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Полный код JMH-бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToList {

    @Param({"10", "100", "1000"})
    private int size;

    private List&amp;lt;Integer&amp;gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; newArrayList() {
        return new ArrayList&amp;lt;&amp;gt;(sourceList);
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; toList() {
        return sourceList.stream().toList();
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; copyOf() {
        return List.copyOf(sourceList);
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToList() {
        return sourceList.stream().collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToUnmodifiableList() {
        return sourceList.stream().collect(Collectors.toUnmodifiableList());
    }
}&lt;/pre&gt;&lt;/details&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC&lt;/pre&gt;&lt;/details&gt;
&lt;img src="stream_tolist_benchmark1.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;Результаты говорят нам о том, что &lt;code&gt;Stream.toList()&lt;/code&gt; не только существенно быстрее &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;, но и может быть быстрее даже &lt;code&gt;List.copyOf()&lt;/code&gt;! Это объясняется тем, что в &lt;code&gt;List.copyOf()&lt;/code&gt; существенное время тратится на проверку &lt;code&gt;requireNonNull&lt;/code&gt; для каждого входного элемента, поскольку он запрещает &lt;code&gt;null&lt;/code&gt;-элементы, в то время как &lt;code&gt;Stream.toList()&lt;/code&gt; не запрещает &lt;code&gt;null&lt;/code&gt; и в нём такая проверка не нужна. На малых размерах &lt;code&gt;List.copyOf()&lt;/code&gt; всё же выигрывает, потому что проверка нескольких элементов на &lt;code&gt;null&lt;/code&gt; быстрее церемоний, которые есть у &lt;code&gt;Stream&lt;/code&gt;: создание &lt;code&gt;Spliterator&lt;/code&gt;, &lt;code&gt;ReferencePipeline&lt;/code&gt; и т.д.&lt;/p&gt;
&lt;p&gt;Теперь рассмотрим случай, когда точный размер неизвестен. Например, добавим одну промежуточную операцию &lt;code&gt;filter()&lt;/code&gt;:&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Полный код JMH-бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToListFilter {

    @Param({"10", "100", "1000"})
    private int size;

    private List&amp;lt;Integer&amp;gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; toList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).toList();
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; newArrayList() {
        var list = new ArrayList&amp;lt;Integer&amp;gt;();
        for (var i : sourceList) {
            if (i % 2 == 0) {
                list.add(i);
            }
        }
        return list;
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToUnmodifiableList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).collect(Collectors.toUnmodifiableList());
    }
}
&lt;/pre&gt;&lt;/details&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC&lt;/pre&gt;&lt;/details&gt;
&lt;img src="stream_tolist_benchmark2.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;В этом случае мы тоже получили большое ускорение! И в этот раз &lt;code&gt;Stream.toList()&lt;/code&gt; на большом количестве элементов выиграл даже у простого &lt;code&gt;new ArrayList()&lt;/code&gt; с последующим заполнением в цикле. Как так получается? Дело в том, что при неизвестном размере &lt;code&gt;Stream.toArray()&lt;/code&gt; использует структуру данных &lt;a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/stream/SpinedBuffer.java"&gt;&lt;code&gt;SpinedBuffer&lt;/code&gt;&lt;/a&gt;, которая более эффективна для накопления элементов, чем &lt;code&gt;ArrayList&lt;/code&gt;. Она представляет собой массив массивов, где подмассивы имеют длины в виде возрастающих степеней двойки (каждый следующий chunk в два раза больше предыдущего). Структуру &lt;code&gt;SpinedBuffer&lt;/code&gt; можно легко понять из этого рисунка, где изображён буфер со 100 элементами (&lt;code&gt;Integer&lt;/code&gt; от 0 до 99):&lt;/p&gt;
&lt;img src="spined_buffer.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;Также &lt;code&gt;ArrayList&lt;/code&gt; проигрывает ещё и потому, что расширяется всего лишь в 1.5 раза при заполнении внутреннего массива, а значит делает это намного чаще, что приводит к дополнительным накладным расходам. &lt;code&gt;ArrayList&lt;/code&gt; вынужден балансировать между экономией памяти и скоростью операции &lt;code&gt;add()&lt;/code&gt;, поэтому и проигрывает &lt;code&gt;SpinedBuffer&lt;/code&gt;, который заточен исключительно на скорость. Излишний расход памяти для него не играет роли, так как это недолгоживующая структура, которая сразу же отбрасывается после завершения терминальной операции.&lt;/p&gt;
&lt;p&gt;Вывод: &lt;code&gt;Stream.toList()&lt;/code&gt; короче, чище и почти всегда быстрее, чем &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;. Так что о втором способе можно забыть и использовать всегда первый (хотя &lt;code&gt;Collectors.toList()&lt;/code&gt; сам по себе всё ещё может быть нужен, например как downstream &lt;code&gt;Collector&lt;/code&gt; для других &lt;code&gt;Collector&lt;/code&gt;'ов). Если же нужен гарантированно изменяемый список, то можно использовать &lt;code&gt;collect(Collectors.toCollection(ArrayList::new))&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;2. &lt;code&gt;String&lt;/code&gt;: &lt;code&gt;formatted()&lt;/code&gt;, &lt;code&gt;stripIndent()&lt;/code&gt; и  &lt;code&gt;translateEscapes()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 15&lt;/h5&gt;
&lt;p&gt;В Java 15 появились &lt;a href="https://openjdk.java.net/jeps/378"&gt;блоки текста&lt;/a&gt; &amp;ndash; строковые литералы, которые могут состоять из одной или нескольких линий:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"""
        Привет,
        Юзер!"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;При этом довольно часто блоки будут использоваться в качестве шаблонов с последующей заменой:&lt;/p&gt;
&lt;pre&gt;String str = String.format(&lt;span style="color: darkred"&gt;"""
        Привет,
        %s!"""&lt;/span&gt;, user);&lt;/pre&gt;
&lt;p&gt;Не кажется ли вам, что код выше выглядит несколько громоздким? Мне вот тоже кажется. Но у нас есть способ, как сделать его немножко чище. Это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object...)"&gt;&lt;code&gt;String.formatted()&lt;/code&gt;&lt;/a&gt;, который является нестатическим эквивалентом &lt;code&gt;String.format()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"""
        Привет,
        %s!"""&lt;/span&gt;.formatted(user);&lt;/pre&gt;
&lt;p&gt;Вы, конечно, скажете, что разница лишь в трёх символах сэкономленного кода, но, во-первых, второй вариант гораздо проще печатать на клавиатуре (проверьте сами), а во-вторых, он более читабелен.&lt;/p&gt;
&lt;p&gt;Кстати, &lt;code&gt;formatted()&lt;/code&gt; никто не запрещает использовать и с обычными литералами:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"Привет, %s!"&lt;/span&gt;.formatted(user);&lt;/pre&gt;
&lt;p&gt;Лично мне метод очень нравится, и я планирую взять его на вооружение в качестве основного рабочего варианта.&lt;/p&gt;

&lt;p class="pt-2"&gt;Второй метод, появившийся в Java 15 &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#stripIndent()"&gt;&lt;code&gt;String.stripIndent()&lt;/code&gt;&lt;/a&gt;, который удаляет общие пробельные символы в начале всех линий. К примеру, если есть файл &lt;code&gt;hello.txt&lt;/code&gt; с такими строками:&lt;/p&gt;
&lt;pre&gt;    Привет,
    Юзер!&lt;/pre&gt;
&lt;p&gt;Тогда чтобы убрать пробелы слева, как раз и можно воспользоваться &lt;code&gt;stripIndent()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String str = Files.readString(Path.of(&lt;span style="color: darkred"&gt;"hello.txt"&lt;/span&gt;)).stripIndent();
System.out.println(str);&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Привет,
Юзер!&lt;/pre&gt;

&lt;p class="pt-2"&gt;Наконец, третий метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#translateEscapes()"&gt;&lt;code&gt;String.translateEscapes()&lt;/code&gt;&lt;/a&gt;. Он делает простую вещь: заменяет экранирующие последовательности на их соответствующие символы.&lt;/p&gt;
&lt;p&gt;Например, есть файл hello.txt:&lt;/p&gt;
&lt;pre&gt;Привет,\nЮзер!&lt;/pre&gt;
&lt;pre&gt;String str = Files.readString(Path.of(&lt;span style="color: darkred"&gt;"hello.txt"&lt;/span&gt;)).translateEscapes();
System.out.println(str);&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Привет,
Юзер!&lt;/pre&gt;

&lt;h4&gt;3. &lt;code&gt;CharSequence.isEmpty()&lt;/code&gt;, &lt;code&gt;CharSequence.compare()&lt;/code&gt; и &lt;code&gt;StringBuilder.compareTo()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 15 / Java 11&lt;/h5&gt;
&lt;p&gt;Если уж мы начали тему строк, то давайте добьём её до конца.&lt;/p&gt;
&lt;p&gt;Тот, кто писал на Java 1.5 или на более старых версиях, должен помнить, что в классе &lt;code&gt;String&lt;/code&gt; в те времена не было метода &lt;code&gt;isEmpty()&lt;/code&gt;. Поэтому для проверки строки на пустоту каждый раз приходилось использовать &lt;code&gt;length()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (str.length() != 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Это было не совсем удобно, и в Java 1.6 метод &lt;a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#isEmpty()"&gt;&lt;code&gt;String.isEmpty()&lt;/code&gt;&lt;/a&gt; наконец-то завезли:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (!str.isEmpty()) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако про то, что &lt;code&gt;String&lt;/code&gt; &amp;ndash; далеко не единственная реализация &lt;code&gt;CharSequence&lt;/code&gt; (хоть и самая популярная), почему-то не подумали, и этот метод туда добавлять не стали (впрочем, без &lt;code&gt;default&lt;/code&gt;-методов они бы этого сделать и не смогли). Например, для проверки на пустоту &lt;code&gt;StringBuilder&lt;/code&gt; всё ещё приходилось использовать &lt;code&gt;length()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (stringBuilder.length() != 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Но спустя 14 лет всё-таки решили исправить и это: начиная с Java 15, метод &lt;code&gt;isEmpty()&lt;/code&gt; есть не только у &lt;code&gt;String&lt;/code&gt;, но и у любой &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/CharSequence.html#isEmpty()"&gt;&lt;code&gt;CharSequence&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (!stringBuilder.isEmpty()) {
    ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Также иногда приходится тестировать два &lt;code&gt;CharSequence&lt;/code&gt; на равенство. Метод &lt;code&gt;equals()&lt;/code&gt; использовать нельзя: а вдруг он не переопределён в реализации? Поэтому приходится изворачиваться: либо конвертировать каждый &lt;code&gt;CharSequence&lt;/code&gt; в &lt;code&gt;String&lt;/code&gt; и сравнивать их, что может быть накладно, либо писать свою реализацию посимвольного сравнения.&lt;/p&gt;
&lt;p&gt;Однако, начиная с Java 11, всё это не нужно, потому что появился метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html#compare(java.lang.CharSequence,java.lang.CharSequence)"&gt;&lt;code&gt;CharSequence.compare()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (CharSequence.compare(charSeq1, charSeq2) == 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;compare()&lt;/code&gt; также можно использовать не только для просто теста на равенство, но и для лексикографического сравнения.&lt;/p&gt;
&lt;p&gt;Также в Java 11 класс &lt;code&gt;StringBuilder&lt;/code&gt; стал реализовывать интерфейс &lt;code&gt;Comparable&lt;/code&gt;, а значит для сравнения двух &lt;code&gt;StringBuilder&lt;/code&gt; можно использовать &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html#compareTo(java.lang.StringBuilder)"&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (stringBuilder1.compareTo(stringBuilder2) == 0) {
    ...
}&lt;/pre&gt;

&lt;h4&gt;4. &lt;code&gt;Collectors.filtering()&lt;/code&gt; и &lt;code&gt;Collectors.flatMapping()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9&lt;/h5&gt;
&lt;p&gt;Часто ли вам приходится использовать &lt;code&gt;Collectors.groupingBy()&lt;/code&gt;? К примеру, вы ведёте базу данных фильмов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Movie(String title, String genre, &lt;span style="color: blue"&gt;double&lt;/span&gt; rating) {
}&lt;/pre&gt;
&lt;p&gt;Допустим, вы хотите сгруппировать фильмы по жанру:&lt;/p&gt;
&lt;pre&gt;Stream&amp;lt;Movie&amp;gt; allMovies = Stream.of(
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Коммандо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.385),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.974),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор 2"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 8.312),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Молчание ягнят"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.33),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Криминальное чтиво"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.619),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Титаник"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Мелодрама"&lt;/span&gt;, 8.363),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Семьянин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Комедия"&lt;/span&gt;, 7.699)
);

Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre));

groups.forEach((genre, movies) -&gt; {
    System.out.println(genre + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;);
    movies.forEach(movie -&gt;
        System.out.printf(&lt;span style="color: darkred"&gt;"    %s: %.2f%n"&lt;/span&gt;, movie.title(), movie.rating()));
});&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Коммандо: 7.39
    Терминатор: 7.97
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    Семьянин: 7.70&lt;/pre&gt;
&lt;p&gt;Однако, допустим, вы не хотите видеть все фильмы, а только те, у кого рейтинг выше 8. Какой метод вы в этом случае используете? Конечно же, &lt;code&gt;Stream.filter()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies
    .filter(movie -&gt; movie.rating() &gt; 8)
    .collect(Collectors.groupingBy(Movie::genre));&lt;/pre&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62&lt;/pre&gt;
&lt;p&gt;Но вот проблема: вам вдруг захотелось видеть все жанры, даже те, в которые не попало ни одного фильма с рейтингом выше 8. Что делать? Ответ: перейти на новую версию Java, потому что в ней есть &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#filtering(java.util.function.Predicate,java.util.stream.Collector)"&gt;&lt;code&gt;Collectors.filtering()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.filtering(movie -&gt; movie.rating() &gt; 8,
            Collectors.toList())));

groups.forEach((genre, movies) -&gt; {
    System.out.println(genre + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (movies.isEmpty()) {
        System.out.println(&lt;span style="color: darkred"&gt;"    &amp;lt;Фильмов с рейтингом выше 8 нет&amp;gt;"&lt;/span&gt;);
    } &lt;span style="color: blue"&gt;else&lt;/span&gt; {
        movies.forEach(movie -&gt;
            System.out.printf(&lt;span style="color: darkred"&gt;"    %s: %.2f%n"&lt;/span&gt;, movie.title(), movie.rating()));
    }
});&lt;/pre&gt;
&lt;p&gt;В этом случае фильтрация будет перенесена внутрь &lt;code&gt;groupingBy()&lt;/code&gt;, и потери жанров не произойдёт:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    &amp;lt;Фильмов с рейтингом выше 8 нет&amp;gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;Очень хорошо. Теперь добавим в фильмы актёров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Movie(String title, String genre, &lt;span style="color: blue"&gt;double&lt;/span&gt; rating, List&amp;lt;String&amp;gt; actors) {
}&lt;/pre&gt;
&lt;p&gt;И теперь хотите увидеть всех актёров с группировкой по жанру:&lt;/p&gt;
&lt;pre&gt;Stream&amp;lt;Movie&amp;gt; allMovies = Stream.of(
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Коммандо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.385,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Чонг"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хедайя"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.974,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Бин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хэмилтон"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор 2"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 8.312,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хэмилтон"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Ферлонг"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Патрик"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Молчание ягнят"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.33,
        List.of(&lt;span style="color: darkred"&gt;"Фостер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хопкинс"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Криминальное чтиво"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.619,
        List.of(&lt;span style="color: darkred"&gt;"Траволта"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Уиллис"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Джексон"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Турман"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Титаник"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Мелодрама"&lt;/span&gt;, 8.363,
        List.of(&lt;span style="color: darkred"&gt;"ДиКаприо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Уинслет"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Семьянин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Комедия"&lt;/span&gt;, 7.699,
        List.of(&lt;span style="color: darkred"&gt;"Кейдж"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Леони"&lt;/span&gt;))
);&lt;/pre&gt;
&lt;p&gt;Но какой коллектор нужно подсунуть в &lt;code&gt;groupingBy()&lt;/code&gt;, чтобы собрать всех актёров в &lt;code&gt;Set&lt;/code&gt;? Можно попробовать &lt;code&gt;Collectors.mapping()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, Set&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.mapping(Movie::actors, Collectors.toSet())));&lt;/pre&gt;
&lt;p&gt;Но смотрите, у нас получилось множество списков, а нужно просто множество. Что же делать? И тут на помощь приходит &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#flatMapping(java.util.function.Function,java.util.stream.Collector)"&gt;&lt;code&gt;Collectors.flatMapping()&lt;/code&gt;&lt;/a&gt;, ещё один новый метод, появившийся в Java 9:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.flatMapping(movie -&gt; movie.actors().stream(),
            Collectors.toSet())));&lt;/pre&gt;
&lt;p&gt;И вот сейчас тип правильный! Если вывести это, то получится:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    ДиКаприо
    Уинслет
Боевик:
    Бин
    Ферлонг
    Хедайя
    Патрик
    Шварценеггер
    Хэмилтон
    Чонг
Триллер:
    Траволта
    Уиллис
    Хопкинс
    Фостер
    Джексон
    Турман
Комедия:
    Кейдж
    Леони&lt;/pre&gt;
&lt;p&gt;Что и требовалось.&lt;/p&gt;

&lt;h4&gt;5. &lt;code&gt;StackWalker&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 9&lt;/h5&gt;
&lt;p&gt;Приходилось ли вам иметь дело со стеками? Не со стеками в смысле структур данных, а со стеком потоков? Например, вы пишете простенький логгер:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; MyLogger {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
        System.out.println(message);
    }
}&lt;/pre&gt;
&lt;p&gt;Однако вы хотите писать в консоль не просто голое сообщение, а ещё имя класса, метода, файла и номер строки, откуда вызывается метод &lt;code&gt;log()&lt;/code&gt;. В Java 8 единственным стандартным способом для этого является получение массива &lt;code&gt;StackTraceElement[]&lt;/code&gt;, например, с помощью метода &lt;code&gt;Thread.getStackTrace()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    String msg = stackTraceElement.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
               + stackTraceElement.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
               + stackTraceElement.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
               + stackTraceElement.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
               + message;
    System.out.println(msg);
}&lt;/pre&gt;
&lt;p&gt;Можно предположить, что такой способ получения получения номеров строк является довольно дорогим. Ведь нам надо заполнить полностью весь стек, который может быть очень глубоким (особенно в энтерпрайзе, где фреймворк на фреймворке), а потом ещё и сконвертировать внутренние структуры JVM в Java-массив. И всё это ради того, чтобы отбросить его почти полностью и достать только второй элемент. Давайте замерим производительность такого подхода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: gold"&gt;@Benchmark&lt;/span&gt;
&lt;span style="color: blue"&gt;public&lt;/span&gt; String stackTrace() {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    &lt;span style="color: blue"&gt;return&lt;/span&gt; stackTraceElement.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
         + stackTraceElement.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
         + stackTraceElement.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
         + stackTraceElement.getLineNumber() + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;;
}&lt;/pre&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6&lt;/pre&gt;&lt;/details&gt;
&lt;pre&gt;Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op&lt;/pre&gt;
&lt;p&gt;104 микросекунды на каждый вызов! Это невероятно медленно! Есть ли возможность это ускорить? Есть: с помощью нового класса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html"&gt;&lt;code&gt;StackWalker&lt;/code&gt;&lt;/a&gt;, который появился в Java 9. Давайте рассмотрим этот класс поподробнее.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StackWalker&lt;/code&gt; предоставляет возможность &amp;laquo;гулять&amp;raquo; по стеку. Чтобы это сделать, сначала нужно получить экземпляр &lt;code&gt;StackWalker&lt;/code&gt; с помощью метода &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getInstance()"&gt;&lt;code&gt;StackWalker.getInstance()&lt;/code&gt;&lt;/a&gt;. Этот метод возвращает &lt;code&gt;StackWalker&lt;/code&gt; по умолчанию. Также есть возможность передать в метод &lt;code&gt;getInstance()&lt;/code&gt; опции и получить &lt;code&gt;StackWalker&lt;/code&gt; с более богатыми возможностями. Но об этом чуть позже.&lt;/p&gt;
&lt;p&gt;После того, как мы получил объект &lt;code&gt;StackWalker&lt;/code&gt;, у нас есть следующие варианты:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Выполнить на нём метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#forEach(java.util.function.Consumer)"&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/a&gt; и пройтись по всем фреймам стека.&lt;/li&gt;
    &lt;li&gt;Вызвать метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"&gt;&lt;code&gt;getCallerClass()&lt;/code&gt;&lt;/a&gt; и получить класс, который вызвал наш метод (работает только с опцией &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.Option.html#RETAIN_CLASS_REFERENCE"&gt;&lt;code&gt;RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;).&lt;/li&gt;
    &lt;li&gt;Вызвать метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#walk(java.util.function.Function)"&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;, который принимает функцию из &lt;code&gt;Stream&amp;lt;StackFrame&amp;gt;&lt;/code&gt; в &lt;code&gt;T&lt;/code&gt;, где &lt;code&gt;T&lt;/code&gt; &amp;ndash; это что угодно. Это самый гибкий метод.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для нашего логгера мы воспользуемся третьим вариантом. Вот как будет выглядеть реализация метода &lt;code&gt;log()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&amp;lt;StackFrame&amp;gt; frames) -&gt; {
            StackFrame frame = frames.skip(2).findFirst().get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
                 + message;
        });
    System.out.println(msg);
}&lt;/pre&gt;
&lt;p&gt;Теперь давайте замерим производительность варианта со &lt;code&gt;StackWalker&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: gold"&gt;@Benchmark&lt;/span&gt;
&lt;span style="color: blue"&gt;public&lt;/span&gt; String stackWalker() {
    &lt;span style="color: blue"&gt;return&lt;/span&gt; StackWalker
        .getInstance()
        .walk(frames -&gt; {
            StackFrame frame = frames.skip(2).findFirst().get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;;
        });
}&lt;/pre&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6&lt;/pre&gt;&lt;/details&gt;
&lt;pre&gt;Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op
Stack.stackWalker  avgt    5    2,781 ? 0,156  us/op&lt;/pre&gt;
&lt;p&gt;Скорость выросла в 37 раз! Это огромный выигрыш. Конечно, 2.8 микросекунды это всё ещё далеко не бесплатно, но такой вариант кажется уже вполне приемлемым, чтобы включить его в боевом приложении.&lt;/p&gt;
&lt;p&gt;Так как метод &lt;code&gt;StackWalker.walk()&lt;/code&gt; даёт нам &lt;code&gt;Stream&lt;/code&gt;, то наши возможности по обходу стека практически безграничны: можно получить все фреймы, можно отфильтровать, можно пропустить сколько-то. Например, усложним наш логирующий &amp;laquo;фреймворк&amp;raquo;, добавив туда уровни:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.mylogger;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; MyLogger {
    &lt;span style="color: blue"&gt;public enum&lt;/span&gt; Level {
        ERROR, WARN, INFO
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; error(String message) {
        log(Level.ERROR, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; warn(String message) {
        log(Level.WARN, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; info(String message) {
        log(Level.INFO, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(Level level, String message) {
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Сейчас мы уже не можем использовать конструкцию &lt;code&gt;frames.skip(2)&lt;/code&gt;, потому что метод &lt;code&gt;log()&lt;/code&gt; может быть вызван как напрямую, так и через методы &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt;, &lt;code&gt;log()&lt;/code&gt;, а значит фрейм надо искать немножко умнее. Самое простое &amp;ndash; через &lt;code&gt;Stream.dropWhile()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(Level level, String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&amp;lt;StackFrame&amp;gt; frames) -&gt; {
            StackFrame frame = frames
                .dropWhile(f -&gt; f.getClassName().startsWith(&lt;span style="color: darkred"&gt;"org.mylogger"&lt;/span&gt;))
                .findFirst()
                .get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; level + &lt;span style="color: darkred"&gt;" "&lt;/span&gt;
                 + frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
                 + message;
        });
    System.out.println(msg);
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Какие ещё применения есть у &lt;code&gt;StackWalker&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Как вы знаете, в Java 9 появились модули. Но мало кто использует их в своих проектах, и подавляющее большинство всё ещё препочитает класть всё в classpath. Но тогда у нас теряется весьма ценная возможность &amp;ndash; экспортировать из модуля часть пакетов, а остальные скрывать. Представим, что у нас есть пакет &lt;code&gt;org.example.mylib.internal&lt;/code&gt;, который мы хотим, чтобы не использовал никто кроме нашего модуля:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example.mylib.internal;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Handler {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; handle() {
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Класс &lt;code&gt;Handler&lt;/code&gt; публичный, а значит компилятор уже никак не помешает кому угодно использовать этот класс. Но, может быть, можно сделать хотя бы проверку в рантайме? И действительно, это можно сделать через &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"&gt;&lt;code&gt;StackWalker.getCallerClass()&lt;/code&gt;&lt;/a&gt;, и выглядеть этот будет примерно так:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example.mylib.internal;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Handler {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; handle() {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (!StackWalker
            .getInstance(Option.RETAIN_CLASS_REFERENCE)
            .getCallerClass()
            .getPackageName()
            .startsWith(&lt;span style="color: darkred"&gt;"org.example.mylib."&lt;/span&gt;)) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; RuntimeException(&lt;span style="color: darkred"&gt;"Security error"&lt;/span&gt;);
        }
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Здесь мы использовали опцию &lt;code&gt;RETAIN_CLASS_REFERENCE&lt;/code&gt;, иначе получить Class не получилось бы. В принципе, подобную функциональность можно было бы реализовать и через &lt;code&gt;Stream.walk()&lt;/code&gt;, но &lt;code&gt;getCallerClass()&lt;/code&gt; работает немного быстрее.&lt;/p&gt;

&lt;h4&gt;6. &lt;code&gt;System.Logger&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 9&lt;/h5&gt;
&lt;p&gt;Если уж мы начали говорить про логирование, то нельзя не рассказать про &lt;a href="https://openjdk.java.net/jeps/264"&gt;новое стандартное API для логирования&lt;/a&gt;, которое появилось в Java 9. Это API очень маленькое и состоит всего из трёх классов: интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.html"&gt;&lt;code&gt;System.Logger&lt;/code&gt;&lt;/a&gt;, абстрактного класса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.LoggerFinder.html"&gt;&lt;code&gt;System.LoggerFinder&lt;/code&gt;&lt;/a&gt; и перечисления &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.Level.html"&gt;&lt;code&gt;System.Logger.Level&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Использовать &lt;code&gt;System.Logger&lt;/code&gt; чрезвычайно просто:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;private static final&lt;/span&gt; Logger LOGGER = System.getLogger(&lt;span style="color: darkred"&gt;""&lt;/span&gt;);

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args)  {
        LOGGER.log(Level.ERROR, &lt;span style="color: darkred"&gt;"Critical error!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: darkred"&gt;апр. 17, 2021 6:24:57 PM org.example.Main main
SEVERE: Critical error!&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;System.Logger&lt;/code&gt; &amp;ndash; это не новый очередной фреймворк для логирования, как вы могли бы подумать сначала, а только &lt;b&gt;фронтенд&lt;/b&gt; для логирования. Если вы знакомы с существующими фреймворками, то вам должно быть это знакомо: например, &lt;a href="http://www.slf4j.org/"&gt;SLF4J&lt;/a&gt; &amp;ndash; это фронтенд, а его соответствующим бэкендом является &lt;a href="http://logback.qos.ch/"&gt;Logback&lt;/a&gt;. Или &lt;a href="https://logging.apache.org/log4j/2.x/"&gt;Log4j API&lt;/a&gt; &amp;ndash; это фронтенд для Log4j Core. Так вот, &lt;code&gt;System.Logger&lt;/code&gt; &amp;ndash; это фронтенд для знакомого вам фреймворка &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/package-summary.html"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;, который находится в отдельном модуле &lt;code&gt;java.logging&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;При этом нам ничего не мешает для SLF4J использовать другой бэкенд, например, &lt;a href="https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/"&gt;Log4j&lt;/a&gt; или &lt;a href="https://search.maven.org/artifact/org.slf4j/slf4j-jdk14"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;. Или для Log4j API использовать &lt;a href="https://logging.apache.org/log4j/2.x/log4j-to-slf4j/index.html"&gt;SLF4J&lt;/a&gt; как бэкенд или &lt;a href="https://logging.apache.org/log4j/2.x/log4j-jul/index.html"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;. Точно так же и с &lt;code&gt;System.Logger&lt;/code&gt;: он спроектирован так, чтобы реализация могла быть абсолютно любой. Если не нравится неудобный и старый &lt;code&gt;java.util.logging&lt;/code&gt;, то можно использовать что-то другое. Например, можно его настроить на современный Log4j, для чего потребуется подключить следующие зависимости:&lt;/p&gt;
&lt;pre&gt;&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-api&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt; &lt;span style="color: grey"&gt;&amp;lt;!-- Последняя версия на момент написания статьи --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-core&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-jpl&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;p&gt;При этом саму программу изменять не потребуется: то, что &lt;code&gt;log4j-jpl&lt;/code&gt; окажется в classpath, уже будет достаточно. Java через &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html"&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; найдёт нужную реализацию &lt;code&gt;LoggerFinder&lt;/code&gt; в виде &lt;code&gt;Log4jSystemLoggerFinder&lt;/code&gt; и будет направлять логи в Log4j:&lt;/p&gt;
&lt;pre&gt;18:24:57.941 [main] ERROR  - Critical error!&lt;/pre&gt;
&lt;p&gt;После этого модуль &lt;code&gt;java.logging&lt;/code&gt; можно будет даже вообще &lt;a href="https://openjdk.java.net/jeps/282"&gt;исключить&lt;/a&gt; из JRE/JDK, ведь он больше не нужен (если вы конечно нигде не вызываете &lt;code&gt;java.util.logging&lt;/code&gt; напрямую).&lt;/p&gt;
&lt;p&gt;К сожалению, адаптера &lt;code&gt;System.Logger&lt;/code&gt; для SLF4J/Logback нет. Но тут проблема более глобальная &amp;ndash; похоже, что сам проект SLF4J мёртв. Последний коммит в &lt;a href="https://github.com/qos-ch/slf4j"&gt;GitHub&lt;/a&gt; был полтора года назад. Так что Log4j сейчас это самый нормальный вариант &amp;ndash; он активно развивается и поддерживается.&lt;/p&gt;
&lt;p&gt;Несколько примеров использования &lt;code&gt;System.Logger&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;LOGGER.log(Level.INFO, &lt;span style="color: darkred"&gt;"Information"&lt;/span&gt;);
LOGGER.log(Level.DEBUG, &lt;span style="color: darkred"&gt;"Sum of {} and {} is {}:"&lt;/span&gt;, 2, 3, 2+3);
LOGGER.log(Level.TRACE, () -&gt; &lt;span style="color: darkred"&gt;"Lazy message"&lt;/span&gt;);
LOGGER.log(Level.ERROR, &lt;span style="color: darkred"&gt;"Log exception"&lt;/span&gt;, &lt;span style="color: blue"&gt;new&lt;/span&gt; Exception());&lt;/pre&gt;

&lt;h4&gt;7. &lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 15&lt;/h5&gt;
&lt;p&gt;В &lt;a href="api_to_upgrade_from_java_8_part_2.html"&gt;прошлый раз&lt;/a&gt; мы рассказывали про метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineClass(byte[])"&gt;&lt;code&gt;MethodHandles.Lookup.defineClass()&lt;/code&gt;&lt;/a&gt;, с помощью которого можно во время выполнения легко загрузить класс в том же пакете, не создавая при этом новый загрузчик класса. Это очень удобный метод, но у него есть существенный минус: класс, который загружен таким образом, будет до конца жизни висеть в памяти (по крайней мере до конца жизни текущего загрузчика класса). Это не очень подходит для приложений, которым требуется динамически генерировать и загружать много временных классов на лету. Но с Java 15 появилась альтернатива в виде нового вида классов, которые называются &lt;a href="https://openjdk.java.net/jeps/371"&gt;&lt;i&gt;скрытыми&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Скрытые классы создаются с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte[],boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)"&gt;&lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/a&gt;. По сути этот метод очень похож на старый нестандартный метод &lt;code&gt;Unsafe.defineAnonymousClass()&lt;/code&gt;, который много лет используется различными фреймворками, поскольку решает проблему неконтролируемого роста количества временных классов в памяти. При этом сам &lt;code&gt;Unsafe.defineAnonymousClass()&lt;/code&gt; с Java 15 стал deprecated for removal.&lt;/p&gt;
&lt;p&gt;Скрытые классы имеют следующие особенности:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;На них не могут прямо ссылаться другие классы. Всё их использование может осуществляться исключительно через рефлексию.&lt;/li&gt;
    &lt;li&gt;Они являются необнаружимыми. Их нельзя найти ни по имени, ни обнаружить с помощью загрузчиков классов (через &lt;code&gt;Class.forName()&lt;/code&gt;, &lt;code&gt;ClassLoader.loadClass()&lt;/code&gt;, &lt;code&gt;ClassLoader.findLoadedClass()&lt;/code&gt; и т.д.). Однако скрытые классы не являются анонимными и всё-таки имеют имя в формате &lt;code&gt;&amp;lt;имя класса в байт-коде&amp;gt;/&amp;lt;suffix&amp;gt;&lt;/code&gt; (например, &lt;code&gt;org.example.Temp/0x0000000800cb8000&lt;/code&gt;).&lt;/li&gt;
    &lt;li&gt;Они реализованы таким способом, что не связаны сильной ссылкой с загрузчиком класса, а значит могут быть собраны сборщиком мусора, когда их &lt;code&gt;Class&lt;/code&gt; становится недостижимым (но если хочется, то это можно переопределить, передав опцию &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.ClassOption.html#STRONG"&gt;&lt;code&gt;ClassOption.STRONG&lt;/code&gt;&lt;/a&gt; в &lt;code&gt;defineHiddenClass()&lt;/code&gt;).&lt;/li&gt;
    &lt;li&gt;Они не появляются в стектрейсах, если только не включить опции &lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кстати, вы уже должны быть хорошо знакомы со скрытыми классами, поскольку используете их каждый день. Это лямбды:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Runnable runnable = () -&gt; {}
runnable ==&gt; $Lambda$26/0x0000000800c0aa00@443b7951

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; runnable.getClass().isHidden()
$2 ==&gt; true&lt;/pre&gt;

&lt;p&gt;Давайте создадим небольшой примерчик и определим свой скрытый класс &amp;laquo;с нуля&amp;raquo;. Пусть он для простоты складывает два &lt;code&gt;int&lt;/code&gt;'а. Для разнообразия будем это делать не с помощью javac, а через &lt;a href="https://bytebuddy.net/#/"&gt;ByteBuddy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Для начала нужно создать представление класса в байт-коде в виде массива байтов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] bytes = &lt;span style="color: blue"&gt;new&lt;/span&gt; ByteBuddy()
        .subclass(Object.&lt;span style="color: blue"&gt;class&lt;/span&gt;)
        .name(&lt;span style="color: darkred"&gt;"org.example.Temp"&lt;/span&gt;)
        .defineMethod(&lt;span style="color: darkred"&gt;"sum"&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.class, Modifier.PUBLIC)
        .withParameters(&lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;)
        .intercept(&lt;span style="color: blue"&gt;new&lt;/span&gt; Implementation.Simple(
                MethodVariableAccess.INTEGER.loadFrom(1),
                MethodVariableAccess.INTEGER.loadFrom(2),
                Addition.INTEGER,
                MethodReturn.INTEGER))
        .make()
        .getBytes();&lt;/pre&gt;
&lt;p&gt;По сути мы скомпилировали вот такой класс, но сделали это в рантайме непосредственно через манипуляции с байт-кодом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Temp {
    &lt;span style="color: blue"&gt;public int&lt;/span&gt; sum(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {
        &lt;span style="color: blue"&gt;return&lt;/span&gt; x + y;
    }
}&lt;/pre&gt;
&lt;p&gt;Теперь, когда у нас есть байт-код класса, можно его загружать и что-то с ним делать:&lt;/p&gt;
&lt;pre&gt;Lookup lookup = MethodHandles
        .lookup()
        .defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);

&lt;span style="color: green"&gt;// Для разнообразия будем использовать MethodHandle вместо reflection&lt;/span&gt;
Object obj = lookup
        .findConstructor(lookup.lookupClass(), MethodType.methodType(&lt;span style="color: blue"&gt;void&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;))
        .invoke();

MethodHandle sumHandle = lookup.findVirtual(lookup.lookupClass(), &lt;span style="color: darkred"&gt;"sum"&lt;/span&gt;,
        MethodType.methodType(&lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;));

&lt;span style="color: green"&gt;// Вызовем метод sum. Должен напечатать 5&lt;/span&gt;
System.out.println(sumHandle.invoke(obj, 3, 2));&lt;/pre&gt;
&lt;p&gt;Вот и всё.&lt;/p&gt;

&lt;p&gt;Кстати, так как скрытые классы необнаружимы, то загружать один и тот же класс можно сколько угодно раз. По сути каждый раз будет определяться новый уникальный скрытый класс:&lt;/p&gt;
&lt;pre&gt;Lookup lookup1 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
Lookup lookup2 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
Lookup lookup3 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
System.out.println(lookup1.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4000&lt;/span&gt;
System.out.println(lookup2.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4400&lt;/span&gt;
System.out.println(lookup3.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4800&lt;/span&gt;&lt;/pre&gt;



&lt;h4&gt;8. Новые методы в &lt;code&gt;Math&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9 / Java 15&lt;/h5&gt;
&lt;p&gt;Наверное, практически все, кто начинал работать с большими числами в Java, совершал вот такую ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = ...
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = ...
&lt;span style="color: blue"&gt;long&lt;/span&gt; z = x * y;&lt;/pre&gt;
&lt;p&gt;Это один из тех примеров в Java, когда можно угодить в ловушку даже на простом умножении: произведение двух &lt;code&gt;int&lt;/code&gt; &amp;ndash; это тоже &lt;code&gt;int&lt;/code&gt;, а значит то, что переменная &lt;code&gt;z&lt;/code&gt; имеет тип &lt;code&gt;long&lt;/code&gt;, от переполнения никак не спасает. Для исправления этой ошибки нужно явно прикастовать хотя бы один из множителей к &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; z = (&lt;span style="color: blue"&gt;long&lt;/span&gt;) x * y;&lt;/pre&gt;
&lt;p&gt;В то время как такое решение абсолютно рабочее, у меня в моём перфекционистском подсознании остаётся какой-то мелкий осадок. Во-первых, мне не нравится этот явный каст, который применяется то ли к первому множителю, то ли ко всему произведению. Во-вторых, не нравится эта асимметрия, что одна из переменных кастуется, а другая нет. В общем, я хочу кристальную ясность и отсутствие магии. Способ написать вот такое:&lt;/p&gt;
&lt;pre&gt;Возьми два int и перемножь их в long с учётом переполнения&lt;/pre&gt;
&lt;p&gt;И с Java 9 такой способ есть. Это метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#multiplyFull(int,int)"&gt;&lt;code&gt;Math.multiplyFull()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; z = Math.multiplyFull(x, y);&lt;/pre&gt;

&lt;p class="pt-2"&gt;Вообще обработка переполнений в Java реализуется довольно муторно, и чтобы облегчить жизнь программистам, в Java 8 появилась целая пачка методов для этого в классе &lt;code&gt;Math&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; toIntExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; value)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; incrementExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; incrementExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; decrementExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; decrementExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; negateExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; negateExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; addExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; addExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; subtractExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; subtractExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; multiplyExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; multiplyExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все эти методы выбрасывают ошибку в случае переполнения, что во многих случаях лучше, чем просто тихое переполнение &amp;ndash; лучше уж упадёт сразу, чем где-нибудь позже с совсем другой ошибкой. Но все ли возможные случаи тут покрыты? Похоже, что нет. Например, я не вижу модуль, который хоть и в очень редком случае, но всё же может переполниться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.abs(Integer.MIN_VALUE)
$1 ==&gt; -2147483648&lt;/pre&gt;
&lt;p&gt;Как же так, ведь модуль &amp;ndash; это положительное число? Это так, но дело в том, что 2147483648 просто не влезает в &lt;code&gt;int&lt;/code&gt;, поэтому этот отдельный случай является исключением. Чтобы вот так по чистой случайности не напороться на такое, можно обезопасить себя методом &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#absExact(int)"&gt;&lt;code&gt;Math.absExact()&lt;/code&gt;&lt;/a&gt;, который появился в Java 15:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.absExact(Integer.MIN_VALUE)
|  &lt;span style="color: red"&gt;Exception java.lang.ArithmeticException: Overflow to represent absolute value of Integer.MIN_VALUE&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Math.absExact (Math.java:1392)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#1:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.absExact(Long.MIN_VALUE)
|  &lt;span style="color: red"&gt;Exception java.lang.ArithmeticException: Overflow to represent absolute value of Long.MIN_VALUE&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Math.absExact (Math.java:1438)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#2:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;А знаете ли вы, сколько будет, если найти целое от деления -11 на 3? А остаток? Давайте проверим:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; -11 / 3
$1 ==&gt; -3

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; -11 % 3
$2 ==&gt; -2&lt;/pre&gt;
&lt;p&gt;Ну вроде бы логично, ведь &lt;code&gt;-11 = 3 * (-3) - 2&lt;/code&gt;. Однако если вы выполните то же самое, например, на Python, то получите совсем иной результат:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;&gt;&gt;&gt;&lt;/span&gt; -11 / 3
-4
&lt;span style="color: grey"&gt;&gt;&gt;&gt;&lt;/span&gt; -11 % 3
1&lt;/pre&gt;
&lt;p&gt;И этот результат тоже по-своему верный: &lt;code&gt;-11 = 3 * (-4) + 1&lt;/code&gt;. Дело в том, что есть два способа деления целых чисел: с обрезанием в сторону нуля и с обрезанием в сторону минус бесконечности. Java выбрала первый способ, Python &amp;ndash; второй. Ну а что делать, если я хочу в Java делить по-питоновски? Для этого в Java 9 появились методы &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorDiv(int,int)"&gt;&lt;code&gt;Math.floorDiv()&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorMod(int,int)"&gt;&lt;code&gt;Math.floorMod()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.floorDiv(-11, 3)
$1 ==&gt; -4

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.floorMod(-11, 3)
$2 ==&gt; 1&lt;/pre&gt;

&lt;p class="pt-2"&gt;Также для совсем упоротых математиков в Java 9 появились два метода &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(float,float,float)"&gt;&lt;code&gt;Math.fma(float, float, float)&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(double,double,double)"&gt;&lt;code&gt;Math.fma(double, double, double)&lt;/code&gt;&lt;/a&gt;, которые делают то же самое, что и &lt;code&gt;a * b + c&lt;/code&gt;, но только точнее, потому что используют специальную отдельную инструкцию процессора:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.fma(2.99, 5.91, 7.1)
$1 ==&gt; 24.7709

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; 2.99 * 5.91 + 7.1
$2 ==&gt; 24.770900000000005&lt;/pre&gt;

&lt;h4&gt;9. Аннотация &lt;code&gt;java.io.Serial&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появилась в: Java 14&lt;/h5&gt;
&lt;p&gt;Используете ли вы стандартную сериализацию в Java? Этот механизм далеко не идеальный и со своими &lt;a href="https://www.youtube.com/watch?v=dOgfWXw9VrI"&gt;недостатками&lt;/a&gt;, но иногда он может быть очень удобным, потому что позволяет из коробки очень просто сделать сереализацию и десериализацию Java-объектов. Рассмотрим пример:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point {
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1L;

    &lt;span style="color: blue"&gt;public&lt;/span&gt; int x;
    &lt;span style="color: blue"&gt;public&lt;/span&gt; int y;
}&lt;/pre&gt;
&lt;p&gt;Чтобы сконвертировать объект &lt;code&gt;Point&lt;/code&gt; в массив байтов, нужно написать всего несколько строчек:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; point = &lt;span style="color: blue"&gt;new&lt;/span&gt; Point();
point.x = 1;
point.y = 2;

&lt;span style="color: blue"&gt;var&lt;/span&gt; baos = new ByteArrayOutputStream();
&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; oos = &lt;span style="color: blue"&gt;new&lt;/span&gt; ObjectOutputStream(baos)) {
    oos.writeObject(point);
}
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] bytes = baos.toByteArray();&lt;/pre&gt;

&lt;p&gt;Очень удобно. Кстати, вы заметили ошибку в моём коде? Конечно же, я забыл реализовать интерфейс &lt;code&gt;Serializable&lt;/code&gt;! (Я специально добавил поле &lt;code&gt;serialVersionUID&lt;/code&gt;, чтобы отвлечь ваше внимание.)&lt;/p&gt;
&lt;p&gt;Правильный код будет таким:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;

    &lt;span style="color: blue"&gt;public&lt;/span&gt; int x;
    &lt;span style="color: blue"&gt;public&lt;/span&gt; int y;
}&lt;/pre&gt;
&lt;p&gt;И вот это как раз и есть одна из главных проблем сериализации &amp;ndash; при её использовании можно очень легко допустить ошибку: забыть &lt;code&gt;Serializable&lt;/code&gt;, опечататься в названии поля &lt;code&gt;serialVersionUID&lt;/code&gt;, забыть сделать его статическим и т.д. Чтобы немного обезопаситься от такого, в Java 14 ввели новую аннотацию &lt;a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Serial.html"&gt;&lt;code&gt;Serial&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Этой аннотацией теперь рекомендуется помечать все поля и методы, относящиеся к механизму сериализации:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Теперь, если будет допущена ошибка, то появится предупреждение:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt; &lt;span style="color: red"&gt;// Annotated member is not a part of the serialization mechanism&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Или:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt; &lt;span style="color: red"&gt;// Annotated member is not a part of the serialization mechanism&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final int&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Аннотация будет делать проверки на всех полях и методах, которые относятся к сериализации: &lt;code&gt;serialVersionUID&lt;/code&gt;, &lt;code&gt;serialPersistentFields&lt;/code&gt;, &lt;code&gt;writeObject()&lt;/code&gt;, &lt;code&gt;readObject()&lt;/code&gt; и т.д.&lt;/p&gt;
&lt;p&gt;К сожалению, на текущий момент предупреждения хорошо работают только в IntelliJ IDEA. В компиляторе JDK 16 проверки выполняются только с включённым флагом &lt;code&gt;-Xlint:serial&lt;/code&gt; и работают не все. Например, для двух примеров выше &lt;code&gt;javac&lt;/code&gt; ругается только во втором случае:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;&gt;&lt;/span&gt; javac -Xlint:serial Point.java
Point.java:6: warning: [serial] serialVersionUID must be of type long in class Point
    private static final int serialVersionUID = 1;
                             ^&lt;/pre&gt;
&lt;p&gt;Возможно, это &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8202056"&gt;исправят в Java 17&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;10. Методы &lt;code&gt;Objects&lt;/code&gt;: &lt;code&gt;checkIndex()&lt;/code&gt;, &lt;code&gt;checkFromIndexSize()&lt;/code&gt;, &lt;code&gt;checkFromToIndex()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9 / Java 16&lt;/h5&gt;
&lt;p&gt;Завершим нашу статью несколькими полезными методами для проверки индексов.&lt;/p&gt;
&lt;p&gt;Иногда приходится писать функции, принимающие в качестве входных параметров индексы или диапазоны индексов, и чтобы начать использовать эти индексы, нужно сначала убедиться, что они не выходят за границы. То есть приходится писать подобные проверки в начале методов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static void&lt;/span&gt; getAt(&lt;span style="color: blue"&gt;int&lt;/span&gt; index, &lt;span style="color: blue"&gt;int&lt;/span&gt; length) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &lt; 0) {
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &lt; 0"&lt;/span&gt;);
    }
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &gt;= length) {
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &gt;= length"&lt;/span&gt;);
    }
    ...
}&lt;/pre&gt;
&lt;p&gt;Если подобных функций в проекте становится уже несколько, то чтобы не повторяться, такие проверки удобнее вынести в отдельные утилитные методы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; PreconditionUtils {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; checkIndex(&lt;span style="color: blue"&gt;int&lt;/span&gt; index, &lt;span style="color: blue"&gt;int&lt;/span&gt; length) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &lt; 0) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &lt; 0"&lt;/span&gt;);
        }
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &gt;= length) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &gt;= length"&lt;/span&gt;);
        }
    }
}&lt;/pre&gt;

&lt;p&gt;Но с Java 9 теперь это больше не нужно, потому что в классе &lt;code&gt;Objects&lt;/code&gt; теперь есть стандартные методы проверок индексов.&lt;/p&gt;
&lt;p&gt;Метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkIndex(int,int)"&gt;&lt;code&gt;Objects.checkIndex()&lt;/code&gt;&lt;/a&gt; проверяет, что индекс находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkIndex(-3, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Index -3 out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkIndex (Preconditions.java:248)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkIndex (Objects.java:372)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#1:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkIndex(10, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Index 10 out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkIndex (Preconditions.java:248)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkIndex (Objects.java:372)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#2:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(int,int,int)"&gt;&lt;code&gt;Objects.checkFromIndexSize()&lt;/code&gt;&lt;/a&gt; проверяет, что диапазон &lt;code&gt;[fromIndex, fromIndex + size)&lt;/code&gt; находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(3, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#3:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(-2, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [-2, -2 + 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#4:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(3, -4, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + -4) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#5:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Наконец, метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromToIndex(int,int,int)"&gt;&lt;code&gt;Objects.checkFromToIndex()&lt;/code&gt;&lt;/a&gt; проверяет, что диапазон &lt;code&gt;[fromIndex, toIndex)&lt;/code&gt; находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(3, 11, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 11) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#6:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(-4, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [-4, 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#7:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(6, 4, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [6, 4) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#8:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Кроме того, в Java 16 появились перегрузки этих функций для &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkIndex(long,long)"&gt;&lt;code&gt;checkIndex(long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(long,long,long)"&gt;&lt;code&gt;checkFromIndexSize(long, long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromToIndex(long,long,long)"&gt;&lt;code&gt;checkFromToIndex(long, long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Заключение&lt;/h4&gt;
&lt;p&gt;Сегодня я рассказал про 10 интересных API, некоторые из которых появились в буквально только что &lt;a href="java_16.html"&gt;вышедшей Java 16&lt;/a&gt;, а некоторые уже присутствуют довольно давно ещё с 9-й версии. Надеюсь, что после прочтения данной статьи вы стали более заинтересованными в миграции на последнюю версию Java. Помните, что в новых версиях Java появляются не только новые возможности, но и изменения, ломающие обратную совместимость (&lt;a href="https://openjdk.java.net/jeps/260"&gt;1&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/322"&gt;2&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/320"&gt;3&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/372"&gt;4&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/396"&gt;5&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/363"&gt;6&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/367"&gt;7&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/403"&gt;8&lt;/a&gt;). И чем больше вы тянете с переходом с Java 8 на последнюю версию, тем сложнее вам будет осуществить этот переход.&lt;/p&gt;
&lt;p&gt;Продолжение следует...&lt;/p&gt;</content>
  </entry>
</feed>
