<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-05-16T17:00:00Z</updated>
  <entry>
    <title>Новости Java #18</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_18.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_18.html</id>
    <updated>2021-05-16T17:00:00Z</updated>
    <published>2021-05-16T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышла &lt;a href="https://scala-lang.org/blog/2021/05/14/scala3-is-here.html"&gt;Scala 3&lt;/a&gt;. Это следующая версия языка, работа над которой велась более 8 лет более чем 100 разработчиками. В этот релиз попало 28 тысяч коммитов, 7400 пулл-реквестов и 4100 закрытых задач. Новый язык содержит в себе &amp;laquo;последние исследования в теории типов, так же как и индустриальный опыт Scala 2&amp;raquo;. Перечислим лишь некоторые изменения в новой версии:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый синтаксис &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/control-syntax.html"&gt;без фигурных скобок&lt;/a&gt;. Индентация теперь имеет &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/indentation.html"&gt;строгие правила&lt;/a&gt; и влияет на компиляцию.&lt;/li&gt;
  &lt;li&gt;Ключевое слово &lt;code&gt;new&lt;/code&gt; теперь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/creator-applications.html"&gt;опционально&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Implicit'ов больше нет, и теперь концепция разделена на несколько независимых частей, каждая из которых заточена под свои конкретные вещи: &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/using-clauses.html"&gt;условия using&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/givens.html"&gt;given-инстансы&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/extension-methods.html"&gt;extension-методы&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/conversions.html"&gt;неявные конверсии&lt;/a&gt;, &lt;a href="https://dotty.epfl.ch/docs/reference/contextual/context-functions.html"&gt;контекстные функции&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/enums/enums.html"&gt;Перечисления&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/new-types/intersection-types.html"&gt;Пересечения&lt;/a&gt; и &lt;a href="https://dotty.epfl.ch/docs/reference/new-types/union-types.html"&gt;объеденения&lt;/a&gt; типов.&lt;/li&gt;
  &lt;li&gt;Типы функций, &lt;a href="https://dotty.epfl.ch/docs/reference/new-types/dependent-function-types.html"&gt;зависящие от параметров&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://dotty.epfl.ch/docs/reference/new-types/match-types.html"&gt;match-типы&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;trait'ы теперь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/trait-parameters.html"&gt;могут иметь параметры&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Классы, от которых можно наследоваться, теперь должны иметь &lt;a href="https://dotty.epfl.ch/docs/reference/other-new-features/open-classes.html"&gt;модификатор &lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Подробный список новых возможностей и улучшений в Scala 3 можно найти &lt;a href="https://docs.scala-lang.org/scala3/new-in-scala3.html"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="http://openjdk.java.net/jeps/8266010"&gt;JEP: Reimplement Core Reflection on Method Handles&lt;/a&gt;. В нём предлагается реализовать рефлексию в Java поверх method handles, тем самым избавившись от одной лишней реализации рефлективного механизма, которые дублируют друг друга. Это уменьшит затраты на поддержку и разработку API в пакетах &lt;code&gt;java.lang.reflect&lt;/code&gt; и &lt;code&gt;java.lang.invoke&lt;/code&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На сайте OpenJDK впервые появились &lt;a href="https://jdk.java.net/17/"&gt;сборки JDK под Apple M1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains объявил &lt;a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-online-event/"&gt;Kotlin Online Event&lt;/a&gt; в честь выхода Kotlin 1.5. Он состоится 25 мая.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/scala/scala/releases/tag/v2.13.6"&gt;Scala 2.13.6&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли &lt;a href="https://spring.io/blog/2021/05/11/spring-framework-5-3-7-and-5-2-15-available-now"&gt;Spring Framework 5.3.7 и 5.2.15&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-May/003286.html"&gt;JMH 1.31&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #17</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_17.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_17.html</id>
    <updated>2021-05-09T17:00:00Z</updated>
    <published>2021-05-09T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Самая главная новость этой недели &amp;ndash; выход &lt;a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/"&gt;Kotlin 1.5.0&lt;/a&gt;. Перечислим некоторые изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Появилась поддержка &lt;a href="https://openjdk.java.net/jeps/395"&gt;JVM-записей&lt;/a&gt; с помощью аннотации &lt;code&gt;@JvmRecord&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Модификатор &lt;code&gt;sealed&lt;/code&gt; теперь можно применять не только классам, но и к интерфейсам.&lt;/li&gt;
  &lt;li&gt;Подклассы &lt;code&gt;sealed&lt;/code&gt; классов теперь не обязаны объявляться в том же файле, а могут объявляться в любых файлах того же пакета.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md"&gt;&lt;code&gt;inline value&lt;/code&gt; классы&lt;/a&gt;, которые появились в экспериментальном режиме в Kotlin 1.2.30, теперь стали стабильными.&lt;/li&gt;
  &lt;li&gt;Новый &lt;a href="https://blog.jetbrains.com/kotlin/2021/02/the-jvm-backend-is-in-beta-let-s-make-it-stable-together/"&gt;IR (Intermediate Representation) компилятор&lt;/a&gt; Kotlin в JVM стал стабильным и включенным по умолчанию.&lt;/li&gt;
  &lt;li&gt;SAM (Single Abstract Method) адаптеры теперь компилируются в &lt;code&gt;invokedynamic&lt;/code&gt;. Для простых лямбд такая возможность тоже появилась, но только в экспериментальном режиме с включенной опцией &lt;code&gt;-Xlambdas=indy&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Версия JVM target теперь 1.8 вместо 1.6.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="JEP 415: Context-Specific Deserialization Filters"&gt;JEP 415: Context-Specific Deserialization Filters&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/05/java-annotated-monthly-may-2021/"&gt;Java Annotated Monthly за май 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8266431"&gt;предложено&lt;/a&gt; улучшить алгоритм сортировки чисел. Тесты показывают, что прирост производительности составляет 50% в среднем и до 6 раз на больших случайных массивах. Огромный прирост в последнем случае достигается засчёт использования поразрядной сортировки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK было предложено сделать &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2021-May/001518.html"&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; абстрактным классом&lt;/a&gt;. Это бы сделало согласованной модель, в которой примитивные классы могут наследоваться только от абстрактных классов без полей, но сломало бы обратную совместимость на уровне исходного кода. Но запретить вызывать &lt;code&gt;new Object()&lt;/code&gt; можно поэтапно, сначала показывая предупреждение, а спустя несколько лет переквалифицировать в ошибку компиляции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел бэкпорт-релиз &lt;a href="https://docs.gradle.org/6.9/release-notes.html"&gt;Gradle 6.9&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-May/003237.html"&gt;JMH 1.30&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #16</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_16.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_16.html</id>
    <updated>2021-05-02T17:00:00Z</updated>
    <published>2021-05-02T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.java.net/jeps/413"&gt;JEP 413: Code Snippets in Java API Documentation&lt;/a&gt;. Про него мы подробно писали в &lt;a href="java_news_5.html"&gt;выпуске новостей #5&lt;/a&gt;, когда появился его черновик.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://openjdk.java.net/jeps/414"&gt;JEP 414: Vector API (Second Incubator)&lt;/a&gt;. API для векторных вычислений появилось &lt;a href="java_16.html"&gt;в Java 16&lt;/a&gt; в статусе инкубатора, и в следующем релизе продолжит находиться в этом статусе.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Брайан Гётц &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-April/002959.html"&gt;предложил&lt;/a&gt; в рассылке OpenJDK идею сделать все &lt;code&gt;switch&lt;/code&gt; исчерпывающими (exhaustive). Это значит, что подобное использование оператора &lt;code&gt;switch&lt;/code&gt; когда-нибудь перестанет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;enum&lt;/span&gt; COLOR {
    RED, GREEN, BLUE;
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (color) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RED: System.out.println(&lt;span style="color: darkred"&gt;"red"&lt;/span&gt;); &lt;span style="color: blue"&gt;break&lt;/span&gt;;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GREEN: System.out.println(&lt;span style="color: darkred"&gt;"green"&lt;/span&gt;); &lt;span style="color: blue"&gt;break&lt;/span&gt;;
}&lt;/pre&gt;
&lt;p&gt;Чтобы такой statement стал компилироваться, нужно будет добавить либо недостающую константу, либо ветку &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Так как предлагаемое изменение сломает обратную совместимость, то сначала для неисчерпывающих &lt;code&gt;switch&lt;/code&gt; предлагается выдавать предупреждение, а лишь потом переквалифицировать их в ошибки компиляции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли IntelliJ IDEA &lt;a href="https://blog.jetbrains.com/idea/2021/04/intellij-idea-2020-3-4/"&gt;2020.3.4&lt;/a&gt; и &lt;a href="https://blog.jetbrains.com/idea/2021/04/intellij-idea-2021-1-1/"&gt;2021.1.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://medium.com/graalvm/graalvm-21-1-96e18f6806bf"&gt;GraalVM 21.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.micronaut.io/latest/guide/#whatsNew"&gt;Micronaut 2.5&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло обновление JDK: &lt;a href="http://jdk.java.net/17/"&gt;17-ea+20&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jcstress-dev/2021-April/000561.html"&gt;JCStress 0.10&lt;/a&gt; (библиотека для проверки корректности concurrency).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #15</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_15.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_15.html</id>
    <updated>2021-04-25T17:00:00Z</updated>
    <published>2021-04-25T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/16-0-1-relnotes.html"&gt;JDK 16.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005848.html"&gt;JDK 15.0.3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005850.html"&gt;JDK 13.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-April/005860.html"&gt;JDK 11.0.11&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-April/013680.html"&gt;JDK 8u292&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+19&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;bull; Вышел &lt;a href="https://openjdk.java.net/jeps/411"&gt;JEP 411: Deprecate the Security Manager for Removal&lt;/a&gt;. Как следует из названия, в нём предлагается пометить класс &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/SecurityManager.html"&gt;&lt;code&gt;java.lang.SecurityManager&lt;/code&gt;&lt;/a&gt; как deprecated for removal, а в будущих релизах удалить его окончательно. Также этой же участи будут постигнуты ещё 10 классов и 7 методов, связанных с &lt;code&gt;SecurityManager&lt;/code&gt;. Кроме того, значение свойста &lt;code&gt;java.security.manager&lt;/code&gt; станет по умолчанию &lt;code&gt;disallow&lt;/code&gt; (что означает, что &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"&gt;&lt;code&gt;System.setSecurityManager()&lt;/code&gt;&lt;/a&gt; будет выбрасывать &lt;code&gt;UnsupportedOperationException&lt;/code&gt;), а при его указании через аргументы командной строки будет выдаваться предупреждение на старте.&lt;/p&gt;
&lt;p&gt;Отказаться от Security Manager предлагается по причине того, что он слабо отвечает современным требованиям безопасности и не имеет высокого спроса со стороны современных Java-разработчиков, а цена его поддержки очень высока. У него хрупкая модель разрешений, сложная программная модель, и он приносит большие накладные расходы в плане производительности.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один &lt;a href="https://openjdk.java.net/jeps/412"&gt;JEP 412: Foreign Function &amp; Memory API (Incubator)&lt;/a&gt;. Этот JEP &amp;ndash; не что иное, как объединение и дальнейшая эволюция других двух JEP'ов: &lt;a href="https://openjdk.java.net/jeps/370"&gt;JEP 370: Foreign-Memory Access API (Incubator)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/389"&gt;JEP 389: Foreign Linker API (Incubator)&lt;/a&gt;. Эти два API тесно связаны друг с другом и находятся в одном модуле &lt;code&gt;jdk.incubator.foreign&lt;/code&gt;, поэтому было логично их объединить.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2021/04/java-annotated-monthly-april-2021/"&gt;Java Annotated Monthly за апрель 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains &lt;a href="https://blog.jetbrains.com/idea/2021/04/end-of-support-for-32-bit-operating-systems-in-intellij-based-ides/"&gt;откажется от поддержки 32-битных версий&lt;/a&gt; своих IDE. 2021.1 станут последними версиями сред, которые поддерживают 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/blog/2021/04/13/jetbrains-toolbox-2021-1-summary/"&gt;JetBrains ToolBox 2021.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/04/kotlin-1-5-0-rc-released/"&gt;Kotlin 1.5.0-RC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/13/spring-framework-5-3-6-and-5-2-14-available-now"&gt;Spring Framework 5.3.6 и 5.2.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/14/spring-integration-5-5-rc1-5-4-6-5-3-7-available"&gt;Spring Integration 5.5-RC1, 5.4.6 и 5.3.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-5-0-rc1-available-now"&gt;Spring Boot 2.5.0-RC1&lt;/a&gt;, &lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-4-5-available-now"&gt;2.4.5&lt;/a&gt; и &lt;a href="https://spring.io/blog/2021/04/15/spring-boot-2-3-10-is-now-available"&gt;2.3.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/12/spring-security-5-5-0-rc1-released"&gt;Spring Security 5.5.0-RC1&lt;/a&gt;, &lt;a href="https://spring.io/blog/2021/04/12/spring-security-5-2-10-5-3-9-and-5-4-6-released"&gt;5.4.6, 5.3.9 и 5.2.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/04/20/what-s-new-in-spring-data-2021-0"&gt;Spring Data 2021.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/raphw/byte-buddy/blob/master/release-notes.md"&gt;ByteBuddy 1.11.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>API, ради которых наконец-то стоит обновиться с Java 8. Часть 3</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/api_to_upgrade_from_java_8_part_3.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/api_to_upgrade_from_java_8_part_3.html</id>
    <updated>2021-04-23T17:00:00Z</updated>
    <published>2021-04-23T17:00:00Z</published>
    <content type="html">&lt;p&gt;Какие есть причины переходить на новые версии Java? Кто-то это сделает из-за новых языковых возможностей вроде &lt;a href="https://openjdk.java.net/jeps/361"&gt;выражений &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/378"&gt;блоков текста&lt;/a&gt; или &lt;a href="https://openjdk.java.net/jeps/395"&gt;записей&lt;/a&gt;. Кому-то понадобятся новые интересные возможности вроде &lt;a href="https://openjdk.java.net/jeps/261"&gt;модулей&lt;/a&gt; или &lt;a href="https://openjdk.java.net/jeps/379"&gt;низкопаузных сборщиков мусора&lt;/a&gt;. Кто-то это сделает просто из-за того, что обновив версию Java, их программа &lt;a href="https://openjdk.java.net/jeps/341"&gt;станет быстрее&lt;/a&gt; и будет &lt;a href="https://openjdk.java.net/jeps/254"&gt;есть меньше памяти&lt;/a&gt;. Но есть ещё одна, не менее важная причина. Это новые API, которые позволят писать меньше кода и избежать траты времени на поиск нужной функциональности во внешних библиотеках. А в некоторых случаях сделают ваш код быстрее.&lt;/p&gt;
&lt;p&gt;В предыдущих двух частях мы уже рассмотрели по 10 новых API, которые появились в Java 9 и более поздних версиях (&lt;a href="api_to_upgrade_from_java_8.html"&gt;часть 1&lt;/a&gt;, &lt;a href="api_to_upgrade_from_java_8_part_2.html"&gt;часть 2&lt;/a&gt;). Сегодня мы рассмотрим ещё 10.&lt;/p&gt;
&lt;!-- cut --&gt;

&lt;h4&gt;1. &lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: &lt;a href="java_16.html"&gt;Java 16&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Для какой задачи чаще всего используется &lt;code&gt;Stream&lt;/code&gt; в Java? Конечно же, для трансформации списков: у нас есть список, над которым нужно совершить какое-то преобразование и вернуть новый. Такой паттерн вы наверняка видели в своём проекте множество раз:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;T&amp;gt; targetList = sourceList
        .stream()
        &lt;span style="color: green"&gt;// промежуточные операции&lt;/span&gt;
        .collect(Collectors.toList());&lt;/pre&gt;
&lt;p&gt;Нельзя сказать, что &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; является очень уж громоздкой конструкцией, но всё же хочется для такой частой операции писать поменьше кода. И в Java 16 это стало возможно с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"&gt;&lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;T&amp;gt; targetList = sourceList
        .stream()
        &lt;span style="color: green"&gt;// промежуточные операции&lt;/span&gt;
        .toList();&lt;/pre&gt;
&lt;p&gt;Есть ли какая-то разница между &lt;code&gt;toList()&lt;/code&gt; и &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;? Оба ли способа ведут себя одинаково? С практической точки зрения можно сказать, что нет: если &lt;code&gt;toList()&lt;/code&gt; возвращает неизменяемый список, то &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; возвращает некий список, о котором неизвестно, неизменяемый он или нет. То есть если вы нигде в коде не используете негарантированную вам спецификацией изменяемость списка (надеюсь, вы из такой категории людей), то смело можете заменять &lt;code&gt;collect(Collectors.toList())&lt;/code&gt; на &lt;code&gt;toList()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Однако &lt;code&gt;Stream.toList()&lt;/code&gt; делает код не только короче, но и эффективнее! Дело в том, что &lt;code&gt;Stream.toList()&lt;/code&gt; использует внутри себя &lt;code&gt;Stream.toArray()&lt;/code&gt;, который выделяет массив точной длины, если &lt;code&gt;Spliterator&lt;/code&gt; имеет характеристику &lt;code&gt;SIZED&lt;/code&gt;. В то время как &lt;code&gt;Collectors.toList()&lt;/code&gt; никак эту характеристику не использует и всегда начинает с пустого &lt;code&gt;ArrayList&lt;/code&gt;, накапливая в нём элементы с постоянными переаллокациями.&lt;/p&gt;
&lt;p&gt;Давайте напишем несколько бенчмарков. Для начала рассмотрим самый простейший случай: замерим, как быстро создаётся копия исходного списка, т.е. проверим цепочку вообще без промежуточных операций. Так как для такого сценария &lt;code&gt;Stream&lt;/code&gt; по идее вообще не нужен, и того же самого можно добиться просто вызвав &lt;code&gt;new ArrayList&lt;&gt;(sourceList)&lt;/code&gt; или &lt;code&gt;List.copyOf(sourceList)&lt;/code&gt;, то замерим и эти два случая тоже:&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Полный код JMH-бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToList {

    @Param({"10", "100", "1000"})
    private int size;

    private List&amp;lt;Integer&amp;gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; newArrayList() {
        return new ArrayList&amp;lt;&amp;gt;(sourceList);
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; toList() {
        return sourceList.stream().toList();
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; copyOf() {
        return List.copyOf(sourceList);
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToList() {
        return sourceList.stream().collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToUnmodifiableList() {
        return sourceList.stream().collect(Collectors.toUnmodifiableList());
    }
}&lt;/pre&gt;&lt;/details&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC&lt;/pre&gt;&lt;/details&gt;
&lt;img src="stream_tolist_benchmark1.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;Результаты говорят нам о том, что &lt;code&gt;Stream.toList()&lt;/code&gt; не только существенно быстрее &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;, но и может быть быстрее даже &lt;code&gt;List.copyOf()&lt;/code&gt;! Это объясняется тем, что в &lt;code&gt;List.copyOf()&lt;/code&gt; существенное время тратится на проверку &lt;code&gt;requireNonNull&lt;/code&gt; для каждого входного элемента, поскольку он запрещает &lt;code&gt;null&lt;/code&gt;-элементы, в то время как &lt;code&gt;Stream.toList()&lt;/code&gt; не запрещает &lt;code&gt;null&lt;/code&gt; и в нём такая проверка не нужна. На малых размерах &lt;code&gt;List.copyOf()&lt;/code&gt; всё же выигрывает, потому что проверка нескольких элементов на &lt;code&gt;null&lt;/code&gt; быстрее церемоний, которые есть у &lt;code&gt;Stream&lt;/code&gt;: создание &lt;code&gt;Spliterator&lt;/code&gt;, &lt;code&gt;ReferencePipeline&lt;/code&gt; и т.д.&lt;/p&gt;
&lt;p&gt;Теперь рассмотрим случай, когда точный размер неизвестен. Например, добавим одну промежуточную операцию &lt;code&gt;filter()&lt;/code&gt;:&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Полный код JMH-бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;import org.openjdk.jmh.annotations.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ToListFilter {

    @Param({"10", "100", "1000"})
    private int size;

    private List&amp;lt;Integer&amp;gt; sourceList;

    @Setup
    public void setup() {
        sourceList = IntStream
                .range(0, size)
                .boxed()
                .collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; toList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).toList();
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; newArrayList() {
        var list = new ArrayList&amp;lt;Integer&amp;gt;();
        for (var i : sourceList) {
            if (i % 2 == 0) {
                list.add(i);
            }
        }
        return list;
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).collect(Collectors.toList());
    }

    @Benchmark
    public List&amp;lt;Integer&amp;gt; collectToUnmodifiableList() {
        return sourceList.stream().filter(i -&amp;gt; i % 2 == 0).collect(Collectors.toUnmodifiableList());
    }
}
&lt;/pre&gt;&lt;/details&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 3 -wi 3 -w 5 -i 5 -r 5 -t 6 -jvmArgs -XX:+UseParallelGC&lt;/pre&gt;&lt;/details&gt;
&lt;img src="stream_tolist_benchmark2.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;В этом случае мы тоже получили большое ускорение! И в этот раз &lt;code&gt;Stream.toList()&lt;/code&gt; на большом количестве элементов выиграл даже у простого &lt;code&gt;new ArrayList()&lt;/code&gt; с последующим заполнением в цикле. Как так получается? Дело в том, что при неизвестном размере &lt;code&gt;Stream.toArray()&lt;/code&gt; использует структуру данных &lt;a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/stream/SpinedBuffer.java"&gt;&lt;code&gt;SpinedBuffer&lt;/code&gt;&lt;/a&gt;, которая более эффективна для накопления элементов, чем &lt;code&gt;ArrayList&lt;/code&gt;. Она представляет собой массив массивов, где подмассивы имеют длины в виде возрастающих степеней двойки (каждый следующий chunk в два раза больше предыдущего). Структуру &lt;code&gt;SpinedBuffer&lt;/code&gt; можно легко понять из этого рисунка, где изображён буфер со 100 элементами (&lt;code&gt;Integer&lt;/code&gt; от 0 до 99):&lt;/p&gt;
&lt;img src="spined_buffer.png" class="img-fluid" /&gt;
&lt;p class="pt-2"&gt;Также &lt;code&gt;ArrayList&lt;/code&gt; проигрывает ещё и потому, что расширяется всего лишь в 1.5 раза при заполнении внутреннего массива, а значит делает это намного чаще, что приводит к дополнительным накладным расходам. &lt;code&gt;ArrayList&lt;/code&gt; вынужден балансировать между экономией памяти и скоростью операции &lt;code&gt;add()&lt;/code&gt;, поэтому и проигрывает &lt;code&gt;SpinedBuffer&lt;/code&gt;, который заточен исключительно на скорость. Излишний расход памяти для него не играет роли, так как это недолгоживующая структура, которая сразу же отбрасывается после завершения терминальной операции.&lt;/p&gt;
&lt;p&gt;Вывод: &lt;code&gt;Stream.toList()&lt;/code&gt; короче, чище и почти всегда быстрее, чем &lt;code&gt;collect(Collectors.toList())&lt;/code&gt;. Так что о втором способе можно забыть и использовать всегда первый (хотя &lt;code&gt;Collectors.toList()&lt;/code&gt; сам по себе всё ещё может быть нужен, например как downstream &lt;code&gt;Collector&lt;/code&gt; для других &lt;code&gt;Collector&lt;/code&gt;'ов). Если же нужен гарантированно изменяемый список, то можно использовать &lt;code&gt;collect(Collectors.toCollection(ArrayList::new))&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;2. &lt;code&gt;String&lt;/code&gt;: &lt;code&gt;formatted()&lt;/code&gt;, &lt;code&gt;stripIndent()&lt;/code&gt; и  &lt;code&gt;translateEscapes()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 15&lt;/h5&gt;
&lt;p&gt;В Java 15 появились &lt;a href="https://openjdk.java.net/jeps/378"&gt;блоки текста&lt;/a&gt; &amp;ndash; строковые литералы, которые могут состоять из одной или нескольких линий:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"""
        Привет,
        Юзер!"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;При этом довольно часто блоки будут использоваться в качестве шаблонов с последующей заменой:&lt;/p&gt;
&lt;pre&gt;String str = String.format(&lt;span style="color: darkred"&gt;"""
        Привет,
        %s!"""&lt;/span&gt;, user);&lt;/pre&gt;
&lt;p&gt;Не кажется ли вам, что код выше выглядит несколько громоздким? Мне вот тоже кажется. Но у нас есть способ, как сделать его немножко чище. Это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object...)"&gt;&lt;code&gt;String.formatted()&lt;/code&gt;&lt;/a&gt;, который является нестатическим эквивалентом &lt;code&gt;String.format()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"""
        Привет,
        %s!"""&lt;/span&gt;.formatted(user);&lt;/pre&gt;
&lt;p&gt;Вы, конечно, скажете, что разница лишь в трёх символах сэкономленного кода, но, во-первых, второй вариант гораздо проще печатать на клавиатуре (проверьте сами), а во-вторых, он более читабелен.&lt;/p&gt;
&lt;p&gt;Кстати, &lt;code&gt;formatted()&lt;/code&gt; никто не запрещает использовать и с обычными литералами:&lt;/p&gt;
&lt;pre&gt;String str = &lt;span style="color: darkred"&gt;"Привет, %s!"&lt;/span&gt;.formatted(user);&lt;/pre&gt;
&lt;p&gt;Лично мне метод очень нравится, и я планирую взять его на вооружение в качестве основного рабочего варианта.&lt;/p&gt;

&lt;p class="pt-2"&gt;Второй метод, появившийся в Java 15 &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#stripIndent()"&gt;&lt;code&gt;String.stripIndent()&lt;/code&gt;&lt;/a&gt;, который удаляет общие пробельные символы в начале всех линий. К примеру, если есть файл &lt;code&gt;hello.txt&lt;/code&gt; с такими строками:&lt;/p&gt;
&lt;pre&gt;    Привет,
    Юзер!&lt;/pre&gt;
&lt;p&gt;Тогда чтобы убрать пробелы слева, как раз и можно воспользоваться &lt;code&gt;stripIndent()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String str = Files.readString(Path.of(&lt;span style="color: darkred"&gt;"hello.txt"&lt;/span&gt;)).stripIndent();
System.out.println(str);&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Привет,
Юзер!&lt;/pre&gt;

&lt;p class="pt-2"&gt;Наконец, третий метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#translateEscapes()"&gt;&lt;code&gt;String.translateEscapes()&lt;/code&gt;&lt;/a&gt;. Он делает простую вещь: заменяет экранирующие последовательности на их соответствующие символы.&lt;/p&gt;
&lt;p&gt;Например, есть файл hello.txt:&lt;/p&gt;
&lt;pre&gt;Привет,\nЮзер!&lt;/pre&gt;
&lt;pre&gt;String str = Files.readString(Path.of(&lt;span style="color: darkred"&gt;"hello.txt"&lt;/span&gt;)).translateEscapes();
System.out.println(str);&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Привет,
Юзер!&lt;/pre&gt;

&lt;h4&gt;3. &lt;code&gt;CharSequence.isEmpty()&lt;/code&gt;, &lt;code&gt;CharSequence.compare()&lt;/code&gt; и &lt;code&gt;StringBuilder.compareTo()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 15 / Java 11&lt;/h5&gt;
&lt;p&gt;Если уж мы начали тему строк, то давайте добьём её до конца.&lt;/p&gt;
&lt;p&gt;Тот, кто писал на Java 1.5 или на более старых версиях, должен помнить, что в классе &lt;code&gt;String&lt;/code&gt; в те времена не было метода &lt;code&gt;isEmpty()&lt;/code&gt;. Поэтому для проверки строки на пустоту каждый раз приходилось использовать &lt;code&gt;length()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (str.length() != 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Это было не совсем удобно, и в Java 1.6 метод &lt;a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#isEmpty()"&gt;&lt;code&gt;String.isEmpty()&lt;/code&gt;&lt;/a&gt; наконец-то завезли:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (!str.isEmpty()) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Однако про то, что &lt;code&gt;String&lt;/code&gt; &amp;ndash; далеко не единственная реализация &lt;code&gt;CharSequence&lt;/code&gt; (хоть и самая популярная), почему-то не подумали, и этот метод туда добавлять не стали (впрочем, без &lt;code&gt;default&lt;/code&gt;-методов они бы этого сделать и не смогли). Например, для проверки на пустоту &lt;code&gt;StringBuilder&lt;/code&gt; всё ещё приходилось использовать &lt;code&gt;length()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (stringBuilder.length() != 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Но спустя 14 лет всё-таки решили исправить и это: начиная с Java 15, метод &lt;code&gt;isEmpty()&lt;/code&gt; есть не только у &lt;code&gt;String&lt;/code&gt;, но и у любой &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/CharSequence.html#isEmpty()"&gt;&lt;code&gt;CharSequence&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (!stringBuilder.isEmpty()) {
    ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Также иногда приходится тестировать два &lt;code&gt;CharSequence&lt;/code&gt; на равенство. Метод &lt;code&gt;equals()&lt;/code&gt; использовать нельзя: а вдруг он не переопределён в реализации? Поэтому приходится изворачиваться: либо конвертировать каждый &lt;code&gt;CharSequence&lt;/code&gt; в &lt;code&gt;String&lt;/code&gt; и сравнивать их, что может быть накладно, либо писать свою реализацию посимвольного сравнения.&lt;/p&gt;
&lt;p&gt;Однако, начиная с Java 11, всё это не нужно, потому что появился метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html#compare(java.lang.CharSequence,java.lang.CharSequence)"&gt;&lt;code&gt;CharSequence.compare()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (CharSequence.compare(charSeq1, charSeq2) == 0) {
    ...
}&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;compare()&lt;/code&gt; также можно использовать не только для просто теста на равенство, но и для лексикографического сравнения.&lt;/p&gt;
&lt;p&gt;Также в Java 11 класс &lt;code&gt;StringBuilder&lt;/code&gt; стал реализовывать интерфейс &lt;code&gt;Comparable&lt;/code&gt;, а значит для сравнения двух &lt;code&gt;StringBuilder&lt;/code&gt; можно использовать &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html#compareTo(java.lang.StringBuilder)"&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (stringBuilder1.compareTo(stringBuilder2) == 0) {
    ...
}&lt;/pre&gt;

&lt;h4&gt;4. &lt;code&gt;Collectors.filtering()&lt;/code&gt; и &lt;code&gt;Collectors.flatMapping()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9&lt;/h5&gt;
&lt;p&gt;Часто ли вам приходится использовать &lt;code&gt;Collectors.groupingBy()&lt;/code&gt;? К примеру, вы ведёте базу данных фильмов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Movie(String title, String genre, &lt;span style="color: blue"&gt;double&lt;/span&gt; rating) {
}&lt;/pre&gt;
&lt;p&gt;Допустим, вы хотите сгруппировать фильмы по жанру:&lt;/p&gt;
&lt;pre&gt;Stream&amp;lt;Movie&amp;gt; allMovies = Stream.of(
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Коммандо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.385),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.974),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор 2"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 8.312),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Молчание ягнят"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.33),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Криминальное чтиво"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.619),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Титаник"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Мелодрама"&lt;/span&gt;, 8.363),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Семьянин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Комедия"&lt;/span&gt;, 7.699)
);

Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre));

groups.forEach((genre, movies) -&gt; {
    System.out.println(genre + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;);
    movies.forEach(movie -&gt;
        System.out.printf(&lt;span style="color: darkred"&gt;"    %s: %.2f%n"&lt;/span&gt;, movie.title(), movie.rating()));
});&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Коммандо: 7.39
    Терминатор: 7.97
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    Семьянин: 7.70&lt;/pre&gt;
&lt;p&gt;Однако, допустим, вы не хотите видеть все фильмы, а только те, у кого рейтинг выше 8. Какой метод вы в этом случае используете? Конечно же, &lt;code&gt;Stream.filter()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies
    .filter(movie -&gt; movie.rating() &gt; 8)
    .collect(Collectors.groupingBy(Movie::genre));&lt;/pre&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62&lt;/pre&gt;
&lt;p&gt;Но вот проблема: вам вдруг захотелось видеть все жанры, даже те, в которые не попало ни одного фильма с рейтингом выше 8. Что делать? Ответ: перейти на новую версию Java, потому что в ней есть &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#filtering(java.util.function.Predicate,java.util.stream.Collector)"&gt;&lt;code&gt;Collectors.filtering()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, List&amp;lt;Movie&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.filtering(movie -&gt; movie.rating() &gt; 8,
            Collectors.toList())));

groups.forEach((genre, movies) -&gt; {
    System.out.println(genre + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (movies.isEmpty()) {
        System.out.println(&lt;span style="color: darkred"&gt;"    &amp;lt;Фильмов с рейтингом выше 8 нет&amp;gt;"&lt;/span&gt;);
    } &lt;span style="color: blue"&gt;else&lt;/span&gt; {
        movies.forEach(movie -&gt;
            System.out.printf(&lt;span style="color: darkred"&gt;"    %s: %.2f%n"&lt;/span&gt;, movie.title(), movie.rating()));
    }
});&lt;/pre&gt;
&lt;p&gt;В этом случае фильтрация будет перенесена внутрь &lt;code&gt;groupingBy()&lt;/code&gt;, и потери жанров не произойдёт:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    Титаник: 8.36
Боевик:
    Терминатор 2: 8.31
Триллер:
    Молчание ягнят: 8.33
    Криминальное чтиво: 8.62
Комедия:
    &amp;lt;Фильмов с рейтингом выше 8 нет&amp;gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;Очень хорошо. Теперь добавим в фильмы актёров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Movie(String title, String genre, &lt;span style="color: blue"&gt;double&lt;/span&gt; rating, List&amp;lt;String&amp;gt; actors) {
}&lt;/pre&gt;
&lt;p&gt;И теперь хотите увидеть всех актёров с группировкой по жанру:&lt;/p&gt;
&lt;pre&gt;Stream&amp;lt;Movie&amp;gt; allMovies = Stream.of(
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Коммандо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.385,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Чонг"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хедайя"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 7.974,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Бин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хэмилтон"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Терминатор 2"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Боевик"&lt;/span&gt;, 8.312,
        List.of(&lt;span style="color: darkred"&gt;"Шварценеггер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хэмилтон"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Ферлонг"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Патрик"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Молчание ягнят"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.33,
        List.of(&lt;span style="color: darkred"&gt;"Фостер"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Хопкинс"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Криминальное чтиво"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Триллер"&lt;/span&gt;, 8.619,
        List.of(&lt;span style="color: darkred"&gt;"Траволта"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Уиллис"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Джексон"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Турман"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Титаник"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Мелодрама"&lt;/span&gt;, 8.363,
        List.of(&lt;span style="color: darkred"&gt;"ДиКаприо"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Уинслет"&lt;/span&gt;)),
    &lt;span style="color: blue"&gt;new&lt;/span&gt; Movie(&lt;span style="color: darkred"&gt;"Семьянин"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Комедия"&lt;/span&gt;, 7.699,
        List.of(&lt;span style="color: darkred"&gt;"Кейдж"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Леони"&lt;/span&gt;))
);&lt;/pre&gt;
&lt;p&gt;Но какой коллектор нужно подсунуть в &lt;code&gt;groupingBy()&lt;/code&gt;, чтобы собрать всех актёров в &lt;code&gt;Set&lt;/code&gt;? Можно попробовать &lt;code&gt;Collectors.mapping()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, Set&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.mapping(Movie::actors, Collectors.toSet())));&lt;/pre&gt;
&lt;p&gt;Но смотрите, у нас получилось множество списков, а нужно просто множество. Что же делать? И тут на помощь приходит &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#flatMapping(java.util.function.Function,java.util.stream.Collector)"&gt;&lt;code&gt;Collectors.flatMapping()&lt;/code&gt;&lt;/a&gt;, ещё один новый метод, появившийся в Java 9:&lt;/p&gt;
&lt;pre&gt;Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; groups = allMovies.collect(
    Collectors.groupingBy(Movie::genre,
        Collectors.flatMapping(movie -&gt; movie.actors().stream(),
            Collectors.toSet())));&lt;/pre&gt;
&lt;p&gt;И вот сейчас тип правильный! Если вывести это, то получится:&lt;/p&gt;
&lt;pre&gt;Мелодрама:
    ДиКаприо
    Уинслет
Боевик:
    Бин
    Ферлонг
    Хедайя
    Патрик
    Шварценеггер
    Хэмилтон
    Чонг
Триллер:
    Траволта
    Уиллис
    Хопкинс
    Фостер
    Джексон
    Турман
Комедия:
    Кейдж
    Леони&lt;/pre&gt;
&lt;p&gt;Что и требовалось.&lt;/p&gt;

&lt;h4&gt;5. &lt;code&gt;StackWalker&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 9&lt;/h5&gt;
&lt;p&gt;Приходилось ли вам иметь дело со стеками? Не со стеками в смысле структур данных, а со стеком потоков? Например, вы пишете простенький логгер:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; MyLogger {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
        System.out.println(message);
    }
}&lt;/pre&gt;
&lt;p&gt;Однако вы хотите писать в консоль не просто голое сообщение, а ещё имя класса, метода, файла и номер строки, откуда вызывается метод &lt;code&gt;log()&lt;/code&gt;. В Java 8 единственным стандартным способом для этого является получение массива &lt;code&gt;StackTraceElement[]&lt;/code&gt;, например, с помощью метода &lt;code&gt;Thread.getStackTrace()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    String msg = stackTraceElement.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
               + stackTraceElement.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
               + stackTraceElement.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
               + stackTraceElement.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
               + message;
    System.out.println(msg);
}&lt;/pre&gt;
&lt;p&gt;Можно предположить, что такой способ получения получения номеров строк является довольно дорогим. Ведь нам надо заполнить полностью весь стек, который может быть очень глубоким (особенно в энтерпрайзе, где фреймворк на фреймворке), а потом ещё и сконвертировать внутренние структуры JVM в Java-массив. И всё это ради того, чтобы отбросить его почти полностью и достать только второй элемент. Давайте замерим производительность такого подхода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: gold"&gt;@Benchmark&lt;/span&gt;
&lt;span style="color: blue"&gt;public&lt;/span&gt; String stackTrace() {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement stackTraceElement = stackTrace[2];
    &lt;span style="color: blue"&gt;return&lt;/span&gt; stackTraceElement.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
         + stackTraceElement.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
         + stackTraceElement.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
         + stackTraceElement.getLineNumber() + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;;
}&lt;/pre&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6&lt;/pre&gt;&lt;/details&gt;
&lt;pre&gt;Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op&lt;/pre&gt;
&lt;p&gt;104 микросекунды на каждый вызов! Это невероятно медленно! Есть ли возможность это ускорить? Есть: с помощью нового класса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html"&gt;&lt;code&gt;StackWalker&lt;/code&gt;&lt;/a&gt;, который появился в Java 9. Давайте рассмотрим этот класс поподробнее.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StackWalker&lt;/code&gt; предоставляет возможность &amp;laquo;гулять&amp;raquo; по стеку. Чтобы это сделать, сначала нужно получить экземпляр &lt;code&gt;StackWalker&lt;/code&gt; с помощью метода &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getInstance()"&gt;&lt;code&gt;StackWalker.getInstance()&lt;/code&gt;&lt;/a&gt;. Этот метод возвращает &lt;code&gt;StackWalker&lt;/code&gt; по умолчанию. Также есть возможность передать в метод &lt;code&gt;getInstance()&lt;/code&gt; опции и получить &lt;code&gt;StackWalker&lt;/code&gt; с более богатыми возможностями. Но об этом чуть позже.&lt;/p&gt;
&lt;p&gt;После того, как мы получил объект &lt;code&gt;StackWalker&lt;/code&gt;, у нас есть следующие варианты:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Выполнить на нём метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#forEach(java.util.function.Consumer)"&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/a&gt; и пройтись по всем фреймам стека.&lt;/li&gt;
    &lt;li&gt;Вызвать метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"&gt;&lt;code&gt;getCallerClass()&lt;/code&gt;&lt;/a&gt; и получить класс, который вызвал наш метод (работает только с опцией &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.Option.html#RETAIN_CLASS_REFERENCE"&gt;&lt;code&gt;RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;).&lt;/li&gt;
    &lt;li&gt;Вызвать метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#walk(java.util.function.Function)"&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;, который принимает функцию из &lt;code&gt;Stream&amp;lt;StackFrame&amp;gt;&lt;/code&gt; в &lt;code&gt;T&lt;/code&gt;, где &lt;code&gt;T&lt;/code&gt; &amp;ndash; это что угодно. Это самый гибкий метод.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для нашего логгера мы воспользуемся третьим вариантом. Вот как будет выглядеть реализация метода &lt;code&gt;log()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&amp;lt;StackFrame&amp;gt; frames) -&gt; {
            StackFrame frame = frames.skip(2).findFirst().get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
                 + message;
        });
    System.out.println(msg);
}&lt;/pre&gt;
&lt;p&gt;Теперь давайте замерим производительность варианта со &lt;code&gt;StackWalker&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: gold"&gt;@Benchmark&lt;/span&gt;
&lt;span style="color: blue"&gt;public&lt;/span&gt; String stackWalker() {
    &lt;span style="color: blue"&gt;return&lt;/span&gt; StackWalker
        .getInstance()
        .walk(frames -&gt; {
            StackFrame frame = frames.skip(2).findFirst().get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;;
        });
}&lt;/pre&gt;
&lt;details&gt;&lt;summary&gt;&lt;i&gt;Детали запуска бенчмарка&lt;/i&gt;&lt;/summary&gt;&lt;pre&gt;OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing)
Intel Core i5-9500 3.00GHZ
Опции запуска: -f 1 -wi 3 -w 3 -i 5 -r 5 -t 6&lt;/pre&gt;&lt;/details&gt;
&lt;pre&gt;Benchmark          Mode  Cnt    Score   Error  Units
Stack.stackTrace   avgt    5  103,704 ? 1,123  us/op
Stack.stackWalker  avgt    5    2,781 ? 0,156  us/op&lt;/pre&gt;
&lt;p&gt;Скорость выросла в 37 раз! Это огромный выигрыш. Конечно, 2.8 микросекунды это всё ещё далеко не бесплатно, но такой вариант кажется уже вполне приемлемым, чтобы включить его в боевом приложении.&lt;/p&gt;
&lt;p&gt;Так как метод &lt;code&gt;StackWalker.walk()&lt;/code&gt; даёт нам &lt;code&gt;Stream&lt;/code&gt;, то наши возможности по обходу стека практически безграничны: можно получить все фреймы, можно отфильтровать, можно пропустить сколько-то. Например, усложним наш логирующий &amp;laquo;фреймворк&amp;raquo;, добавив туда уровни:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.mylogger;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; MyLogger {
    &lt;span style="color: blue"&gt;public enum&lt;/span&gt; Level {
        ERROR, WARN, INFO
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; error(String message) {
        log(Level.ERROR, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; warn(String message) {
        log(Level.WARN, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; info(String message) {
        log(Level.INFO, message);
    }

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(Level level, String message) {
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Сейчас мы уже не можем использовать конструкцию &lt;code&gt;frames.skip(2)&lt;/code&gt;, потому что метод &lt;code&gt;log()&lt;/code&gt; может быть вызван как напрямую, так и через методы &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt;, &lt;code&gt;log()&lt;/code&gt;, а значит фрейм надо искать немножко умнее. Самое простое &amp;ndash; через &lt;code&gt;Stream.dropWhile()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public static void&lt;/span&gt; log(Level level, String message) {
    String msg = StackWalker
        .getInstance()
        .walk((Stream&amp;lt;StackFrame&amp;gt; frames) -&gt; {
            StackFrame frame = frames
                .dropWhile(f -&gt; f.getClassName().startsWith(&lt;span style="color: darkred"&gt;"org.mylogger"&lt;/span&gt;))
                .findFirst()
                .get();
            &lt;span style="color: blue"&gt;return&lt;/span&gt; level + &lt;span style="color: darkred"&gt;" "&lt;/span&gt;
                 + frame.getClassName() + &lt;span style="color: darkred"&gt;"."&lt;/span&gt;
                 + frame.getMethodName() + &lt;span style="color: darkred"&gt;"("&lt;/span&gt;
                 + frame.getFileName() + &lt;span style="color: darkred"&gt;":"&lt;/span&gt;
                 + frame.getLineNumber() + &lt;span style="color: darkred"&gt;") "&lt;/span&gt;
                 + message;
        });
    System.out.println(msg);
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Какие ещё применения есть у &lt;code&gt;StackWalker&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Как вы знаете, в Java 9 появились модули. Но мало кто использует их в своих проектах, и подавляющее большинство всё ещё препочитает класть всё в classpath. Но тогда у нас теряется весьма ценная возможность &amp;ndash; экспортировать из модуля часть пакетов, а остальные скрывать. Представим, что у нас есть пакет &lt;code&gt;org.example.mylib.internal&lt;/code&gt;, который мы хотим, чтобы не использовал никто кроме нашего модуля:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example.mylib.internal;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Handler {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; handle() {
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Класс &lt;code&gt;Handler&lt;/code&gt; публичный, а значит компилятор уже никак не помешает кому угодно использовать этот класс. Но, может быть, можно сделать хотя бы проверку в рантайме? И действительно, это можно сделать через &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html#getCallerClass()"&gt;&lt;code&gt;StackWalker.getCallerClass()&lt;/code&gt;&lt;/a&gt;, и выглядеть этот будет примерно так:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example.mylib.internal;

&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Handler {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; handle() {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (!StackWalker
            .getInstance(Option.RETAIN_CLASS_REFERENCE)
            .getCallerClass()
            .getPackageName()
            .startsWith(&lt;span style="color: darkred"&gt;"org.example.mylib."&lt;/span&gt;)) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; RuntimeException(&lt;span style="color: darkred"&gt;"Security error"&lt;/span&gt;);
        }
        ...
    }
}&lt;/pre&gt;
&lt;p&gt;Здесь мы использовали опцию &lt;code&gt;RETAIN_CLASS_REFERENCE&lt;/code&gt;, иначе получить Class не получилось бы. В принципе, подобную функциональность можно было бы реализовать и через &lt;code&gt;Stream.walk()&lt;/code&gt;, но &lt;code&gt;getCallerClass()&lt;/code&gt; работает немного быстрее.&lt;/p&gt;

&lt;h4&gt;6. &lt;code&gt;System.Logger&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 9&lt;/h5&gt;
&lt;p&gt;Если уж мы начали говорить про логирование, то нельзя не рассказать про &lt;a href="https://openjdk.java.net/jeps/264"&gt;новое стандартное API для логирования&lt;/a&gt;, которое появилось в Java 9. Это API очень маленькое и состоит всего из трёх классов: интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.html"&gt;&lt;code&gt;System.Logger&lt;/code&gt;&lt;/a&gt;, абстрактного класса &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.LoggerFinder.html"&gt;&lt;code&gt;System.LoggerFinder&lt;/code&gt;&lt;/a&gt; и перечисления &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.Logger.Level.html"&gt;&lt;code&gt;System.Logger.Level&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Использовать &lt;code&gt;System.Logger&lt;/code&gt; чрезвычайно просто:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;private static final&lt;/span&gt; Logger LOGGER = System.getLogger(&lt;span style="color: darkred"&gt;""&lt;/span&gt;);

    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args)  {
        LOGGER.log(Level.ERROR, &lt;span style="color: darkred"&gt;"Critical error!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Вывод:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: darkred"&gt;апр. 17, 2021 6:24:57 PM org.example.Main main
SEVERE: Critical error!&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;System.Logger&lt;/code&gt; &amp;ndash; это не новый очередной фреймворк для логирования, как вы могли бы подумать сначала, а только &lt;b&gt;фронтенд&lt;/b&gt; для логирования. Если вы знакомы с существующими фреймворками, то вам должно быть это знакомо: например, &lt;a href="http://www.slf4j.org/"&gt;SLF4J&lt;/a&gt; &amp;ndash; это фронтенд, а его соответствующим бэкендом является &lt;a href="http://logback.qos.ch/"&gt;Logback&lt;/a&gt;. Или &lt;a href="https://logging.apache.org/log4j/2.x/"&gt;Log4j API&lt;/a&gt; &amp;ndash; это фронтенд для Log4j Core. Так вот, &lt;code&gt;System.Logger&lt;/code&gt; &amp;ndash; это фронтенд для знакомого вам фреймворка &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/package-summary.html"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;, который находится в отдельном модуле &lt;code&gt;java.logging&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;При этом нам ничего не мешает для SLF4J использовать другой бэкенд, например, &lt;a href="https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/"&gt;Log4j&lt;/a&gt; или &lt;a href="https://search.maven.org/artifact/org.slf4j/slf4j-jdk14"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;. Или для Log4j API использовать &lt;a href="https://logging.apache.org/log4j/2.x/log4j-to-slf4j/index.html"&gt;SLF4J&lt;/a&gt; как бэкенд или &lt;a href="https://logging.apache.org/log4j/2.x/log4j-jul/index.html"&gt;&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/a&gt;. Точно так же и с &lt;code&gt;System.Logger&lt;/code&gt;: он спроектирован так, чтобы реализация могла быть абсолютно любой. Если не нравится неудобный и старый &lt;code&gt;java.util.logging&lt;/code&gt;, то можно использовать что-то другое. Например, можно его настроить на современный Log4j, для чего потребуется подключить следующие зависимости:&lt;/p&gt;
&lt;pre&gt;&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-api&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt; &lt;span style="color: grey"&gt;&amp;lt;!-- Последняя версия на момент написания статьи --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-core&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;org.apache.logging.log4j&amp;lt;/&lt;span style="color: darkred"&gt;groupId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;log4j-jpl&amp;lt;/&lt;span style="color: darkred"&gt;artifactId&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;2.14.1&amp;lt;/&lt;span style="color: darkred"&gt;version&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;runtime&amp;lt;/&lt;span style="color: darkred"&gt;scope&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: darkred"&gt;dependency&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;p&gt;При этом саму программу изменять не потребуется: то, что &lt;code&gt;log4j-jpl&lt;/code&gt; окажется в classpath, уже будет достаточно. Java через &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html"&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; найдёт нужную реализацию &lt;code&gt;LoggerFinder&lt;/code&gt; в виде &lt;code&gt;Log4jSystemLoggerFinder&lt;/code&gt; и будет направлять логи в Log4j:&lt;/p&gt;
&lt;pre&gt;18:24:57.941 [main] ERROR  - Critical error!&lt;/pre&gt;
&lt;p&gt;После этого модуль &lt;code&gt;java.logging&lt;/code&gt; можно будет даже вообще &lt;a href="https://openjdk.java.net/jeps/282"&gt;исключить&lt;/a&gt; из JRE/JDK, ведь он больше не нужен (если вы конечно нигде не вызываете &lt;code&gt;java.util.logging&lt;/code&gt; напрямую).&lt;/p&gt;
&lt;p&gt;К сожалению, адаптера &lt;code&gt;System.Logger&lt;/code&gt; для SLF4J/Logback нет. Но тут проблема более глобальная &amp;ndash; похоже, что сам проект SLF4J мёртв. Последний коммит в &lt;a href="https://github.com/qos-ch/slf4j"&gt;GitHub&lt;/a&gt; был полтора года назад. Так что Log4j сейчас это самый нормальный вариант &amp;ndash; он активно развивается и поддерживается.&lt;/p&gt;
&lt;p&gt;Несколько примеров использования &lt;code&gt;System.Logger&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;LOGGER.log(Level.INFO, &lt;span style="color: darkred"&gt;"Information"&lt;/span&gt;);
LOGGER.log(Level.DEBUG, &lt;span style="color: darkred"&gt;"Sum of {} and {} is {}:"&lt;/span&gt;, 2, 3, 2+3);
LOGGER.log(Level.TRACE, () -&gt; &lt;span style="color: darkred"&gt;"Lazy message"&lt;/span&gt;);
LOGGER.log(Level.ERROR, &lt;span style="color: darkred"&gt;"Log exception"&lt;/span&gt;, &lt;span style="color: blue"&gt;new&lt;/span&gt; Exception());&lt;/pre&gt;

&lt;h4&gt;7. &lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появился в: Java 15&lt;/h5&gt;
&lt;p&gt;В &lt;a href="api_to_upgrade_from_java_8_part_2.html"&gt;прошлый раз&lt;/a&gt; мы рассказывали про метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineClass(byte[])"&gt;&lt;code&gt;MethodHandles.Lookup.defineClass()&lt;/code&gt;&lt;/a&gt;, с помощью которого можно во время выполнения легко загрузить класс в том же пакете, не создавая при этом новый загрузчик класса. Это очень удобный метод, но у него есть существенный минус: класс, который загружен таким образом, будет до конца жизни висеть в памяти (по крайней мере до конца жизни текущего загрузчика класса). Это не очень подходит для приложений, которым требуется динамически генерировать и загружать много временных классов на лету. Но с Java 15 появилась альтернатива в виде нового вида классов, которые называются &lt;a href="https://openjdk.java.net/jeps/371"&gt;&lt;i&gt;скрытыми&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Скрытые классы создаются с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte[],boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)"&gt;&lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/a&gt;. По сути этот метод очень похож на старый нестандартный метод &lt;code&gt;Unsafe.defineAnonymousClass()&lt;/code&gt;, который много лет используется различными фреймворками, поскольку решает проблему неконтролируемого роста количества временных классов в памяти. При этом сам &lt;code&gt;Unsafe.defineAnonymousClass()&lt;/code&gt; с Java 15 стал deprecated for removal.&lt;/p&gt;
&lt;p&gt;Скрытые классы имеют следующие особенности:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;На них не могут прямо ссылаться другие классы. Всё их использование может осуществляться исключительно через рефлексию.&lt;/li&gt;
    &lt;li&gt;Они являются необнаружимыми. Их нельзя найти ни по имени, ни обнаружить с помощью загрузчиков классов (через &lt;code&gt;Class.forName()&lt;/code&gt;, &lt;code&gt;ClassLoader.loadClass()&lt;/code&gt;, &lt;code&gt;ClassLoader.findLoadedClass()&lt;/code&gt; и т.д.). Однако скрытые классы не являются анонимными и всё-таки имеют имя в формате &lt;code&gt;&amp;lt;имя класса в байт-коде&amp;gt;/&amp;lt;suffix&amp;gt;&lt;/code&gt; (например, &lt;code&gt;org.example.Temp/0x0000000800cb8000&lt;/code&gt;).&lt;/li&gt;
    &lt;li&gt;Они реализованы таким способом, что не связаны сильной ссылкой с загрузчиком класса, а значит могут быть собраны сборщиком мусора, когда их &lt;code&gt;Class&lt;/code&gt; становится недостижимым (но если хочется, то это можно переопределить, передав опцию &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.ClassOption.html#STRONG"&gt;&lt;code&gt;ClassOption.STRONG&lt;/code&gt;&lt;/a&gt; в &lt;code&gt;defineHiddenClass()&lt;/code&gt;).&lt;/li&gt;
    &lt;li&gt;Они не появляются в стектрейсах, если только не включить опции &lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кстати, вы уже должны быть хорошо знакомы со скрытыми классами, поскольку используете их каждый день. Это лямбды:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Runnable runnable = () -&gt; {}
runnable ==&gt; $Lambda$26/0x0000000800c0aa00@443b7951

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; runnable.getClass().isHidden()
$2 ==&gt; true&lt;/pre&gt;

&lt;p&gt;Давайте создадим небольшой примерчик и определим свой скрытый класс &amp;laquo;с нуля&amp;raquo;. Пусть он для простоты складывает два &lt;code&gt;int&lt;/code&gt;'а. Для разнообразия будем это делать не с помощью javac, а через &lt;a href="https://bytebuddy.net/#/"&gt;ByteBuddy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Для начала нужно создать представление класса в байт-коде в виде массива байтов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] bytes = &lt;span style="color: blue"&gt;new&lt;/span&gt; ByteBuddy()
        .subclass(Object.&lt;span style="color: blue"&gt;class&lt;/span&gt;)
        .name(&lt;span style="color: darkred"&gt;"org.example.Temp"&lt;/span&gt;)
        .defineMethod(&lt;span style="color: darkred"&gt;"sum"&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.class, Modifier.PUBLIC)
        .withParameters(&lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;)
        .intercept(&lt;span style="color: blue"&gt;new&lt;/span&gt; Implementation.Simple(
                MethodVariableAccess.INTEGER.loadFrom(1),
                MethodVariableAccess.INTEGER.loadFrom(2),
                Addition.INTEGER,
                MethodReturn.INTEGER))
        .make()
        .getBytes();&lt;/pre&gt;
&lt;p&gt;По сути мы скомпилировали вот такой класс, но сделали это в рантайме непосредственно через манипуляции с байт-кодом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;package&lt;/span&gt; org.example;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Temp {
    &lt;span style="color: blue"&gt;public int&lt;/span&gt; sum(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {
        &lt;span style="color: blue"&gt;return&lt;/span&gt; x + y;
    }
}&lt;/pre&gt;
&lt;p&gt;Теперь, когда у нас есть байт-код класса, можно его загружать и что-то с ним делать:&lt;/p&gt;
&lt;pre&gt;Lookup lookup = MethodHandles
        .lookup()
        .defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);

&lt;span style="color: green"&gt;// Для разнообразия будем использовать MethodHandle вместо reflection&lt;/span&gt;
Object obj = lookup
        .findConstructor(lookup.lookupClass(), MethodType.methodType(&lt;span style="color: blue"&gt;void&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;))
        .invoke();

MethodHandle sumHandle = lookup.findVirtual(lookup.lookupClass(), &lt;span style="color: darkred"&gt;"sum"&lt;/span&gt;,
        MethodType.methodType(&lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;.&lt;span style="color: blue"&gt;class&lt;/span&gt;));

&lt;span style="color: green"&gt;// Вызовем метод sum. Должен напечатать 5&lt;/span&gt;
System.out.println(sumHandle.invoke(obj, 3, 2));&lt;/pre&gt;
&lt;p&gt;Вот и всё.&lt;/p&gt;

&lt;p&gt;Кстати, так как скрытые классы необнаружимы, то загружать один и тот же класс можно сколько угодно раз. По сути каждый раз будет определяться новый уникальный скрытый класс:&lt;/p&gt;
&lt;pre&gt;Lookup lookup1 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
Lookup lookup2 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
Lookup lookup3 = MethodHandles.lookup().defineHiddenClass(bytes, &lt;span style="color: blue"&gt;false&lt;/span&gt;);
System.out.println(lookup1.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4000&lt;/span&gt;
System.out.println(lookup2.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4400&lt;/span&gt;
System.out.println(lookup3.lookupClass()); &lt;span style="color: green"&gt;// class org.example.Temp/0x0000000800cb4800&lt;/span&gt;&lt;/pre&gt;



&lt;h4&gt;8. Новые методы в &lt;code&gt;Math&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9 / Java 15&lt;/h5&gt;
&lt;p&gt;Наверное, практически все, кто начинал работать с большими числами в Java, совершал вот такую ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = ...
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = ...
&lt;span style="color: blue"&gt;long&lt;/span&gt; z = x * y;&lt;/pre&gt;
&lt;p&gt;Это один из тех примеров в Java, когда можно угодить в ловушку даже на простом умножении: произведение двух &lt;code&gt;int&lt;/code&gt; &amp;ndash; это тоже &lt;code&gt;int&lt;/code&gt;, а значит то, что переменная &lt;code&gt;z&lt;/code&gt; имеет тип &lt;code&gt;long&lt;/code&gt;, от переполнения никак не спасает. Для исправления этой ошибки нужно явно прикастовать хотя бы один из множителей к &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; z = (&lt;span style="color: blue"&gt;long&lt;/span&gt;) x * y;&lt;/pre&gt;
&lt;p&gt;В то время как такое решение абсолютно рабочее, у меня в моём перфекционистском подсознании остаётся какой-то мелкий осадок. Во-первых, мне не нравится этот явный каст, который применяется то ли к первому множителю, то ли ко всему произведению. Во-вторых, не нравится эта асимметрия, что одна из переменных кастуется, а другая нет. В общем, я хочу кристальную ясность и отсутствие магии. Способ написать вот такое:&lt;/p&gt;
&lt;pre&gt;Возьми два int и перемножь их в long с учётом переполнения&lt;/pre&gt;
&lt;p&gt;И с Java 9 такой способ есть. Это метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#multiplyFull(int,int)"&gt;&lt;code&gt;Math.multiplyFull()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; z = Math.multiplyFull(x, y);&lt;/pre&gt;

&lt;p class="pt-2"&gt;Вообще обработка переполнений в Java реализуется довольно муторно, и чтобы облегчить жизнь программистам, в Java 8 появилась целая пачка методов для этого в классе &lt;code&gt;Math&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; toIntExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; value)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; incrementExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; incrementExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; decrementExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; decrementExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; negateExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; negateExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; a)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; addExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; addExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; subtractExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; subtractExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; multiplyExact(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; multiplyExact(&lt;span style="color: blue"&gt;long&lt;/span&gt; x, &lt;span style="color: blue"&gt;long&lt;/span&gt; y)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все эти методы выбрасывают ошибку в случае переполнения, что во многих случаях лучше, чем просто тихое переполнение &amp;ndash; лучше уж упадёт сразу, чем где-нибудь позже с совсем другой ошибкой. Но все ли возможные случаи тут покрыты? Похоже, что нет. Например, я не вижу модуль, который хоть и в очень редком случае, но всё же может переполниться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.abs(Integer.MIN_VALUE)
$1 ==&gt; -2147483648&lt;/pre&gt;
&lt;p&gt;Как же так, ведь модуль &amp;ndash; это положительное число? Это так, но дело в том, что 2147483648 просто не влезает в &lt;code&gt;int&lt;/code&gt;, поэтому этот отдельный случай является исключением. Чтобы вот так по чистой случайности не напороться на такое, можно обезопасить себя методом &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#absExact(int)"&gt;&lt;code&gt;Math.absExact()&lt;/code&gt;&lt;/a&gt;, который появился в Java 15:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.absExact(Integer.MIN_VALUE)
|  &lt;span style="color: red"&gt;Exception java.lang.ArithmeticException: Overflow to represent absolute value of Integer.MIN_VALUE&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Math.absExact (Math.java:1392)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#1:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.absExact(Long.MIN_VALUE)
|  &lt;span style="color: red"&gt;Exception java.lang.ArithmeticException: Overflow to represent absolute value of Long.MIN_VALUE&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Math.absExact (Math.java:1438)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#2:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;А знаете ли вы, сколько будет, если найти целое от деления -11 на 3? А остаток? Давайте проверим:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; -11 / 3
$1 ==&gt; -3

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; -11 % 3
$2 ==&gt; -2&lt;/pre&gt;
&lt;p&gt;Ну вроде бы логично, ведь &lt;code&gt;-11 = 3 * (-3) - 2&lt;/code&gt;. Однако если вы выполните то же самое, например, на Python, то получите совсем иной результат:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;&gt;&gt;&gt;&lt;/span&gt; -11 / 3
-4
&lt;span style="color: grey"&gt;&gt;&gt;&gt;&lt;/span&gt; -11 % 3
1&lt;/pre&gt;
&lt;p&gt;И этот результат тоже по-своему верный: &lt;code&gt;-11 = 3 * (-4) + 1&lt;/code&gt;. Дело в том, что есть два способа деления целых чисел: с обрезанием в сторону нуля и с обрезанием в сторону минус бесконечности. Java выбрала первый способ, Python &amp;ndash; второй. Ну а что делать, если я хочу в Java делить по-питоновски? Для этого в Java 9 появились методы &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorDiv(int,int)"&gt;&lt;code&gt;Math.floorDiv()&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floorMod(int,int)"&gt;&lt;code&gt;Math.floorMod()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.floorDiv(-11, 3)
$1 ==&gt; -4

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.floorMod(-11, 3)
$2 ==&gt; 1&lt;/pre&gt;

&lt;p class="pt-2"&gt;Также для совсем упоротых математиков в Java 9 появились два метода &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(float,float,float)"&gt;&lt;code&gt;Math.fma(float, float, float)&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#fma(double,double,double)"&gt;&lt;code&gt;Math.fma(double, double, double)&lt;/code&gt;&lt;/a&gt;, которые делают то же самое, что и &lt;code&gt;a * b + c&lt;/code&gt;, но только точнее, потому что используют специальную отдельную инструкцию процессора:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Math.fma(2.99, 5.91, 7.1)
$1 ==&gt; 24.7709

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; 2.99 * 5.91 + 7.1
$2 ==&gt; 24.770900000000005&lt;/pre&gt;

&lt;h4&gt;9. Аннотация &lt;code&gt;java.io.Serial&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появилась в: Java 14&lt;/h5&gt;
&lt;p&gt;Используете ли вы стандартную сериализацию в Java? Этот механизм далеко не идеальный и со своими &lt;a href="https://www.youtube.com/watch?v=dOgfWXw9VrI"&gt;недостатками&lt;/a&gt;, но иногда он может быть очень удобным, потому что позволяет из коробки очень просто сделать сереализацию и десериализацию Java-объектов. Рассмотрим пример:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point {
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1L;

    &lt;span style="color: blue"&gt;public&lt;/span&gt; int x;
    &lt;span style="color: blue"&gt;public&lt;/span&gt; int y;
}&lt;/pre&gt;
&lt;p&gt;Чтобы сконвертировать объект &lt;code&gt;Point&lt;/code&gt; в массив байтов, нужно написать всего несколько строчек:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; point = &lt;span style="color: blue"&gt;new&lt;/span&gt; Point();
point.x = 1;
point.y = 2;

&lt;span style="color: blue"&gt;var&lt;/span&gt; baos = new ByteArrayOutputStream();
&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; oos = &lt;span style="color: blue"&gt;new&lt;/span&gt; ObjectOutputStream(baos)) {
    oos.writeObject(point);
}
&lt;span style="color: blue"&gt;byte&lt;/span&gt;[] bytes = baos.toByteArray();&lt;/pre&gt;

&lt;p&gt;Очень удобно. Кстати, вы заметили ошибку в моём коде? Конечно же, я забыл реализовать интерфейс &lt;code&gt;Serializable&lt;/code&gt;! (Я специально добавил поле &lt;code&gt;serialVersionUID&lt;/code&gt;, чтобы отвлечь ваше внимание.)&lt;/p&gt;
&lt;p&gt;Правильный код будет таким:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;

    &lt;span style="color: blue"&gt;public&lt;/span&gt; int x;
    &lt;span style="color: blue"&gt;public&lt;/span&gt; int y;
}&lt;/pre&gt;
&lt;p&gt;И вот это как раз и есть одна из главных проблем сериализации &amp;ndash; при её использовании можно очень легко допустить ошибку: забыть &lt;code&gt;Serializable&lt;/code&gt;, опечататься в названии поля &lt;code&gt;serialVersionUID&lt;/code&gt;, забыть сделать его статическим и т.д. Чтобы немного обезопаситься от такого, в Java 14 ввели новую аннотацию &lt;a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Serial.html"&gt;&lt;code&gt;Serial&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Этой аннотацией теперь рекомендуется помечать все поля и методы, относящиеся к механизму сериализации:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Теперь, если будет допущена ошибка, то появится предупреждение:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt; &lt;span style="color: red"&gt;// Annotated member is not a part of the serialization mechanism&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final long&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Или:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Point &lt;span style="color: blue"&gt;implements&lt;/span&gt; Serializable {
    &lt;span style="color: grey"&gt;@Serial&lt;/span&gt; &lt;span style="color: red"&gt;// Annotated member is not a part of the serialization mechanism&lt;/span&gt;
    &lt;span style="color: blue"&gt;private static final int&lt;/span&gt; serialVersionUID = 1;
    ...
}&lt;/pre&gt;
&lt;p&gt;Аннотация будет делать проверки на всех полях и методах, которые относятся к сериализации: &lt;code&gt;serialVersionUID&lt;/code&gt;, &lt;code&gt;serialPersistentFields&lt;/code&gt;, &lt;code&gt;writeObject()&lt;/code&gt;, &lt;code&gt;readObject()&lt;/code&gt; и т.д.&lt;/p&gt;
&lt;p&gt;К сожалению, на текущий момент предупреждения хорошо работают только в IntelliJ IDEA. В компиляторе JDK 16 проверки выполняются только с включённым флагом &lt;code&gt;-Xlint:serial&lt;/code&gt; и работают не все. Например, для двух примеров выше &lt;code&gt;javac&lt;/code&gt; ругается только во втором случае:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;&gt;&lt;/span&gt; javac -Xlint:serial Point.java
Point.java:6: warning: [serial] serialVersionUID must be of type long in class Point
    private static final int serialVersionUID = 1;
                             ^&lt;/pre&gt;
&lt;p&gt;Возможно, это &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8202056"&gt;исправят в Java 17&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;10. Методы &lt;code&gt;Objects&lt;/code&gt;: &lt;code&gt;checkIndex()&lt;/code&gt;, &lt;code&gt;checkFromIndexSize()&lt;/code&gt;, &lt;code&gt;checkFromToIndex()&lt;/code&gt;&lt;/h4&gt;
&lt;h5&gt;Появились в: Java 9 / Java 16&lt;/h5&gt;
&lt;p&gt;Завершим нашу статью несколькими полезными методами для проверки индексов.&lt;/p&gt;
&lt;p&gt;Иногда приходится писать функции, принимающие в качестве входных параметров индексы или диапазоны индексов, и чтобы начать использовать эти индексы, нужно сначала убедиться, что они не выходят за границы. То есть приходится писать подобные проверки в начале методов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static void&lt;/span&gt; getAt(&lt;span style="color: blue"&gt;int&lt;/span&gt; index, &lt;span style="color: blue"&gt;int&lt;/span&gt; length) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &lt; 0) {
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &lt; 0"&lt;/span&gt;);
    }
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &gt;= length) {
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &gt;= length"&lt;/span&gt;);
    }
    ...
}&lt;/pre&gt;
&lt;p&gt;Если подобных функций в проекте становится уже несколько, то чтобы не повторяться, такие проверки удобнее вынести в отдельные утилитные методы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public final class&lt;/span&gt; PreconditionUtils {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; checkIndex(&lt;span style="color: blue"&gt;int&lt;/span&gt; index, &lt;span style="color: blue"&gt;int&lt;/span&gt; length) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &lt; 0) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &lt; 0"&lt;/span&gt;);
        }
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (index &gt;= length) {
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"index &gt;= length"&lt;/span&gt;);
        }
    }
}&lt;/pre&gt;

&lt;p&gt;Но с Java 9 теперь это больше не нужно, потому что в классе &lt;code&gt;Objects&lt;/code&gt; теперь есть стандартные методы проверок индексов.&lt;/p&gt;
&lt;p&gt;Метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkIndex(int,int)"&gt;&lt;code&gt;Objects.checkIndex()&lt;/code&gt;&lt;/a&gt; проверяет, что индекс находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkIndex(-3, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Index -3 out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkIndex (Preconditions.java:248)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkIndex (Objects.java:372)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#1:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkIndex(10, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Index 10 out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkIndex (Preconditions.java:248)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkIndex (Objects.java:372)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#2:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(int,int,int)"&gt;&lt;code&gt;Objects.checkFromIndexSize()&lt;/code&gt;&lt;/a&gt; проверяет, что диапазон &lt;code&gt;[fromIndex, fromIndex + size)&lt;/code&gt; находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(3, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#3:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(-2, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [-2, -2 + 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#4:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromIndexSize(3, -4, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 3 + -4) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromIndexSize (Preconditions.java:82)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromIndexSize (Preconditions.java:343)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromIndexSize (Objects.java:424)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#5:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Наконец, метод &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#checkFromToIndex(int,int,int)"&gt;&lt;code&gt;Objects.checkFromToIndex()&lt;/code&gt;&lt;/a&gt; проверяет, что диапазон &lt;code&gt;[fromIndex, toIndex)&lt;/code&gt; находится в диапазоне &lt;code&gt;[0, length)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(3, 11, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [3, 11) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#6:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(-4, 8, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [-4, 8) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#7:1)&lt;/span&gt;

&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Objects.checkFromToIndex(6, 4, 10)
|  &lt;span style="color: red"&gt;Exception java.lang.IndexOutOfBoundsException: Range [6, 4) out of bounds for length 10&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBounds (Preconditions.java:64)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.outOfBoundsCheckFromToIndex (Preconditions.java:76)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Preconditions.checkFromToIndex (Preconditions.java:295)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at Objects.checkFromToIndex (Objects.java:398)&lt;/span&gt;
|        &lt;span style="color: red"&gt;at (#8:1)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Кроме того, в Java 16 появились перегрузки этих функций для &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkIndex(long,long)"&gt;&lt;code&gt;checkIndex(long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromIndexSize(long,long,long)"&gt;&lt;code&gt;checkFromIndexSize(long, long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Objects.html#checkFromToIndex(long,long,long)"&gt;&lt;code&gt;checkFromToIndex(long, long, long)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Заключение&lt;/h4&gt;
&lt;p&gt;Сегодня я рассказал про 10 интересных API, некоторые из которых появились в буквально только что &lt;a href="java_16.html"&gt;вышедшей Java 16&lt;/a&gt;, а некоторые уже присутствуют довольно давно ещё с 9-й версии. Надеюсь, что после прочтения данной статьи вы стали более заинтересованными в миграции на последнюю версию Java. Помните, что в новых версиях Java появляются не только новые возможности, но и изменения, ломающие обратную совместимость (&lt;a href="https://openjdk.java.net/jeps/260"&gt;1&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/322"&gt;2&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/320"&gt;3&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/372"&gt;4&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/396"&gt;5&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/363"&gt;6&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/367"&gt;7&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/403"&gt;8&lt;/a&gt;). И чем больше вы тянете с переходом с Java 8 на последнюю версию, тем сложнее вам будет осуществить этот переход.&lt;/p&gt;
&lt;p&gt;Продолжение следует...&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #14</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_14.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_14.html</id>
    <updated>2021-04-11T17:00:00Z</updated>
    <published>2021-04-11T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; На сайте OpenJDK появилось два новых JEP.&lt;/p&gt;
&lt;p&gt;В &lt;a href="https://openjdk.java.net/jeps/409"&gt;JEP 409: Sealed Classes&lt;/a&gt; предлагается, наконец, вывести &lt;code&gt;sealed&lt;/code&gt; классы из режима preview и сделать их стабильной языковой конструкцией.&lt;/p&gt;
&lt;p&gt;В &lt;a href="https://openjdk.java.net/jeps/410"&gt;JEP 410: Remove the Experimental AOT and JIT Compiler&lt;/a&gt; предлагается убрать экспериментальные &lt;a href="https://openjdk.java.net/jeps/295"&gt;ahead-of-time&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/317"&gt;just-in-time&lt;/a&gt; Graal компиляторы из-за их малой используемости и сложности поддержки. По факту эти компиляторы уже исчезли из сборок JDK 16 от Oracle. При этом интерфейс компилятора &lt;a href="https://openjdk.java.net/jeps/243"&gt;JVMCI&lt;/a&gt; не планируется удалять.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Проект Lilliput стартовал. У него появилась &lt;a href="https://openjdk.java.net/projects/lilliput/"&gt;собственная страница&lt;/a&gt; на сайте OpenJDK, &lt;a href="https://wiki.openjdk.java.net/display/lilliput"&gt;Wiki&lt;/a&gt; и &lt;a href="https://mail.openjdk.java.net/mailman/listinfo/lilliput-dev"&gt;e-mail рассылка&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/ru/idea/2021/04/intellij-idea-2021-1/"&gt;IntelliJ IDEA 2021.1&lt;/a&gt;. В ней появилась поддержка Java 16, WSL 2, интеграция с JetBrains Space, сервис Code With Me с поддержкой видео- и аудиозвонков, новая функция Run Targets, новые инспекции и многое другое.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Google &lt;a href="https://3dnews.ru/1036576/sud-reshil-chto-google-zakonno-ispolzovalajava-v-android-kompanii-ne-pridyotsya-viplachivat-oracle-kompensatsiyu-v-9-mlrd"&gt;выиграл многолетнюю тяжбу с Oracle&lt;/a&gt;, которая продолжалась с 2010 года. Окончательным решением Верховного Суда США стало то, что Google не нарушал авторские права Oracle, используя Java API для разработки своей операционной системы Android.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Microsoft теперь будет выпускать свою &lt;a href="https://devblogs.microsoft.com/java/announcing-preview-of-microsoft-build-of-openjdk/"&gt;собственную сборку OpenJDK&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.0/release-notes.html"&gt;Gradle 7.0&lt;/a&gt; с улучшенной инкрементальной сборкой, поддержкой Java 16, сборки на Apple Silicon и т.д.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Тагир Валеев предложил &lt;a href="https://github.com/openjdk/jdk/pull/3427"&gt;патч&lt;/a&gt; в OpenJDK с оптимизацией операций &lt;code&gt;Stream::limit&lt;/code&gt; и &lt;code&gt;Stream::skip&lt;/code&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #13</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_13.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_13.html</id>
    <updated>2021-04-04T17:00:00Z</updated>
    <published>2021-04-04T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Появилось &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-March/005266.html"&gt;расписание процесса выхода JDK 17&lt;/a&gt;. Общедоступная версия Java 17 по плану должна выйти 14 сентября 2021 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появился новый &lt;a href="https://openjdk.java.net/jeps/408"&gt;JEP 408: Simple Web Server&lt;/a&gt;. В нём предлагается добавить в JDK стандартную утилиту, которая будет запускать простой веб-сервер для хостинга статических файлов в указанной директории. При этом реализация веб-сервера в Java существует ещё с JDK 1.6 в публичном пакете &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html"&gt;&lt;code&gt;com.sun.net.httpserver&lt;/code&gt;&lt;/a&gt;, а задачей JEP будет лишь предоставить для него простое API и возможность запускать его из командной строки одной простой командой.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-April/000299.html"&gt;Завершено голосование&lt;/a&gt; по созданию проекта Lilliput, и теперь он будет официально запущен. Напомним, в этом проекте будут исследоваться возможности по &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;сжатию заголовков&lt;/a&gt; Java-объектов до 64/32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; На YouTube &lt;a href="https://www.youtube.com/playlist?list=PLutlXcN4EAwD4L_vwgYXtoHoNembpw_t0"&gt;появились видео докладов&lt;/a&gt; с конференции JakartaOne Livestream.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.8.1/release-notes.html"&gt;Apache Maven 3.8.1&lt;/a&gt;. В этой версии внешние репозитории, использующие протокол HTTP, теперь блокируются по умолчанию. Это первый релиз Maven спустя полтора года после выхода версии 3.6.3.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://projectlombok.org/changelog"&gt;Lombok 1.18.20&lt;/a&gt; с поддержкой Java 16 и записей.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/03/intellij-idea-2021-1-rc/"&gt;IntelliJ IDEA 2021.1 RC&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jol-dev/2021-March/000335.html"&gt;JOL 0.15&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+16&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+6&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://dotty.epfl.ch/blog/2021/03/31/scala3-rc2.html"&gt;Scala 3.0.0-RC2&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #12</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_12.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_12.html</id>
    <updated>2021-03-28T17:00:00Z</updated>
    <published>2021-03-28T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло 3 новых JEP. Это &lt;a href="http://openjdk.java.net/jeps/405"&gt;JEP 405: Record Patterns &amp; Array Patterns (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/406"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/407"&gt;JEP 407: Remove RMI Activation&lt;/a&gt;. Про первые два мы уже писали в &lt;a href="java_news_8.html"&gt;предыдущих выпусках&lt;/a&gt;. В JEP 407 предлагается окончательно удалить устаревшую часть RMI, которая называется RMI Activation. В Java 15 она стала &lt;a href="http://openjdk.java.net/jeps/385"&gt;deprecated for removal&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Появилось 3 новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8263381"&gt;Dynamic Deserialization Filters&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/8264130"&gt;PAC-RET protection for Linux/AArch64&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8264131"&gt;Arm64e support for MacOS/AArch64&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Официально объявлено, что проект jdk11u &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-March/005470.html"&gt;переедет на Git и GitHub&lt;/a&gt;. Это случится летом, когда начнётся разработка JDK 11.0.13.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://newsroom.eclipse.org/news/announcements/eclipse-foundation%E2%80%99s-eclipse-jetty-project-prepares-future-jetty-11-release"&gt;Eclipse Jetty 11&lt;/a&gt; (а точнее 11.0.2).&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-March/003218.html"&gt;JMH 1.29&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pr-2"&gt;&amp;bull; Вышла статья &lt;a href="https://malloc.se/blog/zgc-jdk16"&gt;ZGC | What's new in JDK 16&lt;/a&gt;. В ней утверждается, что в JDK 16 удалось снизить максимальные паузы с 10мс до 1мс.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #11</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_11.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_11.html</id>
    <updated>2021-03-20T17:00:00Z</updated>
    <published>2021-03-20T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Главная новость этой недели &amp;ndash; это, конечно же, выход Java 16. Про неё мы подробно написали в &lt;a href="java_16.html"&gt;этой статье&lt;/a&gt;. В течение небольшого промежутка времени после выхода большинство поставщиков выкатили свои сборки OpenJDK 16: &lt;a href="https://sap.github.io/SapMachine/"&gt;SapMachine&lt;/a&gt;, &lt;a href="https://aws.amazon.com/ru/about-aws/whats-new/2021/03/announcing-general-availability-amazon-corretto-16/"&gt;Amazon Corretto&lt;/a&gt;, &lt;a href="https://www.azul.com/downloads/zulu-community/?version=java-16&amp;package=jdk"&gt;Azul Zulu&lt;/a&gt;, &lt;a href="https://blog.adoptopenjdk.net/2021/03/adoptopenjdk-16-available/"&gt;AdoptOpenJDK&lt;/a&gt; (в т.ч. OpenJ9), &lt;a href="https://bell-sw.com/announcements/2021/03/19/JDK-16-Release/"&gt;Liberica JDK&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Сразу позле выхода Java 16 вышло 4 новых JEP. Это &lt;a href="http://openjdk.java.net/jeps/401"&gt;JEP 401: Primitive Objects (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/402"&gt;JEP 402: Unify the Basic Primitives with Objects (Preview)&lt;/a&gt;, &lt;a href="http://openjdk.java.net/jeps/403"&gt;JEP 403: Strongly Encapsulate JDK Internals&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/404"&gt;JEP 404: Generational Shenandoah&lt;/a&gt;. Про все JEP кроме третьего мы уже писали в предыдущих выпусках, когда они ещё были черновиками.&lt;/p&gt;
&lt;p&gt;В JEP 403 предлагается сделать опцию &lt;code&gt;--illegal-access&lt;/code&gt; недействующей. В Java 9-16 эта опция позволяет глобально открыть все внутренности JDK без перечисления конкретных пакетов (в Java 16 её значение &lt;a href="http://openjdk.java.net/jeps/396"&gt;стало&lt;/a&gt; по умолчанию &lt;code&gt;deny&lt;/code&gt;). Если JEP будет реализован, то &lt;code&gt;--illegal-access=permit/warn/debug&lt;/code&gt; не будет иметь эффекта, и для открытия пакетов придётся использовать опцию &lt;code&gt;--add-opens&lt;/code&gt;. Также в будущем планируется удалить &lt;code&gt;--illegal-access&lt;/code&gt; окончательно.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ещё два JEP были предложены к попаданию в Java 17. Это &lt;a href="https://openjdk.java.net/jeps/391"&gt;JEP 391: macOS/AArch64 Port&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/398"&gt;JEP 398: Deprecate the Applet API for Removal&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Роман Кеннке, который на прошлой неделе предложил &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;проект Lilliput&lt;/a&gt;, запустил &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-March/000296.html"&gt;официальное голосование&lt;/a&gt; по созданию проекта. На текущий момент проголосовало 26 членов OpenJDK, и все они проголосовали за создание проекта.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=OGGALLHnH-c"&gt;Eclipse 2021-03&lt;/a&gt;. В нём появилось параллельное построение индекса поиска, неблокирующее автодополнение, 16 новых Clean Up действий, quick fix для инициализации переменной в &lt;code&gt;try-with-resources&lt;/code&gt;, улучшенная поддержка &lt;code&gt;sealed&lt;/code&gt; классов и многое другое.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел баг-фикс релиз &lt;a href="https://blog.jetbrains.com/idea/2021/03/intellij-idea-2020-3-3/"&gt;IntelliJ IDEA 2020.3.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v2.0"&gt;Async Profiler 2.0&lt;/a&gt;. Также &lt;a href="https://www.youtube.com/watch?v=TDpbt4thECc"&gt;вышло видео&lt;/a&gt;, где Андрей Паньгин демонстрирует работу Async Profiler в IntelliJ IDEA.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://inside.java/2021/03/16/jmc-8-released/"&gt;JDK Misson Control 8.0.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2021/03/16/spring-framework-5-3-5-available-now"&gt;Spring Framefork 5.3.5&lt;/a&gt; с поддержкой Java 16.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла статья &lt;a href="https://seanjmullan.org/blog/2021/03/18/jdk16"&gt;JDK 16 Security Enhancements&lt;/a&gt;, где рассказано какие изменения в криптографии, PKI, TLS, Signed JARs были сделаны в Java 16.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://github.com/google/guava/releases/tag/v30.1.1"&gt;Guava 30.1.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+13&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+5&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 16</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_16.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_16.html</id>
    <updated>2021-03-15T17:00:00Z</updated>
    <published>2021-03-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;16-я версия&lt;/a&gt; платформы Java SE. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-16.txt"&gt;двух с половиной тысяч&lt;/a&gt; закрытых задач и 17 JEP'ов. Изменения API можно посмотреть &lt;a href="https://javaalmanac.io/jdk/16/apidiff/15/"&gt;здесь&lt;/a&gt;. Release notes &lt;a href="https://www.oracle.com/java/technologies/javase/16-all-relnotes.html"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Уже сейчас доступны для скачивания дистрибутивы &lt;a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html"&gt;Oracle JDK&lt;/a&gt; и &lt;a href="http://jdk.java.net/16/"&gt;OpenJDK&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;JEP'ы, которые попали в Java 16, мы разобьём на четыре категории: язык, API, JVM и инфраструктура.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/375"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (JEP 375)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Оператор &lt;code&gt;instanceof&lt;/code&gt; с паттерн-матчингом, который &lt;a href="https://openjdk.java.net/jeps/305"&gt;появился&lt;/a&gt; в Java 14 и перешёл во &lt;a href="https://openjdk.java.net/jeps/375"&gt;второе preview&lt;/a&gt; в Java 15, теперь стал стабильной синтаксической конструкцией и больше не требует флага &lt;code&gt;--enable-preview&lt;/code&gt;. Паттерн-матчинг мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;, и с того момента в него было внесено два изменения:&lt;/p&gt;
&lt;p&gt;Во-первых, переменные паттернов теперь не являются неявно финальными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) {
    s = &lt;span style="color: darkred"&gt;"Hello"&lt;/span&gt;; &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Во-вторых, если тип выражения, известный на этапе компиляции, является подтипом проверяемого типа, то теперь это ошибка компиляции:&lt;/p&gt;
&lt;pre&gt;String str = ...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (str &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) { &lt;span style="color: green"&gt;// Oшибка в Java 16, OK в Java 15&lt;/span&gt;
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/395"&gt;Записи (JEP 395)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одна синтаксическая конструкция, которая стала стабильной &amp;ndash; это записи. Она также была в режиме preview в &lt;a href="https://openjdk.java.net/jeps/359"&gt;Java 14&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/384"&gt;Java 15&lt;/a&gt;. Записи мы также подробно &lt;a href="trying_records_in_java14.html"&gt;рассматривали ранее&lt;/a&gt;. В Java 16 было внесено следующее изменение: теперь во внутренних классах разрешено объявлять статические члены:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;static void&lt;/span&gt; main(String[] args) {
        }

        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {
        }
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/397"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (второе preview) (JEP 397)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;&amp;laquo;Запечатанные&amp;raquo; классы, которые появились в Java 15 в режиме preview, остаются в этом статусе. Их мы рассматривали в &lt;a href="trying_sealed_classes_in_java_15.html"&gt;этой статье&lt;/a&gt;. Изменения по сравнению с прошлой версией следующие:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Теперь в спецификации языка Java появилось понятие contextual keyword взамен старым понятиям restricted keyword и restricted identifier, и одними из таких contextual keywords стали &lt;code&gt;sealed&lt;/code&gt;, &lt;code&gt;non-sealed&lt;/code&gt; и &lt;code&gt;permits&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Компилятор теперь производит более строгие проверки при конверсии типов, в иерархиях которых есть &lt;code&gt;sealed&lt;/code&gt; классы:&lt;pre&gt;
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Sealed {
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Impl &lt;span style="color: blue"&gt;implements&lt;/span&gt; Sealed {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; f(Runnable r) {
        Sealed s = (Sealed) r; &lt;span style="color: red"&gt;// error: incompatible types&lt;/span&gt;
    }
}&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Метод &lt;code&gt;Class.permittedSubclasses()&lt;/code&gt; переименован в &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#getPermittedSubclasses()"&gt;&lt;code&gt;Class.getPermittedSubclasses()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/396"&gt;Строгая инкапсуляция внутренностей JDK по умолчанию (JEP 396)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инкапсуляция внутренних API JDK, которая была &lt;a href="https://openjdk.java.net/jeps/260"&gt;введена в Java 9&lt;/a&gt;, теперь стала строгой: если в Java 9-15 значение опции &lt;code&gt;--illegal-access&lt;/code&gt; было по умолчанию &lt;code&gt;permit&lt;/code&gt;, то с Java 16 она становится &lt;code&gt;deny&lt;/code&gt;. Это значит, что рефлективный доступ к защищённым членам классов и статический доступ к неэкспортированным API (&lt;code&gt;sun.*&lt;/code&gt;, &lt;code&gt;com.sun.*&lt;/code&gt;, &lt;code&gt;jdk.internal.*&lt;/code&gt; и т.д.) теперь будет выбрасывать ошибку.&lt;/p&gt;
&lt;p&gt;Если код требует доступа к внутренностям JDK во время выполнения, то чтобы он продолжал работать на Java 16, теперь придётся явно указывать одну из трёх опций JVM:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--illegal-access=permit/warn/debug&lt;/code&gt;: открытие всех пакетов JDK&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-opens=module/package=target-module&lt;/code&gt;: открытие одного пакета&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-exports=module/package=target-module&lt;/code&gt;: экспортирование одного пакета (только для статического доступа)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В будущем опция &lt;code&gt;--illegal-access&lt;/code&gt; может быть удалена окончательно. Начиная с Java 16, при её использовании выдаётся предупреждение: &lt;code&gt;Option --illegal-access is deprecated and will be removed in a future release&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Изменения не касаются критического API в модуле &lt;code&gt;jdk.unsupported&lt;/code&gt;: классы в пакетах &lt;code&gt;sun.misc&lt;/code&gt; и &lt;code&gt;sun.reflect&lt;/code&gt; остаются доступными без флагов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/390"&gt;Warnings for Value-Based Classes (JEP 390)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Классы-обёртки примитивных типов (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt; и т.д.) теперь относятся к категории value-based классов, и их конструкторы, которые ранее &lt;a href="new_integer_is_deprecated.html"&gt;стали deprecated&lt;/a&gt; в Java 9, теперь помечены как &lt;a href="https://openjdk.java.net/jeps/277"&gt;deprecated for removal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Понятие value-based классов появилось в спецификации API &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html"&gt;Java 8&lt;/a&gt;. Такие классы являются неизменяемыми, создаются только через фабрики, и в их использовании не должны использоваться операции, чувствительные к identity: сравнение на &lt;code&gt;==&lt;/code&gt;, синхронизация, &lt;code&gt;identityHashCode()&lt;/code&gt; и т.д. Value-based классы являются кандидатами для миграции на &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;примитивные классы&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;, который сейчас находится в стадии активной разработки.&lt;/p&gt;
&lt;p&gt;При синхронизации на объектах value-based классов теперь будет выдаваться предупреждение во время компиляции:&lt;/p&gt;
&lt;pre&gt;Double d = 0.0;
&lt;span style="color: blue"&gt;synchronized&lt;/span&gt; (d) { &lt;span style="color: orange"&gt;// warning: [synchronization] attempt to synchronize on an instance of a value-based class&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Также можно включить проверки синхронизации на value-based объектах во время выполнения с помощью флагов JVM:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=1&lt;/code&gt;: при попытке синхронизации будет фатальная ошибка.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=2&lt;/code&gt;: при попытке синхронизации будет предупреждение.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/376"&gt;ZGC: Concurrent Thread-Stack Processing (JEP 376)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Обработка стеков потоков в сборщике мусора &lt;a href="https://openjdk.java.net/jeps/377"&gt;ZGC&lt;/a&gt; теперь перенесена из safepoints в конкурентную фазу. Это позволило ещё сильнее уменьшить паузы сборщика мусора.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/380"&gt;Unix-Domain Socket Channels (JEP 380)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Добавлена поддержка &lt;a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0_Unix"&gt;сокетов доменов Unix&lt;/a&gt; в socket channel и server-socket channel API. Такие сокеты используются для межпроцессного взаимодействия внутри одного хоста, и в них не используются сетевые соединения, что делает такое взаимодействие более безопасным и эффективным. Сокеты доменов Unix с &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/"&gt;недавних пор&lt;/a&gt; поддерживаются в Windows 10 и Windows Server 2019.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/387"&gt;Elastic Metaspace (JEP 387)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Metaspace (пространство JVM, в котором хранятся метаданные классов) переработан для более эффективной отдачи неиспользуемой памяти обратно операционной системе и меньшего потребления памяти вне кучи в целом. Такое улучшение может быть полезно для приложений, которые интенсивно загружают и выгружают классы посредством большого количества загрузчиков классов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/386"&gt;Alpine Linux Port (JEP 386)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь портирован на &lt;a href="https://ru.wikipedia.org/wiki/Alpine_Linux"&gt;Alpine Linux&lt;/a&gt; и другие дистрибутивы Linux, которые используют &lt;a href="https://ru.wikipedia.org/wiki/Musl"&gt;musl&lt;/a&gt; в качестве реализации стандартной библиотеки C. Alpine Linux популярен в облаках, микросервисах и контейнерах благодаря своему маленькому размеру образа. Новый порт позволит нативно запускать JDK в этих окружениях.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/388"&gt;Windows/AArch64 Port (JEP 388)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK также портирован на архитектуру &lt;a href="https://docs.microsoft.com/ru-ru/windows/uwp/porting/apps-on-arm"&gt;Windows/AArch64&lt;/a&gt;. Это позволит запускать Java на компьютерах с Windows on ARM, которые в последнее время набирают популярность.&lt;/p&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;Новые методы в &lt;code&gt;Stream&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;Хотя для этих двух новых методов в интерфейсе &lt;code&gt;java.util.stream.Stream&lt;/code&gt; нет отдельного JEP, хочется упомянуть их здесь, так как это довольно заметное изменение.&lt;/p&gt;
&lt;p&gt;Первый метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"&gt;&lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/a&gt;. Этот метод собирает содержимое &lt;code&gt;Stream&lt;/code&gt; в неизменяемый список и возвращает его. При этом, в отличие от &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableList()"&gt;&lt;code&gt;Collectors.toUnmodifiableList()&lt;/code&gt;&lt;/a&gt;, список, который возвращается из &lt;code&gt;Stream.toList()&lt;/code&gt;, толерантен к &lt;code&gt;null&lt;/code&gt;-элементам.&lt;/p&gt;
&lt;p&gt;Второй метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)"&gt;&lt;code&gt;Stream.mapMulti()&lt;/code&gt;&lt;/a&gt; (и примитивные специализации). Это метод является императивным аналогом метода &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;Stream.flatMap()&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;flatMap()&lt;/code&gt; принимает функцию, которая для каждого элемента должна вернуть &lt;code&gt;Stream&lt;/code&gt;, то &lt;code&gt;mapMulti()&lt;/code&gt; принимает процедуру с двумя параметрами, где первый параметр &amp;ndash; это текущий элемент, а второй &amp;ndash; Consumer, в который кладутся значения. Пример:&lt;/p&gt;
&lt;pre&gt;IntStream.rangeClosed(1, 10).mapMulti((i, consumer) -&gt; {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; j = 1; j &lt;= i; j++) {
        consumer.accept(j);
    }
}); &lt;span style="color: green"&gt;// Возвращает 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/392"&gt;Инструмент упаковки (JEP 392)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инструмент создания самодостаточных приложений &lt;code&gt;jpackage&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/343"&gt;появился в Java 14&lt;/a&gt; в инкубационном статусе, теперь стал постоянным модулем.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/338"&gt;Vector API (Incubator) (JEP 338)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый инструментарий для преобразования векторных вычислений в SIMD-инструкции процессора (x64 и AArch64). Векторное API позволит разработчику контролировать процесс компиляции и не полагаться на автовекторизацию, которая в JVM является ограниченным и хрупким механизмом. Явная векторизация может применяться в таких областях как машинное обучение, линейная алгебра, криптография и др.&lt;/p&gt;
&lt;p&gt;API находится в инкубационном модуле &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/389"&gt;Foreign Linker API (Incubator) (JEP 389)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новое API, которое появилось в результате работы над проектом &lt;a href="http://openjdk.java.net/projects/panama/"&gt;Panama&lt;/a&gt; &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/module-summary.html"&gt;Foreign Linker API&lt;/a&gt;. Это инструментарий для статического доступа к нативному коду из Java, созданный для замены JNI: он должен быть более простым в использовании, более безопасным и желательно более быстрым.&lt;/p&gt;
&lt;p&gt;Про Foreign API &lt;a href="https://www.youtube.com/watch?v=4vHMmLqF09Y"&gt;делал доклад&lt;/a&gt; Владимир Иванов из Oracle.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/393"&gt;Foreign-Memory Access API (Third Incubator) (JEP 393)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API для доступа вне кучи Java, которое появилось &lt;a href="https://openjdk.java.net/jeps/370"&gt;в Java 14&lt;/a&gt;, остаётся в инкубационном статусе с некоторыми изменениями.&lt;/p&gt;

&lt;h4&gt;Инфраструктура&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/347"&gt;Enable C++14 Language Features (JEP 347)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Кодовая база JDK до Java 16 использовала стандарты C++98/03. При этом с Java 11 код стал собираться версией с более новым стандартом, однако в нём всё ещё нельзя было использовать возможности стандарта C++11/14. Теперь же часть из этих возможностей использовать можно: в гиде по стилю HotSpot определён список возможностей C++11/14, которые можно использовать и которые нельзя.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/357"&gt;Migrate from Mercurial to Git (JEP 357)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/369"&gt;Migrate to GitHub (JEP 369)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Совершён переход репозиториев JDK на Git и GitHub. Миграция была полностью завершена в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2020-September/004694.html"&gt;сентябре 2020 года&lt;/a&gt;, и разработка Java 16 уже полностью велась в &lt;a href="https://git.openjdk.java.net/jdk"&gt;новом репозитории&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Переход на GitHub облегчил процесс принятия изменений контрибьюторами. Теперь изменения предлагаются через привычные большинству пользователей пулл-реквесты, и большая часть процесса автоматизирована с помощью команд и ботов. Подробнее про процесс можно прочитать на &lt;a href="https://wiki.openjdk.java.net/display/SKARA/Skara"&gt;странице проекта Skara&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также сейчас &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;обсуждается&lt;/a&gt; переход на Git более старых версий JDK: &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; и, возможно, &lt;a href="https://wiki.openjdk.java.net/display/jdk8u/Main"&gt;jdk8u&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;Java 16 является STS-релизом, у которого выйдет только два обновления.&lt;/p&gt;</content>
  </entry>
</feed>
