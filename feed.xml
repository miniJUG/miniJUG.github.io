<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-01-24T17:00:00Z</updated>
  <entry>
    <title>Новости Java #4</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_4.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_4.html</id>
    <updated>2021-01-24T17:00:00Z</updated>
    <published>2021-01-24T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Java отпраздновала знаменательную дату: 23 января 1996 года, ровно 25 лет назад, вышла первая стабильная версия JDK, которая имела версию &lt;a href="https://javaalmanac.io/jdk/1.0/"&gt;1.0.2&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://blog.adoptopenjdk.net/2021/01/adoptopenjdk-8u282-11010-and-1502-available/"&gt;Вышли&lt;/a&gt; обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-January/013337.html"&gt;JDK 8u282&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004689.html"&gt;JDK 11.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004690.html"&gt;JDK 13.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://jdk.java.net/15/"&gt;JDK 15.0.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также вышли обновления ранних сборок JDK: &lt;a href="http://jdk.java.net/16/"&gt;JDK 16-ea+33&lt;/a&gt; и &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+6&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайн Гетц опубликовал несколько писем в &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/thread.html"&gt;рассылке Amber&lt;/a&gt; с рассуждениями относительно паттерн-матчинга и подробностями его развития в ближайшем будущем:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002758.html"&gt;Pattern features for next iteration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002763.html"&gt;Patterns: Nullity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002778.html"&gt;Patterns: Declaration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002782.html"&gt;Relaxed assignment conversions for sealed types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также Брайн Гетц опубликовал статью на InfoQ: &lt;a href="https://www.infoq.com/articles/java-pattern-matching/"&gt;Java Feature Spotlight: Pattern Matching&lt;/a&gt;. В ней он рассказывает, как выглядит паттерн-матчинг в Java сейчас и в каком направлении он будет развиваться.&lt;/p&gt;
&lt;p&gt;Кроме того, выложено &lt;a href="https://freecontent.manning.com/interview-with-brian-goetz/"&gt;большое интервью&lt;/a&gt; с Брайном про его работу над развитием языка.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Ещё один день рождения празднует IntelliJ IDEA. Её первая версия вышла в свет в 2001 году. В связи с этим JetBrains организует бесплатную виртуальную конференцию &lt;a href="https://www.jetbrains.com/ru-ru/lp/intellijidea-20-anniversary/"&gt;IntelliJ IDEA Conf&lt;/a&gt;, которая состоится 25-26 февраля.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В новосибирском сообществе Java-программистов JUGNsk объявили об очередном &lt;a href="https://www.meetup.com/JUGNsk/events/275807033/"&gt;онлайн-митапе&lt;/a&gt;, который состоится 28 января в 15:00 по московскому времени.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Тагир Валеев опубликовал статью на Хабре: &lt;a href="https://habr.com/ru/post/538280/"&gt;Анбоксинг в современной Java&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла GraalVM 21.0. В дополнение к &lt;a href="https://medium.com/graalvm/graalvm-21-0-introducing-a-new-way-to-run-java-df894256de28"&gt;основной новости&lt;/a&gt; о выходе новой версии была опубликована &lt;a href="https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840"&gt;дополнительная статья&lt;/a&gt; с подробностями того, как JVM реализована полностью на Java с использованием фреймворка Truffle.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/lists/tycho-dev/msg01837.html"&gt;Eclipse Tycho 2.2.0.&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #3</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_3.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_3.html</id>
    <updated>2021-01-17T17:00:00Z</updated>
    <published>2021-01-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; По просьбам читателей на сайт &lt;a href="https://minijug.ru"&gt;minijug.ru&lt;/a&gt; был добавлен feed в формате Atom. Это сделано для тех, кто предпочитает узнавать о новых публикациях через агрегатор новостных лент, а не через &lt;a href="https://t.me/miniJUG"&gt;Telegram-канал&lt;/a&gt;. Адрес feed &lt;a href="https://minijug.ru/feed.xml"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Java 16 теперь во &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-January/005001.html"&gt;второй фазе Rampdown&lt;/a&gt;, а значит на одну ступень ближе к релизу, который &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;по плану&lt;/a&gt; должен произойти 16 марта.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В компилятор Java было внесено &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8250769"&gt;несколько изменений&lt;/a&gt; в отношении preview API. Preview API &amp;ndash; это один из трёх типов &lt;a href="https://openjdk.java.net/jeps/12"&gt;preview feature&lt;/a&gt; в Java, наряду с preview language feature и preview VM feature. Preview API разделены на две большие группы: &lt;em&gt;нормальные&lt;/em&gt; (normal) и &lt;em&gt;рефлективные&lt;/em&gt; (reflective). Нормальные также подразделяются на &lt;em&gt;неотъемлемые&lt;/em&gt; (essential), &lt;em&gt;удобные&lt;/em&gt; (convenient) и &lt;em&gt;автономные&lt;/em&gt; (standalone). Однако для &lt;code&gt;javac&lt;/code&gt; важно только разделение на нормальные и рефлективные. Главные изменения &lt;code&gt;javac&lt;/code&gt; следующие:&lt;/p&gt;
&lt;p&gt;1. Аннотация &lt;code&gt;@PreviewFeature&lt;/code&gt; перенесена из пакета &lt;code&gt;jdk.internal&lt;/code&gt; в пакет &lt;code&gt;jdk.internal.javac&lt;/code&gt;, и в неё добавлен флаг &lt;code&gt;reflective&lt;/code&gt;, который заменил старый флаг &lt;code&gt;essentialAPI&lt;/code&gt;. Этот новый флаг как раз и поможет компилятору отличать рефлективные preview API от нормальных.&lt;/p&gt;
&lt;p&gt;2. Рефлективные preview API можно использовать без флага компилятора &lt;code&gt;--enable-preview&lt;/code&gt;, а нормальные &amp;ndash; только с флагом.&lt;/p&gt;
&lt;p&gt;3. При использовании класса, который использует preview feature, теперь выдаётся предупреждение (например, если использован &lt;code&gt;sealed&lt;/code&gt;-класс из какой-нибудь библиотеки). Но это предупреждение можно подавить через &lt;code&gt;@SuppressWarnings(&lt;span style="color: darkred"&gt;"preview"&lt;/span&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;4. Классы помечаются как зависящие от preview feature, только если это действительно необходимо (такие class-файлы имеют специальную минорную версию 65535, например 61.65535 для Java 17). Если класс не использует ни одной preview language feature (ни прямо, ни косвенно), ни одной preview VM feature и ни одного нормального preview API, то он компилируется в обычный (не-preview) class-файл. Другими словами, если из preview features использовать только рефлективные preview API, то такие программы можно будет запускать без флага &lt;code&gt;--enable-preview&lt;/code&gt;, даже если они скомпилированы с флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Эти изменения в &lt;code&gt;javac&lt;/code&gt; будут работать только начиная с Java 17.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Опубликован новый черновик &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;JEP: Primitive Objects (Preview)&lt;/a&gt;, в котором описывается, как в Java планируется внедрить примитивные объекты. Примитивные объекты &amp;ndash; это объекты, которые не имеют идентичности, то есть при их копировании получается объект, неотличимый от оригинального. Такие объекты могут передаваться напрямую и легко встраиваться (в другие объекты/массивы/стек), что снижает накладные расходы на их использование и делает их более эффективными, чем объекты с идентичностью.&lt;/p&gt;
&lt;p class="pt-3"&gt;Новый черновик JEP &amp;ndash; это возможно первая детальная публичная спецификация, которая стала результатом многолетних исследований, множества встреч экспертов и обсуждений, проведённых по value-типам в рамках проекта &lt;a href="http://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;. В ходе проекта было сделано несколько прототипов, несколько раз значительно менялась концепция, а сами value-типы дважды переименовывались: сначала в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2019-April/000916.html"&gt;inline-классы&lt;/a&gt;, а потом в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2020-October/001415.html"&gt;примитивные классы&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/01/java-annotated-monthly-january-2021/"&gt;&amp;laquo;Java Annotated Monthly&amp;raquo;&lt;/a&gt;, где собрано огромное количество ссылок на новости, статьи, тьюториалы и прочие материалы о Java и связанных темах.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://mail.openjdk.java.net/pipermail/loom-dev/2021-January/002046.html"&gt;новая сборка Loom&lt;/a&gt;, основанная на JDK 17+5.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://github.com/scala/scala/releases/tag/v2.12.13"&gt;Scala 2.12.13&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #2</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_2.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_2.html</id>
    <updated>2021-01-10T17:00:00Z</updated>
    <published>2021-01-10T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стал известен первый JEP, который попадёт в Java 17. Это &lt;a href="https://openjdk.java.net/jeps/356"&gt;JEP 356: Enhanced Pseudo-Random Number Generators&lt;/a&gt;. В рамках этого JEP'а будет добавлен интерфейс &lt;code&gt;RandomGenerator&lt;/code&gt; с четырьмя его специализациями: &lt;code&gt;SplittableRandomGenerator&lt;/code&gt;, &lt;code&gt;JumpableRandomGenerator&lt;/code&gt;, &lt;code&gt;LeapableRandomGenerator&lt;/code&gt; и &lt;code&gt;ArbitrarilyJumpableRandomGenerator&lt;/code&gt;. Кроме того, будет добавлен класс &lt;code&gt;RandomGeneratorFactory&lt;/code&gt;, который будет возвращать конкретные реализации &lt;code&gt;RandomGenerator&lt;/code&gt;. Старые классы &lt;code&gt;Random&lt;/code&gt;, &lt;code&gt;ThreadLocalRandom&lt;/code&gt; и &lt;code&gt;SplittableRandom&lt;/code&gt; будут отрефакторены и станут одними из реализаций &lt;code&gt;RandomGenerator&lt;/code&gt;. Также будут реализованы новые алгоритмы генерации псевдослучайных чисел.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайан Гетц опубликовал &lt;a href="https://github.com/openjdk/amber-docs/blob/master/site/design-notes/pattern-match-object-model.md"&gt;новый документ&lt;/a&gt; &amp;laquo;Паттерн-матчинг в объектной модели Java&amp;raquo;. В нём описывается возможный подход внедрения паттерн-матчинга в язык. Документ довольно большой, поэтому попробуем выделить основные моменты:&lt;/p&gt;
&lt;p&gt;&amp;ndash; Если язык предоставляет возможноть агрегации посредством конструкторов/фабричных методов, то он должен предоставлять и обратный механизм деконструкции:&lt;/p&gt;
&lt;pre&gt;Object x = &lt;span style="color: blue"&gt;new&lt;/span&gt; Foo(a, b); &lt;span style="color: green"&gt;// конструкция&lt;/span&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b): ... &lt;span style="color: green"&gt;// деконструкция&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Если конструирование объекта поддерживает композицию, то и деконструирование тоже должно её поддерживать:&lt;/p&gt;
&lt;pre&gt;Optional.of(Shape.redBall(1));&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Optional.of(Shape.redBall(&lt;span style="color: blue"&gt;var&lt;/span&gt; size)): ...&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Паттерны деконструкции являются точно такими же членами класса, как и конструкторы/методы. Паттерны имеют тело, в котором описывается всё необходимое поведение.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Раз паттерны являются членами класса, то они поддерживают все их атрибуты: модификаторы доступа, перегрузка, переопределение, static/instance, параметрический полиморфизм, делегирование к другим паттернам, varargs и т.д.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Паттерны также имеют дополнительные уникальные атрибуты: наличие целевого операнда, тип которого должен быть совместим с целевым типом, полнота/частичность, исчерпываемость, разделение аргументов на входные и выходные.&lt;/p&gt;
&lt;p&gt;&amp;ndash; В конце документа описываются также другие идеи вроде комбинирования паттернов с помощью булевых операторов (AND/OR), структурные паттерны и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Также Брайн Гетц предложил в рассылке Amber несколько идей относительно паттерн-матчинга:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002688.html"&gt;Оператор алмаза в паттернах&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Было&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;K, ? extends V&amp;gt; em) { ... }

&lt;span style="color: green"&gt;// Стало&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;&amp;gt; em) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002695.html"&gt;Паттерны массивов&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (arr &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { &lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b }) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002710.html"&gt;Охранные паттерны&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; P(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) __AND &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0) __AND Q(&lt;span style="color: blue"&gt;var&lt;/span&gt; y):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Джонатан Гиббонс (Oracle) &lt;a href="https://mail.openjdk.java.net/pipermail/code-tools-dev/2021-January/000625.html"&gt;предложил&lt;/a&gt; добавить в JDK утилиту &lt;code&gt;apidiff&lt;/code&gt; для сравнения нескольких версий API. Утилита сможет анализировать class-файлы, исходные файлы Java и файлы документации и генерировать HTML-отчёт о различиях в API. Внутри она будет использовать фронтенд &lt;code&gt;javac&lt;/code&gt; и модули &lt;code&gt;java.compiler&lt;/code&gt;/&lt;code&gt;jdk.compiler&lt;/code&gt; для чтения исходных и класс-файлов, а значит не будет проблем с поддержкой в утилите последних языковых изменений. Джонатан пишет, что у него уже есть продвинутый прототип утилиты и он надеется в скором времени опубликовать его на GitHub.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Американские новостные агентства &lt;a href="https://www.wsj.com/articles/solarwinds-hack-breached-justice-department-systems-11609958761"&gt;написали&lt;/a&gt; о взломе нескольких министерств США через программное обеспечение компании SolarWinds и о возможной организации этих кибератак хакерами, связанными с Россией. В статьях написано, что хакеры могли это сделать, получив доступ к билд-серверу TeamCity, развёрнутому в компании для сборки ПО. Далее сообщается, что американские спецслужбы и специалисты по кибербезопасности начали исследование возможной роли JetBrains в атаке.&lt;/p&gt;
&lt;p&gt;При этом авторы не объясняют, почему такой негативный акцент в статьях сделан именно на JetBrains, ведь кроме TeamCity в SolarWinds должно использоваться множество других программ и инструментов для разработки. New York Times вообще &lt;a href="https://web.archive.org/web/20210106195835/https://www.nytimes.com/2021/01/06/us/politics/russia-cyber-hack.html"&gt;назвал&lt;/a&gt; JetBrains &amp;laquo;obscure software company&amp;raquo; (&amp;laquo;тёмная&amp;raquo;, &amp;laquo;неясная&amp;raquo;), но позже изменил эту фразу в статье на &amp;laquo;widely used software company&amp;raquo;, и вообще в течение последующих дней множество раз изменял статью, постоянно внося туда правки и уточнения. Многие программисты в Твиттере довольно резко отреагировали на &lt;a href="https://twitter.com/nicoleperlroth/status/1346909580219936769"&gt;твит&lt;/a&gt; редактора New York Times и одной из авторов статьи, делая &lt;a href="https://twitter.com/nikitonsky/status/1347004468966141954"&gt;ретвиты&lt;/a&gt; с саркастическими шутками.&lt;/p&gt;
&lt;p&gt;Максим Шафиров, CEO JetBrains, после выхода новостей, сразу написал &lt;a href="https://blog.jetbrains.com/blog/2021/01/06/statement-on-the-story-from-the-new-york-times-regarding-jetbrains-and-solarwinds/"&gt;официальный ответ&lt;/a&gt;, что JetBrains никак не может быть причастен к атаке и компания не была извещена о расследовании, но полностью готова к сотрудничеству. На следующий день он выложил &lt;a href="https://blog.jetbrains.com/blog/2021/01/07/an-update-on-solarwinds/"&gt;более подробный пост&lt;/a&gt;, в котором более подробно описал ситуацию. Он написал, что компании неизвестно об уязвимостях в TeamCity, которые могли бы быть эксплуатированы для организации подобных атак, и компания проводит регулярный аудит своих инструментов и систем.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Брюс Эккель, автор &amp;laquo;Философия Java&amp;raquo; и многих других книг о Java, C++ и JVM языках, &lt;a href="https://www.bruceeckel.com/2021/01/02/the-problem-with-gradle/"&gt;написал пост&lt;/a&gt; &amp;laquo;The Problem with Gradle&amp;raquo;, где рассказал свою историю использования Gradle и перечислил его проблемы.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://docs.gradle.org/6.8/release-notes.html"&gt;Вышел Gradle 6.8&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #1</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_1.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_1.html</id>
    <updated>2021-01-03T17:00:00Z</updated>
    <published>2021-01-03T17:00:00Z</published>
    <content type="html">&lt;p&gt;Всех с Новым 2021 Годом!&lt;/p&gt;
&lt;p&gt;&amp;bull; В компиляторе javac &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8259025"&gt;нашли баг&lt;/a&gt;, который не позволяет использовать лямбды в компактных конструкторах записей при определённых обстоятельствах. Баг был обнаружен пользователем @skohlman &lt;a href="https://twitter.com/skohlmann/status/1344684426836500480"&gt;в Твиттере&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;bull; &lt;a href="https://youtrack.jetbrains.com/issue/JBR-2526#focus=Comments-27-4620322.0-0"&gt;Вышла&lt;/a&gt; стабильная версия JetBrains Runtime под Apple M1. Теперь она включена почти во все IDE компании, начиная с версии 2020.3.1. Пользователи уже доложили о нескольких ошибках, которые проявляются в различных IDE.&lt;/p&gt;
&lt;p&gt;&amp;bull; Разработчики обнаружили новый класс &lt;a href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/util/HexFormat.html"&gt;HexFormat&lt;/a&gt;, который появится в Java 17. С помощью этого класса можно будет конвертировать строки с шестнадцатеричными символами в массивы байтов и обратно.&lt;/p&gt;
&lt;p&gt;&amp;bull; Huawei реализовал &lt;a href="https://gitee.com/openeuler/bishengjdk-11/tree/risc-v/"&gt;свой порт&lt;/a&gt; OpenJDK 11 под архитектуру Linux/RISC-V и &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2020-December/005657.html"&gt;спрашивает&lt;/a&gt;, заинтересовано ли сообщество во включении этого порта в jdk-master. Alibaba изъявили желание помочь и сделать вклад в разработку.&lt;/p&gt;
&lt;p&gt;&amp;bull; Команда Jetty &lt;a href="https://mail.openjdk.java.net/pipermail/loom-dev/2020-December/001974.html"&gt;рассказала&lt;/a&gt; об опыте перехода веб-сервера на виртуальные нити из проекта Loom. Они сделали вывод, что количество нитей &amp;ndash; это не всегда главный лимитирующий фактор, и правило &amp;laquo;просто всегда создавай виртуальную нить&amp;raquo; может не сработать, если каждая нить имеет глубокий стек или держит какие-то большие ресурсы.&lt;/p&gt;
&lt;p&gt;&amp;bull; Разработчик из Oracle &lt;a href="https://cl4es.github.io/2021/01/04/Investigating-MD5-Overheads.html"&gt;рассказал&lt;/a&gt; о том, как ускорил MD5 в OpenJDK.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 15</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_15_is_out.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_15_is_out.html</id>
    <updated>2020-09-14T17:00:00Z</updated>
    <published>2020-09-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;Сегодня в свет вышла новая, &lt;a href="http://openjdk.java.net/projects/jdk/15/"&gt;15-я версия платформы Java&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Скачать JDK 15 можно по следующим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html"&gt;Oracle JDK&lt;/a&gt; (проприетарная версия, обратите внимание на ограничения в использовании).&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/15/"&gt;OpenJDK&lt;/a&gt; (бесплатная версия)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В новый релиз попало 14 JEP'ов и &lt;a href="http://jdk.java.net/15/release-notes"&gt;сотни более мелких улучшений&lt;/a&gt;. Если хочется ознакомиться с полным списком изменений с точностью до всех JIRA-тикетов, то их можно посмотреть на &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-15.txt"&gt;сайте Алексея Шипилёва&lt;/a&gt;. Также если интересны все изменения API, то их можно посмотреть &lt;a href="https://javaalmanac.io/jdk/15/apidiff/14/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Перечислим JEP'ы, которые попали в Java 15:&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/378"&gt;Блоки текста (JEP 378)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Блоки текста, которые &lt;a href="text_blocks.html"&gt;появились&lt;/a&gt; в Java 13 и прошли два preview, теперь стали стабильной синтаксической конструкцией. Это значит, что в Java теперь две постоянные конструкции, которые появились с выхода Java 11: &lt;a href="https://openjdk.java.net/jeps/361"&gt;выражения &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt; и блоки текста.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/375"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (второе preview) (JEP 375)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Улучшенный оператор &lt;code&gt;instanceof&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/305"&gt;появился&lt;/a&gt; в Java 14, перешёл во второе preview без изменений. Напомним, что &lt;a href="https://openjdk.java.net/jeps/12"&gt;режим preview&lt;/a&gt; существует в Java для нововведений, которые находятся в предварительном статусе, т.е. могут измениться несовместимым образом или даже совсем исчезнуть, и для их включения необходим специальный флаг &lt;code&gt;--enable-preview&lt;/code&gt;. Паттерн-матчинг для &lt;code&gt;instanceof&lt;/code&gt; мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/384"&gt;Записи (второе preview) (JEP 384)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Записи, которые также &lt;a href="https://openjdk.java.net/jeps/359"&gt;появились&lt;/a&gt; в Java 14, тоже остались в режиме preview. Изменений по сравнению с прошлой версией немного: убрано ограничение, что канонический конструктор должен быть &lt;code&gt;public&lt;/code&gt;, а также разрешены &lt;a href="local_interfaces_and_enums.html"&gt;локальные перечисления и интерфейсы&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/360"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (preview) (JEP 360)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появилось языковое нововведение: &amp;laquo;запечатанные&amp;raquo; классы. Помечаются такие классы модификатором &lt;code&gt;sealed&lt;/code&gt;, после чего круг классов, которые могут наследоваться от данного класса, становится ограниченным. &lt;code&gt;sealed&lt;/code&gt; классы мы подробно рассматривали в &lt;a href="trying_sealed_classes_in_java_15.html"&gt;этой статье&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/377"&gt;ZGC (JEP 377)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;ZGC, который &lt;a href="https://openjdk.java.net/jeps/333"&gt;появился&lt;/a&gt; в Java 11 в экспериментальном статусе, теперь официально готов к продуктовой разработке. Напомним, что ZGC &amp;ndash; это сборщик мусора, который нацелен на маленькие паузы (&lt; 10мс) и готовность работать в условиях огромных куч (&gt; 1TB).&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/379"&gt;Shenandoah (JEP 379)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Shenandoah, ещё один низкопаузный сборщик мусора и &lt;a href="zgc.html"&gt;конкурент&lt;/a&gt; ZGC, теперь также имеет статус готового к продуктовой разработке. Shenandoah впервые &lt;a href="https://openjdk.java.net/jeps/189"&gt;появился&lt;/a&gt; в Java 12. Также недавно стало известно, что Shenandoah был &lt;a href="https://twitter.com/rkennke/status/1288530745179463680"&gt;бэкпортирован в JDK 11&lt;/a&gt;, который является текущим LTS-релизом Java. Это значит, что чтобы его использовать, необязательно обновляться до JDK 15, а достаточно обновиться до JDK 11.0.9, которая &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;выйдет&lt;/a&gt; 20 октября 2020 года.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/374"&gt;Disable and Deprecate Biased Locking (JEP 374)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Biased Locking, который много лет существовал в JDK, было решено убрать из-за сложности поддержки и "неочевидных преимуществ" этой оптимизации. Начиная с этого релиза, опция &lt;code&gt;-XX:+UseBiasedLocking&lt;/code&gt; отключена по умолчанию, а при её использовании и всех её связанных опций будет выдаваться предупреждение. Про мотивы отключения Biased Locking рассказал Сергей Куксенко в &lt;a href="https://www.youtube.com/watch?v=v3oK5_docYE"&gt;подкасте Hydra&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/381"&gt;Удаление портов Solaris и SPARC (JEP 381)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Порты JDK на Solaris/SPARC, Solaris/x64 и Linux/SPARC, которые &lt;a href="https://openjdk.java.net/jeps/362"&gt;стали&lt;/a&gt; deprecated for removal в Java 14, теперь удалены окончательно. Удаление этих портов упростит и ускорит разработку JDK.&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/371"&gt;Скрытые классы (JEP 371)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый тип классов, называемых &lt;a href="hidden_classes.html"&gt;скрытыми&lt;/a&gt;. На скрытые классы не могут прямо ссылаться другие классы, и всё их использование может осуществляться только через рефлексию. Также их нельзя обнаружить по имени, и их методы не появляются в стек-трейсах. Создаются такие классы с помощью нового метода &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)"&gt;&lt;code&gt;Lookup.defineHiddenClass()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/372"&gt;Удаление движка JavaScript Nashorn (JEP 372)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Движок Nashorn, который &lt;a href="https://openjdk.java.net/jeps/335"&gt;стал&lt;/a&gt; deprecated for removal в Java 11, теперь удалён &lt;a href="remove_nashorn.html"&gt;окончательно&lt;/a&gt;. В качестве замены Nashorn теперь придётся искать другой движок JavaScript, например, &lt;a href="https://github.com/graalvm/graaljs"&gt;GraalVM JavaScript&lt;/a&gt; или &lt;a href="https://github.com/mozilla/rhino"&gt;Rhino&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/373"&gt;Reimplement the Legacy DatagramSocket API (JEP 373)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Реализации старых сокетов из JDK 1.0 &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/DatagramSocket.html"&gt;&lt;code&gt;java.net.DatagramSocket&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/MulticastSocket.html"&gt;&lt;code&gt;java.net.MulticastSocket&lt;/code&gt;&lt;/a&gt; были полностью заменены на более простые, современные и легкоадаптируемые к виртуальным нитям, которые планируется ввести в язык в рамках &lt;a href="https://openjdk.java.net/projects/loom/"&gt;проекта Loom&lt;/a&gt;. Ранее в Java 13 &lt;a href="https://openjdk.java.net/jeps/353"&gt;были переписаны&lt;/a&gt; &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/Socket.html"&gt;&lt;code&gt;java.net.Socket&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/ServerSocket.html"&gt;&lt;code&gt;java.net.ServerSocket&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/383"&gt;Foreign-Memory Access API (Second Incubator) (JEP 383)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API для доступа вне кучи Java, которое &lt;a href="https://openjdk.java.net/jeps/370"&gt;появилось&lt;/a&gt; в Java 14 в статусе модуля-&lt;a href="https://openjdk.java.net/jeps/11"&gt;инкубатора&lt;/a&gt;, остаётся в этом статусе.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/385"&gt;Deprecate RMI Activation for Removal (JEP 385)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Устаревшая и малоиспользуемая часть RMI, которая называется RMI Activation, стала deprecated for removal.&lt;/p&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/339"&gt;Edwards-Curve Digital Signature Algorithm (EdDSA) (JEP 339)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Современный алгоритм с открытым ключом для создания цифровой подписи EdDSA реализован в Java.&lt;/p&gt;
&lt;p class="pt-3"&gt;Java 15, как и 12, 13, 14, является STS-релизом, и у неё выйдет только два обновления.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Исследуем sealed классы в Java 15</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/trying_sealed_classes_in_java_15.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/trying_sealed_classes_in_java_15.html</id>
    <updated>2020-06-06T17:00:00Z</updated>
    <published>2020-06-06T17:00:00Z</published>
    <content type="html">&lt;p&gt;Продолжаем исследовать новые возможности, которые появляются в Java. В прошлые разы мы подробно рассматривали &lt;a href="trying_new_instanceof_in_java_14.html"&gt;улучшенный оператор &lt;code&gt;instanceof&lt;/code&gt;&lt;/a&gt; и &lt;a href="trying_records_in_java14.html"&gt;записи&lt;/a&gt;, а сегодня объектом исследования будут &lt;code&gt;sealed&lt;/code&gt; классы, которые запланированы к выходу в &lt;a href="https://openjdk.java.net/projects/jdk/15/"&gt;пятнадцатой версии&lt;/a&gt; Java.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Идея введения в язык &amp;laquo;запечатанных&amp;raquo; типов впервые была подробно описана в феврале 2019 года в документе &lt;a href="http://cr.openjdk.java.net/~briangoetz/amber/datum.html"&gt;"Data Classes and Sealed Types for Java"&lt;/a&gt;, и в июле того же года получила свой &lt;a href="https://openjdk.java.net/jeps/360"&gt;JEP 360&lt;/a&gt;, который был любезно &lt;a href="https://habr.com/ru/company/jugru/blog/498494/"&gt;переведён на Хабре&lt;/a&gt; Олегом Чирухиным. Стоит отметить, что версия JEP'а, которую перевёл Олег, немного устарела и отличается от актуальной. В частности, в новой версии &lt;code&gt;sealed&lt;/code&gt; типы больше не типы, а классы и интерфейсы. Связано это переименование с тем, что термин &amp;laquo;тип&amp;raquo; слишком перегружен и может означать не только классы и интерфейсы, но и их производные вроде массивов (&lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;String[]&lt;/code&gt;) и параметризацией дженериков (&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;). Подробнее про это переименование можно прочитать &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2020-May/002175.html"&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Впрочем, довольно лирики, и давайте перейдём непосредственно к нашим &lt;code&gt;sealed&lt;/code&gt; классам. Программистам, знакомым со Scala и Kotlin, такой вид классов должен быть знаком. В Java он означает в точности то же самое, что и там: модификатор &lt;code&gt;sealed&lt;/code&gt; ограничивает круг классов, которые могут наследоваться от данного класса. А вот в C# &lt;code&gt;sealed&lt;/code&gt; означает &lt;a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/sealed"&gt;совсем другое&lt;/a&gt;. Так что если вы пришли из C#, то будьте осторожнее: аналог ключевого слова &lt;code&gt;sealed&lt;/code&gt; в Java &amp;ndash; это &lt;code&gt;final&lt;/code&gt;, а не &lt;code&gt;sealed&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Давайте же наконец играться с &lt;code&gt;sealed&lt;/code&gt; классами. Но для начала проверим нашу версию Java:&lt;/p&gt;
&lt;pre&gt;&amp;gt; java --version
openjdk 15-ea 2020-09-15
OpenJDK Runtime Environment (build 15-ea+26-1287)
OpenJDK 64-Bit Server VM (build 15-ea+26-1287, mixed mode, sharing)&lt;/pre&gt;
&lt;p&gt;Как видите, я запустил &lt;a href="http://jdk.java.net/15/"&gt;раннюю сборку&lt;/a&gt; JDK 15. В ней &lt;code&gt;sealed&lt;/code&gt; классы уже присутствуют.&lt;/p&gt;
&lt;p&gt;Напишем и запустим какой-нибудь простой код:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Shape rectangle = &lt;span style="color: blue"&gt;new&lt;/span&gt; Rectangle(1, 2);
        Shape circle = &lt;span style="color: blue"&gt;new&lt;/span&gt; Circle(3);
        System.out.println(rectangle);
        System.out.println(circle);
    }
}

&lt;span style="color: blue"&gt;sealed abstract class&lt;/span&gt; Shape {
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Rectangle &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; width, height;

    Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.width = width;
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.height = height;
    }
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Circle &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; radius;

    Circle(&lt;span style="color: blue"&gt;int&lt;/span&gt; radius) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.radius = radius;
    }
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
&lt;span style="color: grey"&gt;Note: Main.java uses preview language features.
Note: Recompile with -Xlint:preview for details.&lt;/span&gt;
Rectangle@11e21d0e
Circle@1dd02175&lt;/pre&gt;
&lt;p&gt;В коде выше особо ничего интересного, но заметьте, что мне пришлось сделать классы &lt;code&gt;Rectangle&lt;/code&gt; и &lt;code&gt;Shape&lt;/code&gt; &lt;code&gt;final&lt;/code&gt;, иначе бы код не скомпилировался:&lt;/p&gt;
&lt;pre&gt;&amp;hellip;

&lt;span style="color: blue"&gt;class&lt;/span&gt; Rectangle &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape {
    &amp;hellip;
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Circle &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape {
    &amp;hellip;
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
&lt;span style="color: red"&gt;Main.java:13: error: sealed, non-sealed or final modifiers expected
class Rectangle extends Shape {
^
Main.java:22: error: sealed, non-sealed or final modifiers expected
class Circle extends Shape {
^&lt;/span&gt;
&amp;hellip;&lt;/pre&gt;
&lt;p&gt;Таким образом, подклассы &lt;code&gt;sealed&lt;/code&gt; классов могут быть либо &lt;code&gt;sealed&lt;/code&gt;, либо &lt;code&gt;non-sealed&lt;/code&gt;, либо &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Кстати, у нас же есть записи. Может, перепишем код, используя их, чтобы стало короче?&lt;/p&gt;
&lt;pre&gt;&amp;hellip;

&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Shape {
}

&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}

&lt;span style="color: blue"&gt;record&lt;/span&gt; Circle(&lt;span style="color: blue"&gt;int&lt;/span&gt; radius) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
Rectangle[width=1, height=2]
Circle[radius=3]&lt;/pre&gt;
&lt;p&gt;Так гораздо лучше. Но пришлось сделать &lt;code&gt;Shape&lt;/code&gt; интерфейсом, потому что записи не могут наследоваться от классов.&lt;/p&gt;
&lt;p&gt;Однако мы так и не проверили, что модификатор &lt;code&gt;sealed&lt;/code&gt; действительно работает. Давайте перенесём один из классов в другой файл:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Main.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Shape rectangle = &lt;span style="color: blue"&gt;new&lt;/span&gt; Rectangle(1, 2);
        Shape circle = &lt;span style="color: blue"&gt;new&lt;/span&gt; Circle(3);
        System.out.println(rectangle);
        System.out.println(circle);
    }
}

&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Shape {
}

&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Circle.java&lt;/span&gt;
&lt;span style="color: blue"&gt;record&lt;/span&gt; Circle(&lt;span style="color: blue"&gt;int&lt;/span&gt; radius) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 15 Main.java Circle.java
&lt;span style="color: red"&gt;Circle.java:1: error: class is not allowed to extend sealed class: Shape
record Circle(int radius) implements Shape {
^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Чего и следовало ожидать: компилятор разрешает наследоваться от &lt;code&gt;sealed&lt;/code&gt; интерфейса только тем классам, которые находятся в том же файле. Но что если мне нужно, чтобы мои классы были в разных файлах? Например, я хочу сделать все классы публичными, а значит они должны находиться в отдельных файлах, но при этом я не хочу терять преимущества &lt;code&gt;sealed&lt;/code&gt;. На помощь приходит ключевое слово &lt;code&gt;permits&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Shape.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; Rectangle, Circle {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Rectangle.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Circle.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public record&lt;/span&gt; Circle(&lt;span style="color: blue"&gt;int&lt;/span&gt; radius) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;p&gt;Теперь всё успешно компилируется. С помощью &lt;code&gt;permits&lt;/code&gt; мы указали явно все классы, которые будут наследоваться от &lt;code&gt;Shape&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Давайте попробуем сделать что-нибудь нелегальное. Например, укажем в &lt;code&gt;permits&lt;/code&gt; класс, но &amp;laquo;забудем&amp;raquo; его отнаследовать:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Shape.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; Rectangle {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Rectangle.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 15 Shape.java Rectangle.java
&lt;span style="color: red"&gt;Shape.java:1: error: invalid permits clause
public sealed interface Shape permits Rectangle {
                                      ^
  (subclass Rectangle must extend sealed class)&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Это явно ошибочная ситуация, и компилятор надёжно её перехватывает, сообщая нам об ошибке.&lt;/p&gt;
&lt;p&gt;А если попробовать вписать в &lt;code&gt;permits&lt;/code&gt; класс, который не является прямым наследником?&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Shape.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; RectangleShape, Rectangle {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// RectangleShape.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; RectangleShape &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; Rectangle {
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Rectangle.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; RectangleShape {
}&lt;/pre&gt;
&lt;p&gt;Заметьте, что в данной иерархии &lt;code&gt;Rectangle&lt;/code&gt; наследуется от &lt;code&gt;RectangleShape&lt;/code&gt;, а &lt;code&gt;RectangleShape&lt;/code&gt; &amp;ndash; от &lt;code&gt;Shape&lt;/code&gt;. Но при этом в &lt;code&gt;Shape permits&lt;/code&gt; указан &lt;code&gt;Rectangle&lt;/code&gt;. Попробуем скомпилировать это:&lt;/p&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 15 Shape.java RectangleShape.java Rectangle.java
&lt;span style="color: red"&gt;Shape.java:1: error: invalid permits clause
public sealed interface Shape permits RectangleShape, Rectangle {
                                                      ^
  (subclass Rectangle must extend sealed class)&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Получили в общем-то ту же самую ошибку, что и выше: если указываешь в &lt;code&gt;permits&lt;/code&gt; класс, то это класс должен быть отнаследован напрямую.&lt;/p&gt;
&lt;p&gt;Интересно, что будет, если указать в &lt;code&gt;permits&lt;/code&gt; какой-нибудь совершенно левый класс?&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; &lt;b&gt;Integer&lt;/b&gt;, Rectangle, Circle {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 15 Shape.java Rectangle.java Circle.java
&lt;span style="color: red"&gt;Shape.java:1: error: class is not allowed to extend sealed class: Shape
public sealed interface Shape permits Integer, Rectangle, Circle {
                                      ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Здесь мы тоже совершенно ожидаемо получили ошибку: Java разрешает указывать в &lt;code&gt;permits&lt;/code&gt; только классы из того же модуля. Класс &lt;code&gt;java.lang.Integer&lt;/code&gt; находится в модуле &lt;code&gt;java.base&lt;/code&gt;, поэтому код не компилируется.&lt;/p&gt;
&lt;p&gt;Что если сделать &lt;code&gt;sealed&lt;/code&gt; без единого наследника?&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Shape.java&lt;/span&gt;
&lt;span style="color: blue"&gt;public sealed interface&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; javac --enable-preview --release 15 Shape.java
&lt;span style="color: red"&gt;Shape.java:1: error: sealed class must have subclasses
public sealed interface Shape {
              ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;И здесь компилятор надёжен. Если класс &lt;code&gt;sealed&lt;/code&gt;, то он должен иметь хотя бы один подкласс, иначе какой тогда смысл в &lt;code&gt;sealed&lt;/code&gt;? (Хотя это могло бы быть полезным для возможности объявления &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-October/001719.html"&gt;утилитных интерфейсов&lt;/a&gt;, но тут скорее нужно позволить объявлять &lt;code&gt;final&lt;/code&gt; интерфейсы, нежели &lt;code&gt;sealed&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Было бы ещё интересно проверить вот что. Java на этапе компиляции умеет делать проверки совместимости типов. Если она сможет доказать, что два типа не могут быть приведены друг к другу, то будет ошибка компиляции. Например:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Rectangle rect = &lt;span style="color: blue"&gt;new&lt;/span&gt; Rectangle();
        System.out.println(rect &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Runnable);
    }
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Rectangle {
}&lt;/pre&gt;
&lt;p&gt;Такой код ожидаемо не скомпилируется, ведь совершенно точно известно, что никакой объект &lt;code&gt;Rectangle&lt;/code&gt; не может быть &lt;code&gt;Runnable&lt;/code&gt;, потому что &lt;code&gt;Rectangle&lt;/code&gt; объявлен как &lt;code&gt;final&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&amp;gt; java Main.java
&lt;span style="color: red"&gt;Main.java:4: error: incompatible types: Rectangle cannot be converted to Runnable
        System.out.println(rect instanceof Runnable);
                           ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;А теперь вопрос: будет ли ошибка компиляции, если усложнить наш пример, введя промежуточный &lt;code&gt;sealed&lt;/code&gt; класс? Давайте проверим:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Shape rect = &lt;span style="color: blue"&gt;new&lt;/span&gt; Rectangle();
        System.out.println(rect &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Runnable);
    }
}

&lt;span style="color: blue"&gt;sealed class&lt;/span&gt; Shape &lt;span style="color: blue"&gt;permits&lt;/span&gt; Rectangle {
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Rectangle &lt;span style="color: blue"&gt;extends&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;p&gt;В данном примере объект &lt;code&gt;rect&lt;/code&gt; тоже абсолютно точно не может быть &lt;code&gt;Runnable&lt;/code&gt;, потому что иерархия &lt;code&gt;Shape&lt;/code&gt; закрытая, и ни &lt;code&gt;Shape&lt;/code&gt;, ни &lt;code&gt;Rectangle&lt;/code&gt; не реализуют &lt;code&gt;Runnable&lt;/code&gt;. Хватит ли компилятору ума, чтобы обнаружить ошибку?&lt;/p&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
false&lt;/pre&gt;
&lt;p&gt;К сожалению, не хватило. Вообще это довольно странно, потому что это было бы совершенно логичным поведением компилятора. Я решил задать про это вопрос в рассылке OpenJDK, и &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-observers/2020-June/002344.html"&gt;мне ответили&lt;/a&gt;, что решили эту возможность пока не реализовывать и отложить её до следующего релиза. Ну что ж, тогда будем ждать.&lt;/p&gt;
&lt;p&gt;Что мы ещё не попробовали? Что насчёт анонимных классов? Могут ли они наследоваться от sealed классов?&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Shape shape = &lt;span style="color: blue"&gt;new&lt;/span&gt; Shape() {};
    }
}

&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Shape {
}

&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
&lt;span style="color: red"&gt;Main.java:3: error: local classes must not extend sealed classes
        Shape shape = new Shape() {};
                                  ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Ага, значит наследоваться не могут не только анонимные, но и вообще любые локальные классы. Ну и, конечно же, логично было бы запретить лямбды:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Main {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) {
        Shape shape = () -&gt; {};
    }
}

&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Shape {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; f();
}

&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(&lt;span style="color: blue"&gt;int&lt;/span&gt; width, &lt;span style="color: blue"&gt;int&lt;/span&gt; height) &lt;span style="color: blue"&gt;implements&lt;/span&gt; Shape {
    &lt;span style="color: blue"&gt;public void&lt;/span&gt; f() {
    }
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
&lt;span style="color: red"&gt;Main.java:3: error: incompatible types: Shape is not a functional interface
        Shape shape = () -&gt; {};
                      ^&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Интересное сообщение об ошибке. То есть sealed интерфейс не может быть функциональным интерфейсом. И если просто попытаться использовать аннотацию &lt;code&gt;@FunctionalInterface&lt;/code&gt;, то будет ошибка:&lt;/p&gt;
&lt;pre&gt;&amp;hellip;

@FunctionalInterface
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Shape {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; f();
}&lt;/pre&gt;
&lt;pre&gt;&amp;gt; java --enable-preview --source 15 Main.java
&lt;span style="color: red"&gt;Main.java:6: error: Unexpected @FunctionalInterface annotation
@FunctionalInterface
^
  Shape is not a functional interface&lt;/span&gt;&lt;/pre&gt;
&lt;h4&gt;Заключение&lt;/h4&gt;
&lt;p&gt;Далеко не всегда иерархии классов должны быть открыты для расширения неограниченным кругом лиц. Часто встречается необходимость смоделировать такую иерархию, которая будет открыта для использования, но закрыта для расширения. &amp;laquo;Запечатанные&amp;raquo; классы и интерфейсы в Java 15, наконец, сделают такое возможным. Особенно хорошо &lt;code&gt;sealed&lt;/code&gt; классы будут взаимодействовать с записями, позволив легко моделировать алгебраические типы данных.&lt;/p&gt;
&lt;p&gt;Но ещё более эффектной эта возможность будет, когда реализуют полноценный &lt;a href="https://openjdk.java.net/jeps/8213076"&gt;паттерн-матчинг для оператора &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;, и компилятор, работая с &lt;code&gt;sealed&lt;/code&gt; иерархией, сможет делать проверки исчерпываемости (exhaustiveness). Это поможет разработчику сделать код ещё более безопасным.&lt;/p&gt;
&lt;p&gt;Сейчас &lt;code&gt;sealed&lt;/code&gt; классы некоторое время будут находиться в режиме preview, но к следующему LTS релизу Java 17 они, скорее всего, станут стабильными. Это даст неплохую мотивацию перейти на последнюю версию Java.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Java исполняется 25 лет</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_celebrates_25_years.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_celebrates_25_years.html</id>
    <updated>2020-05-22T17:00:00Z</updated>
    <published>2020-05-22T17:00:00Z</published>
    <content type="html">&lt;p&gt;Друзья, сегодня у нас знаменательная дата. 23 мая 1995 года, ровно 25 лет назад, вышла первая публичная версия языка программирования Java. Новый язык мгновенно завоевал огромную популярность: благодаря простоте, кроссплатформенности, отсутствию необходимости вручную освобождать память и при этом довольно неплохой производительности разработчики получили огромный прирост в скорости написания программ. Java быстро стала стандартом де-факто для написания корпоративных веб-приложений. Сегодня по самым скромным оценкам порядка 15% всего Интернета работает на JVM.&lt;/p&gt;
&lt;p&gt;С момента выхода первой версии язык и платформа кардинально эволюционировали. JDK стала полностью открытым и свободным ПО. JIT-компилятор был усовершенствован настолько, что программы на Java по скорости хорошо приблизились к C++. Появилось несметное количество инструментов и библиотек, решающих самый большой спектр задач. С возможностями IntelliJ IDEA не может соревноваться ни одна другая среда разработки. Новые сборщики мусора Shenandoah и ZGC сделали возможным писать приложения, чувствительные к миллисекундным временам отклика. Сам язык значительно изменился: появились дженерики, аннотации, лямбда-выражения, модули. Были созданы другие популярные языки на основе JVM, такие как Scala, Kotlin, Groovy.&lt;/p&gt;
&lt;p&gt;Сегодня Java продолжает развиваться огромными темпами. Версии Java стали выходить раз в полгода, что теперь позволяет разработчикам начать пользоваться нововведениями намного раньше. В рамках проекта Amber в языке появляются всё новые и новые синтаксические изменения, которые позволят сделать код ещё выразительнее и безопаснее. Проекты Valhalla и Graal позволят ещё сильнее увеличить производительность Java-программ, сократив разницу с нативными языками до минимума. Проект Panama ликвидирует брешь в возможностях взаимодействия JVM с нативным кодом. Проект Loom позволит писать многопоточные конкурентные приложения так же просто, как в Erlang и Go. Проект Leyden поможет в решении проблемы медленного старта Java-приложений.&lt;/p&gt;
&lt;p&gt;25 лет – это немалый возраст для языка, но Java ни в коем случае не устарела. Наоборот, сегодня она находится на самом пике своего цветения и продолжает уверенно укреплять свои позиции на рынке. Эти 25 лет были прекрасным временем, но будущее будет ещё более светлым и захватывающим.&lt;/p&gt;
&lt;p&gt;Всех с праздником!&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>В Java можно будет объявлять локальные интерфейсы и перечисления</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/local_interfaces_and_enums.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/local_interfaces_and_enums.html</id>
    <updated>2020-04-30T17:00:00Z</updated>
    <published>2020-04-30T17:00:00Z</published>
    <content type="html">&lt;p&gt;На сайте OpenJDK вышел &lt;a href="http://openjdk.java.net/jeps/8242303"&gt;новый черновик&lt;/a&gt; JEP с заголовком "Records (Second Preview)". В нём специфицируются некоторые изменения в записях по сравнению с &lt;a href="http://openjdk.java.net/jeps/359"&gt;первым preview&lt;/a&gt;, а также возможность объявлять в методах интерфейсы и перечисления.&lt;/p&gt;
&lt;p&gt;Напомним, что в Java есть возможность объявлять классы прямо внутри методов и блоков. Такие классы называются &lt;i&gt;локальными&lt;/i&gt;, и они могут захватывать effectively final переменные, объявленные выше в этом же методе или блоке. Пример объявления локального класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; m() {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Foo {
        …
    }
}&lt;/pre&gt;
&lt;p&gt;С &lt;a href="java_14_is_out.html"&gt;Java 14&lt;/a&gt; появилась возможность также объявлять локальные записи. Особенность локальных записей заключается в том, что они неявно являются &lt;i&gt;статическими&lt;/i&gt; в отличие от локальных классов, которые могут быть только &lt;i&gt;нестатическими&lt;/i&gt;. Таким образом, локальные записи стали первым историческим примером статических деклараций внутри метода, которые до этого в Java были запрещены (локальные классы и переменные не могут быть статическими). Пример стал успешным: локальные записи ничему не противоречат и не нарушают никакую семантику. Такой успешный пример навёл на мысль о том, что нужно расширить поле возможных локальных статических деклараций на интерфейсы и перечисления:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; m() {
    &lt;span style="color: blue"&gt;enum&lt;/span&gt; Foo {
        A, B
    }

    &lt;span style="color: blue"&gt;interface&lt;/span&gt; Bar {
         Foo getFoo();
    }
}&lt;/pre&gt;
&lt;p&gt;По аналогии с локальными записями локальные интерфейсы и перечисления могут ссылаться только на объявленные выше локальные записи, интерфейсы и перечисления, но не на те, которые объявлены ниже. Также они могут ссылаться на самих себя.&lt;/p&gt;
&lt;p&gt;Про возможность объявлять локальные статические классы пока ничего не сказано, однако в январе Brian Goetz &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2020-January/001904.html"&gt;написал письмо&lt;/a&gt; в рассылку, в котором он сказал, что конечной целью должна быть возможность вкладывать всё что угодно во всё что угодно. Это значит, что локальные статические классы могут появиться позже.&lt;/p&gt;
&lt;p&gt;Остальные изменения в JEP'е относятся к самим записям. Их мало, и они незначительны. Например, в новой версии убрано ограничение, что канонический конструктор записи обязательно должен быть публичным.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>В Java появятся паттерны деконструкции</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/deconstruction_patterns.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/deconstruction_patterns.html</id>
    <updated>2020-03-29T17:00:00Z</updated>
    <published>2020-03-29T17:00:00Z</published>
    <content type="html">&lt;p&gt;В недавно вышедшем &lt;a href="https://openjdk.java.net/jeps/375"&gt;JEP 375&lt;/a&gt; появилась информация о введении в язык так называемых &lt;i&gt;паттернов деконструкции&lt;/i&gt;. Такие паттерны позволят применять оператор &lt;code&gt;instanceof&lt;/code&gt; не просто для теста по типу, но и для извлечения компонентов этого типа. В первой реализации можно будет извлекать только компоненты &lt;a href="trying_records_in_java14.html"&gt;записей&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point (&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b)) {
    System.out.println(a + b);
}&lt;/pre&gt;
&lt;p&gt;В примере выше сначала проверяется, является ли &lt;code&gt;obj&lt;/code&gt; объектом типа &lt;code&gt;Point&lt;/code&gt;, а затем происходит "привязка" новых переменных &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; типа &lt;code&gt;int&lt;/code&gt; к полям &lt;code&gt;Point.x&lt;/code&gt; и &lt;code&gt;Point.y&lt;/code&gt; соответственно. Использование ключевого слово &lt;code&gt;var&lt;/code&gt; в паттерне является обязательным: чтобы нельзя было &lt;a href="https://mail.openjdk.java.net/pipermail/amber-dev/2020-March/005645.html"&gt;перепутать&lt;/a&gt; привязки переменных с константами с тем же именем, которые случайно могут оказаться в той же области видимости (хотя константы пока что не могут использоваться в паттернах, однако в будущем это может измениться).&lt;/p&gt;
&lt;p&gt;Код выше семантически эквивалентен следующему более громоздкому коду:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; a = ((Point) obj).x;
    &lt;span style="color: blue"&gt;var&lt;/span&gt; b = ((Point) obj).y;
    System.out.println(a + b);
}&lt;/pre&gt;
&lt;p&gt;Как видно, новый подход является более компактным, декларативным и более типобезопасным.&lt;/p&gt;
&lt;p&gt;Новый паттерн-матчинг также будет поддерживать вложенные паттерны:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Circle(Point origin, &lt;span style="color: blue"&gt;int&lt;/span&gt; radius) {}

&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Circle(Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b), &lt;span style="color: blue"&gt;var&lt;/span&gt; r)) {
    System.out.println(&lt;span style="color: darkred"&gt;"Circle centered at ("&lt;/span&gt; + a + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + b + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;);
    System.out.println(&lt;span style="color: darkred"&gt;"Area is: "&lt;/span&gt; + Math.PI*r*r);
}&lt;/pre&gt;
&lt;p&gt;Во вложенных паттернах весь матчинг будет являться успешным только в том случае, если все его компоненты прошли соответственные тесты типа.&lt;/p&gt;
&lt;p&gt;На текущий момент неизвестно, успеют ли деконструкционные паттерны попасть в Java 15 (но с большой вероятностью это будет так).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 14</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_14_is_out.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_14_is_out.html</id>
    <updated>2020-03-17T17:00:00Z</updated>
    <published>2020-03-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная &lt;a href="https://openjdk.java.net/projects/jdk/14/"&gt;версия Java 14&lt;/a&gt;. Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase-jdk14-downloads.html"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://jdk.java.net/14/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В этот релиз попало 16 JEP'ов, а также &lt;a href="https://jdk.java.net/14/release-notes"&gt;сотни более мелких улучшений&lt;/a&gt; и &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-14.txt"&gt;тысячи исправлений багов&lt;/a&gt;. Список JEP'ов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/305"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (JEP 305)&lt;/a&gt; &amp;ndash; улучшение оператора &lt;code&gt;instanceof&lt;/code&gt; для поддержки паттерн-матчинга по типу. Его мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/359"&gt;Записи (Preview) (JEP 359)&lt;/a&gt; &amp;ndash; новая синтаксическая конструкция в языке, которая позволяет объвлять классы-носители данных намного более компактно посредством нового ключевого слова &lt;code&gt;record&lt;/code&gt;. Записи мы также рассматривали в &lt;a href="trying_records_in_java14.html"&gt;отдельной статье&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/361"&gt;Выражения &lt;code&gt;switch&lt;/code&gt; (JEP 361)&lt;/a&gt; &amp;ndash; улучшенный оператор &lt;code&gt;switch&lt;/code&gt;, который &lt;a href="switch_expressions.html"&gt;появился&lt;/a&gt; в Java 12 и был &lt;a href="yield_in_switch.html"&gt;немного изменён&lt;/a&gt; в Java 13, теперь стал стабильной конструкцией и больше не требует preview-режима.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/368"&gt;Блоки текста (второе Preview) (JEP 368)&lt;/a&gt; &amp;ndash; новый вид строковых литералов, который &lt;a href="text_blocks.html"&gt;появился&lt;/a&gt; в Java 13, теперь &lt;a href="escape_sequences_for_line_continuation_and_whitespace.html"&gt;дополнен&lt;/a&gt; двумя новыми экранирующими последовательностями для продолжения строки и пробела. Конструкция пока ещё остаётся в preview-режиме.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/358"&gt;Полезные &lt;code&gt;NullPointerException&lt;/code&gt;'ы (JEP 358)&lt;/a&gt; &amp;ndash; улучшение &lt;code&gt;NullPointerException&lt;/code&gt;, которое детально сообщает, что именно было &lt;code&gt;null&lt;/code&gt;. Включается с помощью ключа &lt;code&gt;-XX:+ShowCodeDetailsInExceptionMessages&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/343"&gt;Инструмент упаковки (JEP 343)&lt;/a&gt; &amp;ndash; новый инструмент &lt;code&gt;jpackage&lt;/code&gt; для создания самодостаточных Java-приложений, который поддерживает нативные форматы упаковки. Пока предоставляется как инкубационный модуль.&lt;/li&gt;
  &lt;li&gt;ZGC на &lt;a href="https://openjdk.java.net/jeps/364"&gt;macos&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/365"&gt;Windows&lt;/a&gt; (JEP 364 и 365) &amp;ndash; порт сборщика мусора ZGC, который был доступен &lt;a href="https://openjdk.java.net/jeps/333"&gt;только на Linux&lt;/a&gt;, на другие операционные системы. Сборщик мусора всё ещё находится в экспериментальном статусе.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/363"&gt;Удаление сборщика мусора CMS (JEP 363)&lt;/a&gt; &amp;ndash; сборщик мусора Concurrent Mark Sweep, который &lt;a href="https://openjdk.java.net/jeps/291"&gt;стал deprecated&lt;/a&gt; в Java 9, теперь окончательно удалён.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/366"&gt;Deprecate the ParallelScavenge + SerialOld GC Combination (JEP 366)&lt;/a&gt; &amp;ndash; комбинация флагов &lt;code&gt;-XX:+UseParallelGC -XX:-UseParallelOldGC&lt;/code&gt; теперь стала deprecated.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/345"&gt;NUMA-Aware Memory Allocation for G1 (JEP 345)&lt;/a&gt; &amp;ndash; неравномерный доступ к памяти теперь поддерживается не только в ParallelGC, но и в G1.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/349"&gt;JFR Event Streaming (JEP 349)&lt;/a&gt; &amp;ndash; предоставление возможности поглощения данных JDK Flight Recorder в непрерывном режиме. Это может быть полезно, например, в целях непрерывного мониторинга Java-процесса. Раньше данные можно было считывать только путём остановки записи, сохранения файла на диск и его последующего чтения.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/352"&gt;Non-Volatile Mapped Byte Buffers (JEP 352)&lt;/a&gt; &amp;ndash; поддержка неволатильной памяти в &lt;code&gt;MappedByteBuffer&lt;/code&gt;. Ранее в Java это было возможно лишь посредством внешних вызовов к системной библиотеке, написанной на C (например, &lt;a href="https://pmem.io/pmdk/libpmem/"&gt;libpmem&lt;/a&gt;). Однако такие вызовы стоят очень дорого, что делает Java плохо пригодной для написания транзакционных программ с персистестным состоянием. Новый же режим отображения в &lt;code&gt;MappedByteBuffer&lt;/code&gt; решает эту проблему.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/362"&gt;Deprecate the Solaris and SPARC Ports (JEP 362)&lt;/a&gt; &amp;ndash; порты JDK на Solaris/SPARC, Solaris/x64 и Linux/SPARC стали deprected for removal. Когда порты исчезнут окончательно, это упростит и ускорит разработку JDK.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/367"&gt;Remove the Pack200 Tools and API (JEP 367)&lt;/a&gt; &amp;ndash; инструменты &lt;code&gt;pack200&lt;/code&gt; и &lt;code&gt;unpack200&lt;/code&gt;, которые &lt;a href="https://openjdk.java.net/jeps/336"&gt;стали deprecated&lt;/a&gt; в Java 11, теперь удалены окончательно.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://openjdk.java.net/jeps/370"&gt;Foreign-Memory Access API (Incubator) (JEP 370)&lt;/a&gt; &amp;ndash; долгожданное стандартное API для доступа к памяти вне кучи Java, которое разрабатывается в рамках проекта &lt;a href="https://openjdk.java.net/projects/panama/"&gt;Panama&lt;/a&gt;. Это новое API не имеет ограничений, которые есть у direct &lt;code&gt;ByteBuffer&lt;/code&gt;, более безопасно, чем нестандартный &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; и более эффективно, чем JNI (и без возни с кодом на C). Однако новое API ещё имеет экспериментальном статус, и поэтому находится в инкубационном модуле.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java 14 не является LTS-релизом.&lt;/p&gt;</content>
  </entry>
</feed>
