<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2022-09-25T18:00:00Z</updated>
  <entry>
    <title>Новости Java #45</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_45.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_45.html</id>
    <updated>2022-09-25T18:00:00Z</updated>
    <published>2022-09-25T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt;. Про шаблонные строки мы писали в &lt;a href="java_news_28.html"&gt;выпуске #28&lt;/a&gt;, когда они были предложены в рассылке проекта Amber. С тех пор концепция шаблонных строк дозрела до JEP-кандидата, и возможно, они попадут в следующий релиз &lt;a href="https://jdk.java.net/20/"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://jakarta.ee/release/10/"&gt;Jakarta EE 10&lt;/a&gt;. В этом релизе теперь требуется Java 11 в качестве минимальной версии, а также есть поддержка Java 17. В Jakarta EE 10 более 20 спецификаций получили обновления, а также появилась новая спецификация CDI Lite 4.0. Из принципиальных нововведений также стало появление &lt;a href="https://jakarta.ee/specifications/coreprofile/10/"&gt;Core Profile&lt;/a&gt;, минимального набора спецификаций, созданного специально для микросервисов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Lightbend &lt;a href="https://www.lightbend.com/blog/why-we-are-changing-the-license-for-akka"&gt;объявила&lt;/a&gt; об изменении лицензии у Akka, инструментария, реализующего программную модель на основе акторов.&lt;/p&gt;
&lt;p&gt;Начиная с версии 2.7, которая выйдет в октябре, Akka будет иметь коммерческую лицензию BSL 1.1. Это значит, что Akka будет иметь не open-source, а так называемую source-available модель, при которой исходные коды будут всё ещё доступны, но Akka можно будет использовать бесплатно только для разработки и других непроизводственных целей. Для производственных целей придётся приобретать коммерческую лицензию, которая, однако, будет бесплатной для компаний с годовым оборотом меньше 25 миллионов долларов. Кроме того, через 3 года после выхода код Akka становится полностью свободным под лицензией Apache 2.0. Также исключением является Play Framework, который внутри себя использует Akka: его также можно использовать бесплатно. Akka 2.6 &lt;a href="https://www.lightbend.com/akka/license-faq"&gt;будет оставаться&lt;/a&gt; под лицензией Apache 2.0 и будет получать критические обновления до сентября 2023 года.&lt;/p&gt;
&lt;p&gt;Йонас Бонер, создатель Akka, объяснил такое решение тем, что большое количество крупных компаний, таких как Apple, Disney и GM, используют Akka совершенно бесплатно, но все усилия и затраты несёт на себе небольшая компания Lightbend. Новая лицензия позволит сдвинуть баланс в сторону других участников, которые будут обязаны платить и тем самым вносить вклад в будущее Akka.&lt;/p&gt;
&lt;p&gt;Цены на Akka уже &lt;a href="https://www.lightbend.com/akka#pricing"&gt;опубликованы&lt;/a&gt; и составляют от 1995 до 2995 долларов в год за одно ядро в зависимости от лицензии.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=eEXvOjtauxI"&gt;Eclipse 2022-09&lt;/a&gt;. Вот некоторые улучшения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Более быстрый поиск по подстроке в workspace.&lt;/li&gt;
  &lt;li&gt;Поддержка цветного вывода в консоли.&lt;/li&gt;
  &lt;li&gt;Новая галочка "Enable word wrap when opening an editor".&lt;/li&gt;
  &lt;li&gt;Улучшения в Clean Up Actions "Convert to switch expression" и "Convert to enhanced 'for' loops".&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 19</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_19.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_19.html</id>
    <updated>2022-09-19T18:00:00Z</updated>
    <published>2022-09-19T18:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;Java 19&lt;/a&gt;. В этот релиз попало более &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-19.html"&gt;двух тысяч закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/19/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/19/apidiff/18/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/19/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вот список JEP'ов, которые попали в Java 19.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/427"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Third Preview) (JEP 427)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt;, который &lt;a href="https://openjdk.org/jeps/406"&gt;появился в Java 17&lt;/a&gt; в режиме preview и остался на &lt;a href="https://openjdk.org/jeps/420"&gt;второе preview в Java 18&lt;/a&gt;, всё ещё остаётся в этом статусе. Это первый случай в Java, когда языковой конструкции не хватило двух релизов, чтобы стать стабильной: ранее все конструкции укладывались в два preview.&lt;/p&gt;
&lt;p&gt;В этом релизе в паттерн-матчинг было внесено два главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, охранные паттерны &lt;code&gt;&amp;&amp;&lt;/code&gt; были заменены на условия &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &amp;&amp; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;

&lt;p&gt;О мотивации такого изменения можно прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003195.html"&gt;в рассылке проекта Amber&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Во-вторых, было изменено поведение матчинга &lt;code&gt;null&lt;/code&gt;. Теперь &lt;code&gt;null&lt;/code&gt; матчится только в ветке &lt;code&gt;case null&lt;/code&gt; и большие ни в каких других, включая тотальных:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 18:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: green"&gt;// matches because total pattern&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;// NPE&lt;/span&gt;
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; ...; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Про причины такого изменения можно также прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003194.html"&gt;в рассылке&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/405"&gt;Паттерны записей (Preview) (JEP 405)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг дополнился новым видом паттерна: паттерн записей.&lt;/p&gt;
&lt;p&gt;Раньше для паттерн-матчинга записей был доступен только паттерн по типу с дальнейшим ручным извлечением компонентов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point p) {
        &lt;span style="color: blue"&gt;int&lt;/span&gt; x = p.x();
        &lt;span style="color: blue"&gt;int&lt;/span&gt; y = p.y();
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;С паттернами записей код становится существенно компактнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object o) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printCoordinatesAndColor(ColoredPoint cp) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (cp &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y), &lt;span style="color: blue"&gt;var&lt;/span&gt; c)) {
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
        System.out.println(&lt;span style="color: darkred"&gt;"color = "&lt;/span&gt; + c);
    }
}&lt;/pre&gt;

&lt;p&gt;Также паттерны записей могут быть именованными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) {
        System.out.println(&lt;span style="color: darkred"&gt;"point = "&lt;/span&gt; + p);
        System.out.println(&lt;span style="color: darkred"&gt;"x = "&lt;/span&gt; + x);
        System.out.println(&lt;span style="color: darkred"&gt;"y = "&lt;/span&gt; + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Кроме того, паттерны записей хорошо сочетаются со &lt;code&gt;switch&lt;/code&gt; из предыдущего JEP'а:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printObject(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 &amp;&amp; y &gt; 0 -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Positive point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) -&gt;
            System.out.println(&lt;span style="color: darkred"&gt;"Point: x = "&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", y = "&lt;/span&gt; + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/425"&gt;Virtual Threads (Preview) (JEP 425)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java появились виртуальные потоки в режиме preview.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" и не прибегать к более сложному асинхронному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt;, а значит, большую часть существующего кода не придётся переписывать.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент работает виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и малый размер виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоки и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в дебаггере, JVM TI и Java Flight Recorder.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки разрабатываются &lt;a href="https://mail.openjdk.org/pipermail/announce/2017-October/000238.html"&gt;с 2017 года&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/428"&gt;Structured Concurrency (Incubator) (JEP 428)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одним результатом работы над проектом Loom стало добавление в Java нового API для Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;. Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Future&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Future&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join();           &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
    scope.throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.resultNow(), order.resultNow());
}&lt;/pre&gt;

&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием &lt;code&gt;ExecutorService&lt;/code&gt; и &lt;code&gt;submit()&lt;/code&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;code&gt;close()&lt;/code&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новое API должно облегчить написание многопоточных программ благодаря знакомому структурному подходу. Пока API имеет инкубационный статус, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; и одноимённом пакете.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/424"&gt;Foreign Function &amp; Memory API (Preview) (JEP 424)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, которое было в инкубационном статусе &lt;a href="https://openjdk.org/jeps/412"&gt;в Java 17&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/419"&gt;Java 18&lt;/a&gt;, теперь стало Preview API. Оно находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;


&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/426"&gt;Vector API (Fourth Incubator) (JEP 426)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API, которое уже было в инкубационном статусе три релиза (&lt;a href="https://openjdk.org/jeps/338"&gt;Java 16&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/414"&gt;Java 17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/417"&gt;Java 18&lt;/a&gt;), продолжает в нём находиться. Пока API не выйдет из инкубационного статуса, оно будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/19/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/422"&gt;Linux/RISC-V Port (JEP 422)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь официально портирован под архитектуру Linux/RISC-V.&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 19 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до марта 2023 года). Однако Azul обещает выпускать обновления Zulu как минимум &lt;a href="https://www.azul.com/products/azul-support-roadmap/"&gt;до марта 2025 года&lt;/a&gt; (2.5 года).&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #44</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_44.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_44.html</id>
    <updated>2022-08-28T18:00:00Z</updated>
    <published>2022-08-28T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/18-0-2-relnotes.html#R18_0_2_1"&gt;JDK 18.0.2.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-4-relnotes.html#R17_0_4_1"&gt;JDK 17.0.4.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-August/016645.html"&gt;JDK 11.0.16.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-August/015329.html"&gt;JDK 8u345&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;18.0.2.1, 17.0.4.1, 11.0.6.1 &amp;ndash; вынужденные обновления, которые пришлось выпустить из-за &lt;a href="https://bugs.openjdk.org/browse/JDK-8292260"&gt;критической регрессии&lt;/a&gt; в JIT-компиляторе C2, вызывающей креш JVM.&lt;/p&gt;
&lt;p&gt;8u345 пришлось выпустить из-за другого &lt;a href="https://bugs.openjdk.org/browse/JDK-8290832"&gt;критического бага&lt;/a&gt; в 8u342.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел первый &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-August/006861.html"&gt;релиз-кандидат Java 19&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/429"&gt;JEP 429: Extent-Local Variables (Incubator)&lt;/a&gt;. В нём предлагается ввести новый класс &lt;a href="https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ExtentLocal.html"&gt;&lt;code&gt;ExtentLocal&lt;/code&gt;&lt;/a&gt; в качестве альтернативы существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ExtentLocal&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одной нити (или дерева нитей) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данной нити, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд проблем, например, неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно), неограниченное время жизни (переменная очистится, только когда исполнение всей нити завершится или когда будет вызван remove(), но про него часто забывают), высокая цена наследования (дочерние нити всегда вынуждены делать полную копию переменной, даже если родительская нить никогда не будет её изменять).&lt;/p&gt;
&lt;p&gt;В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ExtentLocal&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Однажды ассоциированное с объектом &lt;code&gt;ExtentLocal&lt;/code&gt; значение остаётся иммутабельным. Для этого используется метод &lt;code&gt;where()&lt;/code&gt;. Кроме того, значение ассоциируется на ограниченный срок, который определяется длительностью метода &lt;code&gt;run()&lt;/code&gt;. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ExtentLocal&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним нитям не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;p&gt;Пример использования &lt;code&gt;ExtentLocal&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ExtentLocal&amp;lt;Credentials&amp;gt; CREDENTIALS =
    ExtentLocal.newInstance();

Credentials creds = ...
ExtentLocal.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ExtentLocal&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.slf4j.org/news.html"&gt;SLF4J 2.0&lt;/a&gt;. Это первое мажорное обновление фасада логирования спустя 17 лет после выхода первой версии. Новая версия теперь требует Java 8 и содержит новый &lt;a href="https://www.slf4j.org/manual.html#fluent"&gt;Fluent Logging API&lt;/a&gt;. Кроме того, SLF4J API теперь использует механизм &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; для нахождения соответствующего логирующего провайдера. SLF4J 2.0 полностью обратно совместим с SLF4J 1.x, т.е. весь существующий код, использующий SLF4J API, не требует перекомпиляции. Однако при обновлении до второй версии потребуется соответствующее обновление бэкенда, иначе SLF4J API не сможет найти бэкенд и выдаст предупреждение.&lt;/p&gt;
&lt;p&gt;Вместе с выходом второй версии SLF4J вышли &lt;a href="https://logback.qos.ch/news.html"&gt;Logback 1.3.0 и 1.4.0&lt;/a&gt;, которые поддерживают SLF4J 2.0. Различие между 1.3.0 и 1.4.0 состоит в том, Logback 1.4.0 требует Java 11 и использует пространство имён Jakarta EE (&lt;code&gt;jakarta.*&lt;/code&gt;), в то время как Logback 1.3.0 работает на Java 8 и использует Java EE (&lt;code&gt;javax.*&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://www.jetbrains.com/idea/whatsnew/"&gt;IntelliJ IDEA 2022.2&lt;/a&gt;. Теперь среда разработки использует JetBrains Runtime 17 вместо 11.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/08/java-annotated-monthly-august-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за август.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://medium.com/helidon/helidon-3-0-is-released-1bd2df1f999b"&gt;Helidon 3.0&lt;/a&gt;. Теперь фреймворк требует Java 17 и поддерживает спецификации MicroProfile 5.0 и Jakarta EE 9.1.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #43</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_43.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_43.html</id>
    <updated>2022-07-24T18:00:00Z</updated>
    <published>2022-07-24T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/18-0-2-relnotes.html"&gt;JDK 18.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-4-relnotes.html"&gt;JDK 17.0.4&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-July/015833.html"&gt;JDK 15.0.8 и 13.0.12&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-16-relnotes.html"&gt;JDK 11.0.16&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-July/015254.html"&gt;JDK 8u342&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; JDK 19 перешёл &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-July/006803.html"&gt;во вторую фазу Rampdown&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Visual Studio Code появилась &lt;a href="https://devblogs.microsoft.com/java/java-on-visual-studio-code-update-july-2022/"&gt;поддержка Lombok&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/07/java-annotated-monthly-july-2022/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за июль.&lt;/p&gt;

&lt;p class="pt-3"&gt;Возвращаем рубрику &amp;laquo;Полезняшки&amp;raquo;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://maven.apache.org/wrapper/"&gt;Maven Wrapper&lt;/a&gt;. Надоело держать зоопарк Maven'ов для своих проектов? Хорошая новость: скачивать Maven теперь вообще не нужно. Просто запускаете один раз &lt;code&gt;mvn wrapper:wrapper&lt;/code&gt; на проекте и дальше вместо &lt;code&gt;mvn command&lt;/code&gt; просто вызываете &lt;code&gt;mvnw command&lt;/code&gt;. Maven Wrapper сам скачает и запустит нужную версию Maven.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sho7a/Decompiler"&gt;Decompiler&lt;/a&gt; &amp;ndash; простой декомпилятор байткода Java с графическим интерфейсом. В качестве движка декомпиляции использует недавно анонсированный &lt;a href="https://github.com/QuiltMC/quiltflower"&gt;Quiltflower&lt;/a&gt;, который хорошо поддерживает современные синтаксические конструкции Java.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/weisJ/jsvg"&gt;JSVG&lt;/a&gt; &amp;ndash; очень лёгкая и быстрая Java-библиотека для рисования SVG. Потребляет на ~98% меньше памяти, чем Apache Batik. Находится в стадии ранней разработки.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #42</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_42.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_42.html</id>
    <updated>2022-07-03T18:00:00Z</updated>
    <published>2022-07-03T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8280389"&gt;JEP: Classfile API&lt;/a&gt;. Цель этого JEP &amp;ndash; создать API для парсинга, генерации и трансформации class-файлов.&lt;/p&gt;
&lt;p&gt;В данный момент наиболее распространена библиотека для работы с байткодом ASM, форк которой используется, в том числе, в самой JDK. Основная проблема с ASM заключается в том, что она всегда отстаёт на один релиз от JDK. Когда выходит новая версия JDK, последняя версия ASM поддерживает только предпоследнюю версию байткода. Из-за этого инструменты и библиотеки, которые корректно работали на предпоследней версии байткода, могут неожиданно ломаться, когда сталкиваются с новыми class-файлами. Раньше это не было большой проблемой, так как релизы Java выходили раз в 3-5 лет. С переходом на &lt;a href="java_18_3.html"&gt;новую частоту&lt;/a&gt; релизов это стало создавать неприятности как для пользователей, так и для разработчиков библиотек.&lt;/p&gt;
&lt;p&gt;Решение этой проблемы очевидное: библиотека для работы с class-файлами должна быть частью JDK. Тогда пользователи такого classfile API не будут иметь проблем с только что вышедшей новой версией Java, поскольку поддержка новой версии байткода будет идти сразу "из коробки".&lt;/p&gt;
&lt;p&gt;Новое API будет учитывать и ряд других проблем ASM. Например, ASM имеет старую кодовую базу с большим количеством багажа, доставшегося по наследству от первых версий. Также в ASM используется подход, основанный на Visitor. Было бы глупо в 2022-м году использовать этот же шаблон при наличии современных языковых конструкций: лямбд, записей и паттерн-матчинга.&lt;/p&gt;
&lt;p&gt;Планируется, что API сначала заменит ASM внутри самой JDK, а позже станет частью публичного API.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=zDJtVYAJwyY"&gt;Eclipse 2022-06&lt;/a&gt;. Перечислим самые заметные нововведения и улучшения в среде разработки:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поддержка Java 18.&lt;/li&gt;
  &lt;li&gt;Улучшена производительность автодополнения в редакторе.&lt;/li&gt;
  &lt;li&gt;Несколько новых &lt;i&gt;Quick Fix&lt;/i&gt; и &lt;i&gt;Cleanup Action&lt;/i&gt; для Java.&lt;/li&gt;
  &lt;li&gt;Улучшена производительность печати в консоль.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Find Actions&lt;/i&gt; (&lt;code&gt;Ctrl+3&lt;/code&gt;) теперь может искать файлы.&lt;/li&gt;
  &lt;li&gt;Несколько новых команд, связанных с режимом multi-selection.&lt;/li&gt;
  &lt;li&gt;Кодировка по умолчанию для workspace теперь UTF-8.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/netbeans/releases/tag/14"&gt;Apache NetBeans 14&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/"&gt;Kotlin 1.7.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.gwtproject.org/release-notes.html#Release_Notes_2_10_0"&gt;GWT 2.10.0&lt;/a&gt;. Это первое обновление библиотеки спустя два года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2022/06/14/orm-61-final/"&gt;Hibernate 6.1&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #41</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_41.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_41.html</id>
    <updated>2022-06-12T18:00:00Z</updated>
    <published>2022-06-12T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; JDK 19 перешёл в &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2022-June/006735.html"&gt;первую фазу Rampdown&lt;/a&gt;. Список JEP'ов &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;заморожен&lt;/a&gt;, а исходный код ответвлён в &lt;a href="https://github.com/openjdk/jdk19"&gt;стабилизационный репозиторий&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Примечательно, что из всех семи JEP'ов Java 19 только один будет иметь стабильный характер (&lt;a href="https://openjdk.java.net/jeps/422"&gt;Linux/RISC-V Port&lt;/a&gt;). Все остальные будут иметь статус Preview, либо Incubator.&lt;/p&gt;
&lt;p&gt;Тем временем, уже &lt;a href="https://github.com/openjdk/jdk/pull/8236"&gt;началась&lt;/a&gt; разработка Java 20. У нового релиза появилась &lt;a href="https://jdk.java.net/20/"&gt;своя страница&lt;/a&gt;, где можно скачать первую сборку JDK 20-ea+1.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Java 19 попал интересный &lt;a href="https://github.com/openjdk/jdk/pull/3402"&gt;патч&lt;/a&gt;, который исправляет &lt;a href="https://bugs.openjdk.org/browse/JDK-4511638"&gt;баг 20-летней давности&lt;/a&gt;. Баг этот заключается в том, что метод &lt;code&gt;Double.toString()&lt;/code&gt; иногда возвращает некорректный результат, например:&lt;/p&gt;
&lt;pre&gt;&amp;gt; jshell
&lt;span style="color: grey"&gt;|  Welcome to JShell -- Version 18.0.1.1
|  For an introduction type: /help intro&lt;/span&gt;

jshell&amp;gt; Double.toString(1e23)
$1 ==&gt; "9.999999999999999E22"&lt;/pre&gt;
&lt;p&gt;В Java 19 это исправлено:&lt;/p&gt;
&lt;pre&gt;&amp;gt; jshell
&lt;span style="color: grey"&gt;|  Welcome to JShell -- Version 19-ea
|  For an introduction type: /help intro&lt;/span&gt;

jshell&amp;gt; Double.toString(1e23)
$1 ==&gt; "1.0E23"&lt;/pre&gt;
&lt;p&gt;Помимо возвращения корректного результата новая реализация также значительно быстрее (в 17.7 раз по &lt;a href="https://mail.openjdk.org/pipermail/core-libs-dev/2020-April/065921.html"&gt;замерам автора&lt;/a&gt;), поскольку не выделяет промежуточных объектов, не содержит циклов и использует только целочисленную арифметику.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В блоге IntelliJ IDEA вышел новый выпуск &lt;a href="https://blog.jetbrains.com/idea/2022/06/java-annotated-monthly-june-2022/"&gt;Java Annotated Monthly&lt;/a&gt; за июнь.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #40</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_40.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_40.html</id>
    <updated>2022-05-29T18:00:00Z</updated>
    <published>2022-05-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java18"&gt;JDK 18.0.1.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java17"&gt;JDK 17.0.3.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java11"&gt;JDK 11.0.15.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/#java8"&gt;JDK 8u333&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Такое внеплановое обновление пришлось выпустить из-за &lt;a href="https://bugs.openjdk.org/browse/JDK-8285468?jql=project%20%3D%20JDK%20AND%20fixVersion%20%3D%2018.0.1.1"&gt;нескольких критических багов&lt;/a&gt; в OpenJDK.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Ещё один JEP предложен к JDK 19. Это &lt;a href="https://openjdk.org/jeps/428"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;. Это седьмой и, вероятно, последний JEP, который попадёт в этот релиз, поскольку до первой фазы Rampdown остаётся &lt;a href="http://openjdk.org/projects/jdk/19/"&gt;меньше двух недель&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Марк Рейнолд &lt;a href="https://mail.openjdk.org/pipermail/discuss/2022-May/006110.html"&gt;заявил&lt;/a&gt; о начале работы над проектом Leyden. У проекта появилась &lt;a href="https://openjdk.org/projects/leyden/"&gt;своя страница&lt;/a&gt; на сайте OpenJDK и &lt;a href="https://mail.openjdk.org/mailman/listinfo/leyden-dev"&gt;почтовая рассылка&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напомним, что целью проекта Leyden является решение проблемы медленного старта JVM и большого размера образа. Призыв к обсуждению проекта был ещё &lt;a href="https://mail.openjdk.org/pipermail/discuss/2020-April/005429.html"&gt;в апреле 2020 года&lt;/a&gt;, а голосование по нему завершилось &lt;a href="https://mail.openjdk.org/pipermail/announce/2020-June/000290.html"&gt;в июне того же года&lt;/a&gt;. Тогда предлагалось, что упомянутые проблемы будут решаться через концепцию статического образа &amp;ndash; автономной программы, которая выполняет целевое приложение и ничего больше.&lt;/p&gt;
&lt;p&gt;В текущем предложении подход будет &lt;a href="https://openjdk.org/projects/leyden/notes/01-beginnings"&gt;несколько иным&lt;/a&gt;: движение к "закрытому миру" будет постепенным и инкрементальным. Полностью статические образы будут самой конечной целью, а в промежутке в JDK будут внедряться улучшения, которые разработчики смогут начать использовать раньше.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; JetBrains планирует полностью поменять интерфейс IntelliJ IDEA и других своих IDE. Как &lt;a href="https://blog.jetbrains.com/idea/2022/05/take-part-in-the-new-ui-preview-for-your-jetbrains-ide/"&gt;утверждается&lt;/a&gt; в блоге JetBrains, "тренды графического интерфейса эволюционировали, и многие из наших пользователей говорят нам, что текущий интерфейс кажется тяжеловесным и устаревшим". Поэтому в компании было принято решение разработать абсолютно новый look-and-feel, который будет чистым, современным и мощным.&lt;/p&gt;
&lt;p&gt;Новый графический интерфейс будет внедряться постепенно. Сначала ограниченный круг пользователей сможет принять участие в &lt;a href="https://www.jetbrains.com/lp/intellij-new-ui-preview/"&gt;программе раннего доступа&lt;/a&gt;, где сможет попробовать новый интерфейс и поделиться обратной связью с командой JetBrains. Позже в этом году новый интерфейс станет общедоступным, а в следующем году он станет интерфейсом по умолчанию, сначала для новых пользователей, а потом для всех остальных. После этого старый интерфейс будет всё ещё доступен как минимум в течение года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://spring.io/blog/2022/05/19/spring-boot-2-7-0-available-now"&gt;Spring Boot 2.7.0&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #39</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_39.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_39.html</id>
    <updated>2022-05-15T18:00:00Z</updated>
    <published>2022-05-15T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стало известно ещё о трёх новых JEP, которые попадут в JDK 19.&lt;/p&gt;
&lt;p&gt;Первый &amp;ndash; &lt;a href="https://openjdk.org/jeps/425"&gt;JEP 425: Virtual Threads (Preview)&lt;/a&gt; (этот JEP уже интегрирован в сборку &lt;a href="https://jdk.java.net/19/"&gt;JDK 19-ea+22&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Второй &amp;ndash; &lt;a href="https://openjdk.org/jeps/427"&gt;JEP 427: Pattern Matching for switch (Third Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_37.html"&gt;выпуске #37&lt;/a&gt;, когда он был ещё в статусе черновика.&lt;/p&gt;
&lt;p&gt;Третий &amp;ndash; &lt;a href="https://openjdk.org/jeps/424"&gt;JEP 424: Foreign Function &amp; Memory API (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_35.html"&gt;выпуске #35&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-1"&gt;Также предложен ко включению в Java 19 &lt;a href="https://openjdk.org/jeps/405"&gt;JEP 405: Record Patterns (Preview)&lt;/a&gt;. Про этот JEP мы писали давно в &lt;a href="java_news_8.html"&gt;выпуске #8&lt;/a&gt;, когда он ещё был озаглавлен как "Record and Array Patterns (Preview)". В текущий JEP было решено не включать паттерны массивов и оставить только паттерны записей. Паттерны массивов отложены на один из будущих JEP'ов.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Марк Рейнолд предложил переименовать домен &lt;a href="https://openjdk.org/"&gt;openjdk.java.net&lt;/a&gt; в &lt;a href="https://openjdk.org"&gt;openjdk.org&lt;/a&gt;. С момента появления OpenJDK в 2007 году вся его инфраструктура (исходный код, веб, e-mail, wiki, задачи) хостится в домене третьего уровня openjdk.java.net, хотя веб-сайт &lt;a href="https://en.wikipedia.org/wiki/Java.net"&gt;java.net&lt;/a&gt; был сайтом для Java-сообщества и имел слабое отношение к разработке самого OpenJDK. В 2017 году этот сайт был закрыт.&lt;/p&gt;
&lt;p&gt;С тех пор много открытого ПО стало хоститься в домене .org, и перемещение туда OpenJDK будет логичным шагом. Также это послужит напоминанием о том, что OpenJDK разрабатывается сообществом, а не одной главенствующей корпорацией.&lt;/p&gt;
&lt;p&gt;Вместе с самим доменом openjdk.java.net также будут переименованы все его активные поддомены (bugs, cr, db, git, hg, mail, wiki). При этом старые ссылки, ведущие на openjdk.java.net, будут перенаправлены на соответствующие адреса в домене openjdk.org.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел в свет новый декомпилятор Java-байткода &lt;a href="https://github.com/QuiltMC/quiltflower"&gt;Quiltflower&lt;/a&gt;. Quiltflower является форком декомпилятора Fernflower, который является стандартным декомпилятором в IntelliJ IDEA. Как &lt;a href="https://www.reddit.com/r/java/comments/ue8u59/new_open_source_java_decompiler/"&gt;утверждает автор&lt;/a&gt;, Quiltflower более точно воспроизводит исходный Java-код и поддерживает различные синтаксические конструкции (try-with-resources, выражения &lt;code&gt;switch&lt;/code&gt;, паттерн-матчинг, sealed-классы и т.д). В доказательство приводятся &lt;a href="https://gist.github.com/SuperCoder7979/c7171b0e34b6eccf0b9f1c37030867dc"&gt;примеры&lt;/a&gt;, сравнивающие результаты декомпиляции Fernflower и Quiltflower.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Роман Кеннке &lt;a href="https://mail.openjdk.org/pipermail/lilliput-dev/2022-May/000457.html"&gt;сообщил&lt;/a&gt;, что проекту &lt;a href="https://openjdk.org/projects/lilliput/"&gt;Lilliput&lt;/a&gt; удалось сократить размер заголовков объектов с 96/128 бит до 64 бит. При этом 64-битные заголовки являются лишь промежуточным шагом, и он заявил, что следующим шагом будет сокращение заголовков ещё сильнее: до 32 бит.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="http://weld.cdi-spec.org/news/2022/04/29/weld-500Final/"&gt;Weld 5.0.0.Final&lt;/a&gt;, который поддерживает спецификацию &lt;a href="https://jakarta.ee/specifications/cdi/4.0/"&gt;CDI 4&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #38</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_38.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_38.html</id>
    <updated>2022-04-24T18:00:00Z</updated>
    <published>2022-04-24T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/18-0-1-relnotes.html"&gt;JDK 18.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-3-relnotes.html"&gt;JDK 17.0.3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-April/013820.html"&gt;JDK 15.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2022-April/013821.html"&gt;JDK 13.0.11&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-15-relnotes.html"&gt;JDK 11.0.15&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2022-April/014839.html"&gt;JDK 8u332&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Появилось &lt;a href="https://openjdk.org/projects/jdk/19/"&gt;расписание выхода JDK 19&lt;/a&gt;. Общедоступная версия Java 19 по плану должна выйти 20 сентября 2022 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://openjdk.org/jeps/426"&gt;JEP 426: Vector API (Fourth Incubator)&lt;/a&gt;, который сразу стал предложен к выходу в JDK 19.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2022/04/intellij-idea-2022-1/"&gt;IntelliJ IDEA 2022.1&lt;/a&gt;. Перечислим главные новшества:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новый инструмент &lt;i&gt;Dependency Analyzer&lt;/i&gt;, позволяющий находить конфликты зависимостей.&lt;/li&gt;
  &lt;li&gt;Новый улучшенный мастер создания проектов.&lt;/li&gt;
  &lt;li&gt;Новая вкладка &lt;i&gt;Notifications&lt;/i&gt; вместо &lt;i&gt;Event Log&lt;/i&gt;.&lt;/li&gt;
  &lt;li&gt;Улучшенные встроенные подсказки в редакторе, которые теперь отображают автора кода, использования, cвязанные проблемы и производные типы.&lt;/li&gt;
  &lt;li&gt;Обновленные диалоги &lt;i&gt;Structural Search&lt;/i&gt; и &lt;i&gt;Structural Replace&lt;/i&gt;.&lt;/li&gt;
  &lt;li&gt;Отображение уязвимостей в зависимостях (только в Ultimate).&lt;/li&gt;
  &lt;li&gt;Выполнение команд прямо из Markdown-файлов нажатием на иконку рядом с командой.&lt;/li&gt;
  &lt;li&gt;Копирование фрагментов кода из Markdown-файлов в буфер обмена.&lt;/li&gt;
  &lt;li&gt;Новая инспекция Incorrect formatting, предупреждающая о том, соответствует ли форматирование файла настройкам стиля кода.&lt;/li&gt;
  &lt;li&gt;Поддержка Java 18: сниппеты в документации, второе preview паттерн-матчинга для &lt;code&gt;switch&lt;/code&gt;. Кодировкой по умолчанию для Java-файлов теперь является UTF-8 на всех платформах.&lt;/li&gt;
  &lt;li&gt;Улучшенная совместимость декомпилятора Java с Java 17.&lt;/li&gt;
  &lt;li&gt;Поддержка новых возможностей, появившихся в JUnit 5.7.&lt;/li&gt;
  &lt;li&gt;Шаблон &lt;i&gt;Surround with try/catch&lt;/i&gt; теперь выбрасывает исключение, обернутое в &lt;code&gt;RuntimeException&lt;/code&gt;, вместо проглатывания.&lt;/li&gt;
  &lt;li&gt;Новый значок &lt;i&gt;Reset Frame&lt;/i&gt; вместо старого действия &lt;i&gt;Drop Frame&lt;/i&gt; в панели инструментов отладчика.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #37</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_37.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_37.html</id>
    <updated>2022-04-10T18:00:00Z</updated>
    <published>2022-04-10T18:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://openjdk.org/jeps/425"&gt;JEP 425: Virtual Threads (Preview)&lt;/a&gt;. Это значит, что проект Loom перешёл в свою финальную стадию и результаты многолетней работы над виртуальными нитями в скором времени станут доступны широкой публике.&lt;/p&gt;
&lt;p&gt;Напомним, что о старте проекта Loom было заявлено &lt;a href="project_loom.html"&gt;в ноябре 2017 года&lt;/a&gt; вскоре после выхода Java 9, а первый черновик JEP по виртуальным нитям по нему появился лишь спустя 4 года, о чём мы писали в &lt;a href="java_news_32.html"&gt;выпуске #32&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Вместе с выходом JEP 425 также вышла новая Early-Access сборка Loom &lt;a href="https://jdk.java.net/loom/"&gt;19-loom+5&lt;/a&gt; с большим количеством изменений по сравнению с предыдущей версией.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел черновик &lt;a href="https://openjdk.org/jeps/8282272"&gt;JEP Pattern matching for switch (Third Preview)&lt;/a&gt;. Это значит, что паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; стал первой языковой конструкцией, которой не хватило два preview, чтобы стать стабильной.&lt;/p&gt;
&lt;p&gt;В этой итерации предлагается внести два изменения относительно предыдущей.&lt;/p&gt;
&lt;p&gt;Во-первых, заменить охранные паттерны на условия &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Java 18:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &amp;&amp; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}

&lt;span style="color: green"&gt;// Java 19:&lt;/span&gt;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0 -&gt; ...;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;p&gt;О мотивации заменить &lt;code&gt;&amp;&amp;&lt;/code&gt; на &lt;code&gt;when&lt;/code&gt; можно прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003195.html"&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Во-вторых, предлагается изменить поведения матчинга &lt;code&gt;null&lt;/code&gt; таким образом, чтобы он матчился только в ветках &lt;code&gt;case null&lt;/code&gt; и ни в каких других (даже тотальных):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Java 18:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: green"&gt;// matches&lt;/span&gt;
}

&lt;span style="color: green"&gt;// Java 19:&lt;/span&gt;
Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Object x -&gt; ...; &lt;span style="color: red"&gt;// NPE&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Про причины такого изменения можно прочитать &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-January/003194.html"&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Также вышло ещё два новых черновика JEP: &lt;a href="https://openjdk.org/jeps/8284289"&gt;Improved way of obtaining call traces asynchronously for profiling&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8284453"&gt;Optionally Record Thread Context in JFR&lt;/a&gt;.&lt;/p&gt;


&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://in.relation.to/2022/03/31/orm-60-final/"&gt;Hibernate 6.0 Final&lt;/a&gt;. Новая версия фреймворка не является полностью совместимой с предыдущей версией 5.x, но в значительной степени совместимость удалось сохранить. Для тех, кто использует Hibernate исключительно через &lt;a href="https://docs.jboss.org/hibernate/orm/6.0/migration-guide/migration-guide.html#_jakarta_persistence"&gt;Jakarta Persistence API&lt;/a&gt;, переход должен быть полностью совместимым. Для остальных был написан &lt;a href="https://docs.jboss.org/hibernate/orm/6.0/migration-guide/migration-guide.html"&gt;подробный гид по миграции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Перечислим некоторые существенные изменения Hibernate 6.0:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Базовая версия Java теперь 11.&lt;/li&gt;
  &lt;li&gt;Java Persistence больше не поддерживается. Hibernate 6.0 можно использовать только с пространством имён &lt;code&gt;jakarta.persistence&lt;/code&gt;, но не &lt;code&gt;javax.persistence&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Теперь используется Read-by-position вместо Read-by-name при чтении из JDBC &lt;code&gt;ResultSet&lt;/code&gt;. Это приводит к улучшению производительности, а также к более компактным и читаемым сгенерированным SQL-запросам.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышла &lt;a href="https://newsroom.eclipse.org/eclipse-newsletter/2022/march/what%E2%80%99s-new-jakarta-persistence-31"&gt;Jakarta Persistence 3.1&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; В Spring обнаружена &lt;a href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement"&gt;критическая уязвимость&lt;/a&gt;, позволяющая злоумышленнику выполнить произвольный код. Уязвимости подвержены приложения при следующих условиях:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Приложение запускается на JDK 9 или выше.&lt;/li&gt;
  &lt;li&gt;Используется Apache Tomcat в качестве контейнера сервлетов.&lt;/li&gt;
  &lt;li&gt;Приложение пакуется в WAR, а не JAR.&lt;/li&gt;
  &lt;li&gt;Используются зависимости &lt;code&gt;spring-webmvc&lt;/code&gt; или &lt;code&gt;spring-webflux&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;К моменту публикации уязвимости уже были выпущены новые версии Spring 5.3.18 и 5.2.20, в которых уязвимость была исправлена. На следующий день Apache Tomcat исправил уязвимость на своей стороне, выпустив версии 10.0.20, 9.0.62 и 8.5.78.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Eclipse начал &lt;a href="https://blogs.eclipse.org/post/denis-roy/moving-eclipse-projects-github-and-gitlab"&gt;переезд на GitHub&lt;/a&gt;. Многие проекты на данный момент уже переехали (&lt;a href="https://github.com/eclipse-platform/eclipse.platform"&gt;Platform&lt;/a&gt;, &lt;a href="https://github.com/eclipse-equinox"&gt;Equinox&lt;/a&gt;, &lt;a href="https://github.com/eclipse-platform/eclipse.platform.swt"&gt;SWT&lt;/a&gt;, &lt;a href="https://github.com/eclipse-jdt"&gt;JDT&lt;/a&gt; и т.д).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/idea/2022/04/java-annotated-monthly-april-2022/"&gt;Java Annotated Monthly&lt;/a&gt; за апрель 2022.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/oracle/helidon/releases/tag/2.5.0"&gt;Helidon 2.5.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://andresalmiray.com/jreleaser-1-0-0-is-here/"&gt;JReleaser 1.0.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jmh-dev/2022-March/003422.html"&gt;JMH 1.35&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
</feed>
