<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.org" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.org/feed.xml</id>
  <updated>2024-09-16T19:00:00Z</updated>
  <entry>
    <title>Вышла Java 23</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_23.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_23.html</id>
    <updated>2024-09-16T19:00:00Z</updated>
    <published>2024-09-16T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/23/"&gt;Java 23&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-23.html"&gt;2400 закрытых задач и 12 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/23/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/23/apidiff/22/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 23 не является LTS-релизом, и у неё будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;только полгода&lt;/a&gt; (до марта 2025 года).&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 23 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/23/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Рассмотрим все JEP'ы, которые попали в Java 23.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/467"&gt;Markdown Documentation Comments (JEP 467)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь JavaDoc поддерживает формат Markdown. Для его использования документация должна начинаться с &lt;code&gt;///&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// Returns `true` if, and only if, [#length()] is `0`.
///
/// @return `true` if [#length()] is `0`, otherwise `false`&lt;/span&gt;
&lt;span style="color: blue"&gt;public boolean&lt;/span&gt; isEmpty() {
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Markdown компактнее, читабельнее и удобнее для написания, чем существующий формат HTML. Рассмотрим несколько примеров элементов, написанных в формате HTML и Markdown:&lt;/p&gt;
&lt;table class="table"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;HTML&lt;/th&gt;
      &lt;th&gt;Markdown&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;{@link java.util.List}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;[java.util.List]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;{@code true}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;`true`&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;em&gt;warning&amp;lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;_warning_&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;b&gt;error&amp;lt;/b&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;**error**&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
&lt;pre&gt;&amp;lt;ul&gt;
  &amp;lt;li&gt;Item 1&amp;lt;/li&gt;
  &amp;lt;li&gt;Item 2&amp;lt;/li&gt;
  &amp;lt;li&gt;Item 3&amp;lt;/li&gt;
&amp;lt;/ul&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td&gt;
&lt;pre&gt;- Item 1
- Item 2
- Item 3&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;p&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Не нужен (просто необходимо вставить новую строку)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;При этом JavaDoc-теги, такие как &lt;code&gt;{@inheritDoc}&lt;/code&gt;, &lt;code&gt;@param&lt;/code&gt;, &lt;code&gt;@return&lt;/code&gt;, &lt;code&gt;@throws&lt;/code&gt;, остаются прежними:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// {@inheritDoc}
/// In addition, this method calls [#wait()].
///
/// @param i the index&lt;/span&gt;
&lt;span style="color: blue"&gt;public void&lt;/span&gt; m(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Кроме компактности и удобства новый формат также решает проблему сочетания двух символов &lt;code&gt;*/&lt;/code&gt;, которые в формате HTML означают окончание документации:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**
 * &amp;lt;pre&gt;
 * var pattern = Pattern.compile("\\w*/"); // Проблема
 * &amp;lt;/pre&gt;
 */&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;В Markdown-документации же можно не только использовать эту последовательность символов, но и вставлять целые блоки HTML-комментариев:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/// Here is an example:
///
/// ```
/// /** Hello World! */
/// public class HelloWorld {
///     public static void main(String... args) {
///         System.out.println("Hello World!"); // the traditional example
///     }
/// }
/// ```&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/455"&gt;Primitive Types in Patterns, instanceof, and switch (Preview) (JEP 455)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь в режиме preview паттерны и операторы &lt;code&gt;instanceof&lt;/code&gt; / &lt;code&gt;switch&lt;/code&gt; поддерживают примитивные типы:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;

Object obj = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof int&lt;/span&gt; i) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i);
}

&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case double&lt;/span&gt; d -&gt; System.out.println(&lt;span style="color: darkred"&gt;"double: "&lt;/span&gt; + d);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Проверять можно также и то, попадают ли значения в диапазон типа:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 42;
&lt;span style="color: blue"&gt;if&lt;/span&gt; (i &lt;span style="color: blue"&gt;instanceof byte&lt;/span&gt; b) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    System.out.println(&lt;span style="color: darkred"&gt;"byte: "&lt;/span&gt; + b);
}

&lt;span style="color: blue"&gt;double&lt;/span&gt; d = 3.0;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (d) {
    &lt;span style="color: blue"&gt;case int&lt;/span&gt; i -&gt; System.out.println(&lt;span style="color: darkred"&gt;"int: "&lt;/span&gt; + i); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"float: "&lt;/span&gt; + f);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;В примерах выше &lt;code&gt;42&lt;/code&gt; попадает в диапазон byte (&lt;code&gt;[-128; 127]&lt;/code&gt;), а &lt;code&gt;3.0&lt;/code&gt; без потери точности приводится к &lt;code&gt;int&lt;/code&gt;. Таким образом, это позволит более безопасно приводить одни числовые типы к другим, не прибегая к ручным проверкам диапазонов.&lt;/p&gt;
&lt;p&gt;Подобные проверки могут быть полезны и в паттернах записей:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;double&lt;/span&gt; d) {}

&lt;span style="color: blue"&gt;var&lt;/span&gt; json = &lt;span style="color: blue"&gt;new&lt;/span&gt; JsonNumber(3.0);
&lt;span style="color: blue"&gt;if&lt;/span&gt; (json &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; JsonNumber(&lt;span style="color: blue"&gt;int&lt;/span&gt; i)) { &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Если раньше типы выражений-селекторов в &lt;code&gt;switch&lt;/code&gt; могли быть только &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; и для них поддерживались только константные ветки (&lt;code&gt;case 3&lt;/code&gt; и т.п.), то сейчас поддерживаются все примитивные типы и ветки могут быть паттернами:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = 1.0f;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 0f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"0"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x == 1f -&gt; System.out.println(&lt;span style="color: darkred"&gt;"1"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; x -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other"&lt;/span&gt;);
}

&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = &lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;.isEmpty();
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"empty"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"non-empty"&lt;/span&gt;); &lt;span style="color: green"&gt;// matches&lt;/span&gt;
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/476"&gt;Module Import Declarations (Preview) (JEP 476)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview появилась возможность импортировать модули:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;import module&lt;/span&gt; M;&lt;/pre&gt;
&lt;p&gt;Такой импорт эквивалентен импорту всех экспортированных пакетов из модуля &lt;code&gt;M&lt;/code&gt; и его транзитивных зависимостей в текущий модуль.&lt;/p&gt;
&lt;p&gt;Например, импорт модуля &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/module-summary.html"&gt;&lt;code&gt;java.base&lt;/code&gt;&lt;/a&gt; имеет тот же эффект, как если бы мы вручную импортировались все его 54 экспортированных пакета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;import&lt;/span&gt; java.io.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; java.lang.annotation.*;
&lt;span style="color: green"&gt;// ... 49 packages ...&lt;/span&gt;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.auth.x500.*;
&lt;span style="color: blue"&gt;import&lt;/span&gt; javax.security.cert.*;&lt;/pre&gt;

&lt;p&gt;Таким образом, написав всего лишь один импорт, можно будет получить доступ до таких неотъемлемых классов и интерфейсов как &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt;, &lt;code&gt;Path&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; и др. без необходимости отдельного импорта их соответствующих пакетов.&lt;/p&gt;
&lt;p&gt;Такое нововведение может быть полезным при прототипировании, изучении языка и новых фич, а также для написания коротких скриптов, которые запускаются напрямую &lt;a href="https://openjdk.org/jeps/458"&gt;без предварительной компиляции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;При использовании &lt;i&gt;неявно объявленных классов&lt;/i&gt; модуль &lt;code&gt;java.base&lt;/code&gt; импортируется автоматически. Об этом следующий JEP 477.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/477"&gt;Implicitly Declared Classes and Instance Main Methods (Third Preview) (JEP 477)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java 21 в режиме preview появились &lt;a href="https://openjdk.org/jeps/445"&gt;безымянные классы и инстанс-методы &lt;code&gt;main()&lt;/code&gt;&lt;/a&gt;. В Java 22 они были оставлены &lt;a href="https://openjdk.org/jeps/463"&gt;на второе preview&lt;/a&gt; с несколькими изменениями, среди которых самым важным был отказ от безымянных классов в пользу неявно объявленных классов.&lt;/p&gt;
&lt;p&gt;В Java 23 теперь выходит третье preview этой фичи ещё с несколькими изменениями:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html"&gt;&lt;code&gt;java.io.IO&lt;/code&gt;&lt;/a&gt; с тремя публичными статическими методами, которые автоматически импортируются во все неявно объявленные классы:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#print(java.lang.Object)"&gt;&lt;code&gt;void print(Object obj)&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#println(java.lang.Object)"&gt;&lt;code&gt;void println(Object obj)&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/io/IO.html#readln(java.lang.String)"&gt;&lt;code&gt;String readln(String prompt)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Неявно объявленные классы автоматически импортируют модуль &lt;code&gt;java.base&lt;/code&gt; (см. JEP 476 выше). То есть автоматически будут видны все публичные верхнеуровневые классы и интерфейсы всех экспортированных пакетов модуля &lt;code&gt;java.base&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Новый протокол запуска Java-программ позволяет запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; (т.е. является instance-методом) и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 23 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 23 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// import module java.base; ← неявно
// import static java.io.IO.*; ← неявно

// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Заметьте, что второй пример стал короче не только из-за отсутствия объявления класса, но и из-за использования метода &lt;code&gt;println()&lt;/code&gt; вместо &lt;code&gt;System.out.println()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один неявный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p class="mt-2"&gt;Упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/482"&gt;Flexible Constructor Bodies (Second Preview) (JEP 482)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Statements before &lt;code&gt;super()&lt;/code&gt;, которые появились &lt;a href="https://openjdk.org/jeps/447"&gt;в Java 22&lt;/a&gt; в режиме preview, остаются на второе preview и теперь называются Flexible Constructor Bodies. По сравнению с Java 22 есть одно важное изменение: теперь можно инициализировать поля до вызова конструктора. Про это будет подробнее рассказано дальше.&lt;/p&gt;

&lt;p&gt;Flexible Constructor Bodies разрешают писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Super(C x, C y) { ... }
}

&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(C x) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x); &lt;span style="color: green"&gt;// x is shared here&lt;/span&gt;
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(&lt;span style="color: blue"&gt;new&lt;/span&gt; C(i));
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 23, включив режим preview, то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --source 23&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = &lt;span style="color: blue"&gt;new&lt;/span&gt; C(i);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(x, x);
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект (читать поля, вызывать инстанс-методы). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        var x = i;              &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на родительский объект также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; B {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
    &lt;span style="color: blue"&gt;void&lt;/span&gt; m() {}
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; C &lt;span style="color: blue"&gt;extends&lt;/span&gt; B {
    C() {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; x = i; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        m();       &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Однако если читать поля конструируемого класса до вызова &lt;code&gt;super()&lt;/code&gt; нельзя, то инициализировать их можно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i = i; &lt;span style="color: green"&gt;// OK&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Это может быть полезным для ситуаций, когда в конструкторе суперкласса может случайно прочитаться нежелательное дефолтное значение поля при вызове виртуального метода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: red"&gt;// new Sub(42) will print 0&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Чтобы предотвратить такую ситуацию, нужно поместить инициализацию поле выше вызова &lt;code&gt;super()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Super {
    Super() { overriddenMethod(); }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(&lt;span style="color: darkred"&gt;"hello"&lt;/span&gt;);
    }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;final int&lt;/span&gt; x;

    Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; x) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.x = x;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }

    @Override
    &lt;span style="color: blue"&gt;void&lt;/span&gt; overriddenMethod() {
        System.out.println(x); &lt;span style="color: green"&gt;// new Sub(42) will print 42&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;Также инициализация полей до &lt;code&gt;super()&lt;/code&gt; можно пригодиться в проекте Valhalla для &lt;a href="https://youtu.be/IF9l8fYfSnI?t=2006"&gt;definite assignment полей&lt;/a&gt; null-restricted value-классов.&lt;/p&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/473"&gt;Stream Gatherers (Second Preview) (JEP 473)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Stream gatherers, которые &lt;a href="https://openjdk.org/jeps/461"&gt;появились в Java 22&lt;/a&gt; в режиме preview, остаются на второе preview без изменений.&lt;/p&gt;

&lt;p&gt;Gatherers &amp;ndash; это усовершенствование Stream API для поддержки произвольных промежуточных операций.&lt;/p&gt;
&lt;p&gt;Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#limit(long)"&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/a&gt;,
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#skip(long)"&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; и т.д). В Java 9 были добавлены &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"&gt;&lt;code&gt;dropWhile&lt;/code&gt;&lt;/a&gt;. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.&lt;/p&gt;
&lt;p&gt;Новая точка расширения &amp;ndash; это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"&gt;&lt;code&gt;Stream::gather(Gatherer)&lt;/code&gt;&lt;/a&gt;, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html"&gt;&lt;code&gt;Gatherer&lt;/code&gt;&lt;/a&gt;, предоставляемого пользователем. Операция &lt;code&gt;gather()&lt;/code&gt; аналогична уже имеющейся операции &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"&gt;&lt;code&gt;Stream::collect(Collector)&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;collect()&lt;/code&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html"&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; определяют точку расширения для терминальных операций, то &lt;code&gt;gather()&lt;/code&gt; и &lt;code&gt;Gatherer&lt;/code&gt; определяют точкой расширения для промежуточных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gatherer&lt;/code&gt; представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса &lt;code&gt;Gatherer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gather()&lt;/code&gt; также является промежуточной операцией, поэтому может быть несколько &lt;code&gt;gather()&lt;/code&gt; в одной цепочке:&lt;/p&gt;
&lt;pre&gt;source.gather(a).gather(b).gather(c).collect(...)&lt;/pre&gt;

&lt;p&gt;Вместе с самим &lt;code&gt;Gatherer&lt;/code&gt; было добавлено несколько готовых gatherer'ов, определённых в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html"&gt;&lt;code&gt;Gatherers&lt;/code&gt;&lt;/a&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"&gt;&lt;code&gt;mapConcurrent&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"&gt;&lt;code&gt;windowFixed&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"&gt;&lt;code&gt;windowSliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Давайте рассмотрим несколько примеров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.fold(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .findFirst()
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .get();
&lt;span style="color: grey"&gt;$1 ==&gt;&lt;/span&gt; "123456789"&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.scan(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .toList()
&lt;span style="color: grey"&gt;$2 ==&gt;&lt;/span&gt; [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
&lt;span style="color: grey"&gt;$3 ==&gt;&lt;/span&gt; [[1, 2, 3], [4, 5, 6], [7, 8]]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
&lt;span style="color: grey"&gt;$4 ==&gt;&lt;/span&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]&lt;/pre&gt;

&lt;p&gt;Дизайн интерфейса &lt;code&gt;Gatherer&lt;/code&gt; был создан под влиянием интерфейса &lt;code&gt;Collector&lt;/code&gt;. Вот основная часть его сигнатуры:&lt;/p&gt;
&lt;pre&gt;public interface Gatherer&amp;lt;T, A, R&gt; {
    Supplier&amp;lt;A&gt; initializer();
    Integrator&amp;lt;A, T, R&gt; integrator();
    BinaryOperator&amp;lt;A&gt; combiner();
    BiConsumer&amp;lt;A, Downstream&amp;lt;? super R&gt;&gt; finisher();
}&lt;/pre&gt;
&lt;p&gt;Если взглянуть на &lt;code&gt;Collector&lt;/code&gt;, то он также имеет три параметра &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt; и содержит 4 основных метода: &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#supplier()"&gt;&lt;code&gt;supplier&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#accumulator()"&gt;&lt;code&gt;accumulator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#combiner()"&gt;&lt;code&gt;combiner&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collector.html#finisher()"&gt;&lt;code&gt;finisher&lt;/code&gt;&lt;/a&gt;. Однако &lt;code&gt;Gatherer&lt;/code&gt; использует два вспомогательных интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"&gt;&lt;code&gt;Integrator&lt;/code&gt;&lt;/a&gt; и
  &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"&gt;&lt;code&gt;Downstream&lt;/code&gt;&lt;/a&gt;, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.&lt;/p&gt;
&lt;p&gt;Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс &lt;code&gt;Gatherer&lt;/code&gt; и можно воспользоваться готовыми методами-фабриками: &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::of(Integrator)&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::ofSequential(Integrator)&lt;/code&gt;&lt;/a&gt; или другими вариациями.&lt;/p&gt;

&lt;p&gt;Stream gatherers станут постоянным API &lt;a href="https://openjdk.org/jeps/485"&gt;в Java 24&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/466"&gt;Class-File API (Second Preview) (JEP 466)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Стандартное API для парсинга, генерации и трансформации class-файлов, которое &lt;a href="https://openjdk.org/jeps/457"&gt;появилось в Java 22&lt;/a&gt;, остаётся на второе preview с несколькими изменениями.&lt;/p&gt;
&lt;p&gt;Новое API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/classfile/package-summary.html"&gt;&lt;code&gt;java.lang.classfile&lt;/code&gt;&lt;/a&gt;. Оно должно заменить копию библиотеки &lt;a href="https://asm.ow2.io/"&gt;ASM&lt;/a&gt; внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.&lt;/p&gt;
&lt;p&gt;Основная проблема ASM (и других библиотек для работы с class-файлами) &amp;ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &amp;ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.&lt;/p&gt;
&lt;p&gt;Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &amp;ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.&lt;/p&gt;

&lt;p&gt;Class-File API станет постоянным API &lt;a href="https://openjdk.org/jeps/484"&gt;в Java 24&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/471"&gt;Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (JEP 471)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В классе &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; все методы доступа к памяти стали deprecated for removal. Это 77 из 87 методов (в JEP написано 79 из 87, но, похоже, автор посчитал неправильно). При этом 3 из них стали deprecated for removal ещё &lt;a href="https://bugs.openjdk.org/browse/JDK-8278223"&gt;в Java 18&lt;/a&gt;: &lt;code&gt;objectFieldOffset()&lt;/code&gt;, &lt;code&gt;staticFieldOffset()&lt;/code&gt; и &lt;code&gt;staticFieldBase()&lt;/code&gt;. Также &lt;a href="https://bugs.openjdk.org/browse/JDK-8315953"&gt;в Java 22&lt;/a&gt; стали deprecated for removal 6 методов, не относящиеся к памяти: &lt;code&gt;park()&lt;/code&gt;, &lt;code&gt;unpark()&lt;/code&gt;, &lt;code&gt;fullFence()&lt;/code&gt;, &lt;code&gt;loadFence()&lt;/code&gt;, &lt;code&gt;storeFence()&lt;/code&gt; и &lt;code&gt;getLoadAverage()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, в &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; остаётся всего 4 метода, которые пока не являются deprecated, причём один из них &amp;ndash; это &lt;code&gt;getUnsafe()&lt;/code&gt;, который получает сам объект &lt;code&gt;Unsafe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;По факту всё это означает, что &lt;code&gt;Unsafe&lt;/code&gt; больше крайне не рекомендуется использовать. Вместо методов доступа к памяти необходимо использовать стандартное API в Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/invoke/VarHandle.html"&gt;&lt;code&gt;java.lang.invoke.VarHandle&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для манипуляций с памятью внутри кучи, появилось &lt;a href="https://openjdk.org/jeps/193"&gt;в Java 9&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;java.lang.foreign.MemorySegment&lt;/code&gt;&lt;/a&gt; &amp;ndash; API для доступа к памяти вне кучи (часто в кооперации с &lt;code&gt;VarHandle&lt;/code&gt;), появилось &lt;a href="https://openjdk.org/jeps/454"&gt;в Java 22&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Использования deprecated методов в &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; будут вызывать предупреждения во время компиляции:&lt;/p&gt;
&lt;pre&gt;HelloWorld.java:4: warning: [removal] getByte(long) in Unsafe has been deprecated and marked for removal
        unsafe.getByte(address);
              ^&lt;/pre&gt;

&lt;p&gt;В дополнение к предупреждениям на этапе компиляции появится возможность включать предупреждения в рантайме при использовании методов доступа к памяти. Для этого появилась новая опция командной строки &lt;code&gt;--sun-misc-unsafe-memory-access={allow|warn|debug|deny}&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=allow&lt;/code&gt; &amp;ndash; при вызове методов предупреждения нет (дефолтное значение в Java 23).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=warn&lt;/code&gt; &amp;ndash; выдаётся предупреждение при первом вызове (станет дефолтным значением в Java 24 или 25).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=debug&lt;/code&gt; &amp;ndash; выдаётся предупреждение при каждом вызове.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--sun-misc-unsafe-memory-access=deny&lt;/code&gt; &amp;ndash; выбрасывается &lt;code&gt;UnsupportedOperationException&lt;/code&gt; (станет дефолтным значением в Java 26 или позже; &lt;code&gt;allow&lt;/code&gt; использовать будет нельзя).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В конце концов методы доступа к памяти будут удалены совсем (опция &lt;code&gt;--sun-misc-unsafe-memory-access&lt;/code&gt; будет игнорироваться какое-то время, а потом удалится).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/480"&gt;Structured Concurrency (Third Preview) (JEP 480)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое находится в режиме preview &lt;a href="https://openjdk.org/jeps/453"&gt;с Java 21&lt;/a&gt;, остаётся на третий раунд preview без изменений (&lt;a href="https://openjdk.org/jeps/462"&gt;в Java 22&lt;/a&gt; также не было изменений). До этого оно было в инкубаторе в &lt;a href="https://openjdk.org/jeps/428"&gt;Java 19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;Java 20&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
  &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
  &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
  &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/481"&gt;Scoped Values (Third Preview) (JEP 481)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые стали preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt; и остались на второе preview в &lt;a href="https://openjdk.org/jeps/464"&gt;Java 22&lt;/a&gt;, уходят на третье preview. До этого Scoped Values были в инкубаторе в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В третье preview было внесено пару изменений: метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#callWhere(java.lang.ScopedValue,T,java.lang.ScopedValue.CallableOp)"&gt;&lt;code&gt;callWhere()&lt;/code&gt;&lt;/a&gt; третьим аргументом теперь принимает новый функциональный интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.CallableOp.html"&gt;&lt;code&gt;CallableOp&lt;/code&gt;&lt;/a&gt; вместо &lt;code&gt;Callable&lt;/code&gt;, а также удалён метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#getWhere(java.lang.ScopedValue,T,java.util.function.Supplier)"&gt;&lt;code&gt;getWhere()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Класс &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
  &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
  &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/469"&gt;Vector API (Eighth Incubator) (JEP 469)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/23/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в восьмой раз без изменений.&lt;/p&gt;
&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API сразу же перейдёт из инкубатора в статус preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/474"&gt;ZGC: Generational Mode by Default (JEP 474)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Режим работы с поколениями, который появился в сборщике мусора ZGC &lt;a href="https://openjdk.org/jeps/439"&gt;в Java 21&lt;/a&gt;, стал включённым по умолчанию. То есть теперь опция &lt;code&gt;-XX:+UseZGC&lt;/code&gt; автоматически включает опцию &lt;code&gt;-XX:+ZGenerational&lt;/code&gt;. Для выключения режима необходимо указать опцию &lt;code&gt;-XX:-ZGenerational&lt;/code&gt;. Однако режим без поколений стал deprecated, и в будущем планируется его окончательное удаление (вместе с опцией &lt;code&gt;-XX:&amp;pm;ZGenerational&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в &lt;a href="https://openjdk.org/jeps/248"&gt;Java 9&lt;/a&gt; (до него дефолтным был Parallel GC)&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 22</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_22.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_22.html</id>
    <updated>2024-03-18T19:00:00Z</updated>
    <published>2024-03-18T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/22/"&gt;Java 22&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-22.html"&gt;2300 закрытых задач и 12 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/22/release-notes"&gt;здесь&lt;/a&gt;. Полный список изменений API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/22/apidiff/21/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java 22 не является LTS-релизом, и у неё будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;только полгода&lt;/a&gt; (до сентября 2024 года).&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 22 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://jdk.java.net/22/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Рассмотрим все JEP'ы, которые попали в Java 22.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/456"&gt;Unnamed Variables &amp; Patterns (JEP 456)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Безымянные переменные и паттерны, которые появились &lt;a href="https://openjdk.org/jeps/443"&gt;в режиме preview в Java 21&lt;/a&gt;, теперь стали постоянной языковой конструкцией.&lt;/p&gt;

&lt;p&gt;Безымянная переменная &amp;ndash; это переменная, которая обозначена автором как неиспользуемая и обозначаемая символом подчёркивания (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Неиспользуемые переменные довольно часто встречаются на практике:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static int&lt;/span&gt; count(Iterable&amp;lt;Order&gt; orders) {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; total = 0;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Order _ : orders) &lt;span style="color: green"&gt;// order is unused&lt;/span&gt;
        total++;
    &lt;span style="color: blue"&gt;return&lt;/span&gt; total;
}&lt;/pre&gt;
&lt;p&gt;В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому для неё был выбран символ подчёркивания вместо имени. Другой пример:&lt;/p&gt;
&lt;pre&gt;Queue&amp;lt;Integer&gt; q = &lt;span style="color: grey"&gt;...&lt;/span&gt; &lt;span style="color: green"&gt;// x1, y1, z1, x2, y2, z2, ...&lt;/span&gt;
&lt;span style="color: blue"&gt;while&lt;/span&gt; (q.size() &gt;= 3) {
   &lt;span style="color: blue"&gt;var&lt;/span&gt; x = q.remove();
   &lt;span style="color: blue"&gt;var&lt;/span&gt; y = q.remove();
   &lt;span style="color: blue"&gt;var&lt;/span&gt; _ = q.remove();
   &lt;span style="color: grey"&gt;... new Point(x, y) ...&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Здесь были необходимы только координаты &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt;, поэтому для третьей координаты была явно выбрана безымянная переменная, чтобы явно продемонстрировать, что она не используется.&lt;/p&gt;

&lt;p&gt;Частый случай необходимости безымянных переменных &amp;ndash; это неиспользуемые исключения в блоке &lt;code&gt;catch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = ...
&lt;span style="color: blue"&gt;try&lt;/span&gt; {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    &lt;span style="color: grey"&gt;... i ...&lt;/span&gt;
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Здесь важен сам факт наличия исключения, но не само исключение.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try&lt;/code&gt; с ресурсом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; _ = ScopedContext.acquire()) {
    &lt;span style="color: grey"&gt;... no use of acquired resource ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Ну и, конечно же, неиспользуемые параметры лямбда-выражений:&lt;/p&gt;
&lt;pre&gt;...stream.collect(Collectors.toMap(String::toUpperCase, _ -&gt; &lt;span style="color: darkred"&gt;"NODATA"&lt;/span&gt;))&lt;/pre&gt;

&lt;p&gt;Во всех примерах выше использование символа подчёркивания делает код короче и читабельнее, явно обозначает намерения автора и уменьшает пространство для допущения ошибок. Также оно помогает инструментам статического анализа, которые могут жаловаться на неиспользуемые переменные.&lt;/p&gt;

&lt;p&gt;Безымянными могут быть не только переменные, но и &lt;i&gt;паттерны&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), _)) {
    &lt;span style="color: grey"&gt;... x ... y ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Аналогичным образом можно извлечь только цвет, если нужен только он, но не нужны координаты:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(_, Color c)) {
    &lt;span style="color: grey"&gt;... c ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Также есть возможность объявлять &lt;i&gt;безымянные переменные паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (ball) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RedBall _   -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; BlueBall _  -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GreenBall _ -&gt; stopProcessing();
}&lt;/pre&gt;

&lt;p&gt;Код выше можно сократить, объединив две первые ветки &lt;code&gt;case&lt;/code&gt; в одну:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (ball) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; RedBall _, BlueBall _  -&gt; process(ball);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; GreenBall _            -&gt; stopProcessing();
}&lt;/pre&gt;

&lt;p&gt;Заметим, что такое объединение было бы невозможным без использования безымянных паттернов, так как раньше несколько паттернов в одной ветке разрешались только при отсутствии в них переменных паттернов.&lt;/p&gt;

&lt;p&gt;Более сложный пример со вложенными паттернами, где есть и безымянные паттерны, и безымянные переменные паттернов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(RedBall _), Box(BlueBall _) -&gt; processBox(box);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(GreenBall _)                -&gt; stopProcessing();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(_)                          -&gt; pickAnotherBox();
}&lt;/pre&gt;

&lt;p&gt;В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/458"&gt;Launch Multi-File Source-Code Programs (JEP 458)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь лаунчер &lt;code&gt;java&lt;/code&gt; может запускать программы, состоящие из нескольких исходных файлов Java.&lt;/p&gt;
&lt;p&gt;Напомним, что ранее в Java 11 появилась возможность запускать программы, состоящие из одного файла, без необходимости самостоятельной компиляции (&lt;a href="https://openjdk.org/jeps/330"&gt;JEP 330&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Prog.java&lt;/span&gt;

&lt;span style="color: blue"&gt;class&lt;/span&gt; Prog {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) { Helper.run(); }
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; Helper {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; run() { System.out.println(&lt;span style="color: darkred"&gt;"Hello!"&lt;/span&gt;); }
}
&lt;/pre&gt;
&lt;p&gt;Такой файл можно было запустить, просто написав:&lt;/p&gt;
&lt;pre&gt;$ java Prog.java
Hello!&lt;/pre&gt;

&lt;p&gt;А сейчас эта возможность была расширена до произвольного количества файлов:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Prog.java&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; Prog {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String[] args) { Helper.run(); }
}

&lt;span style="color: green"&gt;// Helper.java&lt;/span&gt;
&lt;span style="color: blue"&gt;class&lt;/span&gt; Helper {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; run() { System.out.println(&lt;span style="color: darkred"&gt;"Hello!"&lt;/span&gt;); }
}&lt;/pre&gt;
&lt;p&gt;Если программу выше запустить через &lt;code&gt;java Prog.java&lt;/code&gt;, то Java скомпилирует в память класс &lt;code&gt;Prog&lt;/code&gt; и запустит его метод &lt;code&gt;main&lt;/code&gt;. Так как класс &lt;code&gt;Prog&lt;/code&gt; ссылается на класс &lt;code&gt;Helper&lt;/code&gt;, то Java найдёт его в файле &lt;code&gt;Helper.java&lt;/code&gt; и тоже скомпилирует его. Таким образом, программа, разбитая на два файла будет работать точно так же, как если бы все классы были помещены в один исходный файл. Этот алгоритм может быть расширен до произвольного количества файлов. Например, если &lt;code&gt;Helper&lt;/code&gt; ссылается ещё на один класс &lt;code&gt;HelperAux&lt;/code&gt;, то будет найден и скомпилирован файл &lt;code&gt;HelperAux.java&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Возможность запускать без отдельного шага компиляции программы, состоящие из нескольких исходных файлов, может быть очень полезной. Главным образом, это может пригодиться для быстрого прототипирования или на ранних стадиях проектов, когда проект ещё не обрёл более-менее стабильную форму. В таких случаях у разработчика есть возможность пропустить стадию настройки сборки проекта и сразу приступить к написанию кода, не ограничиваясь при этом одним исходным файлом (что пришлось бы делать до Java 22). Для некоторых несложных проектов такая конфигурация запуска без инструментов сборки может и вовсе оставаться постоянной.&lt;/p&gt;

&lt;p&gt;Программы, использующие библиотеки в виде уже скомпилированных jar-файлов, также могут быть запущены напрямую. Например, если есть структура:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Prog.java&lt;/li&gt;
    &lt;li&gt;Helper.java&lt;/li&gt;
    &lt;li&gt;libs/library.jar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;То такую программу можно запустить с помощью опции &lt;code&gt;--class-path&lt;/code&gt; (или &lt;code&gt;-cp&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;$ java --class-path "libs/*" Prog.java&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/459"&gt;String Templates (Second Preview) (JEP 459)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Строковые шаблоны, которые появились в режиме preview &lt;a href="https://openjdk.org/jeps/430"&gt;в Java 21&lt;/a&gt;, уходят на второй раунд preview без изменений.&lt;/p&gt;
&lt;p&gt;Строковые шаблоны &amp;ndash; это новая синтаксическая возможность, позволяющая встраивать в строки выражения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = 10;
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = 20;
&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
String str = STR.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
&lt;span style="color: green"&gt;// В str будет лежать "10 + 20 equals 30"&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;То есть это строковая интерполяция, которая уже давно есть во многих других известных языках программирования.&lt;/p&gt;

&lt;p&gt;Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html"&gt;&lt;code&gt;java.lang.StringTemplate&lt;/code&gt;&lt;/a&gt;, а затем &lt;i&gt;процессор&lt;/i&gt;, реализующий &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html"&gt;&lt;code&gt;java.lang.StringTemplate.Processor&lt;/code&gt;&lt;/a&gt;, конвертирует этот объект в строку или объект другого класса (&lt;i&gt;примечание: сейчас &lt;a href="https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html"&gt;идут обсуждения&lt;/a&gt; относительно отказа идеи процессоров и оставления только &lt;code&gt;StringTemplate&lt;/code&gt;&lt;/i&gt;). В примере выше &lt;code&gt;STR."…"&lt;/code&gt; есть ничто иное, как сокращённый вариант следующего кода:&lt;/p&gt;
&lt;pre&gt;StringTemplate template = RAW.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
String str = STR.process(template);&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#STR"&gt;&lt;code&gt;STR&lt;/code&gt;&lt;/a&gt; &amp;ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. &lt;code&gt;STR&lt;/code&gt; неявно импортируется в любой исходный файл, поэтому его можно использовать без &lt;code&gt;import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.html#RAW"&gt;&lt;code&gt;RAW&lt;/code&gt;&lt;/a&gt; &amp;ndash; это процессор, который ничего не делает со &lt;code&gt;StringTemplate&lt;/code&gt; и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.&lt;/p&gt;

&lt;p&gt;Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/FormatProcessor.html#FMT"&gt;&lt;code&gt;FMT&lt;/code&gt;&lt;/a&gt; поддерживает форматирование с использованием спецификаторов, определённых в &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;java.util.Formatter&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;double&lt;/span&gt; length = 46;
System.out.println(FMT.&lt;span style="color: darkred"&gt;"The length is %.2f&lt;/span&gt;\{length} &lt;span style="color: darkred"&gt;cm"&lt;/span&gt;);
&lt;span style="color: green"&gt;// The length is 46.00 cm&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Процессоры необязательно должны возвращать &lt;code&gt;String&lt;/code&gt;. Вот общая сигнатура метода &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"&gt;&lt;code&gt;process()&lt;/code&gt;&lt;/a&gt; интерфейса &lt;code&gt;Processor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public interface&lt;/span&gt; Processor&amp;lt;R, E &lt;span style="color: blue"&gt;extends&lt;/span&gt; Throwable&gt; {
    R process(StringTemplate stringTemplate) &lt;span style="color: blue"&gt;throws&lt;/span&gt; E;
}&lt;/pre&gt;
&lt;p&gt;Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор &lt;code&gt;JSON&lt;/code&gt; будет создавать напрямую объекты JSON (без промежуточного объекта &lt;code&gt;String&lt;/code&gt;) и при этом поддерживать экранирование кавычек:&lt;/p&gt;
&lt;pre&gt;JSONObject doc = JSON.&lt;span style="color: darkred"&gt;"""&lt;/span&gt;
    &lt;span style="color: darkred"&gt;{&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"name":    "&lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"phone":   "&lt;/span&gt;\{phone}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"address": "&lt;/span&gt;\{address}&lt;span style="color: darkred"&gt;"&lt;/span&gt;
    };
    &lt;span style="color: darkred"&gt;"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt; или &lt;code&gt;address&lt;/code&gt; будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит &lt;code&gt;&amp;quot;&lt;/code&gt; на &lt;code&gt;\&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Или, например, процессор &lt;code&gt;SQL&lt;/code&gt; будет создавать PreparedStatement'ы, защищая от атак SQL Injection:&lt;/p&gt;
&lt;pre&gt;PreparedStatement ps = SQL.&lt;span style="color: darkred"&gt;"SELECT * FROM Person p WHERE p.name = &lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;

&lt;p&gt;Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/447"&gt;Statements before &lt;code&gt;super(...)&lt;/code&gt; (Preview) (JEP 447)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview теперь стало возможным писать инструкции кода в конструкторе перед явным вызовом конструктора (&lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value);
    }
}&lt;/pre&gt;

&lt;p&gt;Напомним, что с самого первого релиза Java 1.0 это было запрещено, поэтому в случаях, когда необходимо выполнить код перед вызовом конструктора, приходилось использовать обходные пути, например, прибегать к вспомогательным статическим методам:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(verifyPositive(value));
    }

    &lt;span style="color: blue"&gt;private static long&lt;/span&gt; verifyPositive(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (&lt;span style="color: blue"&gt;value&lt;/span&gt; &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Или к вспомогательным конструкторам, если нужно передать одно и то же значение для нескольких параметров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;private&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i, F f) { &lt;span style="color: green"&gt;// Auxiliary constructor&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(f, f); &lt;span style="color: green"&gt;// f is shared here&lt;/span&gt;
        ...
    }

    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;(i, &lt;span style="color: blue"&gt;new&lt;/span&gt; F());
    }
}&lt;/pre&gt;

&lt;p&gt;В Java 22, включив режим preview, то же самое можно реализовать гораздо короче:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// --enable-preview --release 22&lt;/span&gt;
&lt;span style="color: blue"&gt;public class&lt;/span&gt; Sub &lt;span style="color: blue"&gt;extends&lt;/span&gt; Super {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; Sub(&lt;span style="color: blue"&gt;int&lt;/span&gt; i) {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; f = &lt;span style="color: blue"&gt;new&lt;/span&gt; F();
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(f, f); &lt;span style="color: green"&gt;// f is shared here&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Не всякий код можно поместить перед вызовом конструктора: код в прологе не должен ссылаться на конструируемый объект. Это обеспечивает гарантию того, что инициализация всегда происходит сверху-вниз: инициализация полей суперкласса должна всегда выполняться раньше инициализации полей подкласса (&lt;i&gt;возможно такое ограничение смягчат в Java 23 &lt;a href="https://openjdk.org/jeps/8325803"&gt;в следующем preview&lt;/a&gt;&lt;/i&gt;). Рассмотрим несколько примеров некорректного кода:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; A {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.i++;               &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        hashCode();             &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        System.out.print(&lt;span style="color: blue"&gt;this&lt;/span&gt;); &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Ссылаться на поля суперкласса также нельзя (ведь это тоже часть текущего объекта):&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; D {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;
}

&lt;span style="color: blue"&gt;class&lt;/span&gt; A &lt;span style="color: blue"&gt;extends&lt;/span&gt; D {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i;

    A() {
        &lt;span style="color: blue"&gt;super&lt;/span&gt;.i++; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Также запрещены ситуации, когда есть неявная ссылка на объект, например, через экземпляр внутреннего класса:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;class&lt;/span&gt; Inner {
    }

    Outer() {
        &lt;span style="color: blue"&gt;new&lt;/span&gt; Inner(); &lt;span style="color: red"&gt;// Error - 'this' is enclosing instance&lt;/span&gt;
        &lt;span style="color: blue"&gt;super&lt;/span&gt;();
    }
}&lt;/pre&gt;

&lt;p&gt;Интересно, что новая возможность затрагивает исключительно компилятор Java &amp;ndash; JVM уже и так давно поддерживает байткод, в котором присутствуют инструкции перед вызовом &lt;code&gt;super()&lt;/code&gt; или &lt;code&gt;this()&lt;/code&gt;, если эти инструкции не трогают конструируемый объект (JVM даже ещё более либеральна, например, она разрешает несколько вызовов конструкторов, если любой путь обязательно завершается одним вызовом конструктора).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/463"&gt;Implicitly Declared Classes and Instance Main Methods (Second Preview) (JEP 463)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В Java 21 в режиме preview появились &lt;a href="https://openjdk.org/jeps/445"&gt;Unnamed Classes and Instance Main Methods&lt;/a&gt;. В Java 22 было принято решение оставить эту фичу на второе preview с некоторыми изменениями. Основное из них &amp;ndash; это отказ от &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isUnnamedClass()"&gt;безымянных классов&lt;/a&gt; в пользу неявно объявленных классов. Также упрощена процедура выбора &lt;code&gt;main&lt;/code&gt;-метода для запуска: если есть метод &lt;code&gt;main&lt;/code&gt; с &lt;code&gt;String[] args&lt;/code&gt;, то запускается он (неважно, &lt;code&gt;static&lt;/code&gt; или нет), иначе запускается метод &lt;code&gt;main&lt;/code&gt; без аргументов.&lt;/p&gt;
&lt;p&gt;Новый протокол запуска позволяет запускать классы, у которых метод &lt;code&gt;main()&lt;/code&gt; не является &lt;code&gt;public static&lt;/code&gt; и у которого нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае во время запуска JVM сама создаст экземпляр класса &lt;code&gt;HelloWorld&lt;/code&gt; и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;$ java --enable-preview --source 22 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p class="mt-2"&gt;Кроме того, новый протокол может запускать программы и без объявленного класса вовсе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// HelloWorld.java&lt;/span&gt;

String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;pre&gt;$ java --enable-preview --source 22 HelloWorld.java
Hello, World!&lt;/pre&gt;

&lt;p&gt;В таком случае виртуальная машина сама объявит неявный класс, в который поместит метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Неявный класс обладает практически всеми возможностями явного класса (возможность содержать методы, поля), но есть несколько отличий:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Код в неявном классе не может ссылаться на него по имени.&lt;/li&gt;
  &lt;li&gt;Неявный класс всегда имеет один неявный конструктор без аргументов.&lt;/li&gt;
  &lt;li&gt;Неявный класс может находиться только в безымянном пакете.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом неявный класс не является безымянным: у него есть &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt;, совпадающее с именем файла (но это является деталью реализации, на которую не стоит полагаться).&lt;/p&gt;

&lt;p class="mt-2"&gt;Упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
  &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/461"&gt;Stream Gatherers (Preview) (JEP 461)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Stream API был усовершенствован, чтобы поддерживать произвольные промежуточные операции, в режиме preview.&lt;/p&gt;
&lt;p&gt;Напомним, что стримы с появления в Java 8 имели фиксированный набор промежуточных операций (&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#map(java.util.function.Function)"&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate)"&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)"&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#limit(long)"&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/a&gt;,
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#skip(long)"&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; и т.д). В Java 9 были добавлены &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"&gt;&lt;code&gt;dropWhile&lt;/code&gt;&lt;/a&gt;. Хотя этот стандартный набор операций довольно богатый и покрывает большинство случаев, иногда бывают необходимы более изощрённые промежуточные операции для более сложных задач. Чтобы решить эту проблему, было предложено создать точку расширения для стримов, которая позволит кому угодно создать свои промежуточные операции.&lt;/p&gt;
&lt;p&gt;Новая точка расширения &amp;ndash; это новый метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)"&gt;&lt;code&gt;Stream::gather(Gatherer)&lt;/code&gt;&lt;/a&gt;, который обрабатывает элементы стрима путём применения объекта, реализующего интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html"&gt;&lt;code&gt;Gatherer&lt;/code&gt;&lt;/a&gt;, предоставляемого пользователем. Операция &lt;code&gt;gather()&lt;/code&gt; аналогична уже имеющейся операции &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)"&gt;&lt;code&gt;Stream::collect(Collector)&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;collect()&lt;/code&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html"&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; определяют точку расширения для терминальных операций, то &lt;code&gt;gather()&lt;/code&gt; и &lt;code&gt;Gatherer&lt;/code&gt; определяют точкой расширения для промежуточных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gatherer&lt;/code&gt; представляет собой трансформацию элементов стрима. Манера трансформации может быть совершенно произвольной: one-to-one, one-to-many, many-to-one или many-to-many. Поддерживается короткое замыкание, если надо в какой-то момент остановить обработку и отбросить все дальнейшие элементы. Бесконечные стримы могут преобразовываться в конечные, и наоборот, конечные могут преобразовываться в бесконечные. Поддерживается параллельное исполнение. Всё это возможно благодаря максимально обобщённой форме интерфейса &lt;code&gt;Gatherer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gather()&lt;/code&gt; также является промежуточной операцией, поэтому может быть несколько &lt;code&gt;gather()&lt;/code&gt; в одной цепочке:&lt;/p&gt;
&lt;pre&gt;source.gather(a).gather(b).gather(c).collect(...)&lt;/pre&gt;

&lt;p&gt;Вместе с самим &lt;code&gt;Gatherer&lt;/code&gt; было добавлено несколько готовых gatherer'ов, определённых в новом классе &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html"&gt;&lt;code&gt;Gatherers&lt;/code&gt;&lt;/a&gt;. Это &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#fold(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#mapConcurrent(int,java.util.function.Function)"&gt;&lt;code&gt;mapConcurrent&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#scan(java.util.function.Supplier,java.util.function.BiFunction)"&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowFixed(int)"&gt;&lt;code&gt;windowFixed&lt;/code&gt;&lt;/a&gt; и
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherers.html#windowSliding(int)"&gt;&lt;code&gt;windowSliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Давайте рассмотрим несколько примеров:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.fold(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .findFirst()
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .get();
&lt;span style="color: grey"&gt;$1 ==&gt;&lt;/span&gt; "123456789"&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8,9)
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .gather(Gatherers.scan(() -&gt; "", (str, n) -&gt; str + n))
   &lt;span style="color: grey"&gt;...&gt;&lt;/span&gt;       .toList()
&lt;span style="color: grey"&gt;$2 ==&gt;&lt;/span&gt; [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList()
&lt;span style="color: grey"&gt;$3 ==&gt;&lt;/span&gt; [[1, 2, 3], [4, 5, 6], [7, 8]]&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: grey"&gt;jshell&gt;&lt;/span&gt; Stream.of(1,2,3,4,5,6).gather(Gatherers.windowSliding(3)).toList()
&lt;span style="color: grey"&gt;$4 ==&gt;&lt;/span&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]&lt;/pre&gt;

&lt;p&gt;Дизайн интерфейса &lt;code&gt;Gatherer&lt;/code&gt; был создан под влиянием интерфейса &lt;code&gt;Collector&lt;/code&gt;. Вот основная часть его сигнатуры:&lt;/p&gt;
&lt;pre&gt;public interface Gatherer&amp;lt;T, A, R&gt; {
    Supplier&amp;lt;A&gt; initializer();
    Integrator&amp;lt;A, T, R&gt; integrator();
    BinaryOperator&amp;lt;A&gt; combiner();
    BiConsumer&amp;lt;A, Downstream&amp;lt;? super R&gt;&gt; finisher();
}&lt;/pre&gt;
&lt;p&gt;Если взглянуть на &lt;code&gt;Collector&lt;/code&gt;, то он также имеет три параметра &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt; и содержит 4 основных метода: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#supplier()"&gt;&lt;code&gt;supplier&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#accumulator()"&gt;&lt;code&gt;accumulator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#combiner()"&gt;&lt;code&gt;combiner&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Collector.html#finisher()"&gt;&lt;code&gt;finisher&lt;/code&gt;&lt;/a&gt;. Однако &lt;code&gt;Gatherer&lt;/code&gt; использует два вспомогательных интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Integrator.html"&gt;&lt;code&gt;Integrator&lt;/code&gt;&lt;/a&gt; и
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.Downstream.html"&gt;&lt;code&gt;Downstream&lt;/code&gt;&lt;/a&gt;, так как поддержка произвольных промежуточных операций требует немного более сложного устройства, чем терминальных.&lt;/p&gt;
&lt;p&gt;Для написания собственных gatherer'ов, как правило, не приходится с нуля реализовывать интерфейс &lt;code&gt;Gatherer&lt;/code&gt; и можно воспользоваться готовыми методами-фабриками: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#of(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::of(Integrator)&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.stream.Gatherer.Integrator)"&gt;&lt;code&gt;Gatherer::ofSequential(Integrator)&lt;/code&gt;&lt;/a&gt; или другими вариациями.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/457"&gt;Class-File API (Preview) (JEP 457)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В режиме preview появилось стандартное API для парсинга, генерации и трансформации class-файлов.&lt;/p&gt;
&lt;p&gt;Новое API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/classfile/package-summary.html"&gt;&lt;code&gt;java.lang.classfile&lt;/code&gt;&lt;/a&gt;. Оно должно заменить копию библиотеки &lt;a href="https://asm.ow2.io/"&gt;ASM&lt;/a&gt; внутри JDK, которую планируется удалить, как только все компоненты JDK перейдут с неё на новое API.&lt;/p&gt;
&lt;p&gt;Основная проблема ASM (и других библиотек для работы с class-файлами) &amp;ndash; это то, что она не успевает за ускорившимся в последнее время темпом выхода релизов JDK (два раза в год), а соответственно, и за изменениями в формате class-файлов. Кроме того, ASM &amp;ndash; это сторонняя библиотека, а значит её поддержка возможностей class-файлов всегда отстаёт от JDK, что создаёт проблемы как в экосистеме, так и в самой JDK. Стандартное API же эволюционирует одновременно с форматом class-файлов. Как только выходит новая версия Java, фреймворки и инструменты, использующие API, немедленно и автоматически получают поддержку нового формата.&lt;/p&gt;
&lt;p&gt;Новое API также спроектировано с учётом новых возможностей Java, таких, как лямбды, записи, sealed-классы и паттерн-матчинг. ASM же &amp;ndash; очень старая библиотека, основанная на визиторах, что совершенно неуместно в 2024 году.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/462"&gt;Structured Concurrency (Second Preview) (JEP 462)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured Concurrency, которое перешло в режим preview &lt;a href="https://openjdk.org/jeps/453"&gt;в Java 21&lt;/a&gt;, уходит на второй раунд preview без изменений. Ранее оно было в инкубаторе в &lt;a href="https://openjdk.org/jeps/428"&gt;Java 19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;Java 20&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
    &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
    &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
    &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/464"&gt;Scoped Values (Second Preview) (JEP 464)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые стали preview в &lt;a href="https://openjdk.org/jeps/446"&gt;Java 21&lt;/a&gt;, как и Structured Concurrency, уходят на второе preview без изменений. До этого Scoped Values были в инкубаторе в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/454"&gt;Foreign Function &amp; Memory API (JEP 454)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, которое было долго в режиме preview (а до этого ещё дольше в инкубаторе), наконец-то стабилизировалось.&lt;/p&gt;
&lt;p&gt;Главной задачей FFM API является замена устаревшего JNI, который является опасным и хрупким средством вызова нативных библиотек и обработки нативных данных. FFM API, напротив, создан как безопасное, удобное, читаемое и эффективное средство интеропа со средой вне Java.&lt;/p&gt;
&lt;p&gt;FFM API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;. Оно состоит из двух частей: API для доступа к внешней памяти (foreign memory) и API для вызова внешних функций (foreign functions).&lt;/p&gt;
&lt;p&gt;API для доступа к внешней памяти предоставляет классы и интерфейсы, которые позволяют выделять, освобождать внешнюю память и манипулировать ею: &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SegmentAllocator.html"&gt;&lt;code&gt;SegmentAllocator&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;. Также оно использует уже существующий класс &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/VarHandle.html"&gt;&lt;code&gt;VarHandle&lt;/code&gt;&lt;/a&gt;. API для вызова внешних функций предоставляет классы и интерфейсы
    &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Linker.html"&gt;&lt;code&gt;Linker&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/SymbolLookup.html"&gt;&lt;code&gt;SymbolLookup&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/FunctionDescriptor.html"&gt;&lt;code&gt;FunctionDescriptor&lt;/code&gt;&lt;/a&gt;. Для непосредственно вызовов используется привычный &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/invoke/MethodHandle.html"&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Вот небольшой пример использования FFM API, в котором код на Java получает &lt;code&gt;MethodHandle&lt;/code&gt; для функции &lt;code&gt;radixsort&lt;/code&gt;, написанной на C, и вызывает её для сортировки массива из 4 строк:&lt;/p&gt;

&lt;pre&gt;&lt;span style="color: green"&gt;// 1. Find foreign function on the C library path&lt;/span&gt;
Linker linker          = Linker.nativeLinker();
SymbolLookup stdlib    = linker.defaultLookup();
MethodHandle radixsort = linker.downcallHandle(stdlib.find(&lt;span style="color: darkred"&gt;"radixsort"&lt;/span&gt;), ...);
&lt;span style="color: green"&gt;// 2. Allocate on-heap memory to store four strings&lt;/span&gt;
String[] javaStrings = { &lt;span style="color: darkred"&gt;"mouse"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"cat"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"dog"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"car"&lt;/span&gt; };

&lt;span style="color: green"&gt;// 3. Use try-with-resources to manage the lifetime of off-heap memory&lt;/span&gt;
&lt;span style="color: blue"&gt;try&lt;/span&gt; (Arena offHeap = Arena.ofConfined()) {
    &lt;span style="color: green"&gt;// 4. Allocate a region of off-heap memory to store four pointers&lt;/span&gt;
    MemorySegment pointers
        = offHeap.allocate(ValueLayout.ADDRESS, javaStrings.length);
    &lt;span style="color: green"&gt;// 5. Copy the strings from on-heap to off-heap&lt;/span&gt;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 0; i &lt; javaStrings.length; i++) {
        MemorySegment cString = offHeap.allocateFrom(javaStrings[i]);
        pointers.setAtIndex(ValueLayout.ADDRESS, i, cString);
    }
    &lt;span style="color: green"&gt;// 6. Sort the off-heap data by calling the foreign function&lt;/span&gt;
    radixsort.invoke(pointers, javaStrings.length, MemorySegment.NULL, &lt;span style="color: darkred"&gt;'\0'&lt;/span&gt;);
    &lt;span style="color: green"&gt;// 7. Copy the (reordered) strings from off-heap to on-heap&lt;/span&gt;
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; i = 0; i &lt; javaStrings.length; i++) {
        MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);
        javaStrings[i] = cString.reinterpret(...).getString(0);
    }
} &lt;span style="color: green"&gt;// 8. All off-heap memory is deallocated here&lt;/span&gt;

&lt;span style="color: blue"&gt;assert&lt;/span&gt; Arrays.equals(javaStrings,
                     &lt;span style="color: blue"&gt;new&lt;/span&gt; String[] {&lt;span style="color: darkred"&gt;"car"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"cat"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"dog"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"mouse"&lt;/span&gt;});  &lt;span style="color: green"&gt;// true&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Этот код гораздо чище и прозрачнее, чем любое решение с использованием JNI.&lt;/p&gt;

&lt;p&gt;Большая часть FFM API является безопасной по умолчанию. Многие задачи, для которых ранее необходимо было писать нативный код, вызываемый через JNI, теперь решаются написанием только Java-кода. Однако у FFM API есть &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html#restricted"&gt;ограниченные методы&lt;/a&gt; (например, &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/MemorySegment.html#reinterpret(long)"&gt;&lt;code&gt;MemorySegment::reinterpret&lt;/code&gt;&lt;/a&gt;), которые по своей сути являются небезопасными. При их использовании могут возникнуть ужасные последствия вроде краха JVM, которые виртуальная машина не в состоянии предотвратить. Поэтому при выполнении ограниченного метода JVM выдаёт предупреждение, например:&lt;/p&gt;
&lt;pre&gt;WARNING: A restricted method in java.lang.foreign.Linker has been called
WARNING: Linker::downcallHandle has been called by com.foo.Server in an unnamed module
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled&lt;/pre&gt;
&lt;p&gt;Чтобы разрешить модулю использовать ограниченные методы без предупреждений, необходимо использовать опцию командной строки &lt;code&gt;--enable-native-access=M&lt;/code&gt;, где &lt;code&gt;M&lt;/code&gt; &amp;ndash; имя модуля или список модулей через запятую (можно использовать &lt;code&gt;ALL-UNNAMED&lt;/code&gt; для всего кода в classpath). При этом любое использование ограниченных методов вне списка модулей будет выбрасывать &lt;code&gt;IllegalCallerException&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/460"&gt;Vector API (Seventh Incubator) (JEP 460)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/22/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в седьмой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.&lt;/p&gt;
&lt;p&gt;Векторное API остаётся так долго в инкубаторе, потому что зависит от некоторых фич проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; (главным образом, от &lt;a href="https://openjdk.org/jeps/401"&gt;value-классов&lt;/a&gt;), который пока что находится в разработке. Как только эти фичи станут доступны в виде preview, векторное API тоже сразу же выйдет из инкубатора в статус preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/423"&gt;Region Pinning for G1 (JEP 423)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В сборщике мусора G1 было реализовано &lt;i&gt;закрепление регионов&lt;/i&gt;, которое предотвращает отключение сборки мусора, пока JNI находится в критическом регионе.&lt;/p&gt;
&lt;p&gt;Критический регион &amp;ndash; это код, который выполняется в промежутке между двумя событиями: захват указателя на Java-объект и его освобождение. В этом промежутке сборщик мусора не имеет права двигать Java-объект, чтобы не сломать нативный код, который полагается на то, что он будет находиться по одному и тому же адресу в течение всего времени захвата.&lt;/p&gt;
&lt;p&gt;До Java 22 G1 имел простейшую стратегию: если хотя бы один из потоков находился в критическом регионе, то он просто отключал сборку мусора. Это могло приводить к различным проблемам, начиная с длительных пауз и заканчивая нехваткой памяти при её фактическом избытке.&lt;/p&gt;
&lt;p&gt;Для закрепления критических объектов вовсе необязательно полностью отключать сборщик мусора: достаточно закрепить только тот регион сборщика, в котором находится объект. Это и было реализовано в JEP 423. Это было сделано путём использования счётчика, который увеличивается при захвате критического объекта и уменьшается при освобождении. Если счётчик равен нулю, то регион собирается в нормальном режиме. Если счётчик больше нуля, то регион сборщика закрепляется. Это должно решить вышеописанные проблемы.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 21</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_21.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_21.html</id>
    <updated>2023-09-18T19:00:00Z</updated>
    <published>2023-09-18T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-21.html"&gt;2500 закрытых задач и 15 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/21/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/21/apidiff/20/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Java 21 является LTS-релизом, а значит у него будут выходить обновления &lt;a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"&gt;как минимум 5 лет&lt;/a&gt; с момента выхода.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Скачать JDK 21 можно по этим ссылкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt; (лицензия &lt;a href="https://www.oracle.com/downloads/licenses/no-fee-license.html"&gt;NFTC&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/21/"&gt;OpenJDK&lt;/a&gt; (лицензия &lt;a href="https://openjdk.org/legal/gplv2+ce.html"&gt;GPLv2 with Classpath Exception&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 21.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/441"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (JEP 441)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; наконец-то был финализирован и стал стабильной конструкцией языка. Напомним, что он появился в &lt;a href="java_17.html"&gt;Java 17&lt;/a&gt; и был в состоянии &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; четыре релиза: &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/433"&gt;20&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Новый паттерн-матчинг существенно расширяет возможности оператора &lt;code&gt;switch&lt;/code&gt;. Начиная с Java 1.0, &lt;code&gt;switch&lt;/code&gt; поддерживал только сравнение с примитивными константами. Позже список типов был расширен (Java 5 &amp;ndash; перечисления, Java 7 &amp;ndash; строки), но в ветках &lt;code&gt;case&lt;/code&gt; всё ещё могли быть только константы.&lt;/p&gt;
&lt;p&gt;Теперь же &lt;code&gt;switch&lt;/code&gt; поддерживает в ветках &lt;code&gt;case&lt;/code&gt; так называемые &lt;i&gt;паттерны&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Паттерны могут снабжаться условиями с использованием нового ключевого слова &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i &lt;span style="color: blue"&gt;when&lt;/span&gt; i &gt; 0 -&gt; String.format(&lt;span style="color: darkred"&gt;"positive int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; obj.toString();
};&lt;/pre&gt;
&lt;p&gt;Также добавлена поддержка матчинга &lt;code&gt;null&lt;/code&gt;. Сделать это можно с помощью явной отдельной ветки &lt;code&gt;case null&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Если ветка &lt;code&gt;case null&lt;/code&gt; отсутствует, то &lt;code&gt;switch&lt;/code&gt; с переданным в него &lt;code&gt;null&lt;/code&gt; всегда будет выбрасывать &lt;code&gt;NullPointerException&lt;/code&gt; (даже если есть ветка &lt;code&gt;default&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;Object obj = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// NullPointerException&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Other"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Ветки &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;default&lt;/code&gt; можно объединять друг с другом:&lt;/p&gt;
&lt;pre&gt;String str = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (str) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Foo or Bar"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null or other"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;Новый паттерн-матчинг обладает рядом ограничений.&lt;/p&gt;
&lt;p&gt;Во-первых, все &lt;code&gt;switch&lt;/code&gt; (кроме тех, что были корректными до Java 21) должны быть &lt;i&gt;исчерпывающими&lt;/i&gt;. Т.е. в ветках должны покрываться все возможные случаи:&lt;/p&gt;
&lt;pre&gt;Object obj = …
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) { &lt;span style="color: red"&gt;// error: the switch statement does not cover all possible input values&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(s.length());
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; System.out.println(i);
};&lt;/pre&gt;
&lt;p&gt;Пример выше можно исправить, добавив ветку &lt;code&gt;Object o&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Во-вторых, все ветки &lt;code&gt;case&lt;/code&gt; должны располагаться в таком порядке, что ни перед одной веткой нет &lt;i&gt;доминирующей&lt;/i&gt; ветки:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; CharSequence cs -&gt;
        &lt;span style="color: darkred"&gt;"sequence of length "&lt;/span&gt; + cs.length();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// error: this case label is dominated by a preceding case label&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"string of length "&lt;/span&gt; + s.length();
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Так как &lt;code&gt;CharSequence&lt;/code&gt; это более широкий тип, чем &lt;code&gt;String&lt;/code&gt;, то его ветка должна быть расположена ниже.&lt;/p&gt;

&lt;p class="mt-2"&gt;В-третьих, несколько паттернов в одной ветке работать не будут:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (obj) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s, Integer i -&gt; &lt;span style="color: darkred"&gt;"string or integer"&lt;/span&gt;; &lt;span style="color: red"&gt;// error: illegal fall-through from a pattern&lt;/span&gt;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; &lt;span style="color: darkred"&gt;"other"&lt;/span&gt;;
 };&lt;/pre&gt;
&lt;p&gt;Т.е. сделать тест по нескольким типам в одной ветке пока что нельзя (хотя грамматика языка это позволяет). Это можно обойти, только включив режим preview и заменив &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;i&lt;/code&gt; на символы подчёркивания (см. JEP про безымянные переменные ниже).&lt;/p&gt;

&lt;p class="mt-2"&gt;В целом новый паттерн-матчинг значительно увеличивает выразительность языка. Особенно хорошо он сочетается с записями. Паттерны записей мы рассмотрим отдельно, поскольку про них есть свой собственный JEP (см. следующий раздел).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/440"&gt;Record Patterns (JEP 440)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Отдельным видом паттернов являются &lt;i&gt;паттерны записей&lt;/i&gt;. Они появились в &lt;a href="https://openjdk.org/jeps/405"&gt;Java 19&lt;/a&gt; в режиме preview и стали стабильными в Java 21.&lt;/p&gt;
&lt;p&gt;Паттерны записей позволяют осуществлять деконструкцию значений записей чрезвычайно компактно:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
        System.out.println(x + y);
    }
}&lt;/pre&gt;

&lt;p&gt;Или через оператор &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printSum(Object obj) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (obj) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) -&gt; System.out.println(x + y);
        &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Not a point"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Особая мощь паттернов записей состоит в том, что они могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
&lt;span style="color: blue"&gt;enum&lt;/span&gt; Color { RED, GREEN, BLUE }
&lt;span style="color: blue"&gt;record&lt;/span&gt; ColoredPoint(Point p, Color c) {}
&lt;span style="color: blue"&gt;record&lt;/span&gt; Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Используя &lt;code&gt;var&lt;/code&gt;, можно сократить код ещё сильнее:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; printColorOfUpperLeftPoint(Rectangle r) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(&lt;span style="color: blue"&gt;var&lt;/span&gt; p, &lt;span style="color: blue"&gt;var&lt;/span&gt; c), &lt;span style="color: blue"&gt;var&lt;/span&gt; lr)) {
        System.out.println(c);
    }
}&lt;/pre&gt;

&lt;p&gt;Паттерны записей отлично сочетаются с паттернами по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box(Object obj) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box box) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(String s) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"string: "&lt;/span&gt; + s);
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(Object o) -&gt; System.out.println(&lt;span style="color: darkred"&gt;"other: "&lt;/span&gt; + o);
    }
}&lt;/pre&gt;

&lt;p&gt;Поддерживается вывод типов записей-дженериков:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;Box&amp;lt;String&gt;&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s))) { &lt;span style="color: green"&gt;// Infers Box&amp;lt;Box&amp;lt;String&gt;&gt;(Box&amp;lt;String&gt;(String s))&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p class="mt-2"&gt;К сожалению, паттерны записей могут использоваться только в &lt;code&gt;instanceof&lt;/code&gt; и &lt;code&gt;switch&lt;/code&gt;, но не могут использоваться сами по себе:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static void&lt;/span&gt; usePoint(Point p) {
    Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) = p; &lt;span style="color: red"&gt;// Не сработает&lt;/span&gt;
    &lt;span style="color: green"&gt;// Use x and y&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;Будем надеяться, что когда-нибудь добавят и такую возможность.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/430"&gt;String Templates (Preview) (JEP 430)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Строковые шаблоны &amp;ndash; новая синтаксическая возможность, позволяющая встраивать в строки выражения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; x = 10;
&lt;span style="color: blue"&gt;int&lt;/span&gt; y = 20;
String str = STR.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
&lt;span style="color: green"&gt;// В str будет лежать "10 + 20 equals 30"&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, в Java появилась строковая интерполяция, которая уже давно есть во многих других известных языках программирования. Однако в Java она работает только в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt;, т.е. использовать в Java 21 её можно только с включенным флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Реализация строковых шаблонов в Java отличается от большинства реализаций в других языках: в Java строковый шаблон на самом деле сначала превращается в объект &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html"&gt;&lt;code&gt;java.lang.StringTemplate&lt;/code&gt;&lt;/a&gt;, а затем &lt;i&gt;процессор&lt;/i&gt;, реализующий &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html"&gt;&lt;code&gt;java.lang.StringTemplate.Processor&lt;/code&gt;&lt;/a&gt;, конвертирует этот объект в строку (или объект другого класса). В примере выше &lt;code&gt;STR."…"&lt;/code&gt; есть ничто иное, как сокращённый вариант следующего кода:&lt;/p&gt;
&lt;pre&gt;StringTemplate template = RAW.&lt;span style="color: darkred"&gt;"&lt;/span&gt;\{x} &lt;span style="color: darkred"&gt;plus&lt;/span&gt; \{y} &lt;span style="color: darkred"&gt;equals&lt;/span&gt; \{x + y}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;
String str = STR.process(template);&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#STR"&gt;&lt;code&gt;STR&lt;/code&gt;&lt;/a&gt; &amp;ndash; это стандартный и наиболее часто используемый процессор, который выполняет простую подстановку значений в шаблон и возвращает сконкатенированную строку. &lt;code&gt;STR&lt;/code&gt; неявно импортируется в любой исходный файл, поэтому его можно использовать без &lt;code&gt;import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.html#RAW"&gt;&lt;code&gt;RAW&lt;/code&gt;&lt;/a&gt; &amp;ndash; это процессор, который ничего не делает со &lt;code&gt;StringTemplate&lt;/code&gt; и просто возвращает его. Обычно он не используется, т.к. на практике мало кому нужны сырые представления шаблонов, а нужны результаты интерполяции в виде готовых объектов.&lt;/p&gt;
&lt;p&gt;Процессоры были введены для того, чтобы была возможность кастомизировать процесс интерполяции. Например, ещё один стандартный процессор &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/FormatProcessor.html#FMT"&gt;&lt;code&gt;FMT&lt;/code&gt;&lt;/a&gt; поддерживает форматирование с использованием спецификаторов, определённых в &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html"&gt;&lt;code&gt;java.util.Formatter&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;double&lt;/span&gt; length = 46;
System.out.println(FMT.&lt;span style="color: darkred"&gt;"The length is %.2f&lt;/span&gt;\{length} &lt;span style="color: darkred"&gt;cm"&lt;/span&gt;);
&lt;span style="color: green"&gt;// The length is 46.00 cm&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Процессоры необязательно должны возвращать &lt;code&gt;String&lt;/code&gt;. Вот общая сигнатура метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/StringTemplate.Processor.html#process(java.lang.StringTemplate)"&gt;&lt;code&gt;process()&lt;/code&gt;&lt;/a&gt; интерфейса &lt;code&gt;Processor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public interface&lt;/span&gt; Processor&amp;lt;R, E &lt;span style="color: blue"&gt;extends&lt;/span&gt; Throwable&gt; {
    R process(StringTemplate stringTemplate) &lt;span style="color: blue"&gt;throws&lt;/span&gt; E;
}&lt;/pre&gt;
&lt;p&gt;Это значит, что можно реализовать процессор, который будет делать практически всё что угодно и возвращать что угодно. Например, гипотетический процессор &lt;code&gt;JSON&lt;/code&gt; будет создавать напрямую объекты JSON (без промежуточного объекта &lt;code&gt;String&lt;/code&gt;) и при этом поддерживать экранирование кавычек:&lt;/p&gt;
&lt;pre&gt;JSONObject doc = JSON.&lt;span style="color: darkred"&gt;"""&lt;/span&gt;
    &lt;span style="color: darkred"&gt;{&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"name":    "&lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"phone":   "&lt;/span&gt;\{phone}&lt;span style="color: darkred"&gt;",&lt;/span&gt;
        &lt;span style="color: darkred"&gt;"address": "&lt;/span&gt;\{address}&lt;span style="color: darkred"&gt;"&lt;/span&gt;
    }
    &lt;span style="color: darkred"&gt;"""&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt; или &lt;code&gt;address&lt;/code&gt; будут содержаться кавычки, то они не испортят объект, т.к. процессор заменит &lt;code&gt;&amp;quot;&lt;/code&gt; на &lt;code&gt;\&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Или, например, процессор &lt;code&gt;SQL&lt;/code&gt; будет создавать PreparedStatement'ы, защищая от атак SQL Injection:&lt;/p&gt;
&lt;pre&gt;PreparedStatement ps = SQL.&lt;span style="color: darkred"&gt;"SELECT * FROM Person p WHERE p.name = &lt;/span&gt;\{name}&lt;span style="color: darkred"&gt;"&lt;/span&gt;;&lt;/pre&gt;
&lt;p&gt;Таким образом, строковые шаблоны гораздо более мощный инструмент, нежели простая конкатенирующая строковая интерполяция. Они решают не только проблему простого внедрения выражений в строки и увеличивают читабельность, но и улучшают безопасность и гибкость программ.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/443"&gt;Unnamed Patterns and Variables (Preview) (JEP 443)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новшество в режиме preview: теперь можно объявлять так называемые безымянные переменные и паттерны. Делается это с помощью символа подчеркивания (&lt;code&gt;_&lt;/code&gt;). Это часто необходимо, когда переменная или паттерн не используются:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; acc = 0;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (Order _ : orders) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (acc &lt; LIMIT) {
        … acc++ …
    }
}&lt;/pre&gt;
&lt;p&gt;В примере выше важен факт наличия элемента, но сама переменная не нужна. Поэтому, чтобы не придумывать этой переменной название, было использовано подчеркивание вместо имени.&lt;/p&gt;
&lt;p&gt;Довольно частый пример нужности безымянных переменных &amp;ndash; блок &lt;code&gt;catch&lt;/code&gt; с неиспользуемым исключением:&lt;/p&gt;
&lt;pre&gt;String s = …
try {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; i = Integer.parseInt(s);
    …
} &lt;span style="color: blue"&gt;catch&lt;/span&gt; (NumberFormatException _) {
    System.out.println(&lt;span style="color: darkred"&gt;"Bad number: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Полный список случаев, в которых можно использовать безымянные переменные:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Локальная переменная в блоке,&lt;/li&gt;
  &lt;li&gt;Объявление ресурса в &lt;code&gt;try-with-resources&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Заголовок &lt;code&gt;for&lt;/code&gt; statement,&lt;/li&gt;
  &lt;li&gt;Заголовок улучшенного цикла &lt;code&gt;for&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Исключение в блоке &lt;code&gt;catch&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;Параметр лямбда-выражения,&lt;/li&gt;
  &lt;li&gt;Переменная паттерна (см. ниже).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Внимательный читатель заметит, что в списке выше отсутствуют параметры методов. Действительно, они не могут быть безымянными, и для любых методов (как интерфейсов, так и классов) по-прежнему всегда нужно указывать имена параметров.&lt;/p&gt;

&lt;p class="mt-2"&gt;Символы подчёркивания также можно использовать для указания &lt;i&gt;безымянных паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), _)) {
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Здесь разработчику понадобились только координаты точки, но не её цвет. Без безымянного паттерна ему пришлось бы объявлять неиспользуемую переменную типа &lt;code&gt;Color&lt;/code&gt; и придумывать ей имя:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color c)) { &lt;span style="color: orange"&gt;// Warning: unused c&lt;/span&gt;
    &lt;span style="color: green"&gt;// Используются только x и y&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Такой код менее читабелен и хуже позволяет сфокусироваться на главном (координатах). Кроме того, некоторые IDE подсветили бы неиспользуемую переменную &lt;code&gt;c&lt;/code&gt;, что ещё одно дополнительное неудобство.&lt;/p&gt;
&lt;p&gt;Есть также возможность объявлять &lt;i&gt;безымянные переменные паттернов&lt;/i&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; ColoredPoint(Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y), Color _)) {
    …
}&lt;/pre&gt;
&lt;p&gt;Безымянные паттерны и переменные паттернов прекрасно сочетаются и со &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (box) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(RedBall _), Box(BlueBall _) -&gt; processBox(box);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(GreenBall _)                -&gt; stopProcessing();
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Box(_)                          -&gt; pickAnotherBox();
}&lt;/pre&gt;
&lt;p&gt;В целом, паттерн-матчинг и безымянные паттерны вместе обладают большой синергией и позволяют писать действительно мощные, компактные и выразительные конструкции.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;Unnamed Classes and Instance Main Methods (Preview) (JEP 445)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Теперь в режиме preview можно запускать программы с методами &lt;code&gt;main()&lt;/code&gt;, которые не являются &lt;code&gt;public static&lt;/code&gt; и у которых нет параметра &lt;code&gt;String[] args&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;В таком случае JVM сама создаст экземпляр класса (у него должен быть не-&lt;code&gt;private&lt;/code&gt; конструктор без параметров) и вызовет у него метод &lt;code&gt;main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Протокол запуска будет выбирать метод &lt;code&gt;main()&lt;/code&gt; согласно следующему приоритету:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;static void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;static void main()&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main(String[] args)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;void main()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p class="mt-2"&gt;Кроме того, можно писать программы и без объявления класса вовсе:&lt;/p&gt;
&lt;pre&gt;String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}&lt;/pre&gt;
&lt;p&gt;В таком случае будет создан неявный безымянный класс (не путать с анонимным классом), которому будут принадлежать метод &lt;code&gt;main()&lt;/code&gt; и другие верхнеуровневые объявления в файле:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// class &amp;lt;some name&gt; { ← неявно&lt;/span&gt;
String greeting = &lt;span style="color: darkred"&gt;"Hello, World!"&lt;/span&gt;;

&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(greeting);
}
&lt;span style="color: green"&gt;// }&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Безымянный класс является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#isSynthetic()"&gt;синтетическим&lt;/a&gt; и &lt;code&gt;final&lt;/code&gt;. Его &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getSimpleName()"&gt;simple name&lt;/a&gt; является пустой строкой:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(getClass().isUnnamed()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().isSynthetic()); &lt;span style="color: green"&gt;// true&lt;/span&gt;
    System.out.println(getClass().getSimpleName()); &lt;span style="color: green"&gt;// ""&lt;/span&gt;
    System.out.println(getClass().getCanonicalName()); &lt;span style="color: green"&gt;// null&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;При этом &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#getName()"&gt;имя&lt;/a&gt; класса совпадает с именем файла, но такое поведение не гарантируется.
&lt;p class="mt-2"&gt;Такое упрощение запуска Java-программ было сделано с двумя целями:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Облегчить процесс обучения языку. На новичка, только что начавшего изучение Java, не должно сваливаться всё сразу, а концепции должны вводятся постепенно, начиная с базовых (переменные, циклы, процедуры) и постепенно переходя к более продвинутым (классы, области видимости).&lt;/li&gt;
    &lt;li&gt;Облегчить написание коротких программ и скриптов. Количество церемоний для них должно быть сведено к минимуму.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;Virtual Threads (JEP 444)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые много лет разрабатывались в рамках проекта &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt; и появились в &lt;a href="https://openjdk.org/jeps/425"&gt;Java 19&lt;/a&gt; в режиме preview, теперь наконец-то стали стабильными.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки, в отличие от потоков операционной системы, являются легковесными и могут создаваться в огромном количестве (миллионы экземпляров). Это свойство должно значительно облегчить написание конкурентных программ, поскольку позволит применять простой подход "один запрос &amp;ndash; один поток" (или "одна задача &amp;ndash; один поток") и не прибегать к более сложным асинхронному или реактивному программированию. При этом миграция на виртуальные потоки уже существующего кода должна быть максимально простой, потому что виртуальные потоки являются экземплярами существующего класса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html"&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;/a&gt; и практически полностью совместимы с классическими потоками: поддерживают стек-трейсы, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#interrupt()"&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; и т.д.&lt;/p&gt;
&lt;p&gt;Виртуальные потоки реализованы поверх обычных потоков и существуют только для JVM, но не для операционной системы (отсюда и название "виртуальные"). Поток, на котором в данный момент выполняется виртуальный поток, называется потоком-носителем. Если потоки платформы полагаются на планировщик операционной системы, то планировщиком для виртуальных потоков является &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;&lt;/a&gt;. Когда виртуальный поток блокируется на некоторой блокирующей операции, то он размонтируется от своего потока-носителя, что позволяет потоку-носителю примонтировать другой виртуальный поток и продолжить работу. Такой режим работы и дешевизна виртуальных потоков позволяет им очень хорошо масштабироваться. Однако на данный момент есть два исключения: &lt;code&gt;synchronized&lt;/code&gt; блоки и JNI. При их выполнении виртуальный поток не может быть размонтирован, поскольку он привязан к своему потоку-носителю. Такое ограничение может препятствовать масштабированию. Поэтому при желании максимально использовать потенциал виртуальных потоков рекомендуется избегать &lt;code&gt;synchronized&lt;/code&gt; блоков и операции JNI, которые выполняются часто или занимают длительное время.&lt;/p&gt;
&lt;p&gt;Несмотря на привлекательность виртуальных потоков, вовсе необязательно предпочитать только их и всегда избегать классических потоков. Например, для задач, интенсивно и долго использующих CPU, лучше подойдут обычные потоки. Или если нужен поток, не являющийся &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)"&gt;демоном&lt;/a&gt;, то также придётся использовать обычный поток, потому что виртуальный поток всегда является демоном.&lt;/p&gt;
&lt;p&gt;Для создания виртуальных потоков и работы с ними появилось следующее API:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html"&gt;&lt;code&gt;Thread.Builder&lt;/code&gt;&lt;/a&gt; &amp;ndash; билдер потоков. Например, виртуальный поток можно создать путём вызова &lt;code&gt;Thread.ofVirtual().name("name").unstarted(runnable)&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)"&gt;&lt;code&gt;Thread.startVirtualThread(Runnable)&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт и сразу же запускает виртуальный поток.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#isVirtual()"&gt;&lt;code&gt;Thread.isVirtual()&lt;/code&gt;&lt;/a&gt; &amp;ndash; проверяет, является ли поток виртуальным.&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"&gt;&lt;code&gt;Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/a&gt; &amp;ndash; возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для виртуальных потоков также добавилась поддержка в инструментарии JDK (дебаггер, JVM TI, Java Flight Recorder).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/431"&gt;Sequenced Collections (JEP 431)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появились три новых интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"&gt;&lt;code&gt;SequencedCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"&gt;&lt;code&gt;SequencedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"&gt;&lt;code&gt;SequencedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; является наследником &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html"&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; и представляет собой коллекцию с установленным порядком элементов. Такими коллекциями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashSet.html"&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; и все реализации &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html"&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedSet.html"&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Deque.html"&gt;&lt;code&gt;Deque&lt;/code&gt;&lt;/a&gt;. У этих коллекций есть общее свойство последовательности элементов, но до Java 21 их общим родителем был &lt;code&gt;Collection&lt;/code&gt;, который является слишком общим интерфейсом и не содержит многих методов, характерных для последовательностей (&lt;code&gt;getFirst()&lt;/code&gt;, &lt;code&gt;getLast()&lt;/code&gt;, &lt;code&gt;addFirst()&lt;/code&gt;, &lt;code&gt;addLast()&lt;/code&gt;, &lt;code&gt;reversed()&lt;/code&gt; и т.д). При этом у самих вышеописанных коллекций такие методы были несогласованны друг с другом (например, &lt;code&gt;list.get(0)&lt;/code&gt; против &lt;code&gt;sortedSet.first()&lt;/code&gt; против &lt;code&gt;deque.getFirst()&lt;/code&gt;), либо вовсе отсутствовали (например, &lt;code&gt;linkedHashSet.getLast()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequencedCollection&lt;/code&gt; закрыла эту дыру в иерархии и привела API к общему знаменателю:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedCollection&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Collection&amp;lt;E&gt; {
    E getFirst();
    E getLast();
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addFirst(E);
    &lt;span style="color: blue"&gt;void&lt;/span&gt; addLast(E);
    E removeFirst();
    E removeLast();
    SequencedCollection&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Теперь больше не надо думать, как для конкретной коллекции получить последний элемент, потому что есть универсальный метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#getLast()"&gt;&lt;code&gt;getLast()&lt;/code&gt;&lt;/a&gt;, который есть и у &lt;code&gt;ArrayList&lt;/code&gt;, и у &lt;code&gt;TreeSet&lt;/code&gt;, и у &lt;code&gt;ArrayDeque&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Особый интерес представляет метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html#reversed()"&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;, который возвращает view коллекции с обратным порядком. Это делает обратный обход коллекции гораздо более лаконичным:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;var&lt;/span&gt; linkedList = new LinkedList&lt;&gt;(…);

&lt;span style="color: green"&gt;// До Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; it = linkedList.descendingIterator(); it.hasNext();) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; e = it.next();
    …
}

&lt;span style="color: green"&gt;// С Java 21&lt;/span&gt;
&lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; element : linkedList.reversed()) {
    …
}&lt;/pre&gt;
&lt;p&gt;Для &lt;code&gt;LinkedHashSet&lt;/code&gt; эффективного способа обратного обхода и вовсе не было.&lt;/p&gt;
&lt;p class="mt-2"&gt;Для последовательных множеств ввели интерфейс &lt;code&gt;SequencedSet&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedSet&amp;lt;E&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Set&amp;lt;E&gt;, SequencedCollection&amp;lt;E&gt; {
    SequencedSet&amp;lt;E&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;code&gt;LinkedHashSet&lt;/code&gt; и наследники &lt;code&gt;SortedSet&lt;/code&gt;.&lt;/p&gt;
&lt;p class="mt-2"&gt;Также ввели интерфейс &lt;code&gt;SequencedMap&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; SequencedMap&amp;lt;K,V&gt; &lt;span style="color: blue"&gt;extends&lt;/span&gt; Map&amp;lt;K,V&gt; {
    Entry&amp;lt;K, V&gt; firstEntry();
    Entry&amp;lt;K, V&gt; lastEntry();
    Entry&amp;lt;K, V&gt; pollFirstEntry();
    Entry&amp;lt;K, V&gt; pollLastEntry();
    V putFirst(K, V);
    V putLast(K, V);
    SequencedSet&amp;lt;K&gt; sequencedKeySet();
    SequencedCollection&amp;lt;V&gt; sequencedValues();
    SequencedSet&amp;lt;Entry&amp;lt;K,V&gt;&gt; sequencedEntrySet();
    SequencedMap&amp;lt;K,V&gt; reversed();
}&lt;/pre&gt;
&lt;p&gt;Его реализациями являются &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedHashMap.html"&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; и наследники &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedMap.html"&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;Scoped Values (Preview) (JEP 446)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Scoped Values, которые появились в &lt;a href="https://openjdk.org/jeps/429"&gt;Java 20&lt;/a&gt; в &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационном статусе&lt;/a&gt;, теперь стали Preview API.&lt;/p&gt;
&lt;p&gt;Новый класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt; позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html"&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#set(T)"&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо большем количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#where(java.lang.ScopedValue,T)"&gt;&lt;code&gt;where()&lt;/code&gt;&lt;/a&gt;. Далее вызывается метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.Carrier.html#run(java.lang.Runnable)"&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, на протяжении которого это значение можно получить (через метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ScopedValue.html#get()"&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потокам не надо копировать значение, которое остаётся постоянным в течение периода жизни.&lt;/p&gt;
&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;private static final&lt;/span&gt; ScopedValue&amp;lt;FrameworkContext&gt; CONTEXT = ScopedValue.newInstance();

&lt;span style="color: blue"&gt;void&lt;/span&gt; serve(Request request, Response response) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = createContext(request);
    ScopedValue.where(CONTEXT, context)
               .run(() -&gt; Application.handle(request, response));
}

&lt;span style="color: blue"&gt;public&lt;/span&gt; PersistedObject readKey(String key) {
    &lt;span style="color: blue"&gt;var&lt;/span&gt; context = CONTEXT.get();
    &lt;span style="color: blue"&gt;var&lt;/span&gt; db = getDBConnection(context);
    db.readKey(key);
}&lt;/pre&gt;
&lt;p&gt;В целом &lt;code&gt;ScopedValue&lt;/code&gt; является предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;, т.к. навязывает разработчику безопасную однонаправленную модель работы с неизменяемыми данными. Однако такой подход не всегда применим для некоторых задач, и для них &lt;code&gt;ThreadLocal&lt;/code&gt; может быть единственно возможным решением.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/453"&gt;Structured Concurrency (Preview) (JEP 453)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно API, которое ранее было в инкубационном статусе (Java &lt;a href="https://openjdk.org/jeps/428"&gt;19&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/437"&gt;20&lt;/a&gt;), а теперь стало Preview API &amp;ndash; это Structured Concurrency.&lt;/p&gt;
&lt;p&gt;Structured Concurrency &amp;ndash; это подход многопоточного программирования, который заимствует принципы из однопоточного структурного программирования. Главная идея такого подхода заключается в следующем: если задача расщепляется на несколько конкурентных подзадач, то эти подзадачи воссоединяются в блоке кода главной задачи. Все подзадачи логически сгруппированы и организованы в иерархию. Каждая подзадача ограничена по времени жизни областью видимости блока кода главной задачи.&lt;/p&gt;
&lt;p&gt;В центре нового API класс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"&gt;&lt;code&gt;StructuredTaskScope&lt;/code&gt;&lt;/a&gt;, у которого есть два главных метода:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork(java.util.concurrent.Callable)"&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; &amp;ndash; создаёт подзадачу и запускает её в новом виртуальном потоке,&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#join()"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; &amp;ndash; ждёт, пока не завершатся все подзадачи или пока scope не будет &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#shutdown()"&gt;остановлен&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования &lt;code&gt;StructuredTaskScope&lt;/code&gt;, где показана задача, которая параллельно запускает две подзадачи и дожидается результата их выполнения:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;try&lt;/span&gt; (&lt;span style="color: blue"&gt;var&lt;/span&gt; scope = &lt;span style="color: blue"&gt;new&lt;/span&gt; StructuredTaskScope.ShutdownOnFailure()) {
    Supplier&amp;lt;String&gt; user = scope.fork(() -&gt; findUser());
    Supplier&amp;lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());

    scope.join()            &lt;span style="color: green"&gt;// Join both forks&lt;/span&gt;
         .throwIfFailed();  &lt;span style="color: green"&gt;// ... and propagate errors&lt;/span&gt;

    &lt;span style="color: blue"&gt;return new&lt;/span&gt; Response(user.get(), order.get());
}&lt;/pre&gt;
&lt;p&gt;Может показаться, что в точности аналогичный код можно было бы написать с использованием классического &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html"&gt;&lt;code&gt;ExecutorService&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable)"&gt;&lt;code&gt;submit()&lt;/code&gt;&lt;/a&gt;, но у &lt;code&gt;StructuredTaskScope&lt;/code&gt; есть несколько принципиальных отличий, которые делают код безопаснее:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Время жизни всех потоков подзадач ограничено областью видимости блока &lt;code&gt;try-with-resources&lt;/code&gt;. Метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html#close()"&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; гарантированно не завершится, пока не завершатся все подзадачи.&lt;/li&gt;
    &lt;li&gt;Если одна из операций &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; завершается ошибкой, то другая операция отменяется автоматически, если ещё не завершена (в случае политики &lt;code&gt;ShutdownOnFailure&lt;/code&gt;, возможны другие).&lt;/li&gt;
    &lt;li&gt;Если главный поток прерывается в процессе ожидания &lt;code&gt;join()&lt;/code&gt;, то обе операции &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt; отменяются при выходе из блока.&lt;/li&gt;
    &lt;li&gt;В дампе потоков будет видна иерархия: потоки, выполняющие &lt;code&gt;findUser()&lt;/code&gt; и &lt;code&gt;fetchOrder()&lt;/code&gt;, будут отображаться как дочерние для главного потока.&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="mt-2"&gt;Structured Concurrency должно облегчить написание безопасных многопоточных программ благодаря знакомому структурному подходу.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/442"&gt;Foreign Function &amp; Memory API (Third Preview) (JEP 442)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Напомним, что FFM API много лет разрабатывается в проекте &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; с целью заменить JNI. В &lt;a href="https://openjdk.org/jeps/454"&gt;Java 22&lt;/a&gt; API выйдет из состояния preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;Vector API (Sixth Incubator) (JEP 448)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API в модуле &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;, которое появилось ещё аж &lt;a href="https://openjdk.org/jeps/338"&gt;в Java 16&lt;/a&gt;, остаётся в инкубационном статусе в шестой раз. В этом релизе лишь небольшие изменения API, исправления багов и улучшения производительности.&lt;/p&gt;
&lt;p&gt;Векторное API останется в инкубаторе, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не станут preview.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/452"&gt;Key Encapsulation Mechanism API (JEP 452)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В пакете &lt;code&gt;javax.crypto&lt;/code&gt; появилось новое API, реализующее &lt;a href="https://en.wikipedia.org/wiki/Key_encapsulation_mechanism"&gt;механизм инкапсуляции ключей&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Механизм инкапсуляции ключей (KEM) &amp;ndash; это современная криптографическая техника, позволяющая обмениваться симметричными ключами, используя асимметричное шифрование. Если в традиционной технике симметричный ключ генерируется случайным образом и шифруется с помощью открытого ключа (что требует паддинга), то в KEM симметричный ключ выводится из самого открытого ключа.&lt;/p&gt;
&lt;p&gt;В Java KEM API состоит из трёх главных классов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html"&gt;&lt;code&gt;KEM&lt;/code&gt;&lt;/a&gt; &amp;ndash; входная точка API. У него есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.html#getInstance(java.lang.String)"&gt;&lt;code&gt;getInstance()&lt;/code&gt;&lt;/a&gt;, возвращающий объект &lt;code&gt;KEM&lt;/code&gt; для указанного алгоритма.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html"&gt;&lt;code&gt;Encapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; представляет собой функцию инкапсуляции, которая вызывается отправителем. У этого класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Encapsulator.html#encapsulate()"&gt;&lt;code&gt;encapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает открытый ключ и возвращает секретный ключ, а также key encapsulation message (которое шлётся принимающей стороне).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html"&gt;&lt;code&gt;Decapsulator&lt;/code&gt;&lt;/a&gt; &amp;ndash; функция декапсуляции, которая вызывается принимающей стороной. У класса есть метод &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEM.Decapsulator.html#decapsulate(byte%5B%5D)"&gt;&lt;code&gt;decapsulate()&lt;/code&gt;&lt;/a&gt;, который принимает key encapsulation message и возвращает секретный ключ. Таким образом, у обеих сторон теперь есть одинаковый симметричный ключ, с помощью которого можно дальше обмениваться данными с помощью обычного симметричного шифрования.&lt;/p&gt;
&lt;p&gt;Пример генерации симметричного ключа и его передачи:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kpg = KeyPairGenerator.getInstance(&lt;span style="color: darkred"&gt;"X25519"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; kp = kpg.generateKeyPair();

&lt;span style="color: green"&gt;// Sender side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem1 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; sender = kem1.newEncapsulator(kp.getPublic());
&lt;span style="color: blue"&gt;var&lt;/span&gt; encapsulated = sender.encapsulate();
&lt;span style="color: blue"&gt;var&lt;/span&gt; k1 = encapsulated.key();

&lt;span style="color: green"&gt;// Receiver side&lt;/span&gt;
&lt;span style="color: blue"&gt;var&lt;/span&gt; kem2 = KEM.getInstance(&lt;span style="color: darkred"&gt;"DHKEM"&lt;/span&gt;);
&lt;span style="color: blue"&gt;var&lt;/span&gt; receiver = kem2.newDecapsulator(kp.getPrivate());
&lt;span style="color: blue"&gt;var&lt;/span&gt; k2 = receiver.decapsulate(encapsulated.encapsulation());

&lt;span style="color: blue"&gt;assert&lt;/span&gt; Arrays.equals(k1.getEncoded(), k2.getEncoded());&lt;/pre&gt;

&lt;p class="mt-2"&gt;Для KEM также добавлен интерфейс &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/crypto/KEMSpi.html"&gt;&lt;code&gt;KEMSpi&lt;/code&gt;&lt;/a&gt;, позволяющий предоставлять пользовательские реализации алгоритмов KEM.&lt;/p&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/439"&gt;Generational ZGC (JEP 439)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В сборщик мусора ZGC, который появился в &lt;a href="https://openjdk.org/jeps/377"&gt;Java 15&lt;/a&gt;, добавили поддержку поколений. Поколения в ZGC пока что отключены по умолчанию, и для их включения требуется ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;java -XX:+UseZGC -XX:+ZGenerational ...&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/474"&gt;В будущих версиях Java&lt;/a&gt; режим работы с поколениями будет по умолчанию, и ключ &lt;code&gt;-XX:+ZGenerational&lt;/code&gt; уже требоваться не будет.&lt;/p&gt;
&lt;p&gt;Поколения в ZGC должны улучшить производительность Java-программ, т.к. молодые объекты, которые склонны умирать рано согласно слабой гипотезе о поколениях, будут собираться чаще, а старые объекты &amp;ndash; более редко. При этом характеристики ZGC не должны от этого пострадать: время отклика по-прежнему должно быть сверхнизким (&lt; 1ms) и кучи гигантских размеров (несколько терабайт) должны продолжать поддерживаться.&lt;/p&gt;
&lt;p&gt;Напомним, что также &lt;a href="https://openjdk.org/jeps/404"&gt;ведётся работа&lt;/a&gt; над поддержкой поколений в другом сборщике мусора &lt;a href="https://openjdk.org/jeps/379"&gt;Shenandoah&lt;/a&gt;, похожем по характеристикам на ZGC. Однако в Java 21 Generational Shenandoah попасть не успел.&lt;/p&gt;
&lt;p&gt;Сборщиком мусора по умолчанию по-прежнему остаётся G1. Он стал дефолтным сборщиком мусора в &lt;a href="https://openjdk.org/jeps/248"&gt;Java 9&lt;/a&gt; (до него дефолтным был Parallel GC)&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/451"&gt;Prepare to Disallow the Dynamic Loading of Agents (JEP 451)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;При динамической загрузке агентов теперь выдаётся предупреждение:&lt;/p&gt;
&lt;pre&gt;WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release&lt;/pre&gt;
&lt;p&gt;Агент &amp;ndash; это компонент, который может изменять (инструментировать) код Java-приложения во время работы. Поддержка агентов появилась в Java 5, чтобы была возможность писать продвинутые инструменты вроде профилировщиков, которым необходимо добавлять эмиссию событий в классы, или AOP-библиотек. Для включения агентов требовались опции командной строки &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;, поэтому все агенты тогда могли включаться только явно при старте приложения.&lt;/p&gt;
&lt;p&gt;Однако в Java 6 появился &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html"&gt;Attach API&lt;/a&gt;, который, кроме всего прочего, позволил загружать агенты динамически прямо в работающий JVM. Благодаря этому библиотеки получили возможность подключаться к приложению и по-тихому изменять классы, не имея на то согласия от владельца приложения. Причём изменяться могут не только классы приложения, но и классы JDK. Таким образом, подвергается риску строгая инкапсуляция, которая является одним из краеугольных камней Java.&lt;/p&gt;
&lt;p&gt;Чтобы закрыть такую потенциально опасную дыру, в Java 9 вместе с появлением модулей было предложено запретить динамическую загрузку агентов по умолчанию. Однако тогда было решено отложить на неопределённое время такое радикальное решение, чтобы дать авторам инструментов время подготовиться. В итоге, изменение дожило до наших дней, и было реализовано лишь в Java 21, но в &lt;i&gt;виде предупреждения&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;Чтобы подавить предупреждение, необходимо запускать JVM с опцией &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;, либо загружать агенты при старте JVM, явно перечисляя их с помощью опций &lt;code&gt;-javaagent&lt;/code&gt; или &lt;code&gt;-agentlib&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В будущих версиях Java планируется полностью отключить динамическую загрузку по умолчанию, и она уже не будет работать без &lt;code&gt;-XX:+EnableDynamicAgentLoading&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;Deprecate the Windows 32-bit x86 Port for Removal (JEP 449)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;32-битный порт OpenJDK под Windows стал deprecated for removal. В будущем планируется избавиться от него полностью.&lt;/p&gt;
&lt;p&gt;Удаление порта позволит ускорить разработку платформы. Также причиной стало отсутствие нативной реализации виртуальных потоков на 32-битной версии JDK 21 под Windows: виртуальные потоки в этой версии реализованы через платформенные потоки.&lt;/p&gt;

&lt;p class="mt-4"&gt;Полный список JEP'ов, попавших в JDK 21, начиная с JDK 17: &lt;a href="https://openjdk.org/projects/jdk/21/jeps-since-jdk-17"&gt;ссылка&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #57</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_57.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_57.html</id>
    <updated>2023-04-23T19:00:00Z</updated>
    <published>2023-04-23T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/20-0-1-relnotes.html"&gt;JDK 20.0.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-7-relnotes.html"&gt;JDK 17.0.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-19-relnotes.html"&gt;JDK 11.0.19&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;JDK 8u372&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;bull; Вышло несколько новых JEP'ов.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/444"&gt;JEP 444: Virtual Threads&lt;/a&gt;. Виртуальные потоки уже интегрированы в &lt;a href="https://jdk.java.net/21/"&gt;ранние сборки JDK 21&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/445"&gt;JEP 445: Flexible Main Methods and Anonymous Main Classes (Preview)&lt;/a&gt;. Про него мы подробно писали в &lt;a href="java_news_54.html"&gt;выпуске #54&lt;/a&gt;, когда он был черновиком и имел другое название (Implicit Classes and Enhanced Main Methods).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/446"&gt;JEP 446: Scoped Values (Preview)&lt;/a&gt;. Scoped Values переходят из инкубационного статуса &lt;a href="https://openjdk.org/jeps/429"&gt;в Java 20&lt;/a&gt; в статус Preview в Java 21.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/447"&gt;JEP 447: Statements before &lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;. Про этот JEP мы писали в &lt;a href="java_news_53.html"&gt;выпуске #53&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/448"&gt;JEP 448: Vector API (Sixth Incubator)&lt;/a&gt;. Таким образом, векторное API остаётся в инкубационном статусе уже в шестой раз.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.org/jeps/449"&gt;JEP 449: Deprecate the Windows 32-bit x86 Port for Removal&lt;/a&gt;. Про причины удаления 32-битного порта JDK на Windows мы писали в &lt;a href="java_news_55.html"&gt;выпуске #55&lt;/a&gt;. 32-битные версии JDK под Linux остаются нетронутыми.&lt;/p&gt;

&lt;p&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2023/03/intellij-idea-2023-1/"&gt;IntelliJ IDEA 2023.1&lt;/a&gt;. Перечислим некоторые улучшения и нововведения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Изменение масштаба всей IDE (View &gt; Appearance &gt; Zoom IDE).&lt;/li&gt;
  &lt;li&gt;Появился компактный режим (только для нового UI).&lt;/li&gt;
  &lt;li&gt;Вкладки проектов на macOS.&lt;/li&gt;
  &lt;li&gt;Ускоренный доступ к функциональности IDE при открытии проекта (функции IDE становятся доступными гораздо раньше).&lt;/li&gt;
  &lt;li&gt;Ускоренный импорт Maven-проектов.&lt;/li&gt;
  &lt;li&gt;Фоновые проверки коммитов (чтобы ускорить выполнение коммитов).&lt;/li&gt;
  &lt;li&gt;Возможность сохранять варианты расположения окон (Window &gt; Layouts).&lt;/li&gt;
  &lt;li&gt;Отображение знаков пробела только в выделенном коде.&lt;/li&gt;
  &lt;li&gt;Поддержка Java 20.&lt;/li&gt;
  &lt;li&gt;Улучшенный рефакторинг Extract Method, поддерживающий ситуацию, когда фрагмент кода содержит несколько переменных, которые необходимо вернуть.&lt;/li&gt;
  &lt;li&gt;Автодополнение опций VM в Run/Debug Configurations.&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #56</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_56.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_56.html</id>
    <updated>2023-03-26T19:00:00Z</updated>
    <published>2023-03-26T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8303683"&gt;JEP: Virtual Threads&lt;/a&gt;. В нём предлагается финализировать виртуальные потоки в Java 21, то есть они больше не будут Preview API. Единственным изменением относительно Java 20 будет поддержка &lt;code&gt;ThreadLocal&lt;/code&gt; переменных в виртуальных потоках. Это гарантирует, что многие существующие библиотеки, использующие &lt;code&gt;ThreadLocal&lt;/code&gt;, продолжат корректно работать при переходе на виртуальные потоки.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/443"&gt;JEP 443: Unnamed Patterns and Variables (Preview)&lt;/a&gt;. Про него мы писали в &lt;a href="java_news_46.html"&gt;выпуске #46&lt;/a&gt;, когда вышел его черновик. С тех пор принципиальных изменений в JEP внесено не было.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/442"&gt;JEP 442: Foreign Function &amp; Memory API (Third Preview)&lt;/a&gt;. Таким образом, в Java 21 API остаётся в статусе Preview в третий раз.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик &lt;a href="https://openjdk.org/jeps/8304400"&gt;JEP: Launch Multi-File Source-Code Programs&lt;/a&gt;. В нём предлагается добавить поддержку запуска программ, состоящих из нескольких исходных файлов &lt;code&gt;.java&lt;/code&gt;. Напомним, что сейчас Java поддерживает запуск только одного исходного файла (возможность, которая появилась &lt;a href="https://openjdk.org/jeps/330"&gt;в Java 11&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Предполагается, что запуск нескольких файлов будет работать следующим образом:&lt;/p&gt;
&lt;ul style="list-style-type: none"&gt;
  &lt;li&gt;&amp;bull; В аргумент командной строки по-прежнему передаётся название одного java-файла, например: &lt;code&gt;java Prog.java&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс ссылается на другие классы, то лаунчер пытается найти эти классы в файловой системе. Предполагается, что каждый класс находится в файле с именем, соответствующем имени класса.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Файлы, на которые никто не ссылается, не компилируются. Это может быть удобно для разработки (например, в них можно оставлять синтаксические ошибки).&lt;/li&gt;
  &lt;li&gt;&amp;bull; Если класс используется через рефлексию, то файл ищется и компилируется уже во время работы программы.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование пакетов поддерживается. В таком случае файлы должны лежать в соответствующих директориях.&lt;/li&gt;
  &lt;li&gt;&amp;bull; Использование библиотек также поддерживается. Тогда нужно добавить аргумент &lt;code&gt;-cp&lt;/code&gt;, например: &lt;code&gt;java -cp '*' Prog.java&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; &lt;a href="https://openjdk.org/jeps/401"&gt;JEP 401: Primitive Classes (Preview)&lt;/a&gt; был значительно &lt;a href="https://mail.openjdk.org/pipermail/valhalla-spec-experts/2023-March/002238.html"&gt;переработан и переименован&lt;/a&gt; в Null-Restricted Value Object Storage. В новой версии JEP предлагается ввести так называемые опциональные конструкторы и null-restricted типы.&lt;/p&gt;
&lt;p&gt;Смысл опциональных конструкторов заключается в том, что если в &lt;a href="https://openjdk.org/jeps/8277163"&gt;value-классе&lt;/a&gt; объявлен такой конструктор, то такой класс обязан поддерживать значение по умолчанию, то есть значение, в котором все поля являются нулями. Это значит, что объекты такого класса могут быть проинициализированы в обход конструктора, а значит потенциально нарушать инварианты класса. В результате класс становится менее безопасным, но зато даёт виртуальной машине больше возможностей для более компактного хранения его значений: value-классы с опциональными конструкторами могут иметь лучший flattening, чем просто value-классы.&lt;/p&gt;
&lt;p&gt;JEP также предлагает ввести переменные, которым не может быть присвоен &lt;code&gt;null&lt;/code&gt;. Причём это нововведение будет распространяться на все классы, в том числе и ссылочные. Поскольку null-restricted типы не связаны напрямую с value-классами, то они будут подробно описаны &lt;a href="https://openjdk.java.net/jeps/8303099"&gt;в отдельном JEP'е&lt;/a&gt; (на данный момент ссылка выдаёт 404, т.к. JEP ещё не стал общедоступным). Однако в контексте этого JEP'а они упомянуты, чтобы показать, что они играют важную роль, когда сочетаются с value-классами с опциональными конструкторами: их значения смогут встраиваться в другие объекты и массивы, что и было основной целью проекта Valhalla.&lt;/p&gt;
&lt;p&gt;Также важным изменением в JEP'е стал отказ от нотации &lt;code&gt;X.ref&lt;/code&gt; и &lt;code&gt;X.val&lt;/code&gt;. Вместо них будет восклицательный знак для обозначения null-restricted типов (&lt;code&gt;X!&lt;/code&gt;).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://www.youtube.com/watch?v=JgMLyGBEQ1c"&gt;Eclipse 2023-03&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/javafx20/"&gt;JavaFX 20&lt;/a&gt;. С этой версии фреймворк требует Java 17 в качестве минимальной версии Java.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/03/java-annotated-monthly-march-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за март.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/surefire/maven-surefire-plugin/history.html"&gt;maven-surefire-plugin 3.0.0&lt;/a&gt;. Это первое обновление плагина Maven для запуска тестов спустя почти 4 года.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Вышла Java 20</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_20.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_20.html</id>
    <updated>2023-03-20T19:00:00Z</updated>
    <published>2023-03-20T19:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла общедоступная версия &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;Java 20&lt;/a&gt;. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-20.html"&gt;1500 закрытых задач и 7 JEP'ов&lt;/a&gt;. Release Notes можно посмотреть &lt;a href="http://jdk.java.net/20/release-notes"&gt;здесь&lt;/a&gt;. Изменения API &amp;ndash; &lt;a href="https://javaalmanac.io/jdk/20/apidiff/19/"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;Ссылки на скачивание:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/downloads/"&gt;Oracle JDK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://jdk.java.net/20/"&gt;OpenJDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Вот список JEP'ов, которые попали в Java 20.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/432"&gt;Паттерны записей (Second Preview) (JEP 432)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;В паттерны записей, которые появились &lt;a href="https://openjdk.org/jeps/405"&gt;в Java 19&lt;/a&gt; в режиме &lt;a href="https://openjdk.org/jeps/12"&gt;preview&lt;/a&gt; (и остающиеся в этом статусе в Java 20), было внесено три главные изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, добавилась поддержка вывода типов в записях-дженериках:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Box&amp;lt;T&gt;(T t) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; test(Box&amp;lt;String&gt; box) {
    &lt;span style="color: blue"&gt;if&lt;/span&gt; (box &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Box(&lt;span style="color: blue"&gt;var&lt;/span&gt; s)) { &lt;span style="color: green"&gt;// Выводится Box&amp;lt;String&gt;(var s)&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"String "&lt;/span&gt; + s);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, паттерны записей теперь могут присутствовать в заголовке улучшенного цикла &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; dump(Point[] pointArray) {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) : pointArray) {
        System.out.println(&lt;span style="color: darkred"&gt;"("&lt;/span&gt; + x + &lt;span style="color: darkred"&gt;", "&lt;/span&gt; + y + &lt;span style="color: darkred"&gt;")"&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;p&gt;Примечание: эту возможность было решено удалить &lt;a href="https://openjdk.org/jeps/440"&gt;в Java 21&lt;/a&gt;, но она снова может появиться в будущем в другом JEP'е.&lt;/p&gt;

&lt;p class="pt-1"&gt;В-третьих, исчезла поддержка именованных паттернов записей. Это значит, что такой код, который компилировался в Java 19, в Java 20 уже не будет компилироваться:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;var&lt;/span&gt; x, &lt;span style="color: blue"&gt;var&lt;/span&gt; y) p) { &lt;span style="color: red"&gt;// Syntax error&lt;/span&gt;
    ...
}&lt;/pre&gt;

&lt;p&gt;Хотя именованные паттерны и исчезли в этом релизе, это не значит, что они исчезли насовсем. Возможно они появятся в одном из будущих релизов, когда будут более тщательно продуманы.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/433"&gt;Паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; (Fourth Preview) (JEP 433)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Это уже четвёртая итерация preview паттерн-матчинга в Java. Напомним, что предыдущие три попали в Java &lt;a href="https://openjdk.org/jeps/406"&gt;17&lt;/a&gt;, &lt;a href="https://openjdk.org/jeps/420"&gt;18&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/427"&gt;19&lt;/a&gt;. В новой версии три главных изменения.&lt;/p&gt;

&lt;p&gt;Во-первых, исчерпывающий &lt;code&gt;switch&lt;/code&gt; по перечислениям теперь выбрасывает &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/MatchException.html"&gt;&lt;code&gt;MatchException&lt;/code&gt;&lt;/a&gt;, а не &lt;code&gt;IncompatibleClassChangeError&lt;/code&gt;, если ни одна из меток &lt;code&gt;switch&lt;/code&gt; не сматчилась.&lt;/p&gt;

&lt;p&gt;Во-вторых, упростилась грамматика меток &lt;code&gt;switch&lt;/code&gt; в JLS.&lt;/p&gt;

&lt;p&gt;В-третьих, добавилась поддержка вывода типов в записях-дженериках, если они являются паттернами в &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Pair&amp;lt;S, T&gt;(S first, T second) {}

&lt;span style="color: blue"&gt;static void&lt;/span&gt; recordInference(Pair&amp;lt;String, Integer&gt; pair) {
    &lt;span style="color: blue"&gt;switch&lt;/span&gt; (pair) {
        &lt;span style="color: blue"&gt;case&lt;/span&gt; Pair(&lt;span style="color: blue"&gt;var&lt;/span&gt; fst, &lt;span style="color: blue"&gt;var&lt;/span&gt; snd) -&gt; ... &lt;span style="color: green"&gt;// Выводится Pair&amp;lt;String, Integer&gt;&lt;/span&gt;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;Как видите, здесь JEP 433 полностью согласуется с JEP 432.&lt;/p&gt;

&lt;p&gt;Паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; предлагается финализировать в Java 21 (&lt;a href="https://openjdk.org/jeps/440"&gt;JEP 440&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/441"&gt;JEP 441&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/436"&gt;Virtual Threads (Second Preview) (JEP 436)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Виртуальные потоки, которые появились &lt;a href="https://openjdk.org/jeps/425"&gt;в Java 19&lt;/a&gt;, продолжают оставаться в статусе Preview API (предлагается финализировать их &lt;a href="https://openjdk.org/jeps/8303683"&gt;в Java 21&lt;/a&gt;). Изменений API, связанных с проектом &lt;a href="https://openjdk.org/projects/loom/"&gt;Loom&lt;/a&gt;, в этом релизе нет (если не считать scoped values и structured concurrency, которые имеют &lt;a href="https://openjdk.org/jeps/11"&gt;инкубационный статус&lt;/a&gt;).&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/429"&gt;Scoped Values (Incubator) (JEP 429)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый класс &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/ScopedValue.html"&gt;&lt;code&gt;ScopedValue&lt;/code&gt;&lt;/a&gt;, который позволяет обмениваться иммутабельными данными без их передачи через аргументы методов. Он является альтернативой существующему классу &lt;code&gt;ThreadLocal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Классы &lt;code&gt;ThreadLocal&lt;/code&gt; и &lt;code&gt;ScopedValue&lt;/code&gt; похожи тем, что решают одну и ту же задачу: передать значение переменной в рамках одного потока (или дерева потоков) из одного места в другое без использования явного параметра. В случае &lt;code&gt;ThreadLocal&lt;/code&gt; для этого вызывается метод &lt;code&gt;set()&lt;/code&gt;, который кладёт значение переменной для данного потока, а потом метод &lt;code&gt;get()&lt;/code&gt; вызывается из другого места для получения значения переменной. У данного подхода есть ряд недостатков:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Неконтролируемая мутабельность (&lt;code&gt;set()&lt;/code&gt; можно вызвать когда угодно и откуда угодно).&lt;/li&gt;
    &lt;li&gt;Неограниченное время жизни (переменная очистится, только когда завершится исполнение потока или когда будет вызван &lt;code&gt;ThreadLocal.remove()&lt;/code&gt;, но про него часто забывают).&lt;/li&gt;
    &lt;li&gt;Высокая цена наследования (дочерние потоки всегда вынуждены делать полную копию переменной, даже если родительский поток никогда не будет её изменять).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти проблемы усугубляются с появлением виртуальных потоков, которые могут создаваться в гораздо больше количестве, чем обычные.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt; лишён вышеперечисленных недостатков. В отличие от &lt;code&gt;ThreadLocal&lt;/code&gt;, &lt;code&gt;ScopedValue&lt;/code&gt; не имеет метода &lt;code&gt;set()&lt;/code&gt;. Значение ассоциируется с объектом &lt;code&gt;ScopedValue&lt;/code&gt; путём вызова другого метода &lt;code&gt;where()&lt;/code&gt;. Далее вызывается метод &lt;code&gt;run()&lt;/code&gt;, на протяжении которого это значение можно получить (через метод &lt;code&gt;get()&lt;/code&gt;), но нельзя изменить. Как только исполнение метода &lt;code&gt;run()&lt;/code&gt; заканчивается, значение отвязывается от объекта &lt;code&gt;ScopedValue&lt;/code&gt;. Поскольку значение не меняется, решается и проблема дорогого наследования: дочерним потоком не надо копировать значение, которое остаётся постоянным в течение периода жизни.
&lt;/p&gt;&lt;p&gt;Пример использования &lt;code&gt;ScopedValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;static final&lt;/span&gt; ScopedValue&amp;lt;Credentials&amp;gt; CREDENTIALS = new ScopedValue&lt;&gt;();

Credentials creds = ...
ScopedValue.where(CREDENTIALS, creds).run(() -&gt; {
   ...
   Connection connection = connectDatabase();
   ...
});

Connection connectDatabase() {
   Credentials credentials = CREDENTIALS.get();
   ...
}
&lt;/pre&gt;
&lt;p&gt;Во многих случаях &lt;code&gt;ScopedValue&lt;/code&gt; будет являться предпочтительной заменой &lt;code&gt;ThreadLocal&lt;/code&gt;. Однако когда иммутабельный подход неприменим для решения задачи, &lt;code&gt;ThreadLocal&lt;/code&gt; может остаться предпочтительным.&lt;/p&gt;
&lt;p&gt;На период инкубации новое API будет находиться в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В Java 21 scoped values, скорее всего, &lt;a href="https://openjdk.org/jeps/8304357"&gt;станут preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/437"&gt;Structured Concurrency (Second Incubator) (JEP 437)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Structured concurrency, которое появилось &lt;a href="https://openjdk.org/jeps/428"&gt;в Java 19&lt;/a&gt;, остаётся в инкубационном статусе в модуле &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/module-summary.html"&gt;&lt;code&gt;jdk.incubator.concurrent&lt;/code&gt;&lt;/a&gt; (вместе со &lt;code&gt;ScopedValue&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Единственное отличие от предыдущей версии API &amp;ndash; это то, что &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"&gt;StructuredTaskScope&lt;/a&gt; теперь поддерживает наследование scoped values потоками, созданными внутри области видимости задачи.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/434"&gt;Foreign Function &amp; Memory API (Second Preview) (JEP 434)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Foreign Function &amp; Memory API, ставшее preview &lt;a href="https://openjdk.org/jeps/424"&gt;в Java 19&lt;/a&gt;, продолжает находиться в этом статусе. API находится в пакете &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/package-summary.html"&gt;&lt;code&gt;java.lang.foreign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Основные изменения в этом релизе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemoryAddress&lt;/code&gt;. Теперь адреса моделируются через &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemorySegment.html"&gt;&lt;code&gt;MemorySegment&lt;/code&gt;&lt;/a&gt; с нулевой длиной.&lt;/li&gt;
  &lt;li&gt;Улучшена иерархия &lt;code&gt;sealed&lt;/code&gt; интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/MemoryLayout.html"&gt;&lt;code&gt;MemoryLayout&lt;/code&gt;&lt;/a&gt;, чтобы лучше соответствовать паттерн-матчингу для &lt;code&gt;switch&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Исчез интерфейс &lt;code&gt;MemorySession&lt;/code&gt;. Он разделён на два интерфейса &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/Arena.html"&gt;&lt;code&gt;Arena&lt;/code&gt;&lt;/a&gt; и &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/foreign/SegmentScope.html"&gt;&lt;code&gt;SegmentScope&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В Java 21 Foreign Function &amp; Memory API останется на &lt;a href="https://openjdk.org/jeps/442"&gt;третье preview&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.org/jeps/438"&gt;Vector API (Fifth Incubator) (JEP 438)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Векторное API всё никак не хочет становиться стабильным и остаётся в инкубационном статусе уже в пятый раз (модуль &lt;a href="https://docs.oracle.com/en/java/javase/20/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;). В этом релизе лишь небольшие исправления багов и улучшения производительности. Скорее всего, инкубационный статус будет оставаться до тех пор, пока необходимые фичи проекта &lt;a href="https://openjdk.org/projects/valhalla/"&gt;Valhalla&lt;/a&gt; не появятся в режиме preview (проект &lt;a href="https://openjdk.org/projects/panama/"&gt;Panama&lt;/a&gt; сильно зависит от проекта Valhalla).&lt;/p&gt;

&lt;h5 class="pt-2"&gt;Заключение&lt;/h5&gt;
&lt;p class="pt-3"&gt;Java 20 не является LTS-релизом и будет получать обновления от Oracle только в течение полугода (до сентября 2023 года). LTS-релизом станет следующая версия, &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;Java 21&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #55</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_55.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_55.html</id>
    <updated>2023-03-05T19:00:00Z</updated>
    <published>2023-03-05T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Первые два JEP'а были предложены к попаданию в Java 21. Это &lt;a href="https://openjdk.org/jeps/430"&gt;JEP 430: String Templates (Preview)&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/431"&gt;JEP 431: Sequenced Collections&lt;/a&gt;. Java 21 &amp;ndash; это &lt;a href="https://openjdk.org/projects/jdk/21/"&gt;следующий LTS-релиз&lt;/a&gt; после Java 17, который должен выйти в сентябре 2023 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.org/jeps/438"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;, который сразу же &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-March/007404.html"&gt;был предложен&lt;/a&gt; к попаданию в Java 20. JEP появился с большим опозданием перед самым релизом из-за &lt;a href="https://mail.openjdk.org/pipermail/jdk-dev/2023-February/007389.html"&gt;недопонимания&lt;/a&gt; со стороны владельца JEP'а. Сейчас эта ошибка была исправлена. Напомним, что общедоступная версия Java 20 выходит уже &lt;a href="https://openjdk.org/projects/jdk/20/"&gt;через две недели&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышло несколько новых черновиков JEP.&lt;/p&gt;
&lt;p&gt;Самые главные &amp;ndash; это &lt;a href="https://openjdk.org/jeps/8300541"&gt;Record Patterns&lt;/a&gt; и &lt;a href="https://openjdk.org/jeps/8300542"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;. В них предлагается сделать паттерны записей и паттерн-матчинг для &lt;code&gt;switch&lt;/code&gt; постоянными языковыми конструкциями. Напомним, что в Java 20 они будут всё ещё в статусе preview (&lt;a href="https://openjdk.java.net/jeps/432"&gt;JEP 432&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/433"&gt;JEP 433&lt;/a&gt;). Таким образом, в следующем LTS-релизе Java 21 планируется их &lt;a href="https://mail.openjdk.org/pipermail/amber-dev/2023-February/007841.html"&gt;финализировать&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В финальные версии конструкций предлагается внести следующие небольшие изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Паттерны, заключённые в скобки, поддерживаться не будут.&lt;/li&gt;
  &lt;li&gt;В &lt;code&gt;case&lt;/code&gt;-ветках будут разрешены квалифицированные константы перечислений (при условии, что эти константы совместимы по присваиванию с целевым типом).&lt;/li&gt;
  &lt;li&gt;Паттерны записей в заголовках цикла &lt;code&gt;for&lt;/code&gt; поддерживаться не будут. Однако они снова появятся в отдельном JEP'е.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-1"&gt;Следующий черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303167"&gt;Deprecate the Windows x86-32 Port&lt;/a&gt;. Пометить как deprecated 32-битный порт JDK предлагается ради ускорения разработки платформы. Одной из мотиваций также является отсутствие нативной реализации &lt;a href="https://openjdk.org/jeps/436"&gt;виртуальных потоков&lt;/a&gt; на 32-битной Windows JDK. Также Windows 10 (последняя версия Windows, поддерживающая 32 бит) достигнет своей End of Life в &lt;a href="https://learn.microsoft.com/lifecycle/products/windows-10-home-and-pro"&gt;октябре 2025 года&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-1"&gt;Ещё один черновик JEP &amp;ndash; &lt;a href="https://openjdk.org/jeps/8303358"&gt;Scoped Values (Preview)&lt;/a&gt;. Таким образом, Scoped Values в Java 21 могут выйти из &lt;a href="https://openjdk.org/jeps/429"&gt;инкубационного статуса&lt;/a&gt; и стать preview. Про Scoped Values мы писали в &lt;a href="java_news_44.html"&gt;выпуске #44&lt;/a&gt;, когда они ещё назывались Extent-Local Variables.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Сайт поиска артефактов в Maven Central &lt;a href="https://search.maven.org"&gt;https://search.maven.org&lt;/a&gt; теперь стал перенаправлять на &lt;a href="https://central.sonatype.com"&gt;https://central.sonatype.com&lt;/a&gt;. На сайте Sonatype &lt;a href="https://central.sonatype.org/faq/what-happened-to-search-maven-org/"&gt;это объясняется&lt;/a&gt; тем, что central.sonatype.com уже покрывает главную функциональность search.maven.org, а также предоставляет больше деталей о компонентах, например, рейтинг безопасности. Кроме того, индекс поиска там обновляется гораздо чаще, чем на search.maven.org, а значит там более свежая и надёжная информация.&lt;/p&gt;
&lt;p&gt;Вернуться к старому сайту пока всё ещё можно, если нажать по &lt;a href="https://search.maven.org/?eh"&gt;соответствующей ссылке&lt;/a&gt; во всплывающем сообщении. Полное закрытие старого сайта планируется в конце 2023 - начале 2024 года.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://blogs.apache.org/netbeans/#announce-apache-netbeans-17-released"&gt;Apache NetBeans 17&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.org/pipermail/jol-dev/2023-February/000509.html"&gt;JOL 0.17&lt;/a&gt;. Из основных изменений: минимальная версия Java теперь 8, добавлена поддержка Lilliput.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #54</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_54.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_54.html</id>
    <updated>2023-02-19T19:00:00Z</updated>
    <published>2023-02-19T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8302326"&gt;Implicit Classes and Enhanced Main Methods (Preview)&lt;/a&gt;. В нём предлагается сделать протокол запуска программ на Java более гибким, дав возможность программисту (в особенности новичку) опускать ненужные конструкции при написании простых программ, что поможет упростить вхождение в язык.&lt;/p&gt;
&lt;p&gt;Во-первых, модификатор &lt;code&gt;public&lt;/code&gt; и параметр &lt;code&gt;String[] args&lt;/code&gt; для метода &lt;code&gt;main()&lt;/code&gt; будут опциональными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;static void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;Во-вторых, метод &lt;code&gt;main()&lt;/code&gt; не будет обязан быть статическим. Тогда JVM сама инстанцирует класс (для этого у него должен иметься не-private конструктор без аргументов) и вызовет метод &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; HelloWorld {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
        System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;В-третьих, само объявление класса будет опциональным. В таком случае JVM сама создаст экземпляр безымянного неявного класса и вызовет &lt;code&gt;main()&lt;/code&gt; на нём:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;void&lt;/span&gt; main() {
    System.out.println(&lt;span style="color: darkred"&gt;"Hello World"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;Эти три упрощения помогут новичкам сфокусировать своё изучение языка на простых концепциях вроде объявлений переменных и циклов, а затем постепенно переходить к более сложным (классам, модификаторам доступа и статическим методам).&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел ещё один черновик JEP: &lt;a href="https://openjdk.org/jeps/8299906"&gt;Support Markdown in Documentation Comments&lt;/a&gt;. В этом JEP'е предлагается добавить возможность писать JavaDoc на языке &lt;a href="https://commonmark.org/"&gt;Markdown&lt;/a&gt; вместо HTML. Markdown на сегодняшний день является очень популярным форматом написания документации, отличительной особенностью которого является простота синтаксиса и лёгкость чтения. Markdown трансформируется в HTML, но достаточно легко читаем и в сыром виде.&lt;/p&gt;
&lt;p&gt;Пример возможной документации на Markdown для &lt;code&gt;Object.hashCode()&lt;/code&gt; с использованием Markdown:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**md&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;Returns a hash code value for the object. This method is
&lt;span style="color: green"&gt; * &lt;/span&gt;supported for the benefit of hash tables such as those provided by
&lt;span style="color: green"&gt; * &lt;/span&gt;{&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; java.util.HashMap}.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;The general contract of &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; is:
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;-   Whenever it is invoked on the same object more than once during
&lt;span style="color: green"&gt; * &lt;/span&gt;    an execution of a Java application, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method
&lt;span style="color: green"&gt; * &lt;/span&gt;    must consistently return the same integer, provided no information
&lt;span style="color: green"&gt; * &lt;/span&gt;    used in &lt;span style="color: darkgreen"&gt;`equals`&lt;/span&gt; comparisons on the object is modified.
&lt;span style="color: green"&gt; * &lt;/span&gt;    This integer need not remain consistent from one execution of an
&lt;span style="color: green"&gt; * &lt;/span&gt;    application to another execution of the same application.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   If two objects are equal according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;    #equals(Object) equals} method, then calling the
&lt;span style="color: green"&gt; * &lt;/span&gt;    &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects must produce the
&lt;span style="color: green"&gt; * &lt;/span&gt;    same integer result.
&lt;span style="color: green"&gt; * &lt;/span&gt;-   It is _not_ required that if two objects are unequal
&lt;span style="color: green"&gt; * &lt;/span&gt;    according to the {&lt;span style="color: gray"&gt;&lt;b&gt;@link&lt;/b&gt;&lt;/span&gt; #equals(Object) equals} method, then
&lt;span style="color: green"&gt; * &lt;/span&gt;    calling the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method on each of the two objects
&lt;span style="color: green"&gt; * &lt;/span&gt;    must produce distinct integer results.  However, the programmer
&lt;span style="color: green"&gt; * &lt;/span&gt;    should be aware that producing distinct integer results for
&lt;span style="color: green"&gt; * &lt;/span&gt;    unequal objects may improve the performance of hash tables.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@implSpec&lt;/b&gt;&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;As far as is reasonably practical, the &lt;span style="color: darkgreen"&gt;`hashCode`&lt;/span&gt; method defined
&lt;span style="color: green"&gt; * &lt;/span&gt;by class &lt;span style="color: darkgreen"&gt;`Object`&lt;/span&gt; returns distinct integers for distinct objects.
&lt;span style="color: green"&gt; *&lt;/span&gt;
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@return&lt;/b&gt;&lt;/span&gt;  a hash code value for this object.
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.Object#equals(java.lang.Object)
&lt;span style="color: green"&gt; * &lt;/span&gt;&lt;span style="color: gray"&gt;&lt;b&gt;@see&lt;/b&gt;&lt;/span&gt;     java.lang.System#identityHashCode
&lt;span style="color: green"&gt; */&lt;/span&gt;&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://maven.apache.org/docs/3.9.0/release-notes.html"&gt;Apache Maven 3.9.0&lt;/a&gt;. Самые заметные изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Минимальная версия Java теперь 8. Это первое увеличение минимальной версии Java спустя 8 лет. В прошлый раз это был Maven &lt;a href="https://maven.apache.org/docs/3.3.1/release-notes.html"&gt;3.3.1&lt;/a&gt;, где минимальной версией стала Java 7.&lt;/li&gt;
  &lt;li&gt;Обратная совместимость с Maven 2.x окончательно убрана.&lt;/li&gt;
  &lt;li&gt;Теперь выдаются &lt;a href="https://issues.apache.org/jira/browse/MNG-7457"&gt;предупреждения&lt;/a&gt; об использовании deprecated плагинов, целей, параметров и т.д.&lt;/li&gt;
  &lt;li&gt;В консоли теперь пишутся префиксы плагинов вместо их &lt;code&gt;artifactId&lt;/code&gt; (например, &lt;code&gt;compiler:3.10.1:compile&lt;/code&gt; вместо &lt;code&gt;maven-compiler-plugin:3.10.1:compile&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Теперь можно вызывать цели через &lt;a href="https://issues.apache.org/jira/browse/MNG-7353"&gt;&lt;code&gt;mvn pluginPrefix:version:goal&lt;/code&gt;&lt;/a&gt;. Раньше это можно было делать либо через &lt;code&gt;mvn:pluginPrefix:goal&lt;/code&gt;, либо через &lt;code&gt;groupId:artifactId[:version]:goal&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Стала возможной активация профиля по типу &lt;code&gt;packaging&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список изменений и нововведений &lt;a href="https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316922&amp;version=12350913"&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://docs.gradle.org/8.0/release-notes.html"&gt;Gradle 8.0&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел JetBrains &lt;a href="https://blog.jetbrains.com/idea/2023/02/java-annotated-monthly-february-2023/"&gt;Java Annotated Monthly за февраль&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #53</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_53.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_53.html</id>
    <updated>2023-01-29T19:00:00Z</updated>
    <published>2023-01-29T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышли обновления Java:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/19-0-2-relnotes.html"&gt;JDK 19.0.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/17-0-6-relnotes.html"&gt;JDK 17.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020011.html"&gt;JDK 13.0.14&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk-updates-dev/2023-January/020012.html"&gt;JDK 15.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.oracle.com/java/technologies/javase/11-0-18-relnotes.html"&gt;JDK 11.0.18&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.org/pipermail/jdk8u-dev/2023-January/016479.html"&gt;JDK 8u362&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел новый черновик JEP: &lt;a href="https://openjdk.org/jeps/8300786"&gt;No longer require &lt;code&gt;super()&lt;/code&gt; and &lt;code&gt;this()&lt;/code&gt; to appear first in a constructor&lt;/a&gt;. В нём предлагается разрешить писать инструкции кода до вызова &lt;code&gt;super()&lt;/code&gt; и &lt;code&gt;this()&lt;/code&gt; в конструкторах.&lt;/p&gt;
&lt;p&gt;Напомним, что сейчас эти вызовы всегда должны быть первыми вызовами в конструкторах, иначе код не скомпилируется:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; PositiveBigInteger &lt;span style="color: blue"&gt;extends&lt;/span&gt; BigInteger {
    &lt;span style="color: blue"&gt;public&lt;/span&gt; PositiveBigInteger(&lt;span style="color: blue"&gt;long&lt;/span&gt; value) {
        &lt;span style="color: blue"&gt;if&lt;/span&gt; (value &lt;= 0)
            &lt;span style="color: blue"&gt;throw new&lt;/span&gt; IllegalArgumentException(&lt;span style="color: darkred"&gt;"non-positive value"&lt;/span&gt;);
        &lt;span style="color: blue"&gt;super&lt;/span&gt;(value); &lt;span style="color: red"&gt;// error: call to super must be first statement in constructor&lt;/span&gt;
    }
}&lt;/pre&gt;
&lt;p&gt;Такое ограничение иногда создаёт неудобства, например, при необходимости проверять входные аргументы до вызова суперконструктора (как в примере выше), при передаче одного и того же вычисляемого параметра в суперконструктор несколько раз или при нетривиальной подготовке параметра перед передачей его в суперконструктор.&lt;/p&gt;
&lt;p&gt;JEP предлагает это ограничение снять и позволить писать инструкции до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;. Однако для кода до вызова остаётся ограничение, что он должен быть в статическом контексте, то есть не должен ссылаться на текущий объект явно или неявно (использовать &lt;code&gt;this&lt;/code&gt;, вызывать нестатические методы и так далее).&lt;/p&gt;
&lt;p&gt;Любопытно, что в спецификации JVM подобного ограничения нет, и она разрешает произвольный код до вызова &lt;code&gt;super()&lt;/code&gt; / &lt;code&gt;this()&lt;/code&gt;, если он не ссылается на конструируемый объект. Таким образом, предлагаемое изменение будет чисто языковым изменением, без необходимости менять что-то в виртуальной машине.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Черновик JEP "Support for primitive types in &lt;code&gt;instanceof&lt;/code&gt; and type patterns", о котором мы писали в &lt;a href="java_news_49.html"&gt;выпуске #49&lt;/a&gt;, был переименован в &lt;a href="https://openjdk.org/jeps/8288476"&gt;"Primitive types in patterns, &lt;code&gt;instanceof&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;"&lt;/a&gt;. Добавилось важное дополнение, что примитивные типы смогут появляться в ветках &lt;code&gt;switch&lt;/code&gt;. Например:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt; i = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (i) {
    &lt;span style="color: blue"&gt;case byte&lt;/span&gt; b -&gt; ... ;
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; f -&gt; ... ;
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...;
}&lt;/pre&gt;
&lt;p&gt;Кроме того, список типов константных выражений в ветках будет расширен до всех примитивных типов, включая &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;boolean&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;float&lt;/span&gt; f = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (f) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.0f -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 1.5f -&gt; ...
    &lt;span style="color: blue"&gt;case float&lt;/span&gt; g -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;long&lt;/span&gt; x = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (x) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 10_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; 20_000_000_000L -&gt; ...
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;boolean&lt;/span&gt; b = ...;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (b) {
    &lt;span style="color: blue"&gt;case true&lt;/span&gt; -&gt; ...
    &lt;span style="color: blue"&gt;case false&lt;/span&gt; -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-2"&gt;&amp;bull; Oracle &lt;a href="https://houseofbrick.com/blog/oracle-java-pricing/"&gt;изменила правила&lt;/a&gt; платной подписки на Java SE. Теперь единицей, по которой рассчитывается стоимость, становится сотрудник компании, а не процессор. Таким образом, теперь на цену подписки влияет только количество сотрудников, а не количество серверов и настольных компьютеров, на которых запущена Java (если только у вас не больше 50000 процессоров на серверах). Это приведёт к подорожанию подписки для большинства случаев. В некоторых случаях такой рост будет на порядок.&lt;/p&gt;
&lt;p&gt;Напомним, что Java была и остаётся свободным ПО, и вышеупомянутое изменение ценовой политики Oracle никак не повлияет на пользователей &lt;a href="https://openjdk.org/"&gt;OpenJDK&lt;/a&gt;, которая продолжает оставаться бесплатной. Останется бесплатной и &lt;a href="https://blogs.oracle.com/java/post/free-java-license"&gt;Oracle JDK 17&lt;/a&gt;, в том числе и для коммерческого использования. Повышение тарифных планов коснётся только компаний, имеющих &lt;a href="https://www.oracle.com/java/java-se-subscription/#rc30p3"&gt;Oracle Java SE Universal Subscription&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #52</title>
    <link rel="alternate" type="text/html" href="https://minijug.org/java_news_52.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.org/java_news_52.html</id>
    <updated>2023-01-17T19:00:00Z</updated>
    <published>2023-01-17T19:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел &lt;a href="https://kotlinlang.org/docs/whatsnew18.html"&gt;Kotlin 1.8.0&lt;/a&gt;. Некоторые заметные нововведения и изменения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Новые экспериментальные функции &lt;code&gt;copyToRecursively()&lt;/code&gt; and &lt;code&gt;deleteRecursively()&lt;/code&gt; для директорий.&lt;/li&gt;
  &lt;li&gt;Улучшенная производительность kotlin-reflect.&lt;/li&gt;
  &lt;li&gt;Новая опция &lt;code&gt;-Xdebug&lt;/code&gt;, подавляющая оптимизации, для более удобной отладки.&lt;/li&gt;
  &lt;li&gt;Больше не поддерживается таргетирование в байткод 1.6 и 1.7. Вследствие этого, стандартные библиотеки скомпилированы только в 1.8, и более нет разделения на &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, а есть единый &lt;code&gt;kotlin-stdlib&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Улучшена интероперабельность с Objective-C/Swift.&lt;/li&gt;
  &lt;li&gt;Совместимость с Gradle 7.3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел выпуск &lt;a href="https://blog.jetbrains.com/idea/2023/01/java-annotated-monthly-january-2023/"&gt;Java Annotated Monthly&lt;/a&gt; от JetBrains за январь.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/apache/maven/releases/tag/maven-3.8.7"&gt;Apache Maven 3.8.7&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-2"&gt;&amp;bull; Вышел &lt;a href="https://github.com/mockito/mockito/releases/tag/v5.0.0"&gt;Mockito 5.0.0&lt;/a&gt;. Новая версия библиотеки требует Java 11 в качестве минимальной версии.&lt;/p&gt;</content>
  </entry>
</feed>
