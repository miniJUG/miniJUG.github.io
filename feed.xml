<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miniJUG</title>
  <link rel="alternate" type="text/html" href="https://minijug.ru" />
  <subtitle type="text">Новости Java</subtitle>
  <id>https://minijug.ru/feed.xml</id>
  <updated>2021-03-15T17:00:00Z</updated>
  <entry>
    <title>Вышла Java 16</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_16.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_16.html</id>
    <updated>2021-03-15T17:00:00Z</updated>
    <published>2021-03-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;Вышла &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;16-я версия&lt;/a&gt; платформы Java SE. В этот релиз попало около &lt;a href="https://builds.shipilev.net/backports-monitor/release-notes-16.txt"&gt;двух с половиной тысяч&lt;/a&gt; закрытых задач и 17 JEP'ов. Изменения API можно посмотреть &lt;a href="https://javaalmanac.io/jdk/16/apidiff/15/"&gt;здесь&lt;/a&gt;. Release notes &lt;a href="https://www.oracle.com/java/technologies/javase/16-all-relnotes.html"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Уже сейчас доступны для скачивания дистрибутивы &lt;a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html"&gt;Oracle JDK&lt;/a&gt; и &lt;a href="http://jdk.java.net/16/"&gt;OpenJDK&lt;/a&gt;.&lt;/p&gt;
&lt;!-- cut --&gt;
&lt;p&gt;JEP'ы, которые попали в Java 16, мы разобьём на четыре категории: язык, API, JVM и инфраструктура.&lt;/p&gt;
&lt;h4&gt;Язык&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/375"&gt;Паттерн-матчинг для оператора &lt;code&gt;instanceof&lt;/code&gt; (JEP 375)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Оператор &lt;code&gt;instanceof&lt;/code&gt; с паттерн-матчингом, который &lt;a href="https://openjdk.java.net/jeps/305"&gt;появился&lt;/a&gt; в Java 14 и перешёл во &lt;a href="https://openjdk.java.net/jeps/375"&gt;второе preview&lt;/a&gt; в Java 15, теперь стал стабильной синтаксической конструкцией и больше не требует флага &lt;code&gt;--enable-preview&lt;/code&gt;. Паттерн-матчинг мы подробно рассматривали в &lt;a href="trying_new_instanceof_in_java_14.html"&gt;этой статье&lt;/a&gt;, и с того момента в него было внесено два изменения:&lt;/p&gt;
&lt;p&gt;Во-первых, переменные паттернов теперь не являются неявно финальными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (obj &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) {
    s = &lt;span style="color: darkred"&gt;"Hello"&lt;/span&gt;; &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Во-вторых, если тип выражения, известный на этапе компиляции, является подтипом проверяемого типа, то теперь это ошибка компиляции:&lt;/p&gt;
&lt;pre&gt;String str = ...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (str &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String s) { &lt;span style="color: green"&gt;// Oшибка в Java 16, OK в Java 15&lt;/span&gt;
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/395"&gt;Записи (JEP 395)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одна синтаксическая конструкция, которая стала стабильной &amp;ndash; это записи. Она также была в режиме preview в &lt;a href="https://openjdk.java.net/jeps/359"&gt;Java 14&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/384"&gt;Java 15&lt;/a&gt;. Записи мы также подробно &lt;a href="trying_records_in_java14.html"&gt;рассматривали ранее&lt;/a&gt;. В Java 16 было внесено следующее изменение: теперь во внутренних классах разрешено объявлять статические члены:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; Outer {
    &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;static void&lt;/span&gt; main(String[] args) {
        }

        &lt;span style="color: green"&gt;// OK в Java 16, ошибка в Java 15&lt;/span&gt;
        &lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {
        }
    }
}&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/397"&gt;&lt;code&gt;sealed&lt;/code&gt; классы (второе preview) (JEP 397)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;&amp;laquo;Запечатанные&amp;raquo; классы, которые появились в Java 15 в режиме preview, остаются в этом статусе. Их мы рассматривали в &lt;a href="trying_sealed_classes_in_java_15.html"&gt;этой статье&lt;/a&gt;. Изменения по сравнению с прошлой версией следующие:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Теперь в спецификации языка Java появилось понятие contextual keyword взамен старым понятиям restricted keyword и restricted identifier, и одними из таких contextual keywords стали &lt;code&gt;sealed&lt;/code&gt;, &lt;code&gt;non-sealed&lt;/code&gt; и &lt;code&gt;permits&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Компилятор теперь производит более строгие проверки при конверсии типов, в иерархиях которых есть &lt;code&gt;sealed&lt;/code&gt; классы:&lt;pre&gt;
&lt;span style="color: blue"&gt;sealed interface&lt;/span&gt; Sealed {
}

&lt;span style="color: blue"&gt;final class&lt;/span&gt; Impl &lt;span style="color: blue"&gt;implements&lt;/span&gt; Sealed {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; f(Runnable r) {
        Sealed s = (Sealed) r; &lt;span style="color: red"&gt;// error: incompatible types&lt;/span&gt;
    }
}&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Метод &lt;code&gt;Class.permittedSubclasses()&lt;/code&gt; переименован в &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#getPermittedSubclasses()"&gt;&lt;code&gt;Class.getPermittedSubclasses()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;JVM&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/396"&gt;Строгая инкапсуляция внутренностей JDK по умолчанию (JEP 396)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инкапсуляция внутренних API JDK, которая была &lt;a href="https://openjdk.java.net/jeps/260"&gt;введена в Java 9&lt;/a&gt;, теперь стала строгой: если в Java 9-15 значение опции &lt;code&gt;--illegal-access&lt;/code&gt; было по умолчанию &lt;code&gt;permit&lt;/code&gt;, то с Java 16 она становится &lt;code&gt;deny&lt;/code&gt;. Это значит, что рефлективный доступ к защищённым членам классов и статический доступ к неэкспортированным API (&lt;code&gt;sun.*&lt;/code&gt;, &lt;code&gt;com.sun.*&lt;/code&gt;, &lt;code&gt;jdk.internal.*&lt;/code&gt; и т.д.) теперь будет выбрасывать ошибку.&lt;/p&gt;
&lt;p&gt;Если код требует доступа к внутренностям JDK во время выполнения, то чтобы он продолжал работать на Java 16, теперь придётся явно указывать одну из трёх опций JVM:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--illegal-access=permit/warn/debug&lt;/code&gt;: открытие всех пакетов JDK&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-opens=module/package=target-module&lt;/code&gt;: открытие одного пакета&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--add-exports=module/package=target-module&lt;/code&gt;: экспортирование одного пакета (только для статического доступа)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В будущем опция &lt;code&gt;--illegal-access&lt;/code&gt; может быть удалена окончательно. Начиная с Java 16, при её использовании выдаётся предупреждение: &lt;code&gt;Option --illegal-access is deprecated and will be removed in a future release&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Изменения не касаются критического API в модуле &lt;code&gt;jdk.unsupported&lt;/code&gt;: классы в пакетах &lt;code&gt;sun.misc&lt;/code&gt; и &lt;code&gt;sun.reflect&lt;/code&gt; остаются доступными без флагов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/390"&gt;Warnings for Value-Based Classes (JEP 390)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Классы-обёртки примитивных типов (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt; и т.д.) теперь относятся к категории value-based классов, и их конструкторы, которые ранее &lt;a href="new_integer_is_deprecated.html"&gt;стали deprecated&lt;/a&gt; в Java 9, теперь помечены как &lt;a href="https://openjdk.java.net/jeps/277"&gt;deprecated for removal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Понятие value-based классов появилось в спецификации API &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html"&gt;Java 8&lt;/a&gt;. Такие классы являются неизменяемыми, создаются только через фабрики, и в их использовании не должны использоваться операции, чувствительные к identity: сравнение на &lt;code&gt;==&lt;/code&gt;, синхронизация, &lt;code&gt;identityHashCode()&lt;/code&gt; и т.д. Value-based классы являются кандидатами для миграции на &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;примитивные классы&lt;/a&gt; в рамках проекта &lt;a href="https://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;, который сейчас находится в стадии активной разработки.&lt;/p&gt;
&lt;p&gt;При синхронизации на объектах value-based классов теперь будет выдаваться предупреждение во время компиляции:&lt;/p&gt;
&lt;pre&gt;Double d = 0.0;
&lt;span style="color: blue"&gt;synchronized&lt;/span&gt; (d) { &lt;span style="color: orange"&gt;// warning: [synchronization] attempt to synchronize on an instance of a value-based class&lt;/span&gt;
}&lt;/pre&gt;
&lt;p&gt;Также можно включить проверки синхронизации на value-based объектах во время выполнения с помощью флагов JVM:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=1&lt;/code&gt;: при попытке синхронизации будет фатальная ошибка.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=2&lt;/code&gt;: при попытке синхронизации будет предупреждение.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/376"&gt;ZGC: Concurrent Thread-Stack Processing (JEP 376)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Обработка стеков потоков в сборщике мусора &lt;a href="https://openjdk.java.net/jeps/377"&gt;ZGC&lt;/a&gt; теперь перенесена из safepoints в конкурентную фазу. Это позволило ещё сильнее уменьшить паузы сборщика мусора.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/380"&gt;Unix-Domain Socket Channels (JEP 380)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Добавлена поддержка &lt;a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0_Unix"&gt;сокетов доменов Unix&lt;/a&gt; в socket channel и server-socket channel API. Такие сокеты используются для межпроцессного взаимодействия внутри одного хоста, и в них не используются сетевые соединения, что делает такое взаимодействие более безопасным и эффективным. Сокеты доменов Unix с &lt;a href="https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/"&gt;недавних пор&lt;/a&gt; поддерживаются в Windows 10 и Windows Server 2019.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/387"&gt;Elastic Metaspace (JEP 387)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Metaspace (пространство JVM, в котором хранятся метаданные классов) переработан для более эффективной отдачи неиспользуемой памяти обратно операционной системе и меньшего потребления памяти вне кучи в целом. Такое улучшение может быть полезно для приложений, которые интенсивно загружают и выгружают классы посредством большого количества загрузчиков классов.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/386"&gt;Alpine Linux Port (JEP 386)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK теперь портирован на &lt;a href="https://ru.wikipedia.org/wiki/Alpine_Linux"&gt;Alpine Linux&lt;/a&gt; и другие дистрибутивы Linux, которые используют &lt;a href="https://ru.wikipedia.org/wiki/Musl"&gt;musl&lt;/a&gt; в качестве реализации стандартной библиотеки C. Alpine Linux популярен в облаках, микросервисах и контейнерах благодаря своему маленькому размеру образа. Новый порт позволит нативно запускать JDK в этих окружениях.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/388"&gt;Windows/AArch64 Port (JEP 388)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;JDK также портирован на архитектуру &lt;a href="https://docs.microsoft.com/ru-ru/windows/uwp/porting/apps-on-arm"&gt;Windows/AArch64&lt;/a&gt;. Это позволит запускать Java на компьютерах с Windows on ARM, которые в последнее время набирают популярность.&lt;/p&gt;

&lt;h4&gt;API&lt;/h4&gt;
&lt;h5&gt;Новые методы в &lt;code&gt;Stream&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;Хотя для этих двух новых методов в интерфейсе &lt;code&gt;java.util.stream.Stream&lt;/code&gt; нет отдельного JEP, хочется упомянуть их здесь, так как это довольно заметное изменение.&lt;/p&gt;
&lt;p&gt;Первый метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#toList()"&gt;&lt;code&gt;Stream.toList()&lt;/code&gt;&lt;/a&gt;. Этот метод собирает содержимое &lt;code&gt;Stream&lt;/code&gt; в неизменяемый список и возвращает его. При этом, в отличие от &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableList()"&gt;&lt;code&gt;Collectors.toUnmodifiableList()&lt;/code&gt;&lt;/a&gt;, список, который возвращается из &lt;code&gt;Stream.toList()&lt;/code&gt;, толерантен к &lt;code&gt;null&lt;/code&gt;-элементам.&lt;/p&gt;
&lt;p&gt;Второй метод &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)"&gt;&lt;code&gt;Stream.mapMulti()&lt;/code&gt;&lt;/a&gt; (и примитивные специализации). Это метод является императивным аналогом метода &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)"&gt;&lt;code&gt;Stream.flatMap()&lt;/code&gt;&lt;/a&gt;: если &lt;code&gt;flatMap()&lt;/code&gt; принимает функцию, которая для каждого элемента должна вернуть &lt;code&gt;Stream&lt;/code&gt;, то &lt;code&gt;mapMulti()&lt;/code&gt; принимает процедуру с двумя параметрами, где первый параметр &amp;ndash; это текущий элемент, а второй &amp;ndash; Consumer, в который кладутся значения. Пример:&lt;/p&gt;
&lt;pre&gt;IntStream.rangeClosed(1, 10).mapMulti((i, consumer) -&gt; {
    &lt;span style="color: blue"&gt;for&lt;/span&gt; (&lt;span style="color: blue"&gt;int&lt;/span&gt; j = 1; j &lt;= i; j++) {
        consumer.accept(j);
    }
}); &lt;span style="color: green"&gt;// Возвращает 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...&lt;/span&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/392"&gt;Инструмент упаковки (JEP 392)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Инструмент создания самодостаточных приложений &lt;code&gt;jpackage&lt;/code&gt;, который &lt;a href="https://openjdk.java.net/jeps/343"&gt;появился в Java 14&lt;/a&gt; в инкубационном статусе, теперь стал постоянным модулем.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/338"&gt;Vector API (Incubator) (JEP 338)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Появился новый инструментарий для преобразования векторных вычислений в SIMD-инструкции процессора (x64 и AArch64). Векторное API позволит разработчику контролировать процесс компиляции и не полагаться на автовекторизацию, которая в JVM является ограниченным и хрупким механизмом. Явная векторизация может применяться в таких областях как машинное обучение, линейная алгебра, криптография и др.&lt;/p&gt;
&lt;p&gt;API находится в инкубационном модуле &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.vector/module-summary.html"&gt;&lt;code&gt;jdk.incubator.vector&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/389"&gt;Foreign Linker API (Incubator) (JEP 389)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Ещё одно новое API, которое появилось в результате работы над проектом &lt;a href="http://openjdk.java.net/projects/panama/"&gt;Panama&lt;/a&gt; &amp;ndash; это &lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/jdk.incubator.foreign/module-summary.html"&gt;Foreign Linker API&lt;/a&gt;. Это инструментарий для статического доступа к нативному коду из Java, созданный для замены JNI: он должен быть более простым в использовании, более безопасным и желательно более быстрым.&lt;/p&gt;
&lt;p&gt;Про Foreign API &lt;a href="https://www.youtube.com/watch?v=4vHMmLqF09Y"&gt;делал доклад&lt;/a&gt; Владимир Иванов из Oracle.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/393"&gt;Foreign-Memory Access API (Third Incubator) (JEP 393)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;API для доступа вне кучи Java, которое появилось &lt;a href="https://openjdk.java.net/jeps/370"&gt;в Java 14&lt;/a&gt;, остаётся в инкубационном статусе с некоторыми изменениями.&lt;/p&gt;

&lt;h4&gt;Инфраструктура&lt;/h4&gt;
&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/347"&gt;Enable C++14 Language Features (JEP 347)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Кодовая база JDK до Java 16 использовала стандарты C++98/03. При этом с Java 11 код стал собираться версией с более новым стандартом, однако в нём всё ещё нельзя было использовать возможности стандарта C++11/14. Теперь же часть из этих возможностей использовать можно: в гиде по стилю HotSpot определён список возможностей C++11/14, которые можно использовать и которые нельзя.&lt;/p&gt;

&lt;h5&gt;&lt;a href="https://openjdk.java.net/jeps/357"&gt;Migrate from Mercurial to Git (JEP 357)&lt;/a&gt; и &lt;a href="https://openjdk.java.net/jeps/369"&gt;Migrate to GitHub (JEP 369)&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;Совершён переход репозиториев JDK на Git и GitHub. Миграция была полностью завершена в &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2020-September/004694.html"&gt;сентябре 2020 года&lt;/a&gt;, и разработка Java 16 уже полностью велась в &lt;a href="https://git.openjdk.java.net/jdk"&gt;новом репозитории&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Переход на GitHub облегчил процесс принятия изменений контрибьюторами. Теперь изменения предлагаются через привычные большинству пользователей пулл-реквесты, и большая часть процесса автоматизирована с помощью команд и ботов. Подробнее про процесс можно прочитать на &lt;a href="https://wiki.openjdk.java.net/display/SKARA/Skara"&gt;странице проекта Skara&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также сейчас &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;обсуждается&lt;/a&gt; переход на Git более старых версий JDK: &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; и, возможно, &lt;a href="https://wiki.openjdk.java.net/display/jdk8u/Main"&gt;jdk8u&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;Java 16 является STS-релизом, у которого выйдет только два обновления.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #10</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_10.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_10.html</id>
    <updated>2021-03-13T17:00:00Z</updated>
    <published>2021-03-13T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002895.html"&gt;продолжается обсуждение&lt;/a&gt; того, как должны выглядеть условия в &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;паттернах&lt;/a&gt;, и, похоже, группа экспертов уже близка к единому мнению. Условия, скорее всего, будут отделяться от паттернов оператором &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s &amp;&amp; (s.length() == 1) -&gt; ...
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; ...
}&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Брайан Гетц предвидит, что в Java когда-нибудь могут появиться паттерны в присваивании, поэтому уже сейчас начинает &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002916.html"&gt;обсуждать&lt;/a&gt; эту тему в рассылке.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышло два новых JEP:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.java.net/jeps/399"&gt;JEP 399: Intermediate-Representation Graph Serialization&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://openjdk.java.net/jeps/400"&gt;JEP 400: UTF-8 by Default&lt;/a&gt;. В этом JEP'е предлагается сделать UTF-8 кодировкой по умолчанию для таких API как &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileReader.html"&gt;FileReader&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileWriter.html"&gt;FileWriter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStreamReader.html"&gt;InputStreamReader&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStreamWriter.html"&gt;OutputStreamWriter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html"&gt;Formatter&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Scanner.html"&gt;Scanner&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLEncoder.html"&gt;URLEncoder&lt;/a&gt;, &lt;a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLDecoder.html"&gt;URLDeconder&lt;/a&gt; и т.д. Сейчас кодировка по умолчанию определяется во время старта JVM и может зависеть от различных факторов, таких как операционная система, пользовательская локаль и значения некоторых свойств виртуальной машины. Когда этот JEP будет реализован, UTF-8 станет кодировкой по умолчанию для всех JDK, что сделает приложения на Java более портируемыми.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Роман Кеннке, лидер проекта Shenandoah в RedHat, предложил в рассылке &lt;a href="https://mail.openjdk.java.net/pipermail/discuss/2021-March/005720.html"&gt;новый проект Lilliput&lt;/a&gt;, целью которого будет уменьшение размера заголовка объекта в Hotspot до 64/32 бит и более гибкая схема размещения битов в нём. Сейчас заголовок каждого объекта в 64-разрядном Hotspot имеет размер от 96 до 128 бит, и такое сжатие могло бы существенно снизить нагрузку на память и/или CPU в Java-приложениях.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains выпустила первую версию своего &lt;a href="https://blog.jetbrains.com/blog/2021/03/11/projector-is-out/"&gt;нового инструмента Projector&lt;/a&gt;, который позволяет запускать IDE от JetBrains или Swing-приложения на сервере и управлять ими откуда угодно с помощью браузера или нативного приложения.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://netbeans.apache.org/download/nb123/nb123.html"&gt;Apache NetBeans 12.3&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла версия 1.0 библиотеки &lt;a href="https://in.relation.to/2021/03/08/hibernate-reactive-1/"&gt;Hibernate Reactive&lt;/a&gt;, которая предоставляет реактивное API к Hibernate ORM.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://openjfx.io/highlights/16/"&gt;JavaFX 16&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+13-1000&lt;/a&gt;, &lt;a href="https://jdk.java.net/loom/"&gt;JDK 17-loom+4-174&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #9</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_9.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_9.html</id>
    <updated>2021-03-07T17:00:00Z</updated>
    <published>2021-03-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Брайан Гетц запустил в рассылке Amber &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002862.html"&gt;дискуссию&lt;/a&gt; по поводу того, как в &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/a&gt; должны выглядеть паттерны с условиями. Пока что в этом вопросе консенсуса нет, и была предложена масса вариантов. Вот примеры возможных решений:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp; &lt;span style="color: blue"&gt;when&lt;/span&gt;(x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &lt;span style="color: blue"&gt;if&lt;/span&gt; (x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &lt;span style="color: blue"&gt;when&lt;/span&gt; x &gt; 0):&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) &amp;&amp; x &gt; 0:&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; x &amp;&amp; x &gt; 0):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ещё одно письмо от Брайана Гетца было опубликовано про &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-March/002836.html"&gt;паттерны примитивных типов и конверсии&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел новый &lt;a href="https://openjdk.java.net/jeps/398"&gt;JEP 398: Deprecate the Applet API for Removal&lt;/a&gt;. API аплетов, которое &lt;a href="https://openjdk.java.net/jeps/289"&gt;стало deprecated&lt;/a&gt; в Java 9, теперь предлагается пометить как подлежащее окончательному удалению.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый мартовский выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/03/java-annotated-monthly-march-2021/"&gt;Java Annotated Monthly&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В блоге AdoptOpenJDK &lt;a href="https://blog.adoptopenjdk.net/2021/03/transition-to-eclipse-an-update/"&gt;появился пост&lt;/a&gt; с обновлением статуса переезда проекта в Eclipse Foundation. Напомним, что 9 месяцев назад &lt;a href="https://blog.adoptopenjdk.net/2020/06/adoptopenjdk-to-join-the-eclipse-foundation/"&gt;было объявлено&lt;/a&gt;, что проект AdoptOpenJDK собирается присоединиться к Eclipse Foundation, а его имя будет изменено на Eclipse Adoptium.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+12&lt;/a&gt;, &lt;a href="https://jdk.java.net/lanai/"&gt;JDK 17-lanai+3-133&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://mail.openjdk.java.net/pipermail/jmh-dev/2021-March/003171.html"&gt;JMH 1.28&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #8</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_8.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_8.html</id>
    <updated>2021-02-28T17:00:00Z</updated>
    <published>2021-02-28T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышло два новых черновика JEP: &lt;a href="http://openjdk.java.net/jeps/8260244"&gt;Record and Array Patterns (Preview)&lt;/a&gt; и &lt;a href="http://openjdk.java.net/jeps/8213076"&gt;Pattern Matching for &lt;code&gt;switch&lt;/code&gt; (Preview)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В первом JEP'е предлагается ввести в язык паттерны записей и паттерны массивов. Паттерны записей будут выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;record&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y) {}
...
&lt;span style="color: blue"&gt;if&lt;/span&gt; (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Point(&lt;span style="color: blue"&gt;int&lt;/span&gt; x, &lt;span style="color: blue"&gt;int&lt;/span&gt; y)) {
    System.out.println(x + y);
}&lt;/pre&gt;
&lt;p&gt;Паттерны могут быть вложенными:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (r &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; Rectangle(ColoredPoint(Point p, Color c), ColoredPoint r)) {
    System.out.println(c);
}&lt;/pre&gt;
&lt;p&gt;Паттерны массивов выглядят так:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2, ... }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Паттерн на примере выше срабатывает для массивов длины 2 или более. Если нужен паттерн строгой длины 2, то многоточие не нужно указывать:&lt;/p&gt;
&lt;pre&gt;if (o &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { String s1, String s2 }) {
    System.out.println(s1 + s2);
}&lt;/pre&gt;
&lt;p&gt;Есть возможность осуществлять паттерн-матчинг по многомерным массивам. Также можно вкладывать паттерны массивов в паттерны записей и наоборот.&lt;/p&gt;
&lt;p class="pt-1"&gt;Во втором JEP'е предлагается ввести паттерн-матчинг по типу для оператора &lt;code&gt;switch&lt;/code&gt;, и это будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;Object o = ...
&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;Если пользователю нужен матчинг &lt;code&gt;null&lt;/code&gt;, то придётся указывать отдельную ветку:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case null&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Null"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; System.out.println(&lt;span style="color: darkred"&gt;"String: "&lt;/span&gt; + s);
}&lt;/pre&gt;
&lt;p&gt;Если не указывать явную ветку &lt;code&gt;case null&lt;/code&gt; и в &lt;code&gt;switch&lt;/code&gt; передастся нулевой объект, то будет выбрасываться &lt;code&gt;NullPointerException&lt;/code&gt;, даже если будет присутствовать ветка &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) { &lt;span style="color: red"&gt;// will throw NPE&lt;/span&gt;
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Чтобы ветка &lt;code&gt;default&lt;/code&gt; покрывала &lt;code&gt;null&lt;/code&gt;, нужно будет использовать паттерн &lt;code&gt;null, default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;String s = &lt;span style="color: blue"&gt;null&lt;/span&gt;;
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Foo"&lt;/span&gt;, &lt;span style="color: darkred"&gt;"Bar"&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"My favourite!"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case null, default&lt;/span&gt; -&gt; System.out.println(&lt;span style="color: darkred"&gt;"Acceptable..."&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;Паттерн &lt;code&gt;null&lt;/code&gt; можно будет также объединять и с паттерном по типу:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;return switch&lt;/span&gt; (o) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Integer i -&gt; String.format(&lt;span style="color: darkred"&gt;"int %d"&lt;/span&gt;, i);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Byte b -&gt; String.format(&lt;span style="color: darkred"&gt;"byte %d"&lt;/span&gt;, b);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Long l -&gt; String.format(&lt;span style="color: darkred"&gt;"long %d"&lt;/span&gt;, l);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Double d -&gt; String.format(&lt;span style="color: darkred"&gt;"double %f"&lt;/span&gt;, d);
    &lt;span style="color: blue"&gt;case null&lt;/span&gt;, String s -&gt; String.format(&lt;span style="color: darkred"&gt;"String %s"&lt;/span&gt;, s);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt; o.toString();
};&lt;/pre&gt;
&lt;p&gt;В первой итерации поддержки смешанных паттернов (паттернов по типу и константных паттернов в одном &lt;code&gt;switch&lt;/code&gt;) не будет:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; &lt;span style="color: darkred"&gt;"Hello world"&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Hello back"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;case&lt;/span&gt; String s -&gt; &lt;span style="color: red"&gt;// Error&lt;/span&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Nothing?"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; также будет поддерживать условные паттерны. Для этого предлагается ввести охранные паттерны вида &lt;code&gt;true(boolean expr)&lt;/code&gt; и &lt;code&gt;false(boolean expr)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;Shape s = ...
&lt;span style="color: blue"&gt;switch&lt;/span&gt; (s) {
    &lt;span style="color: blue"&gt;case&lt;/span&gt; Triangle t &amp; &lt;span style="color: blue"&gt;true&lt;/span&gt;(t.calculateArea() &gt; 100) -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"Large Triangle"&lt;/span&gt;);
    &lt;span style="color: blue"&gt;default&lt;/span&gt; -&gt;
        System.out.println(&lt;span style="color: darkred"&gt;"A shape (including small triangles"&lt;/span&gt;);
}&lt;/pre&gt;
&lt;p class="pt-1"&gt;Если оба JEP'а будет реализованы вместе, то первый будет дополнять возможности второго. Так, все паттерны по записям и массивам можно будет использовать и в ветках &lt;code&gt;switch&lt;/code&gt; (в том числе вложенные).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел первый релиз-кандидат языка Scala 3: &lt;a href="https://dotty.epfl.ch/blog/2021/02/17/scala3-rc1.html"&gt;Scala 3.0.0-RC1&lt;/a&gt;. В эту версию попало более 400 пулл-реквестов от контрибьюторов с прошлого релиза 3.0.0-M3.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.scala-lang.org/scala3/new-in-scala3.html"&gt;Scala 3&lt;/a&gt;, разработка которой более 5 лет ведётся в проекте &lt;a href="https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"&gt;Dotty&lt;/a&gt; &amp;ndash; это полная переработка Scala 2, но в значительной части с ней совместимая: большая часть кода на Scala 2 остаётся валидным кодом для компилятора Scala 3, а для остального кода есть &lt;a href="https://scalacenter.github.io/scala-3-migration-guide/"&gt;гид по миграции&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также вышло обновление &lt;a href="https://github.com/scala/scala/releases/tag/v2.13.5"&gt;Scala 2.13.5&lt;/a&gt;. В него попала поддержка последних версий Java вплоть до ещё не вышедшей Java 17, поддержка Scala 3.0.0-RC1, более безопасный паттерн-матчинг и другие изменения.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Опубликованы результаты &lt;a href="https://arjan-tijms.omnifaces.org/2021/02/jakarta-ee-survey-20202021-results.html"&gt;опроса Jakarta EE&lt;/a&gt;, который проводился с сентября 2020 по февраль 2021 года. В нём 684 респондента ответили на вопросы относительно использования технологий Java EE / JakartaEE. Из интересных результатов опроса следующие факты:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;Самый используемый сервер приложений &amp;ndash; это RedHat WildFly, а самый ненавистный &amp;ndash; IBM WebSphere.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые API: JPA, CDI и JAX-RS.&lt;/li&gt;
   &lt;li&gt;Наиболее часто используемые библиотеки: Hibernate, Weld и Hibernate Validator.&lt;/li&gt;
   &lt;li&gt;&lt;a href="https://microprofile.io/"&gt;MicroProfile&lt;/a&gt; попробовало 32% опрошенных. Это на 16% больше, чем 2 года назад.&lt;/li&gt;
   &lt;li&gt;Самые популярные продукты MicroProfile: Quarkus, WildFly и Payara Micro.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class="pt-3"&gt;&amp;bull; Была объявлена виртуальная конференция &lt;a href="https://jakartaone.org/2021/russian/"&gt;JakartaOne Livestream на русском&lt;/a&gt;, которая пройдёт 31 марта 2021 года.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышли новые ранние сборки JDK: &lt;a href="https://jdk.java.net/17/"&gt;JDK 17-ea+11&lt;/a&gt;, &lt;a href="https://jdk.java.net/panama/"&gt;JDK 17-panama+2-51&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышлая &lt;a href="https://www.reddit.com/r/java/comments/lsbcwe/flatlaf_10_swing_look_and_feel/"&gt;версия 1.0&lt;/a&gt; библиотеки &lt;a href="https://github.com/JFormDesigner/FlatLaf"&gt;FlatLaf&lt;/a&gt; для кроссплатформенного Look and Feel в приложениях на Swing.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В официальной документации Android &lt;a href="https://stackoverflow.com/questions/66346971/android-deprecated-annotation-is-deprecated-whats-the-replacement"&gt;обнаружили&lt;/a&gt;, что аннотация &lt;code&gt;@Deprecated&lt;/code&gt; помечена как Deprecated. Эта ошибка возникла из-за того, что в JavaDoc аннотации присутствовал код &lt;code&gt;{@code @deprecated}&lt;/code&gt;, который сигнализировал парсеру документации добавить "пропущенную" аннотацию &lt;code&gt;@Deprecated&lt;/code&gt;. Баг уже был &lt;a href="https://android-review.googlesource.com/c/platform/libcore/+/1601554"&gt;устранён&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #7</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_7.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_7.html</id>
    <updated>2021-02-14T17:00:00Z</updated>
    <published>2021-02-14T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Вышел ещё один JEP по проекту Valhalla: &lt;a href="http://openjdk.java.net/jeps/8259731"&gt;Unify the Basic Primitives with Objects (Preview)&lt;/a&gt;. В нём предлагается мигрировать 8 примитивных типов Java (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;) таким образом, чтобы они стали экземплярами соответствующих классов-обёрток (&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;), которые сами станут примитивными классами. В такой схеме, например, тип &lt;code&gt;int&lt;/code&gt; станет алиасом для &lt;code&gt;Integer.val,&lt;/code&gt; а &lt;code&gt;Integer&lt;/code&gt; &amp;ndash; к &lt;code&gt;int.ref&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Благодаря такой унификации у примитивных типов появятся свойства, которых у них не было с самого появления языка: наследование, наличие методов (&lt;code&gt;17.toString()&lt;/code&gt;, &lt;code&gt;23.compareTo(42))&lt;/code&gt; и возможность быть параметрами дженериков (будет отдельный JEP).&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; В рассылке OpenJDK &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-February/004934.html"&gt;предложили&lt;/a&gt; перевести проект &lt;a href="https://wiki.openjdk.java.net/display/JDKUpdates/JDK11u"&gt;jdk11u&lt;/a&gt; на Git. Так как переход 16u и 13u на Git уже &lt;a href="https://openjdk.java.net/projects/skara/"&gt;совершён&lt;/a&gt;, то это поможет унифицировать процесс разработки обновлений разных мажорных версий JDK. Переход на Git предлагается сделать к июню 2021 года, когда начнётся работа над JDK 11.0.13.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains начала программу раннего доступа (EAP) к своему &lt;a href="https://blog.jetbrains.com/idea/2021/02/early-access-program-for-qodana-a-new-product-that-brings-the-smarts-of-jetbrains-ides-into-your-ci-pipeline/"&gt;новому продукту Qodana&lt;/a&gt; &amp;ndash; платформы для статического анализа и измерения качества кода. Qodana состоит из двух частей: движок для запуска анализа в CI и веб-панель с отчётами. Статический анализатор кода представляет собой движок IntelliJ IDEA без графического интерфейса, и его можно запустить на любом CI-сервере. Для TeamCity есть готовый плагин.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Николай Парлог (aka &lt;a href="https://twitter.com/nipafx"&gt;nipafx&lt;/a&gt;) выложил на YouTube &lt;a href="https://youtu.be/ZyTH8uCziI4"&gt;интервью с Брайаном Гетцом&lt;/a&gt; про то, почему сериализация, nullability, мутабельность и другие аспекты сделаны умолчательными в Java, и можно ли это было сделать по-другому.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #6</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_6.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_6.html</id>
    <updated>2021-02-07T17:00:00Z</updated>
    <published>2021-02-07T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-February/005062.html"&gt;Вышел&lt;/a&gt; первый релиз-кандидат 16-й версии Java: &lt;a href="https://jdk.java.net/16/"&gt;JDK 16+35&lt;/a&gt;. Также вышла новая ранняя сборка JDK 17: &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+8&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Стал известен второй JEP, который предложен к выходу в Java 17. Это &lt;a href="http://openjdk.java.net/jeps/382"&gt;JEP 382: New macOS Rendering Pipeline&lt;/a&gt;. Цель этого JEP'а &amp;ndash; реализовать новый конвейер Java 2D-рендеринга на основе Apple Metal API в качестве альтернативы старому deprecated OpenGL API. Разработка нового конвейера ведётся в рамках &lt;a href="http://openjdk.java.net/projects/lanai/"&gt;проекта Lanai&lt;/a&gt;, у которого недавно вышла &lt;a href="https://jdk.java.net/lanai/"&gt;ранняя сборка&lt;/a&gt; JDK 17-lanai+2-49.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Компания JFrog &lt;a href="https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/"&gt;закрывает&lt;/a&gt; свои облачные платформы Bintray, GoCenter и ChartCenter. Эти сервисы много лет предоставляли возможность бесплатно публиковать и распространять бинарные артефакты любому разработчику открытого программного обеспечения, однако 1 мая 2021 года сервисы будут остановлены, и все опубликованные артефакты перестанут быть доступными.&lt;/p&gt;
&lt;p&gt;Частью Bintray, также подпадающей под закрытие, является репозиторий JCenter, который стал популярной альтернативой &lt;a href="https://search.maven.org/"&gt;Maven Central&lt;/a&gt; благодаря более простому процессу публикации туда Maven-артефактов. Особенно популярен JCenter среди пользователей Gradle, поскольку документация и примеры Gradle &lt;a href="https://docs.gradle.org/current/samples/sample_gradle_plugin.html"&gt;рекомендуют&lt;/a&gt; использовать JCenter в качестве репозитория по умолчанию:&lt;/p&gt;
&lt;pre&gt;repositories {
    &lt;span style="color: darkgreen"&gt;// Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.&lt;/span&gt;
    jcenter()
}&lt;/pre&gt;
&lt;p&gt;Также JCenter &lt;a href="https://developer.android.com/studio/build/dependencies#remote-repositories"&gt;указывается&lt;/a&gt; по умолчанию в новых проектах Android Studio.&lt;/p&gt;
&lt;p&gt;Брайан Фокс, CTO компании Sonatype, которая обслуживает Maven Central, после выхода новости о закрытии Bintray &lt;a href="https://blog.sonatype.com/dear-bintray-and-jcenter-users-heres-what-you-need-to-know-about-the-central-repository"&gt;опубликовал пост&lt;/a&gt;, в котором призвал пользователей JCenter не беспокоиться и ответил на несколько частозадаваемых вопросов относительно перехода на Central.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышло сразу три новых черновика JEP:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261007"&gt;Frozen Arrays (Preview)&lt;/a&gt;. Здесь предлагается ввести в Java замороженные массивы, то есть массивы, которые нельзя изменять. Такие массивы могут сделать код более безопасным, а саму программу более эффективной благодаря лучшей оптимизации неизменяемых массивов виртуальной машиной. Сами массивы можно будет создавать либо с помощью методов-фабрик, либо путём замораживания существующего мутабельного массива (при этом возвращается новый массив).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8261099"&gt;Internal Frozen Arrays&lt;/a&gt;. Этот JEP связан с предыдущим, и в нём описаны внутренние низкоуровневые методы JDK, которые смогут замораживать мутабельные массивы на месте (без копирования). Эти методы предоставят основу для реализации более высокоуровневых методов-фабрик.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/8260865"&gt;Generational Shenandoah&lt;/a&gt;. В этом JEP'е предлагается добавить в сборщик мусора Shenandoah поколения. Это сможет &lt;a href="https://youtu.be/cJyzt9b6KrU?t=2345"&gt;повысить эффективность&lt;/a&gt; сборки мусора.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; JUG.ru &lt;a href="https://www.youtube.com/playlist?list=PLVe-2wcL84b_bCEiqcpNwoB0xT6wlIofb"&gt;выложил видео&lt;/a&gt; с конференции Joker 2020.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://blog.jetbrains.com/kotlin/2021/02/kotlin-1-4-30-released/"&gt;Kotlin 1.4.30&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Компания JetBrains опубликовала &lt;a href="https://www.jetbrains.com/lp/annualreport-2020/"&gt;JetBrains 2020/21 Annual Highlights&lt;/a&gt;. На этой странице собраны все самые значительные события, которые произошли с компанией за предыдущий год, и опубликованы статистики роста популярности продуктов, количества пользователей и прочих показателей.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #5</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_5.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_5.html</id>
    <updated>2021-01-31T17:00:00Z</updated>
    <published>2021-01-31T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; На сайте OpenJDK опубликован черновик JEP &lt;a href="http://openjdk.java.net/jeps/8201533"&gt;&amp;laquo;Enhanced javadoc support for code samples (snippets)&amp;raquo;&lt;/a&gt;. В нём предлагается ввести в javadoc новый тег &lt;code&gt;@snippet&lt;/code&gt;, с помощью которого можно будет вставлять в документацию примеры кода и делать это лучше, чем это делается сейчас с использованием блоков &lt;code&gt;&amp;lt;pre&amp;gt;{@code ...}&amp;lt;/pre&amp;gt;&lt;/code&gt;. Новые сниппеты будут предоставлять механизм для лучшей проверки корректности кода, подсветки синтаксиса, улучшенной поддержки редактирования в IDE.&lt;/p&gt;
&lt;p&gt;Пример сниппета:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;/**
 * The following code shows how to use Optional.isPresent:
 * {@snippet :
 *     &lt;/span&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (v.isPresent()) {
 &lt;span style="color: green"&gt;*&lt;/span&gt;         System.out.println(&lt;span style="color: darkred"&gt;"v: "&lt;/span&gt; + v.get());
 &lt;span style="color: green"&gt;*&lt;/span&gt;     }
 &lt;span style="color: green"&gt;* }
 */&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;Сниппеты в javadoc будут поддерживать вложенные комментарии &lt;code&gt;&lt;span style="color: green"&gt;/* ... */&lt;/span&gt;&lt;/code&gt; (с помощью &amp;lt;pre&amp;gt; это сделать нельзя), ссылки на код из внешнего файла (&lt;code&gt;@snippet file="SomeFile.java"&lt;/code&gt;), обрезание ненужных пробельных символов в началах строк (как в &lt;a href="text_blocks.html"&gt;блоках текста&lt;/a&gt;), подсветку определённых участков сниппета и многие другие возможности.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел ещё один черновик JEP &lt;a href="http://openjdk.java.net/jeps/8260688"&gt;&amp;laquo;Improve regex performance&amp;raquo;&lt;/a&gt;. В этом JEP'е предлагается заменить движок регулярных выражений, который в Java работает довольно быстро, но не даёт гарантированной максимальной сложности алгоритма поиска. Это делает сервисы, написанные на Java, потенциально уязвимыми к DoS-атакам на основе регулярных выражений (&lt;a href="https://en.wikipedia.org/wiki/ReDoS"&gt;ReDoS&lt;/a&gt;). Особенно легко такие атаки могут быть организованы, если пользователь знает, какое именно регулярное выражение используется на сервере для валидации полей, и уж тем более, если сам может загружать своё регулярное выражение.&lt;/p&gt;
&lt;p&gt;Чтобы избежать этого, можно использовать движок регулярных выражений, основанный на детерминированных конечных автоматах (DFA), который даёт гарантированную сложность &lt;code&gt;O(N)&lt;/code&gt;, однако он поддерживает не все возможности регулярных выражений. В JEP'е предлагаются варианты решений такой проблемы, например, использовать разные алгоритмы в зависимости от указанного выражения или позволять пользователю указывать с помощью флага, какой именно алгоритм использовать. Пока что в JEP'е нет окончательного ответа относительно выбора подхода, и, видимо, он ещё будет сильно дорабатываться.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://blog.jetbrains.com/idea/2021/01/intellij-idea-2021-1-eap-1/"&gt;IntelliJ IDEA 2021.1 EAP&lt;/a&gt; (Early Access Program). В этой версии среды появилась базовая поддержка Java 16, WSL 2 (Windows Subsytem for Linux 2), новая возможность Run Targets (выполнение программы в среде: Docker, SSH, WSL), улучшения в UI и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://jdk.java.net/jmc/8/"&gt;JDK Misson Control 8.0.0 EA&lt;/a&gt;.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Ну и напоследок немного юмора. Известный программист, Java-чемпион Heinz Kabutz &lt;a href="https://twitter.com/heinzkabutz/status/1355137101545799682"&gt;выложил в Твиттере задачку&lt;/a&gt; со следующим вопросом:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Как, не меняя ни одного символа, сделать так, чтобы программа скомпилировалась:&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;public class&lt;/span&gt; InnerStaticMember {
  &lt;span style="color: blue"&gt;public class&lt;/span&gt; Inner {
    &lt;span style="color: blue"&gt;public static void&lt;/span&gt; main(String... args) {
      System.out.println(&lt;span style="color: darkred"&gt;"Look Ma, no hands!"&lt;/span&gt;);
    }
  }
}&lt;/pre&gt;
&lt;p&gt;Среди ответов отметилось несколько правильных: нужно просто перейти на Java 16, потому что Java 16 &lt;a href="https://openjdk.java.net/jeps/395"&gt;разрешает статические члены во внутренних классах&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Однако самым смешным (но в то же время абсолютно корректным) оказался ответ, где написан конвейер Linux-команд, который берёт исходное изображение, обрезает её так, что из неё остаётся только кусок с классом &lt;code&gt;Inner&lt;/code&gt;, распознаёт из неё текст и компилирует.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #4</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_4.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_4.html</id>
    <updated>2021-01-24T17:00:00Z</updated>
    <published>2021-01-24T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Java отпраздновала знаменательную дату: 23 января 1996 года, ровно 25 лет назад, вышла первая стабильная версия JDK, которая имела версию &lt;a href="https://javaalmanac.io/jdk/1.0/"&gt;1.0.2&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://blog.adoptopenjdk.net/2021/01/adoptopenjdk-8u282-11010-and-1502-available/"&gt;Вышли&lt;/a&gt; обновления JDK:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/2021-January/013337.html"&gt;JDK 8u282&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004689.html"&gt;JDK 11.0.10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-January/004690.html"&gt;JDK 13.0.6&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://jdk.java.net/15/"&gt;JDK 15.0.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также вышли обновления ранних сборок JDK: &lt;a href="http://jdk.java.net/16/"&gt;JDK 16-ea+33&lt;/a&gt; и &lt;a href="http://jdk.java.net/17/"&gt;JDK 17-ea+6&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайн Гетц опубликовал несколько писем в &lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/thread.html"&gt;рассылке Amber&lt;/a&gt; с рассуждениями относительно паттерн-матчинга и подробностями его развития в ближайшем будущем:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002758.html"&gt;Pattern features for next iteration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002763.html"&gt;Patterns: Nullity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002778.html"&gt;Patterns: Declaration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002782.html"&gt;Relaxed assignment conversions for sealed types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также Брайн Гетц опубликовал статью на InfoQ: &lt;a href="https://www.infoq.com/articles/java-pattern-matching/"&gt;Java Feature Spotlight: Pattern Matching&lt;/a&gt;. В ней он рассказывает, как выглядит паттерн-матчинг в Java сейчас и в каком направлении он будет развиваться.&lt;/p&gt;
&lt;p&gt;Кроме того, выложено &lt;a href="https://freecontent.manning.com/interview-with-brian-goetz/"&gt;большое интервью&lt;/a&gt; с Брайном про его работу над развитием языка.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Ещё один день рождения празднует IntelliJ IDEA. Её первая версия вышла в свет в 2001 году. В связи с этим JetBrains организует бесплатную виртуальную конференцию &lt;a href="https://www.jetbrains.com/ru-ru/lp/intellijidea-20-anniversary/"&gt;IntelliJ IDEA Conf&lt;/a&gt;, которая состоится 25-26 февраля.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В новосибирском сообществе Java-программистов JUGNsk объявили об очередном &lt;a href="https://www.meetup.com/JUGNsk/events/275807033/"&gt;онлайн-митапе&lt;/a&gt;, который состоится 28 января в 15:00 по московскому времени.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Тагир Валеев опубликовал статью на Хабре: &lt;a href="https://habr.com/ru/post/538280/"&gt;Анбоксинг в современной Java&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла GraalVM 21.0. В дополнение к &lt;a href="https://medium.com/graalvm/graalvm-21-0-introducing-a-new-way-to-run-java-df894256de28"&gt;основной новости&lt;/a&gt; о выходе новой версии была опубликована &lt;a href="https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840"&gt;дополнительная статья&lt;/a&gt; с подробностями того, как JVM реализована полностью на Java с использованием фреймворка Truffle.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышел &lt;a href="https://www.eclipse.org/lists/tycho-dev/msg01837.html"&gt;Eclipse Tycho 2.2.0.&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #3</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_3.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_3.html</id>
    <updated>2021-01-17T17:00:00Z</updated>
    <published>2021-01-17T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; По просьбам читателей на сайт &lt;a href="https://minijug.ru"&gt;minijug.ru&lt;/a&gt; был добавлен feed в формате Atom. Это сделано для тех, кто предпочитает узнавать о новых публикациях через агрегатор новостных лент, а не через &lt;a href="https://t.me/miniJUG"&gt;Telegram-канал&lt;/a&gt;. Адрес feed &lt;a href="https://minijug.ru/feed.xml"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Java 16 теперь во &lt;a href="https://mail.openjdk.java.net/pipermail/jdk-dev/2021-January/005001.html"&gt;второй фазе Rampdown&lt;/a&gt;, а значит на одну ступень ближе к релизу, который &lt;a href="http://openjdk.java.net/projects/jdk/16/"&gt;по плану&lt;/a&gt; должен произойти 16 марта.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В компилятор Java было внесено &lt;a href="https://bugs.openjdk.java.net/browse/JDK-8250769"&gt;несколько изменений&lt;/a&gt; в отношении preview API. Preview API &amp;ndash; это один из трёх типов &lt;a href="https://openjdk.java.net/jeps/12"&gt;preview feature&lt;/a&gt; в Java, наряду с preview language feature и preview VM feature. Preview API разделены на две большие группы: &lt;em&gt;нормальные&lt;/em&gt; (normal) и &lt;em&gt;рефлективные&lt;/em&gt; (reflective). Нормальные также подразделяются на &lt;em&gt;неотъемлемые&lt;/em&gt; (essential), &lt;em&gt;удобные&lt;/em&gt; (convenient) и &lt;em&gt;автономные&lt;/em&gt; (standalone). Однако для &lt;code&gt;javac&lt;/code&gt; важно только разделение на нормальные и рефлективные. Главные изменения &lt;code&gt;javac&lt;/code&gt; следующие:&lt;/p&gt;
&lt;p&gt;1. Аннотация &lt;code&gt;@PreviewFeature&lt;/code&gt; перенесена из пакета &lt;code&gt;jdk.internal&lt;/code&gt; в пакет &lt;code&gt;jdk.internal.javac&lt;/code&gt;, и в неё добавлен флаг &lt;code&gt;reflective&lt;/code&gt;, который заменил старый флаг &lt;code&gt;essentialAPI&lt;/code&gt;. Этот новый флаг как раз и поможет компилятору отличать рефлективные preview API от нормальных.&lt;/p&gt;
&lt;p&gt;2. Рефлективные preview API можно использовать без флага компилятора &lt;code&gt;--enable-preview&lt;/code&gt;, а нормальные &amp;ndash; только с флагом.&lt;/p&gt;
&lt;p&gt;3. При использовании класса, который использует preview feature, теперь выдаётся предупреждение (например, если использован &lt;code&gt;sealed&lt;/code&gt;-класс из какой-нибудь библиотеки). Но это предупреждение можно подавить через &lt;code&gt;@SuppressWarnings(&lt;span style="color: darkred"&gt;"preview"&lt;/span&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;4. Классы помечаются как зависящие от preview feature, только если это действительно необходимо (такие class-файлы имеют специальную минорную версию 65535, например 61.65535 для Java 17). Если класс не использует ни одной preview language feature (ни прямо, ни косвенно), ни одной preview VM feature и ни одного нормального preview API, то он компилируется в обычный (не-preview) class-файл. Другими словами, если из preview features использовать только рефлективные preview API, то такие программы можно будет запускать без флага &lt;code&gt;--enable-preview&lt;/code&gt;, даже если они скомпилированы с флагом &lt;code&gt;--enable-preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Эти изменения в &lt;code&gt;javac&lt;/code&gt; будут работать только начиная с Java 17.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Опубликован новый черновик &lt;a href="https://openjdk.java.net/jeps/8251554"&gt;JEP: Primitive Objects (Preview)&lt;/a&gt;, в котором описывается, как в Java планируется внедрить примитивные объекты. Примитивные объекты &amp;ndash; это объекты, которые не имеют идентичности, то есть при их копировании получается объект, неотличимый от оригинального. Такие объекты могут передаваться напрямую и легко встраиваться (в другие объекты/массивы/стек), что снижает накладные расходы на их использование и делает их более эффективными, чем объекты с идентичностью.&lt;/p&gt;
&lt;p class="pt-3"&gt;Новый черновик JEP &amp;ndash; это возможно первая детальная публичная спецификация, которая стала результатом многолетних исследований, множества встреч экспертов и обсуждений, проведённых по value-типам в рамках проекта &lt;a href="http://openjdk.java.net/projects/valhalla/"&gt;Valhalla&lt;/a&gt;. В ходе проекта было сделано несколько прототипов, несколько раз значительно менялась концепция, а сами value-типы дважды переименовывались: сначала в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2019-April/000916.html"&gt;inline-классы&lt;/a&gt;, а потом в &lt;a href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2020-October/001415.html"&gt;примитивные классы&lt;/a&gt;.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; В блоге JetBrains вышел новый выпуск &lt;a href="https://blog.jetbrains.com/idea/2021/01/java-annotated-monthly-january-2021/"&gt;&amp;laquo;Java Annotated Monthly&amp;raquo;&lt;/a&gt;, где собрано огромное количество ссылок на новости, статьи, тьюториалы и прочие материалы о Java и связанных темах.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://mail.openjdk.java.net/pipermail/loom-dev/2021-January/002046.html"&gt;новая сборка Loom&lt;/a&gt;, основанная на JDK 17+5.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Вышла &lt;a href="https://github.com/scala/scala/releases/tag/v2.12.13"&gt;Scala 2.12.13&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <title>Новости Java #2</title>
    <link rel="alternate" type="text/html" href="https://minijug.ru/java_news_2.html" />
    <author>
      <name>Евгений Козлов</name>
    </author>
    <id>https://minijug.ru/java_news_2.html</id>
    <updated>2021-01-10T17:00:00Z</updated>
    <published>2021-01-10T17:00:00Z</published>
    <content type="html">&lt;p&gt;&amp;bull; Стал известен первый JEP, который попадёт в Java 17. Это &lt;a href="https://openjdk.java.net/jeps/356"&gt;JEP 356: Enhanced Pseudo-Random Number Generators&lt;/a&gt;. В рамках этого JEP'а будет добавлен интерфейс &lt;code&gt;RandomGenerator&lt;/code&gt; с четырьмя его специализациями: &lt;code&gt;SplittableRandomGenerator&lt;/code&gt;, &lt;code&gt;JumpableRandomGenerator&lt;/code&gt;, &lt;code&gt;LeapableRandomGenerator&lt;/code&gt; и &lt;code&gt;ArbitrarilyJumpableRandomGenerator&lt;/code&gt;. Кроме того, будет добавлен класс &lt;code&gt;RandomGeneratorFactory&lt;/code&gt;, который будет возвращать конкретные реализации &lt;code&gt;RandomGenerator&lt;/code&gt;. Старые классы &lt;code&gt;Random&lt;/code&gt;, &lt;code&gt;ThreadLocalRandom&lt;/code&gt; и &lt;code&gt;SplittableRandom&lt;/code&gt; будут отрефакторены и станут одними из реализаций &lt;code&gt;RandomGenerator&lt;/code&gt;. Также будут реализованы новые алгоритмы генерации псевдослучайных чисел.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; Брайан Гетц опубликовал &lt;a href="https://github.com/openjdk/amber-docs/blob/master/site/design-notes/pattern-match-object-model.md"&gt;новый документ&lt;/a&gt; &amp;laquo;Паттерн-матчинг в объектной модели Java&amp;raquo;. В нём описывается возможный подход внедрения паттерн-матчинга в язык. Документ довольно большой, поэтому попробуем выделить основные моменты:&lt;/p&gt;
&lt;p&gt;&amp;ndash; Если язык предоставляет возможноть агрегации посредством конструкторов/фабричных методов, то он должен предоставлять и обратный механизм деконструкции:&lt;/p&gt;
&lt;pre&gt;Object x = &lt;span style="color: blue"&gt;new&lt;/span&gt; Foo(a, b); &lt;span style="color: green"&gt;// конструкция&lt;/span&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Foo(&lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b): ... &lt;span style="color: green"&gt;// деконструкция&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Если конструирование объекта поддерживает композицию, то и деконструирование тоже должно её поддерживать:&lt;/p&gt;
&lt;pre&gt;Optional.of(Shape.redBall(1));&lt;/pre&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; Optional.of(Shape.redBall(&lt;span style="color: blue"&gt;var&lt;/span&gt; size)): ...&lt;/pre&gt;
&lt;p&gt;&amp;ndash; Паттерны деконструкции являются точно такими же членами класса, как и конструкторы/методы. Паттерны имеют тело, в котором описывается всё необходимое поведение.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Раз паттерны являются членами класса, то они поддерживают все их атрибуты: модификаторы доступа, перегрузка, переопределение, static/instance, параметрический полиморфизм, делегирование к другим паттернам, varargs и т.д.&lt;/p&gt;
&lt;p&gt;&amp;ndash; Паттерны также имеют дополнительные уникальные атрибуты: наличие целевого операнда, тип которого должен быть совместим с целевым типом, полнота/частичность, исчерпываемость, разделение аргументов на входные и выходные.&lt;/p&gt;
&lt;p&gt;&amp;ndash; В конце документа описываются также другие идеи вроде комбинирования паттернов с помощью булевых операторов (AND/OR), структурные паттерны и т.д.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Также Брайн Гетц предложил в рассылке Amber несколько идей относительно паттерн-матчинга:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002688.html"&gt;Оператор алмаза в паттернах&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: green"&gt;// Было&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;K, ? extends V&amp;gt; em) { ... }

&lt;span style="color: green"&gt;// Стало&lt;/span&gt;:
&lt;span style="color: blue"&gt;if&lt;/span&gt; (m &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; EnumMap&amp;lt;&amp;gt; em) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002695.html"&gt;Паттерны массивов&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;if&lt;/span&gt; (arr &lt;span style="color: blue"&gt;instanceof&lt;/span&gt; String[] { &lt;span style="color: blue"&gt;var&lt;/span&gt; a, &lt;span style="color: blue"&gt;var&lt;/span&gt; b }) { ... }&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://mail.openjdk.java.net/pipermail/amber-spec-experts/2021-January/002710.html"&gt;Охранные паттерны&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;span style="color: blue"&gt;case&lt;/span&gt; P(&lt;span style="color: blue"&gt;var&lt;/span&gt; x) __AND &lt;span style="color: blue"&gt;true&lt;/span&gt;(x &gt; 0) __AND Q(&lt;span style="color: blue"&gt;var&lt;/span&gt; y):&lt;/pre&gt;

&lt;p class="pt-3"&gt;&amp;bull; Джонатан Гиббонс (Oracle) &lt;a href="https://mail.openjdk.java.net/pipermail/code-tools-dev/2021-January/000625.html"&gt;предложил&lt;/a&gt; добавить в JDK утилиту &lt;code&gt;apidiff&lt;/code&gt; для сравнения нескольких версий API. Утилита сможет анализировать class-файлы, исходные файлы Java и файлы документации и генерировать HTML-отчёт о различиях в API. Внутри она будет использовать фронтенд &lt;code&gt;javac&lt;/code&gt; и модули &lt;code&gt;java.compiler&lt;/code&gt;/&lt;code&gt;jdk.compiler&lt;/code&gt; для чтения исходных и класс-файлов, а значит не будет проблем с поддержкой в утилите последних языковых изменений. Джонатан пишет, что у него уже есть продвинутый прототип утилиты и он надеется в скором времени опубликовать его на GitHub.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Американские новостные агентства &lt;a href="https://www.wsj.com/articles/solarwinds-hack-breached-justice-department-systems-11609958761"&gt;написали&lt;/a&gt; о взломе нескольких министерств США через программное обеспечение компании SolarWinds и о возможной организации этих кибератак хакерами, связанными с Россией. В статьях написано, что хакеры могли это сделать, получив доступ к билд-серверу TeamCity, развёрнутому в компании для сборки ПО. Далее сообщается, что американские спецслужбы и специалисты по кибербезопасности начали исследование возможной роли JetBrains в атаке.&lt;/p&gt;
&lt;p&gt;При этом авторы не объясняют, почему такой негативный акцент в статьях сделан именно на JetBrains, ведь кроме TeamCity в SolarWinds должно использоваться множество других программ и инструментов для разработки. New York Times вообще &lt;a href="https://web.archive.org/web/20210106195835/https://www.nytimes.com/2021/01/06/us/politics/russia-cyber-hack.html"&gt;назвал&lt;/a&gt; JetBrains &amp;laquo;obscure software company&amp;raquo; (&amp;laquo;тёмная&amp;raquo;, &amp;laquo;неясная&amp;raquo;), но позже изменил эту фразу в статье на &amp;laquo;widely used software company&amp;raquo;, и вообще в течение последующих дней множество раз изменял статью, постоянно внося туда правки и уточнения. Многие программисты в Твиттере довольно резко отреагировали на &lt;a href="https://twitter.com/nicoleperlroth/status/1346909580219936769"&gt;твит&lt;/a&gt; редактора New York Times и одной из авторов статьи, делая &lt;a href="https://twitter.com/nikitonsky/status/1347004468966141954"&gt;ретвиты&lt;/a&gt; с саркастическими шутками.&lt;/p&gt;
&lt;p&gt;Максим Шафиров, CEO JetBrains, после выхода новостей, сразу написал &lt;a href="https://blog.jetbrains.com/blog/2021/01/06/statement-on-the-story-from-the-new-york-times-regarding-jetbrains-and-solarwinds/"&gt;официальный ответ&lt;/a&gt;, что JetBrains никак не может быть причастен к атаке и компания не была извещена о расследовании, но полностью готова к сотрудничеству. На следующий день он выложил &lt;a href="https://blog.jetbrains.com/blog/2021/01/07/an-update-on-solarwinds/"&gt;более подробный пост&lt;/a&gt;, в котором более подробно описал ситуацию. Он написал, что компании неизвестно об уязвимостях в TeamCity, которые могли бы быть эксплуатированы для организации подобных атак, и компания проводит регулярный аудит своих инструментов и систем.&lt;/p&gt;

&lt;p class="pt-3"&gt;&amp;bull; Брюс Эккель, автор &amp;laquo;Философия Java&amp;raquo; и многих других книг о Java, C++ и JVM языках, &lt;a href="https://www.bruceeckel.com/2021/01/02/the-problem-with-gradle/"&gt;написал пост&lt;/a&gt; &amp;laquo;The Problem with Gradle&amp;raquo;, где рассказал свою историю использования Gradle и перечислил его проблемы.&lt;/p&gt;
&lt;p class="pt-3"&gt;&amp;bull; &lt;a href="https://docs.gradle.org/6.8/release-notes.html"&gt;Вышел Gradle 6.8&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
</feed>
